package migrations

import (
	"encoding/binary"
	"testing"

	"github.com/onflow/atree"
	"github.com/onflow/cadence/runtime"
	"github.com/onflow/cadence/runtime/common"
	"github.com/onflow/cadence/runtime/interpreter"
	"github.com/rs/zerolog"
	"github.com/stretchr/testify/require"

	"github.com/onflow/flow-go/cmd/util/ledger/util"
	"github.com/onflow/flow-go/ledger"
	"github.com/onflow/flow-go/model/flow"
)

func TestFilterUnreferencedSlabs(t *testing.T) {
	t.Parallel()

	// Arrange

	const chainID = flow.Emulator
	chain := chainID.Chain()

	testFlowAddress, err := chain.AddressAtIndex(1_000_000)
	require.NoError(t, err)

	testAddress := common.Address(testFlowAddress)

	payloadSnapshot, err := util.NewPayloadSnapshot(nil)
	require.NoError(t, err)

	payloadsLedger := util.NewPayloadsLedger(payloadSnapshot)

	storageIndices := map[string]uint64{}
	payloadsLedger.AllocateStorageIndexFunc = func(owner []byte) (atree.StorageIndex, error) {
		var index atree.StorageIndex

		storageIndices[string(owner)]++

		binary.BigEndian.PutUint64(
			index[:],
			storageIndices[string(owner)],
		)

		return index, nil
	}

	storage := runtime.NewStorage(payloadsLedger, nil)

	// {Int: Int}
	dictionaryStaticType := interpreter.NewDictionaryStaticType(
		nil,
		interpreter.PrimitiveStaticTypeInt,
		interpreter.PrimitiveStaticTypeInt,
	)

	inter, err := interpreter.NewInterpreter(
		nil,
		nil,
		&interpreter.Config{
			Storage: storage,
		},
	)
	require.NoError(t, err)

	dict1 := interpreter.NewDictionaryValueWithAddress(
		inter,
		interpreter.EmptyLocationRange,
		dictionaryStaticType,
		testAddress,
	)

	// Storage another dictionary in the account.
	// It is not referenced through a storage map though.

	interpreter.NewDictionaryValueWithAddress(
		inter,
		interpreter.EmptyLocationRange,
		dictionaryStaticType,
		testAddress,
	)

	storageMap := storage.GetStorageMap(
		testAddress,
		common.PathDomainStorage.Identifier(),
		true,
	)

	// Only insert first dictionary.
	// Second dictionary is unreferenced.

	storageMap.SetValue(
		inter,
		interpreter.StringStorageMapKey("test"),
		dict1,
	)

	err = storage.Commit(inter, false)
	require.NoError(t, err)

	oldPayloads := make([]*ledger.Payload, 0, len(payloadSnapshot.Payloads))

	for _, payload := range payloadsLedger.Snapshot.Payloads {
		oldPayloads = append(oldPayloads, payload)
	}

	const totalSlabCount = 4

	require.Len(t, oldPayloads, totalSlabCount)

	// Act

	migration := &FilterUnreferencedSlabsMigration{}

	log := zerolog.New(zerolog.NewTestWriter(t))

	err = migration.InitMigration(log, nil, 0)
	require.NoError(t, err)

	newPayloads, err := migration.MigrateAccount(nil, testAddress, oldPayloads)
	require.NoError(t, err)

	// Assert

	require.Len(t, newPayloads, totalSlabCount-1)
}
