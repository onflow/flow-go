// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mock

import (
	"context"

	"github.com/onflow/flow-go/model/flow"
	"github.com/onflow/flow/protobuf/go/flow/execution"
	mock "github.com/stretchr/testify/mock"
)

// NewProvider creates a new instance of Provider. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewProvider(t interface {
	mock.TestingT
	Cleanup(func())
}) *Provider {
	mock := &Provider{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Provider is an autogenerated mock type for the Provider type
type Provider struct {
	mock.Mock
}

type Provider_Expecter struct {
	mock *mock.Mock
}

func (_m *Provider) EXPECT() *Provider_Expecter {
	return &Provider_Expecter{mock: &_m.Mock}
}

// ErrorMessageByBlockIDFromAnyEN provides a mock function for the type Provider
func (_mock *Provider) ErrorMessageByBlockIDFromAnyEN(ctx context.Context, execNodes flow.IdentitySkeletonList, req *execution.GetTransactionErrorMessagesByBlockIDRequest) ([]*execution.GetTransactionErrorMessagesResponse_Result, *flow.IdentitySkeleton, error) {
	ret := _mock.Called(ctx, execNodes, req)

	if len(ret) == 0 {
		panic("no return value specified for ErrorMessageByBlockIDFromAnyEN")
	}

	var r0 []*execution.GetTransactionErrorMessagesResponse_Result
	var r1 *flow.IdentitySkeleton
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, flow.IdentitySkeletonList, *execution.GetTransactionErrorMessagesByBlockIDRequest) ([]*execution.GetTransactionErrorMessagesResponse_Result, *flow.IdentitySkeleton, error)); ok {
		return returnFunc(ctx, execNodes, req)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, flow.IdentitySkeletonList, *execution.GetTransactionErrorMessagesByBlockIDRequest) []*execution.GetTransactionErrorMessagesResponse_Result); ok {
		r0 = returnFunc(ctx, execNodes, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*execution.GetTransactionErrorMessagesResponse_Result)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, flow.IdentitySkeletonList, *execution.GetTransactionErrorMessagesByBlockIDRequest) *flow.IdentitySkeleton); ok {
		r1 = returnFunc(ctx, execNodes, req)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*flow.IdentitySkeleton)
		}
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, flow.IdentitySkeletonList, *execution.GetTransactionErrorMessagesByBlockIDRequest) error); ok {
		r2 = returnFunc(ctx, execNodes, req)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// Provider_ErrorMessageByBlockIDFromAnyEN_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ErrorMessageByBlockIDFromAnyEN'
type Provider_ErrorMessageByBlockIDFromAnyEN_Call struct {
	*mock.Call
}

// ErrorMessageByBlockIDFromAnyEN is a helper method to define mock.On call
//   - ctx context.Context
//   - execNodes flow.IdentitySkeletonList
//   - req *execution.GetTransactionErrorMessagesByBlockIDRequest
func (_e *Provider_Expecter) ErrorMessageByBlockIDFromAnyEN(ctx interface{}, execNodes interface{}, req interface{}) *Provider_ErrorMessageByBlockIDFromAnyEN_Call {
	return &Provider_ErrorMessageByBlockIDFromAnyEN_Call{Call: _e.mock.On("ErrorMessageByBlockIDFromAnyEN", ctx, execNodes, req)}
}

func (_c *Provider_ErrorMessageByBlockIDFromAnyEN_Call) Run(run func(ctx context.Context, execNodes flow.IdentitySkeletonList, req *execution.GetTransactionErrorMessagesByBlockIDRequest)) *Provider_ErrorMessageByBlockIDFromAnyEN_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 flow.IdentitySkeletonList
		if args[1] != nil {
			arg1 = args[1].(flow.IdentitySkeletonList)
		}
		var arg2 *execution.GetTransactionErrorMessagesByBlockIDRequest
		if args[2] != nil {
			arg2 = args[2].(*execution.GetTransactionErrorMessagesByBlockIDRequest)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Provider_ErrorMessageByBlockIDFromAnyEN_Call) Return(getTransactionErrorMessagesResponse_Results []*execution.GetTransactionErrorMessagesResponse_Result, identitySkeleton *flow.IdentitySkeleton, err error) *Provider_ErrorMessageByBlockIDFromAnyEN_Call {
	_c.Call.Return(getTransactionErrorMessagesResponse_Results, identitySkeleton, err)
	return _c
}

func (_c *Provider_ErrorMessageByBlockIDFromAnyEN_Call) RunAndReturn(run func(ctx context.Context, execNodes flow.IdentitySkeletonList, req *execution.GetTransactionErrorMessagesByBlockIDRequest) ([]*execution.GetTransactionErrorMessagesResponse_Result, *flow.IdentitySkeleton, error)) *Provider_ErrorMessageByBlockIDFromAnyEN_Call {
	_c.Call.Return(run)
	return _c
}

// ErrorMessageByIndex provides a mock function for the type Provider
func (_mock *Provider) ErrorMessageByIndex(ctx context.Context, blockID flow.Identifier, height uint64, index uint32) (string, error) {
	ret := _mock.Called(ctx, blockID, height, index)

	if len(ret) == 0 {
		panic("no return value specified for ErrorMessageByIndex")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, flow.Identifier, uint64, uint32) (string, error)); ok {
		return returnFunc(ctx, blockID, height, index)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, flow.Identifier, uint64, uint32) string); ok {
		r0 = returnFunc(ctx, blockID, height, index)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, flow.Identifier, uint64, uint32) error); ok {
		r1 = returnFunc(ctx, blockID, height, index)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Provider_ErrorMessageByIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ErrorMessageByIndex'
type Provider_ErrorMessageByIndex_Call struct {
	*mock.Call
}

// ErrorMessageByIndex is a helper method to define mock.On call
//   - ctx context.Context
//   - blockID flow.Identifier
//   - height uint64
//   - index uint32
func (_e *Provider_Expecter) ErrorMessageByIndex(ctx interface{}, blockID interface{}, height interface{}, index interface{}) *Provider_ErrorMessageByIndex_Call {
	return &Provider_ErrorMessageByIndex_Call{Call: _e.mock.On("ErrorMessageByIndex", ctx, blockID, height, index)}
}

func (_c *Provider_ErrorMessageByIndex_Call) Run(run func(ctx context.Context, blockID flow.Identifier, height uint64, index uint32)) *Provider_ErrorMessageByIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 flow.Identifier
		if args[1] != nil {
			arg1 = args[1].(flow.Identifier)
		}
		var arg2 uint64
		if args[2] != nil {
			arg2 = args[2].(uint64)
		}
		var arg3 uint32
		if args[3] != nil {
			arg3 = args[3].(uint32)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *Provider_ErrorMessageByIndex_Call) Return(s string, err error) *Provider_ErrorMessageByIndex_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *Provider_ErrorMessageByIndex_Call) RunAndReturn(run func(ctx context.Context, blockID flow.Identifier, height uint64, index uint32) (string, error)) *Provider_ErrorMessageByIndex_Call {
	_c.Call.Return(run)
	return _c
}

// ErrorMessageByIndexFromAnyEN provides a mock function for the type Provider
func (_mock *Provider) ErrorMessageByIndexFromAnyEN(ctx context.Context, execNodes flow.IdentitySkeletonList, req *execution.GetTransactionErrorMessageByIndexRequest) (*execution.GetTransactionErrorMessageResponse, error) {
	ret := _mock.Called(ctx, execNodes, req)

	if len(ret) == 0 {
		panic("no return value specified for ErrorMessageByIndexFromAnyEN")
	}

	var r0 *execution.GetTransactionErrorMessageResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, flow.IdentitySkeletonList, *execution.GetTransactionErrorMessageByIndexRequest) (*execution.GetTransactionErrorMessageResponse, error)); ok {
		return returnFunc(ctx, execNodes, req)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, flow.IdentitySkeletonList, *execution.GetTransactionErrorMessageByIndexRequest) *execution.GetTransactionErrorMessageResponse); ok {
		r0 = returnFunc(ctx, execNodes, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*execution.GetTransactionErrorMessageResponse)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, flow.IdentitySkeletonList, *execution.GetTransactionErrorMessageByIndexRequest) error); ok {
		r1 = returnFunc(ctx, execNodes, req)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Provider_ErrorMessageByIndexFromAnyEN_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ErrorMessageByIndexFromAnyEN'
type Provider_ErrorMessageByIndexFromAnyEN_Call struct {
	*mock.Call
}

// ErrorMessageByIndexFromAnyEN is a helper method to define mock.On call
//   - ctx context.Context
//   - execNodes flow.IdentitySkeletonList
//   - req *execution.GetTransactionErrorMessageByIndexRequest
func (_e *Provider_Expecter) ErrorMessageByIndexFromAnyEN(ctx interface{}, execNodes interface{}, req interface{}) *Provider_ErrorMessageByIndexFromAnyEN_Call {
	return &Provider_ErrorMessageByIndexFromAnyEN_Call{Call: _e.mock.On("ErrorMessageByIndexFromAnyEN", ctx, execNodes, req)}
}

func (_c *Provider_ErrorMessageByIndexFromAnyEN_Call) Run(run func(ctx context.Context, execNodes flow.IdentitySkeletonList, req *execution.GetTransactionErrorMessageByIndexRequest)) *Provider_ErrorMessageByIndexFromAnyEN_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 flow.IdentitySkeletonList
		if args[1] != nil {
			arg1 = args[1].(flow.IdentitySkeletonList)
		}
		var arg2 *execution.GetTransactionErrorMessageByIndexRequest
		if args[2] != nil {
			arg2 = args[2].(*execution.GetTransactionErrorMessageByIndexRequest)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Provider_ErrorMessageByIndexFromAnyEN_Call) Return(getTransactionErrorMessageResponse *execution.GetTransactionErrorMessageResponse, err error) *Provider_ErrorMessageByIndexFromAnyEN_Call {
	_c.Call.Return(getTransactionErrorMessageResponse, err)
	return _c
}

func (_c *Provider_ErrorMessageByIndexFromAnyEN_Call) RunAndReturn(run func(ctx context.Context, execNodes flow.IdentitySkeletonList, req *execution.GetTransactionErrorMessageByIndexRequest) (*execution.GetTransactionErrorMessageResponse, error)) *Provider_ErrorMessageByIndexFromAnyEN_Call {
	_c.Call.Return(run)
	return _c
}

// ErrorMessageByTransactionID provides a mock function for the type Provider
func (_mock *Provider) ErrorMessageByTransactionID(ctx context.Context, blockID flow.Identifier, height uint64, transactionID flow.Identifier) (string, error) {
	ret := _mock.Called(ctx, blockID, height, transactionID)

	if len(ret) == 0 {
		panic("no return value specified for ErrorMessageByTransactionID")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, flow.Identifier, uint64, flow.Identifier) (string, error)); ok {
		return returnFunc(ctx, blockID, height, transactionID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, flow.Identifier, uint64, flow.Identifier) string); ok {
		r0 = returnFunc(ctx, blockID, height, transactionID)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, flow.Identifier, uint64, flow.Identifier) error); ok {
		r1 = returnFunc(ctx, blockID, height, transactionID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Provider_ErrorMessageByTransactionID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ErrorMessageByTransactionID'
type Provider_ErrorMessageByTransactionID_Call struct {
	*mock.Call
}

// ErrorMessageByTransactionID is a helper method to define mock.On call
//   - ctx context.Context
//   - blockID flow.Identifier
//   - height uint64
//   - transactionID flow.Identifier
func (_e *Provider_Expecter) ErrorMessageByTransactionID(ctx interface{}, blockID interface{}, height interface{}, transactionID interface{}) *Provider_ErrorMessageByTransactionID_Call {
	return &Provider_ErrorMessageByTransactionID_Call{Call: _e.mock.On("ErrorMessageByTransactionID", ctx, blockID, height, transactionID)}
}

func (_c *Provider_ErrorMessageByTransactionID_Call) Run(run func(ctx context.Context, blockID flow.Identifier, height uint64, transactionID flow.Identifier)) *Provider_ErrorMessageByTransactionID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 flow.Identifier
		if args[1] != nil {
			arg1 = args[1].(flow.Identifier)
		}
		var arg2 uint64
		if args[2] != nil {
			arg2 = args[2].(uint64)
		}
		var arg3 flow.Identifier
		if args[3] != nil {
			arg3 = args[3].(flow.Identifier)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *Provider_ErrorMessageByTransactionID_Call) Return(s string, err error) *Provider_ErrorMessageByTransactionID_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *Provider_ErrorMessageByTransactionID_Call) RunAndReturn(run func(ctx context.Context, blockID flow.Identifier, height uint64, transactionID flow.Identifier) (string, error)) *Provider_ErrorMessageByTransactionID_Call {
	_c.Call.Return(run)
	return _c
}

// ErrorMessageFromAnyEN provides a mock function for the type Provider
func (_mock *Provider) ErrorMessageFromAnyEN(ctx context.Context, execNodes flow.IdentitySkeletonList, req *execution.GetTransactionErrorMessageRequest) (*execution.GetTransactionErrorMessageResponse, error) {
	ret := _mock.Called(ctx, execNodes, req)

	if len(ret) == 0 {
		panic("no return value specified for ErrorMessageFromAnyEN")
	}

	var r0 *execution.GetTransactionErrorMessageResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, flow.IdentitySkeletonList, *execution.GetTransactionErrorMessageRequest) (*execution.GetTransactionErrorMessageResponse, error)); ok {
		return returnFunc(ctx, execNodes, req)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, flow.IdentitySkeletonList, *execution.GetTransactionErrorMessageRequest) *execution.GetTransactionErrorMessageResponse); ok {
		r0 = returnFunc(ctx, execNodes, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*execution.GetTransactionErrorMessageResponse)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, flow.IdentitySkeletonList, *execution.GetTransactionErrorMessageRequest) error); ok {
		r1 = returnFunc(ctx, execNodes, req)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Provider_ErrorMessageFromAnyEN_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ErrorMessageFromAnyEN'
type Provider_ErrorMessageFromAnyEN_Call struct {
	*mock.Call
}

// ErrorMessageFromAnyEN is a helper method to define mock.On call
//   - ctx context.Context
//   - execNodes flow.IdentitySkeletonList
//   - req *execution.GetTransactionErrorMessageRequest
func (_e *Provider_Expecter) ErrorMessageFromAnyEN(ctx interface{}, execNodes interface{}, req interface{}) *Provider_ErrorMessageFromAnyEN_Call {
	return &Provider_ErrorMessageFromAnyEN_Call{Call: _e.mock.On("ErrorMessageFromAnyEN", ctx, execNodes, req)}
}

func (_c *Provider_ErrorMessageFromAnyEN_Call) Run(run func(ctx context.Context, execNodes flow.IdentitySkeletonList, req *execution.GetTransactionErrorMessageRequest)) *Provider_ErrorMessageFromAnyEN_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 flow.IdentitySkeletonList
		if args[1] != nil {
			arg1 = args[1].(flow.IdentitySkeletonList)
		}
		var arg2 *execution.GetTransactionErrorMessageRequest
		if args[2] != nil {
			arg2 = args[2].(*execution.GetTransactionErrorMessageRequest)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Provider_ErrorMessageFromAnyEN_Call) Return(getTransactionErrorMessageResponse *execution.GetTransactionErrorMessageResponse, err error) *Provider_ErrorMessageFromAnyEN_Call {
	_c.Call.Return(getTransactionErrorMessageResponse, err)
	return _c
}

func (_c *Provider_ErrorMessageFromAnyEN_Call) RunAndReturn(run func(ctx context.Context, execNodes flow.IdentitySkeletonList, req *execution.GetTransactionErrorMessageRequest) (*execution.GetTransactionErrorMessageResponse, error)) *Provider_ErrorMessageFromAnyEN_Call {
	_c.Call.Return(run)
	return _c
}

// ErrorMessagesByBlockID provides a mock function for the type Provider
func (_mock *Provider) ErrorMessagesByBlockID(ctx context.Context, blockID flow.Identifier, height uint64) (map[flow.Identifier]string, error) {
	ret := _mock.Called(ctx, blockID, height)

	if len(ret) == 0 {
		panic("no return value specified for ErrorMessagesByBlockID")
	}

	var r0 map[flow.Identifier]string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, flow.Identifier, uint64) (map[flow.Identifier]string, error)); ok {
		return returnFunc(ctx, blockID, height)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, flow.Identifier, uint64) map[flow.Identifier]string); ok {
		r0 = returnFunc(ctx, blockID, height)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[flow.Identifier]string)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, flow.Identifier, uint64) error); ok {
		r1 = returnFunc(ctx, blockID, height)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Provider_ErrorMessagesByBlockID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ErrorMessagesByBlockID'
type Provider_ErrorMessagesByBlockID_Call struct {
	*mock.Call
}

// ErrorMessagesByBlockID is a helper method to define mock.On call
//   - ctx context.Context
//   - blockID flow.Identifier
//   - height uint64
func (_e *Provider_Expecter) ErrorMessagesByBlockID(ctx interface{}, blockID interface{}, height interface{}) *Provider_ErrorMessagesByBlockID_Call {
	return &Provider_ErrorMessagesByBlockID_Call{Call: _e.mock.On("ErrorMessagesByBlockID", ctx, blockID, height)}
}

func (_c *Provider_ErrorMessagesByBlockID_Call) Run(run func(ctx context.Context, blockID flow.Identifier, height uint64)) *Provider_ErrorMessagesByBlockID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 flow.Identifier
		if args[1] != nil {
			arg1 = args[1].(flow.Identifier)
		}
		var arg2 uint64
		if args[2] != nil {
			arg2 = args[2].(uint64)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Provider_ErrorMessagesByBlockID_Call) Return(identifierToString map[flow.Identifier]string, err error) *Provider_ErrorMessagesByBlockID_Call {
	_c.Call.Return(identifierToString, err)
	return _c
}

func (_c *Provider_ErrorMessagesByBlockID_Call) RunAndReturn(run func(ctx context.Context, blockID flow.Identifier, height uint64) (map[flow.Identifier]string, error)) *Provider_ErrorMessagesByBlockID_Call {
	_c.Call.Return(run)
	return _c
}
