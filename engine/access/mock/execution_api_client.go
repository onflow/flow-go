// Code generated by mockery v2.21.4. DO NOT EDIT.

package mock

import (
	context "context"

	execution "github.com/onflow/flow/protobuf/go/flow/execution"
	grpc "google.golang.org/grpc"

	mock "github.com/stretchr/testify/mock"
)

// ExecutionAPIClient is an autogenerated mock type for the ExecutionAPIClient type
type ExecutionAPIClient struct {
	mock.Mock
}

// ExecuteScriptAtBlockID provides a mock function with given fields: ctx, in, opts
func (_m *ExecutionAPIClient) ExecuteScriptAtBlockID(ctx context.Context, in *execution.ExecuteScriptAtBlockIDRequest, opts ...grpc.CallOption) (*execution.ExecuteScriptAtBlockIDResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *execution.ExecuteScriptAtBlockIDResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *execution.ExecuteScriptAtBlockIDRequest, ...grpc.CallOption) (*execution.ExecuteScriptAtBlockIDResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *execution.ExecuteScriptAtBlockIDRequest, ...grpc.CallOption) *execution.ExecuteScriptAtBlockIDResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*execution.ExecuteScriptAtBlockIDResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *execution.ExecuteScriptAtBlockIDRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAccountAtBlockID provides a mock function with given fields: ctx, in, opts
func (_m *ExecutionAPIClient) GetAccountAtBlockID(ctx context.Context, in *execution.GetAccountAtBlockIDRequest, opts ...grpc.CallOption) (*execution.GetAccountAtBlockIDResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *execution.GetAccountAtBlockIDResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *execution.GetAccountAtBlockIDRequest, ...grpc.CallOption) (*execution.GetAccountAtBlockIDResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *execution.GetAccountAtBlockIDRequest, ...grpc.CallOption) *execution.GetAccountAtBlockIDResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*execution.GetAccountAtBlockIDResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *execution.GetAccountAtBlockIDRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlockHeaderByID provides a mock function with given fields: ctx, in, opts
func (_m *ExecutionAPIClient) GetBlockHeaderByID(ctx context.Context, in *execution.GetBlockHeaderByIDRequest, opts ...grpc.CallOption) (*execution.BlockHeaderResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *execution.BlockHeaderResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *execution.GetBlockHeaderByIDRequest, ...grpc.CallOption) (*execution.BlockHeaderResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *execution.GetBlockHeaderByIDRequest, ...grpc.CallOption) *execution.BlockHeaderResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*execution.BlockHeaderResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *execution.GetBlockHeaderByIDRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEventsForBlockIDs provides a mock function with given fields: ctx, in, opts
func (_m *ExecutionAPIClient) GetEventsForBlockIDs(ctx context.Context, in *execution.GetEventsForBlockIDsRequest, opts ...grpc.CallOption) (*execution.GetEventsForBlockIDsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *execution.GetEventsForBlockIDsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *execution.GetEventsForBlockIDsRequest, ...grpc.CallOption) (*execution.GetEventsForBlockIDsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *execution.GetEventsForBlockIDsRequest, ...grpc.CallOption) *execution.GetEventsForBlockIDsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*execution.GetEventsForBlockIDsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *execution.GetEventsForBlockIDsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLatestBlockHeader provides a mock function with given fields: ctx, in, opts
func (_m *ExecutionAPIClient) GetLatestBlockHeader(ctx context.Context, in *execution.GetLatestBlockHeaderRequest, opts ...grpc.CallOption) (*execution.BlockHeaderResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *execution.BlockHeaderResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *execution.GetLatestBlockHeaderRequest, ...grpc.CallOption) (*execution.BlockHeaderResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *execution.GetLatestBlockHeaderRequest, ...grpc.CallOption) *execution.BlockHeaderResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*execution.BlockHeaderResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *execution.GetLatestBlockHeaderRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRegisterAtBlockID provides a mock function with given fields: ctx, in, opts
func (_m *ExecutionAPIClient) GetRegisterAtBlockID(ctx context.Context, in *execution.GetRegisterAtBlockIDRequest, opts ...grpc.CallOption) (*execution.GetRegisterAtBlockIDResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *execution.GetRegisterAtBlockIDResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *execution.GetRegisterAtBlockIDRequest, ...grpc.CallOption) (*execution.GetRegisterAtBlockIDResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *execution.GetRegisterAtBlockIDRequest, ...grpc.CallOption) *execution.GetRegisterAtBlockIDResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*execution.GetRegisterAtBlockIDResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *execution.GetRegisterAtBlockIDRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTransactionErrorMessage provides a mock function with given fields: ctx, in, opts
func (_m *ExecutionAPIClient) GetTransactionErrorMessage(ctx context.Context, in *execution.GetTransactionErrorMessageRequest, opts ...grpc.CallOption) (*execution.GetTransactionErrorMessagesResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *execution.GetTransactionErrorMessagesResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *execution.GetTransactionErrorMessageRequest, ...grpc.CallOption) (*execution.GetTransactionErrorMessagesResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *execution.GetTransactionErrorMessageRequest, ...grpc.CallOption) *execution.GetTransactionErrorMessagesResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*execution.GetTransactionErrorMessagesResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *execution.GetTransactionErrorMessageRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTransactionErrorMessageByIndex provides a mock function with given fields: ctx, in, opts
func (_m *ExecutionAPIClient) GetTransactionErrorMessageByIndex(ctx context.Context, in *execution.GetTransactionErrorMessageByIndexRequest, opts ...grpc.CallOption) (*execution.GetTransactionErrorMessagesResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *execution.GetTransactionErrorMessagesResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *execution.GetTransactionErrorMessageByIndexRequest, ...grpc.CallOption) (*execution.GetTransactionErrorMessagesResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *execution.GetTransactionErrorMessageByIndexRequest, ...grpc.CallOption) *execution.GetTransactionErrorMessagesResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*execution.GetTransactionErrorMessagesResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *execution.GetTransactionErrorMessageByIndexRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTransactionErrorMessagesByBlockID provides a mock function with given fields: ctx, in, opts
func (_m *ExecutionAPIClient) GetTransactionErrorMessagesByBlockID(ctx context.Context, in *execution.GetTransactionErrorMessagesByBlockIDRequest, opts ...grpc.CallOption) (*execution.GetTransactionErrorMessagesResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *execution.GetTransactionErrorMessagesResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *execution.GetTransactionErrorMessagesByBlockIDRequest, ...grpc.CallOption) (*execution.GetTransactionErrorMessagesResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *execution.GetTransactionErrorMessagesByBlockIDRequest, ...grpc.CallOption) *execution.GetTransactionErrorMessagesResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*execution.GetTransactionErrorMessagesResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *execution.GetTransactionErrorMessagesByBlockIDRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTransactionResult provides a mock function with given fields: ctx, in, opts
func (_m *ExecutionAPIClient) GetTransactionResult(ctx context.Context, in *execution.GetTransactionResultRequest, opts ...grpc.CallOption) (*execution.GetTransactionResultResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *execution.GetTransactionResultResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *execution.GetTransactionResultRequest, ...grpc.CallOption) (*execution.GetTransactionResultResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *execution.GetTransactionResultRequest, ...grpc.CallOption) *execution.GetTransactionResultResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*execution.GetTransactionResultResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *execution.GetTransactionResultRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTransactionResultByIndex provides a mock function with given fields: ctx, in, opts
func (_m *ExecutionAPIClient) GetTransactionResultByIndex(ctx context.Context, in *execution.GetTransactionByIndexRequest, opts ...grpc.CallOption) (*execution.GetTransactionResultResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *execution.GetTransactionResultResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *execution.GetTransactionByIndexRequest, ...grpc.CallOption) (*execution.GetTransactionResultResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *execution.GetTransactionByIndexRequest, ...grpc.CallOption) *execution.GetTransactionResultResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*execution.GetTransactionResultResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *execution.GetTransactionByIndexRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTransactionResultsByBlockID provides a mock function with given fields: ctx, in, opts
func (_m *ExecutionAPIClient) GetTransactionResultsByBlockID(ctx context.Context, in *execution.GetTransactionsByBlockIDRequest, opts ...grpc.CallOption) (*execution.GetTransactionResultsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *execution.GetTransactionResultsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *execution.GetTransactionsByBlockIDRequest, ...grpc.CallOption) (*execution.GetTransactionResultsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *execution.GetTransactionsByBlockIDRequest, ...grpc.CallOption) *execution.GetTransactionResultsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*execution.GetTransactionResultsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *execution.GetTransactionsByBlockIDRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Ping provides a mock function with given fields: ctx, in, opts
func (_m *ExecutionAPIClient) Ping(ctx context.Context, in *execution.PingRequest, opts ...grpc.CallOption) (*execution.PingResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *execution.PingResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *execution.PingRequest, ...grpc.CallOption) (*execution.PingResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *execution.PingRequest, ...grpc.CallOption) *execution.PingResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*execution.PingResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *execution.PingRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type mockConstructorTestingTNewExecutionAPIClient interface {
	mock.TestingT
	Cleanup(func())
}

// NewExecutionAPIClient creates a new instance of ExecutionAPIClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewExecutionAPIClient(t mockConstructorTestingTNewExecutionAPIClient) *ExecutionAPIClient {
	mock := &ExecutionAPIClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
