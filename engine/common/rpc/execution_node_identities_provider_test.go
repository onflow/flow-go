package rpc_test

import (
	"context"
	"testing"

	"github.com/rs/zerolog"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"
	"github.com/stretchr/testify/suite"

	"github.com/onflow/flow-go/engine/access/rpc/backend"
	commonrpc "github.com/onflow/flow-go/engine/common/rpc"
	"github.com/onflow/flow-go/model/flow"
	protocol "github.com/onflow/flow-go/state/protocol/mock"
	storagemock "github.com/onflow/flow-go/storage/mock"
	"github.com/onflow/flow-go/utils/unittest"
)

// ENIdentitiesProviderSuite is a test suite for testing the ExecutionNodeIdentitiesProvider.
type ENIdentitiesProviderSuite struct {
	suite.Suite

	state    *protocol.State
	snapshot *protocol.Snapshot
	log      zerolog.Logger

	receipts *storagemock.ExecutionReceipts
}

func TestHandler(t *testing.T) {
	suite.Run(t, new(ENIdentitiesProviderSuite))
}

// SetupTest initializes the test suite with mock state and receipts storage.
func (suite *ENIdentitiesProviderSuite) SetupTest() {
	suite.log = zerolog.New(zerolog.NewConsoleWriter())
	suite.state = new(protocol.State)
	suite.snapshot = new(protocol.Snapshot)
	suite.receipts = new(storagemock.ExecutionReceipts)

	header := unittest.BlockHeaderFixture()
	params := new(protocol.Params)
	params.On("FinalizedRoot").Return(header, nil)
	suite.state.On("Params").Return(params)
}

// TestExecutionNodesForBlockID tests the ExecutionNodesForBlockID function.
// This function is responsible for retrieving execution nodes used to serve
// all API calls that interact with execution nodes.
func (suite *ENIdentitiesProviderSuite) TestExecutionNodesForBlockID() {
	totalReceipts := 5

	block := unittest.BlockFixture()

	// generate one execution node identities for each receipt assuming that each ER is generated by a unique exec node
	allExecutionNodes := unittest.IdentityListFixture(totalReceipts, unittest.WithRole(flow.RoleExecution))

	// one execution result for all receipts for this block
	executionResult := unittest.ExecutionResultFixture()

	// generate execution receipts
	receipts := make(flow.ExecutionReceiptList, totalReceipts)
	for j := 0; j < totalReceipts; j++ {
		r := unittest.ReceiptForBlockFixture(&block)
		r.ExecutorID = allExecutionNodes[j].NodeID
		er := *executionResult
		r.ExecutionResult = er
		receipts[j] = r
	}

	currentAttempt := 0
	attempt1Receipts, attempt2Receipts, attempt3Receipts := receipts, receipts, receipts

	// setup receipts storage mock to return different list of receipts on each call
	suite.receipts.
		On("ByBlockID", block.ID()).Return(
		func(id flow.Identifier) flow.ExecutionReceiptList {
			switch currentAttempt {
			case 0:
				currentAttempt++
				return attempt1Receipts
			case 1:
				currentAttempt++
				return attempt2Receipts
			default:
				currentAttempt = 0
				return attempt3Receipts
			}
		},
		func(id flow.Identifier) error { return nil })

	suite.snapshot.On("Identities", mock.Anything).Return(
		func(filter flow.IdentityFilter[flow.Identity]) flow.IdentityList {
			// apply the filter passed in to the list of all the execution nodes
			return allExecutionNodes.Filter(filter)
		},
		func(flow.IdentityFilter[flow.Identity]) error { return nil })
	suite.state.On("Final").Return(suite.snapshot, nil).Maybe()

	var preferredENIdentifiers flow.IdentifierList
	var fixedENIdentifiers flow.IdentifierList

	testExecutionNodesForBlockID := func(preferredENs, fixedENs, expectedENs flow.IdentityList) {

		if preferredENs != nil {
			preferredENIdentifiers = preferredENs.NodeIDs()
		}
		if fixedENs != nil {
			fixedENIdentifiers = fixedENs.NodeIDs()
		}

		if expectedENs == nil {
			expectedENs = flow.IdentityList{}
		}

		execNodeIdentitiesProvider := commonrpc.NewExecutionNodeIdentitiesProvider(
			suite.log,
			suite.state,
			suite.receipts,
			preferredENIdentifiers,
			fixedENIdentifiers,
		)

		allExecNodes, err := execNodeIdentitiesProvider.ExecutionNodesForBlockID(context.Background(), block.ID())
		require.NoError(suite.T(), err)

		execNodeSelectorFactory := backend.NewNodeSelectorFactory(false)
		execSelector, err := execNodeSelectorFactory.SelectNodes(allExecNodes)
		require.NoError(suite.T(), err)

		actualList := flow.IdentitySkeletonList{}
		for actual := execSelector.Next(); actual != nil; actual = execSelector.Next() {
			actualList = append(actualList, actual)
		}

		{
			expectedENs := expectedENs.ToSkeleton()
			if len(expectedENs) > commonrpc.MaxNodesCnt {
				for _, actual := range actualList {
					require.Contains(suite.T(), expectedENs, actual)
				}
			} else {
				require.ElementsMatch(suite.T(), actualList, expectedENs)
			}
		}
	}
	// if we don't find sufficient receipts, ExecutionNodesForBlockID should return a list of random ENs
	suite.Run("insufficient receipts return random ENs in State", func() {
		// return no receipts at all attempts
		attempt1Receipts = flow.ExecutionReceiptList{}
		attempt2Receipts = flow.ExecutionReceiptList{}
		attempt3Receipts = flow.ExecutionReceiptList{}
		suite.state.On("AtBlockID", mock.Anything).Return(suite.snapshot)

		execNodeIdentitiesProvider := commonrpc.NewExecutionNodeIdentitiesProvider(
			suite.log,
			suite.state,
			suite.receipts,
			flow.IdentifierList{},
			flow.IdentifierList{},
		)

		allExecNodes, err := execNodeIdentitiesProvider.ExecutionNodesForBlockID(context.Background(), block.ID())
		require.NoError(suite.T(), err)

		execNodeSelectorFactory := backend.NewNodeSelectorFactory(false)
		execSelector, err := execNodeSelectorFactory.SelectNodes(allExecNodes)
		require.NoError(suite.T(), err)

		actualList := flow.IdentitySkeletonList{}
		for actual := execSelector.Next(); actual != nil; actual = execSelector.Next() {
			actualList = append(actualList, actual)
		}

		require.Equal(suite.T(), len(actualList), commonrpc.MaxNodesCnt)
	})

	// if no preferred or fixed ENs are specified, the ExecutionNodesForBlockID function should
	// return the exe node list without a filter
	suite.Run("no preferred or fixed ENs", func() {
		testExecutionNodesForBlockID(nil, nil, allExecutionNodes)
	})
	// if only fixed ENs are specified, the ExecutionNodesForBlockID function should
	// return the fixed ENs list
	suite.Run("two fixed ENs with zero preferred EN", func() {
		// mark the first two ENs as fixed
		fixedENs := allExecutionNodes[0:2]
		expectedList := fixedENs
		testExecutionNodesForBlockID(nil, fixedENs, expectedList)
	})
	// if only preferred ENs are specified, the ExecutionNodesForBlockID function should
	// return the preferred ENs list
	suite.Run("two preferred ENs with zero fixed EN", func() {
		// mark the first two ENs as preferred
		preferredENs := allExecutionNodes[0:2]
		expectedList := allExecutionNodes[0:commonrpc.MaxNodesCnt]
		testExecutionNodesForBlockID(preferredENs, nil, expectedList)
	})
	// if both are specified, the ExecutionNodesForBlockID function should
	// return the preferred ENs list
	suite.Run("four fixed ENs of which two are preferred ENs", func() {
		// mark the first four ENs as fixed
		fixedENs := allExecutionNodes[0:5]
		// mark the first two of the fixed ENs as preferred ENs
		preferredENs := fixedENs[0:2]
		expectedList := fixedENs[0:commonrpc.MaxNodesCnt]
		testExecutionNodesForBlockID(preferredENs, fixedENs, expectedList)
	})
	// if both are specified, but the preferred ENs don't match the ExecutorIDs in the ER,
	// the ExecutionNodesForBlockID function should return the fixed ENs list
	suite.Run("four fixed ENs of which two are preferred ENs but have not generated the ER", func() {
		// mark the first two ENs as fixed
		fixedENs := allExecutionNodes[0:2]
		// specify two ENs not specified in the ERs as preferred
		preferredENs := unittest.IdentityListFixture(2, unittest.WithRole(flow.RoleExecution))
		// add one more node ID besides of the fixed ENs list cause expected length of the list should be maxNodesCnt
		expectedList := append(fixedENs, allExecutionNodes[2])
		testExecutionNodesForBlockID(preferredENs, fixedENs, expectedList)
	})
	// if execution receipts are not yet available, the ExecutionNodesForBlockID function should retry twice
	suite.Run("retry execution receipt query", func() {
		// on first attempt, no execution receipts are available
		attempt1Receipts = flow.ExecutionReceiptList{}
		// on second attempt ony one is available
		attempt2Receipts = flow.ExecutionReceiptList{receipts[0]}
		// on third attempt all receipts are available
		attempt3Receipts = receipts
		currentAttempt = 0
		// mark the first two ENs as preferred
		preferredENs := allExecutionNodes[0:2]
		expectedList := allExecutionNodes[0:commonrpc.MaxNodesCnt]
		testExecutionNodesForBlockID(preferredENs, nil, expectedList)
	})
	// if preferredENIdentifiers was set and there are less than maxNodesCnt nodes selected than check the order
	// of adding ENs ids
	suite.Run("add nodes in the correct order", func() {
		//  mark the first EN as preferred
		preferredENIdentifiers = allExecutionNodes[0:1].NodeIDs()
		//  mark the fourth EN with receipt
		executorIDs := allExecutionNodes[3:4].NodeIDs()

		receiptNodes := allExecutionNodes[3:4]   // any EN with a receipt
		preferredNodes := allExecutionNodes[0:1] // preferred EN node not already selected
		additionalNode := allExecutionNodes[1:2] // any EN not already selected

		expectedOrder := flow.IdentityList{
			receiptNodes[0],
			preferredNodes[0],
			additionalNode[0],
		}

		execNodeIdentitiesProvider := commonrpc.NewExecutionNodeIdentitiesProvider(
			suite.log,
			suite.state,
			suite.receipts,
			preferredENIdentifiers,
			flow.IdentifierList{},
		)

		chosenIDs := execNodeIdentitiesProvider.ChooseFromPreferredENIDs(allExecutionNodes, executorIDs)

		require.ElementsMatch(suite.T(), chosenIDs, expectedOrder)
		require.Equal(suite.T(), len(chosenIDs), commonrpc.MaxNodesCnt)
	})
}
