// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mock

import (
	"io"

	"github.com/dgraph-io/badger/v2"
	"github.com/jordanschalm/lockctx"
	"github.com/onflow/crypto"
	"github.com/onflow/flow-go/model/chunks"
	"github.com/onflow/flow-go/model/cluster"
	"github.com/onflow/flow-go/model/flow"
	"github.com/onflow/flow-go/storage"
	mock "github.com/stretchr/testify/mock"
)

// NewResultApprovals creates a new instance of ResultApprovals. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewResultApprovals(t interface {
	mock.TestingT
	Cleanup(func())
}) *ResultApprovals {
	mock := &ResultApprovals{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// ResultApprovals is an autogenerated mock type for the ResultApprovals type
type ResultApprovals struct {
	mock.Mock
}

type ResultApprovals_Expecter struct {
	mock *mock.Mock
}

func (_m *ResultApprovals) EXPECT() *ResultApprovals_Expecter {
	return &ResultApprovals_Expecter{mock: &_m.Mock}
}

// ByChunk provides a mock function for the type ResultApprovals
func (_mock *ResultApprovals) ByChunk(resultID flow.Identifier, chunkIndex uint64) (*flow.ResultApproval, error) {
	ret := _mock.Called(resultID, chunkIndex)

	if len(ret) == 0 {
		panic("no return value specified for ByChunk")
	}

	var r0 *flow.ResultApproval
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, uint64) (*flow.ResultApproval, error)); ok {
		return returnFunc(resultID, chunkIndex)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, uint64) *flow.ResultApproval); ok {
		r0 = returnFunc(resultID, chunkIndex)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.ResultApproval)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier, uint64) error); ok {
		r1 = returnFunc(resultID, chunkIndex)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ResultApprovals_ByChunk_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByChunk'
type ResultApprovals_ByChunk_Call struct {
	*mock.Call
}

// ByChunk is a helper method to define mock.On call
//   - resultID flow.Identifier
//   - chunkIndex uint64
func (_e *ResultApprovals_Expecter) ByChunk(resultID interface{}, chunkIndex interface{}) *ResultApprovals_ByChunk_Call {
	return &ResultApprovals_ByChunk_Call{Call: _e.mock.On("ByChunk", resultID, chunkIndex)}
}

func (_c *ResultApprovals_ByChunk_Call) Run(run func(resultID flow.Identifier, chunkIndex uint64)) *ResultApprovals_ByChunk_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		var arg1 uint64
		if args[1] != nil {
			arg1 = args[1].(uint64)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ResultApprovals_ByChunk_Call) Return(resultApproval *flow.ResultApproval, err error) *ResultApprovals_ByChunk_Call {
	_c.Call.Return(resultApproval, err)
	return _c
}

func (_c *ResultApprovals_ByChunk_Call) RunAndReturn(run func(resultID flow.Identifier, chunkIndex uint64) (*flow.ResultApproval, error)) *ResultApprovals_ByChunk_Call {
	_c.Call.Return(run)
	return _c
}

// ByID provides a mock function for the type ResultApprovals
func (_mock *ResultApprovals) ByID(approvalID flow.Identifier) (*flow.ResultApproval, error) {
	ret := _mock.Called(approvalID)

	if len(ret) == 0 {
		panic("no return value specified for ByID")
	}

	var r0 *flow.ResultApproval
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (*flow.ResultApproval, error)); ok {
		return returnFunc(approvalID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) *flow.ResultApproval); ok {
		r0 = returnFunc(approvalID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.ResultApproval)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(approvalID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ResultApprovals_ByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByID'
type ResultApprovals_ByID_Call struct {
	*mock.Call
}

// ByID is a helper method to define mock.On call
//   - approvalID flow.Identifier
func (_e *ResultApprovals_Expecter) ByID(approvalID interface{}) *ResultApprovals_ByID_Call {
	return &ResultApprovals_ByID_Call{Call: _e.mock.On("ByID", approvalID)}
}

func (_c *ResultApprovals_ByID_Call) Run(run func(approvalID flow.Identifier)) *ResultApprovals_ByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ResultApprovals_ByID_Call) Return(resultApproval *flow.ResultApproval, err error) *ResultApprovals_ByID_Call {
	_c.Call.Return(resultApproval, err)
	return _c
}

func (_c *ResultApprovals_ByID_Call) RunAndReturn(run func(approvalID flow.Identifier) (*flow.ResultApproval, error)) *ResultApprovals_ByID_Call {
	_c.Call.Return(run)
	return _c
}

// StoreMyApproval provides a mock function for the type ResultApprovals
func (_mock *ResultApprovals) StoreMyApproval(approval *flow.ResultApproval) func(lctx lockctx.Proof) error {
	ret := _mock.Called(approval)

	if len(ret) == 0 {
		panic("no return value specified for StoreMyApproval")
	}

	var r0 func(lctx lockctx.Proof) error
	if returnFunc, ok := ret.Get(0).(func(*flow.ResultApproval) func(lctx lockctx.Proof) error); ok {
		r0 = returnFunc(approval)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(func(lctx lockctx.Proof) error)
		}
	}
	return r0
}

// ResultApprovals_StoreMyApproval_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StoreMyApproval'
type ResultApprovals_StoreMyApproval_Call struct {
	*mock.Call
}

// StoreMyApproval is a helper method to define mock.On call
//   - approval *flow.ResultApproval
func (_e *ResultApprovals_Expecter) StoreMyApproval(approval interface{}) *ResultApprovals_StoreMyApproval_Call {
	return &ResultApprovals_StoreMyApproval_Call{Call: _e.mock.On("StoreMyApproval", approval)}
}

func (_c *ResultApprovals_StoreMyApproval_Call) Run(run func(approval *flow.ResultApproval)) *ResultApprovals_StoreMyApproval_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *flow.ResultApproval
		if args[0] != nil {
			arg0 = args[0].(*flow.ResultApproval)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ResultApprovals_StoreMyApproval_Call) Return(fn func(lctx lockctx.Proof) error) *ResultApprovals_StoreMyApproval_Call {
	_c.Call.Return(fn)
	return _c
}

func (_c *ResultApprovals_StoreMyApproval_Call) RunAndReturn(run func(approval *flow.ResultApproval) func(lctx lockctx.Proof) error) *ResultApprovals_StoreMyApproval_Call {
	_c.Call.Return(run)
	return _c
}

// NewTransaction creates a new instance of Transaction. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewTransaction(t interface {
	mock.TestingT
	Cleanup(func())
}) *Transaction {
	mock := &Transaction{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Transaction is an autogenerated mock type for the Transaction type
type Transaction struct {
	mock.Mock
}

type Transaction_Expecter struct {
	mock *mock.Mock
}

func (_m *Transaction) EXPECT() *Transaction_Expecter {
	return &Transaction_Expecter{mock: &_m.Mock}
}

// Set provides a mock function for the type Transaction
func (_mock *Transaction) Set(key []byte, val []byte) error {
	ret := _mock.Called(key, val)

	if len(ret) == 0 {
		panic("no return value specified for Set")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func([]byte, []byte) error); ok {
		r0 = returnFunc(key, val)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Transaction_Set_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Set'
type Transaction_Set_Call struct {
	*mock.Call
}

// Set is a helper method to define mock.On call
//   - key []byte
//   - val []byte
func (_e *Transaction_Expecter) Set(key interface{}, val interface{}) *Transaction_Set_Call {
	return &Transaction_Set_Call{Call: _e.mock.On("Set", key, val)}
}

func (_c *Transaction_Set_Call) Run(run func(key []byte, val []byte)) *Transaction_Set_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []byte
		if args[0] != nil {
			arg0 = args[0].([]byte)
		}
		var arg1 []byte
		if args[1] != nil {
			arg1 = args[1].([]byte)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Transaction_Set_Call) Return(err error) *Transaction_Set_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Transaction_Set_Call) RunAndReturn(run func(key []byte, val []byte) error) *Transaction_Set_Call {
	_c.Call.Return(run)
	return _c
}

// NewBatchStorage creates a new instance of BatchStorage. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewBatchStorage(t interface {
	mock.TestingT
	Cleanup(func())
}) *BatchStorage {
	mock := &BatchStorage{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// BatchStorage is an autogenerated mock type for the BatchStorage type
type BatchStorage struct {
	mock.Mock
}

type BatchStorage_Expecter struct {
	mock *mock.Mock
}

func (_m *BatchStorage) EXPECT() *BatchStorage_Expecter {
	return &BatchStorage_Expecter{mock: &_m.Mock}
}

// Flush provides a mock function for the type BatchStorage
func (_mock *BatchStorage) Flush() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Flush")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// BatchStorage_Flush_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Flush'
type BatchStorage_Flush_Call struct {
	*mock.Call
}

// Flush is a helper method to define mock.On call
func (_e *BatchStorage_Expecter) Flush() *BatchStorage_Flush_Call {
	return &BatchStorage_Flush_Call{Call: _e.mock.On("Flush")}
}

func (_c *BatchStorage_Flush_Call) Run(run func()) *BatchStorage_Flush_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *BatchStorage_Flush_Call) Return(err error) *BatchStorage_Flush_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *BatchStorage_Flush_Call) RunAndReturn(run func() error) *BatchStorage_Flush_Call {
	_c.Call.Return(run)
	return _c
}

// GetWriter provides a mock function for the type BatchStorage
func (_mock *BatchStorage) GetWriter() *badger.WriteBatch {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetWriter")
	}

	var r0 *badger.WriteBatch
	if returnFunc, ok := ret.Get(0).(func() *badger.WriteBatch); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*badger.WriteBatch)
		}
	}
	return r0
}

// BatchStorage_GetWriter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetWriter'
type BatchStorage_GetWriter_Call struct {
	*mock.Call
}

// GetWriter is a helper method to define mock.On call
func (_e *BatchStorage_Expecter) GetWriter() *BatchStorage_GetWriter_Call {
	return &BatchStorage_GetWriter_Call{Call: _e.mock.On("GetWriter")}
}

func (_c *BatchStorage_GetWriter_Call) Run(run func()) *BatchStorage_GetWriter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *BatchStorage_GetWriter_Call) Return(writeBatch *badger.WriteBatch) *BatchStorage_GetWriter_Call {
	_c.Call.Return(writeBatch)
	return _c
}

func (_c *BatchStorage_GetWriter_Call) RunAndReturn(run func() *badger.WriteBatch) *BatchStorage_GetWriter_Call {
	_c.Call.Return(run)
	return _c
}

// OnSucceed provides a mock function for the type BatchStorage
func (_mock *BatchStorage) OnSucceed(callback func()) {
	_mock.Called(callback)
	return
}

// BatchStorage_OnSucceed_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnSucceed'
type BatchStorage_OnSucceed_Call struct {
	*mock.Call
}

// OnSucceed is a helper method to define mock.On call
//   - callback func()
func (_e *BatchStorage_Expecter) OnSucceed(callback interface{}) *BatchStorage_OnSucceed_Call {
	return &BatchStorage_OnSucceed_Call{Call: _e.mock.On("OnSucceed", callback)}
}

func (_c *BatchStorage_OnSucceed_Call) Run(run func(callback func())) *BatchStorage_OnSucceed_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 func()
		if args[0] != nil {
			arg0 = args[0].(func())
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *BatchStorage_OnSucceed_Call) Return() *BatchStorage_OnSucceed_Call {
	_c.Call.Return()
	return _c
}

func (_c *BatchStorage_OnSucceed_Call) RunAndReturn(run func(callback func())) *BatchStorage_OnSucceed_Call {
	_c.Run(run)
	return _c
}

// NewBlocks creates a new instance of Blocks. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewBlocks(t interface {
	mock.TestingT
	Cleanup(func())
}) *Blocks {
	mock := &Blocks{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Blocks is an autogenerated mock type for the Blocks type
type Blocks struct {
	mock.Mock
}

type Blocks_Expecter struct {
	mock *mock.Mock
}

func (_m *Blocks) EXPECT() *Blocks_Expecter {
	return &Blocks_Expecter{mock: &_m.Mock}
}

// BatchIndexBlockContainingCollectionGuarantees provides a mock function for the type Blocks
func (_mock *Blocks) BatchIndexBlockContainingCollectionGuarantees(lctx lockctx.Proof, rw storage.ReaderBatchWriter, blockID flow.Identifier, guaranteeIDs []flow.Identifier) error {
	ret := _mock.Called(lctx, rw, blockID, guaranteeIDs)

	if len(ret) == 0 {
		panic("no return value specified for BatchIndexBlockContainingCollectionGuarantees")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(lockctx.Proof, storage.ReaderBatchWriter, flow.Identifier, []flow.Identifier) error); ok {
		r0 = returnFunc(lctx, rw, blockID, guaranteeIDs)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Blocks_BatchIndexBlockContainingCollectionGuarantees_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BatchIndexBlockContainingCollectionGuarantees'
type Blocks_BatchIndexBlockContainingCollectionGuarantees_Call struct {
	*mock.Call
}

// BatchIndexBlockContainingCollectionGuarantees is a helper method to define mock.On call
//   - lctx lockctx.Proof
//   - rw storage.ReaderBatchWriter
//   - blockID flow.Identifier
//   - guaranteeIDs []flow.Identifier
func (_e *Blocks_Expecter) BatchIndexBlockContainingCollectionGuarantees(lctx interface{}, rw interface{}, blockID interface{}, guaranteeIDs interface{}) *Blocks_BatchIndexBlockContainingCollectionGuarantees_Call {
	return &Blocks_BatchIndexBlockContainingCollectionGuarantees_Call{Call: _e.mock.On("BatchIndexBlockContainingCollectionGuarantees", lctx, rw, blockID, guaranteeIDs)}
}

func (_c *Blocks_BatchIndexBlockContainingCollectionGuarantees_Call) Run(run func(lctx lockctx.Proof, rw storage.ReaderBatchWriter, blockID flow.Identifier, guaranteeIDs []flow.Identifier)) *Blocks_BatchIndexBlockContainingCollectionGuarantees_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 lockctx.Proof
		if args[0] != nil {
			arg0 = args[0].(lockctx.Proof)
		}
		var arg1 storage.ReaderBatchWriter
		if args[1] != nil {
			arg1 = args[1].(storage.ReaderBatchWriter)
		}
		var arg2 flow.Identifier
		if args[2] != nil {
			arg2 = args[2].(flow.Identifier)
		}
		var arg3 []flow.Identifier
		if args[3] != nil {
			arg3 = args[3].([]flow.Identifier)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *Blocks_BatchIndexBlockContainingCollectionGuarantees_Call) Return(err error) *Blocks_BatchIndexBlockContainingCollectionGuarantees_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Blocks_BatchIndexBlockContainingCollectionGuarantees_Call) RunAndReturn(run func(lctx lockctx.Proof, rw storage.ReaderBatchWriter, blockID flow.Identifier, guaranteeIDs []flow.Identifier) error) *Blocks_BatchIndexBlockContainingCollectionGuarantees_Call {
	_c.Call.Return(run)
	return _c
}

// BatchStore provides a mock function for the type Blocks
func (_mock *Blocks) BatchStore(lctx lockctx.Proof, rw storage.ReaderBatchWriter, proposal *flow.Proposal) error {
	ret := _mock.Called(lctx, rw, proposal)

	if len(ret) == 0 {
		panic("no return value specified for BatchStore")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(lockctx.Proof, storage.ReaderBatchWriter, *flow.Proposal) error); ok {
		r0 = returnFunc(lctx, rw, proposal)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Blocks_BatchStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BatchStore'
type Blocks_BatchStore_Call struct {
	*mock.Call
}

// BatchStore is a helper method to define mock.On call
//   - lctx lockctx.Proof
//   - rw storage.ReaderBatchWriter
//   - proposal *flow.Proposal
func (_e *Blocks_Expecter) BatchStore(lctx interface{}, rw interface{}, proposal interface{}) *Blocks_BatchStore_Call {
	return &Blocks_BatchStore_Call{Call: _e.mock.On("BatchStore", lctx, rw, proposal)}
}

func (_c *Blocks_BatchStore_Call) Run(run func(lctx lockctx.Proof, rw storage.ReaderBatchWriter, proposal *flow.Proposal)) *Blocks_BatchStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 lockctx.Proof
		if args[0] != nil {
			arg0 = args[0].(lockctx.Proof)
		}
		var arg1 storage.ReaderBatchWriter
		if args[1] != nil {
			arg1 = args[1].(storage.ReaderBatchWriter)
		}
		var arg2 *flow.Proposal
		if args[2] != nil {
			arg2 = args[2].(*flow.Proposal)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Blocks_BatchStore_Call) Return(err error) *Blocks_BatchStore_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Blocks_BatchStore_Call) RunAndReturn(run func(lctx lockctx.Proof, rw storage.ReaderBatchWriter, proposal *flow.Proposal) error) *Blocks_BatchStore_Call {
	_c.Call.Return(run)
	return _c
}

// BlockIDByCollectionID provides a mock function for the type Blocks
func (_mock *Blocks) BlockIDByCollectionID(collID flow.Identifier) (flow.Identifier, error) {
	ret := _mock.Called(collID)

	if len(ret) == 0 {
		panic("no return value specified for BlockIDByCollectionID")
	}

	var r0 flow.Identifier
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (flow.Identifier, error)); ok {
		return returnFunc(collID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) flow.Identifier); ok {
		r0 = returnFunc(collID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.Identifier)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(collID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Blocks_BlockIDByCollectionID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BlockIDByCollectionID'
type Blocks_BlockIDByCollectionID_Call struct {
	*mock.Call
}

// BlockIDByCollectionID is a helper method to define mock.On call
//   - collID flow.Identifier
func (_e *Blocks_Expecter) BlockIDByCollectionID(collID interface{}) *Blocks_BlockIDByCollectionID_Call {
	return &Blocks_BlockIDByCollectionID_Call{Call: _e.mock.On("BlockIDByCollectionID", collID)}
}

func (_c *Blocks_BlockIDByCollectionID_Call) Run(run func(collID flow.Identifier)) *Blocks_BlockIDByCollectionID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Blocks_BlockIDByCollectionID_Call) Return(identifier flow.Identifier, err error) *Blocks_BlockIDByCollectionID_Call {
	_c.Call.Return(identifier, err)
	return _c
}

func (_c *Blocks_BlockIDByCollectionID_Call) RunAndReturn(run func(collID flow.Identifier) (flow.Identifier, error)) *Blocks_BlockIDByCollectionID_Call {
	_c.Call.Return(run)
	return _c
}

// ByCollectionID provides a mock function for the type Blocks
func (_mock *Blocks) ByCollectionID(collID flow.Identifier) (*flow.Block, error) {
	ret := _mock.Called(collID)

	if len(ret) == 0 {
		panic("no return value specified for ByCollectionID")
	}

	var r0 *flow.Block
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (*flow.Block, error)); ok {
		return returnFunc(collID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) *flow.Block); ok {
		r0 = returnFunc(collID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.Block)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(collID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Blocks_ByCollectionID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByCollectionID'
type Blocks_ByCollectionID_Call struct {
	*mock.Call
}

// ByCollectionID is a helper method to define mock.On call
//   - collID flow.Identifier
func (_e *Blocks_Expecter) ByCollectionID(collID interface{}) *Blocks_ByCollectionID_Call {
	return &Blocks_ByCollectionID_Call{Call: _e.mock.On("ByCollectionID", collID)}
}

func (_c *Blocks_ByCollectionID_Call) Run(run func(collID flow.Identifier)) *Blocks_ByCollectionID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Blocks_ByCollectionID_Call) Return(v *flow.Block, err error) *Blocks_ByCollectionID_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *Blocks_ByCollectionID_Call) RunAndReturn(run func(collID flow.Identifier) (*flow.Block, error)) *Blocks_ByCollectionID_Call {
	_c.Call.Return(run)
	return _c
}

// ByHeight provides a mock function for the type Blocks
func (_mock *Blocks) ByHeight(height uint64) (*flow.Block, error) {
	ret := _mock.Called(height)

	if len(ret) == 0 {
		panic("no return value specified for ByHeight")
	}

	var r0 *flow.Block
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(uint64) (*flow.Block, error)); ok {
		return returnFunc(height)
	}
	if returnFunc, ok := ret.Get(0).(func(uint64) *flow.Block); ok {
		r0 = returnFunc(height)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.Block)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(uint64) error); ok {
		r1 = returnFunc(height)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Blocks_ByHeight_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByHeight'
type Blocks_ByHeight_Call struct {
	*mock.Call
}

// ByHeight is a helper method to define mock.On call
//   - height uint64
func (_e *Blocks_Expecter) ByHeight(height interface{}) *Blocks_ByHeight_Call {
	return &Blocks_ByHeight_Call{Call: _e.mock.On("ByHeight", height)}
}

func (_c *Blocks_ByHeight_Call) Run(run func(height uint64)) *Blocks_ByHeight_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Blocks_ByHeight_Call) Return(v *flow.Block, err error) *Blocks_ByHeight_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *Blocks_ByHeight_Call) RunAndReturn(run func(height uint64) (*flow.Block, error)) *Blocks_ByHeight_Call {
	_c.Call.Return(run)
	return _c
}

// ByID provides a mock function for the type Blocks
func (_mock *Blocks) ByID(blockID flow.Identifier) (*flow.Block, error) {
	ret := _mock.Called(blockID)

	if len(ret) == 0 {
		panic("no return value specified for ByID")
	}

	var r0 *flow.Block
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (*flow.Block, error)); ok {
		return returnFunc(blockID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) *flow.Block); ok {
		r0 = returnFunc(blockID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.Block)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(blockID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Blocks_ByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByID'
type Blocks_ByID_Call struct {
	*mock.Call
}

// ByID is a helper method to define mock.On call
//   - blockID flow.Identifier
func (_e *Blocks_Expecter) ByID(blockID interface{}) *Blocks_ByID_Call {
	return &Blocks_ByID_Call{Call: _e.mock.On("ByID", blockID)}
}

func (_c *Blocks_ByID_Call) Run(run func(blockID flow.Identifier)) *Blocks_ByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Blocks_ByID_Call) Return(v *flow.Block, err error) *Blocks_ByID_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *Blocks_ByID_Call) RunAndReturn(run func(blockID flow.Identifier) (*flow.Block, error)) *Blocks_ByID_Call {
	_c.Call.Return(run)
	return _c
}

// ByView provides a mock function for the type Blocks
func (_mock *Blocks) ByView(view uint64) (*flow.Block, error) {
	ret := _mock.Called(view)

	if len(ret) == 0 {
		panic("no return value specified for ByView")
	}

	var r0 *flow.Block
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(uint64) (*flow.Block, error)); ok {
		return returnFunc(view)
	}
	if returnFunc, ok := ret.Get(0).(func(uint64) *flow.Block); ok {
		r0 = returnFunc(view)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.Block)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(uint64) error); ok {
		r1 = returnFunc(view)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Blocks_ByView_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByView'
type Blocks_ByView_Call struct {
	*mock.Call
}

// ByView is a helper method to define mock.On call
//   - view uint64
func (_e *Blocks_Expecter) ByView(view interface{}) *Blocks_ByView_Call {
	return &Blocks_ByView_Call{Call: _e.mock.On("ByView", view)}
}

func (_c *Blocks_ByView_Call) Run(run func(view uint64)) *Blocks_ByView_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Blocks_ByView_Call) Return(v *flow.Block, err error) *Blocks_ByView_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *Blocks_ByView_Call) RunAndReturn(run func(view uint64) (*flow.Block, error)) *Blocks_ByView_Call {
	_c.Call.Return(run)
	return _c
}

// ProposalByHeight provides a mock function for the type Blocks
func (_mock *Blocks) ProposalByHeight(height uint64) (*flow.Proposal, error) {
	ret := _mock.Called(height)

	if len(ret) == 0 {
		panic("no return value specified for ProposalByHeight")
	}

	var r0 *flow.Proposal
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(uint64) (*flow.Proposal, error)); ok {
		return returnFunc(height)
	}
	if returnFunc, ok := ret.Get(0).(func(uint64) *flow.Proposal); ok {
		r0 = returnFunc(height)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.Proposal)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(uint64) error); ok {
		r1 = returnFunc(height)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Blocks_ProposalByHeight_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ProposalByHeight'
type Blocks_ProposalByHeight_Call struct {
	*mock.Call
}

// ProposalByHeight is a helper method to define mock.On call
//   - height uint64
func (_e *Blocks_Expecter) ProposalByHeight(height interface{}) *Blocks_ProposalByHeight_Call {
	return &Blocks_ProposalByHeight_Call{Call: _e.mock.On("ProposalByHeight", height)}
}

func (_c *Blocks_ProposalByHeight_Call) Run(run func(height uint64)) *Blocks_ProposalByHeight_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Blocks_ProposalByHeight_Call) Return(proposal *flow.Proposal, err error) *Blocks_ProposalByHeight_Call {
	_c.Call.Return(proposal, err)
	return _c
}

func (_c *Blocks_ProposalByHeight_Call) RunAndReturn(run func(height uint64) (*flow.Proposal, error)) *Blocks_ProposalByHeight_Call {
	_c.Call.Return(run)
	return _c
}

// ProposalByID provides a mock function for the type Blocks
func (_mock *Blocks) ProposalByID(blockID flow.Identifier) (*flow.Proposal, error) {
	ret := _mock.Called(blockID)

	if len(ret) == 0 {
		panic("no return value specified for ProposalByID")
	}

	var r0 *flow.Proposal
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (*flow.Proposal, error)); ok {
		return returnFunc(blockID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) *flow.Proposal); ok {
		r0 = returnFunc(blockID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.Proposal)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(blockID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Blocks_ProposalByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ProposalByID'
type Blocks_ProposalByID_Call struct {
	*mock.Call
}

// ProposalByID is a helper method to define mock.On call
//   - blockID flow.Identifier
func (_e *Blocks_Expecter) ProposalByID(blockID interface{}) *Blocks_ProposalByID_Call {
	return &Blocks_ProposalByID_Call{Call: _e.mock.On("ProposalByID", blockID)}
}

func (_c *Blocks_ProposalByID_Call) Run(run func(blockID flow.Identifier)) *Blocks_ProposalByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Blocks_ProposalByID_Call) Return(proposal *flow.Proposal, err error) *Blocks_ProposalByID_Call {
	_c.Call.Return(proposal, err)
	return _c
}

func (_c *Blocks_ProposalByID_Call) RunAndReturn(run func(blockID flow.Identifier) (*flow.Proposal, error)) *Blocks_ProposalByID_Call {
	_c.Call.Return(run)
	return _c
}

// ProposalByView provides a mock function for the type Blocks
func (_mock *Blocks) ProposalByView(view uint64) (*flow.Proposal, error) {
	ret := _mock.Called(view)

	if len(ret) == 0 {
		panic("no return value specified for ProposalByView")
	}

	var r0 *flow.Proposal
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(uint64) (*flow.Proposal, error)); ok {
		return returnFunc(view)
	}
	if returnFunc, ok := ret.Get(0).(func(uint64) *flow.Proposal); ok {
		r0 = returnFunc(view)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.Proposal)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(uint64) error); ok {
		r1 = returnFunc(view)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Blocks_ProposalByView_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ProposalByView'
type Blocks_ProposalByView_Call struct {
	*mock.Call
}

// ProposalByView is a helper method to define mock.On call
//   - view uint64
func (_e *Blocks_Expecter) ProposalByView(view interface{}) *Blocks_ProposalByView_Call {
	return &Blocks_ProposalByView_Call{Call: _e.mock.On("ProposalByView", view)}
}

func (_c *Blocks_ProposalByView_Call) Run(run func(view uint64)) *Blocks_ProposalByView_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Blocks_ProposalByView_Call) Return(proposal *flow.Proposal, err error) *Blocks_ProposalByView_Call {
	_c.Call.Return(proposal, err)
	return _c
}

func (_c *Blocks_ProposalByView_Call) RunAndReturn(run func(view uint64) (*flow.Proposal, error)) *Blocks_ProposalByView_Call {
	_c.Call.Return(run)
	return _c
}

// NewChunkDataPacks creates a new instance of ChunkDataPacks. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewChunkDataPacks(t interface {
	mock.TestingT
	Cleanup(func())
}) *ChunkDataPacks {
	mock := &ChunkDataPacks{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// ChunkDataPacks is an autogenerated mock type for the ChunkDataPacks type
type ChunkDataPacks struct {
	mock.Mock
}

type ChunkDataPacks_Expecter struct {
	mock *mock.Mock
}

func (_m *ChunkDataPacks) EXPECT() *ChunkDataPacks_Expecter {
	return &ChunkDataPacks_Expecter{mock: &_m.Mock}
}

// BatchRemove provides a mock function for the type ChunkDataPacks
func (_mock *ChunkDataPacks) BatchRemove(chunkIDs []flow.Identifier, rw storage.ReaderBatchWriter) ([]flow.Identifier, error) {
	ret := _mock.Called(chunkIDs, rw)

	if len(ret) == 0 {
		panic("no return value specified for BatchRemove")
	}

	var r0 []flow.Identifier
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]flow.Identifier, storage.ReaderBatchWriter) ([]flow.Identifier, error)); ok {
		return returnFunc(chunkIDs, rw)
	}
	if returnFunc, ok := ret.Get(0).(func([]flow.Identifier, storage.ReaderBatchWriter) []flow.Identifier); ok {
		r0 = returnFunc(chunkIDs, rw)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]flow.Identifier)
		}
	}
	if returnFunc, ok := ret.Get(1).(func([]flow.Identifier, storage.ReaderBatchWriter) error); ok {
		r1 = returnFunc(chunkIDs, rw)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ChunkDataPacks_BatchRemove_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BatchRemove'
type ChunkDataPacks_BatchRemove_Call struct {
	*mock.Call
}

// BatchRemove is a helper method to define mock.On call
//   - chunkIDs []flow.Identifier
//   - rw storage.ReaderBatchWriter
func (_e *ChunkDataPacks_Expecter) BatchRemove(chunkIDs interface{}, rw interface{}) *ChunkDataPacks_BatchRemove_Call {
	return &ChunkDataPacks_BatchRemove_Call{Call: _e.mock.On("BatchRemove", chunkIDs, rw)}
}

func (_c *ChunkDataPacks_BatchRemove_Call) Run(run func(chunkIDs []flow.Identifier, rw storage.ReaderBatchWriter)) *ChunkDataPacks_BatchRemove_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []flow.Identifier
		if args[0] != nil {
			arg0 = args[0].([]flow.Identifier)
		}
		var arg1 storage.ReaderBatchWriter
		if args[1] != nil {
			arg1 = args[1].(storage.ReaderBatchWriter)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ChunkDataPacks_BatchRemove_Call) Return(chunkDataPackIDs []flow.Identifier, err error) *ChunkDataPacks_BatchRemove_Call {
	_c.Call.Return(chunkDataPackIDs, err)
	return _c
}

func (_c *ChunkDataPacks_BatchRemove_Call) RunAndReturn(run func(chunkIDs []flow.Identifier, rw storage.ReaderBatchWriter) ([]flow.Identifier, error)) *ChunkDataPacks_BatchRemove_Call {
	_c.Call.Return(run)
	return _c
}

// BatchRemoveChunkDataPacksOnly provides a mock function for the type ChunkDataPacks
func (_mock *ChunkDataPacks) BatchRemoveChunkDataPacksOnly(chunkIDs []flow.Identifier, chunkDataPackBatch storage.ReaderBatchWriter) error {
	ret := _mock.Called(chunkIDs, chunkDataPackBatch)

	if len(ret) == 0 {
		panic("no return value specified for BatchRemoveChunkDataPacksOnly")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func([]flow.Identifier, storage.ReaderBatchWriter) error); ok {
		r0 = returnFunc(chunkIDs, chunkDataPackBatch)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ChunkDataPacks_BatchRemoveChunkDataPacksOnly_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BatchRemoveChunkDataPacksOnly'
type ChunkDataPacks_BatchRemoveChunkDataPacksOnly_Call struct {
	*mock.Call
}

// BatchRemoveChunkDataPacksOnly is a helper method to define mock.On call
//   - chunkIDs []flow.Identifier
//   - chunkDataPackBatch storage.ReaderBatchWriter
func (_e *ChunkDataPacks_Expecter) BatchRemoveChunkDataPacksOnly(chunkIDs interface{}, chunkDataPackBatch interface{}) *ChunkDataPacks_BatchRemoveChunkDataPacksOnly_Call {
	return &ChunkDataPacks_BatchRemoveChunkDataPacksOnly_Call{Call: _e.mock.On("BatchRemoveChunkDataPacksOnly", chunkIDs, chunkDataPackBatch)}
}

func (_c *ChunkDataPacks_BatchRemoveChunkDataPacksOnly_Call) Run(run func(chunkIDs []flow.Identifier, chunkDataPackBatch storage.ReaderBatchWriter)) *ChunkDataPacks_BatchRemoveChunkDataPacksOnly_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []flow.Identifier
		if args[0] != nil {
			arg0 = args[0].([]flow.Identifier)
		}
		var arg1 storage.ReaderBatchWriter
		if args[1] != nil {
			arg1 = args[1].(storage.ReaderBatchWriter)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ChunkDataPacks_BatchRemoveChunkDataPacksOnly_Call) Return(err error) *ChunkDataPacks_BatchRemoveChunkDataPacksOnly_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ChunkDataPacks_BatchRemoveChunkDataPacksOnly_Call) RunAndReturn(run func(chunkIDs []flow.Identifier, chunkDataPackBatch storage.ReaderBatchWriter) error) *ChunkDataPacks_BatchRemoveChunkDataPacksOnly_Call {
	_c.Call.Return(run)
	return _c
}

// ByChunkID provides a mock function for the type ChunkDataPacks
func (_mock *ChunkDataPacks) ByChunkID(chunkID flow.Identifier) (*flow.ChunkDataPack, error) {
	ret := _mock.Called(chunkID)

	if len(ret) == 0 {
		panic("no return value specified for ByChunkID")
	}

	var r0 *flow.ChunkDataPack
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (*flow.ChunkDataPack, error)); ok {
		return returnFunc(chunkID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) *flow.ChunkDataPack); ok {
		r0 = returnFunc(chunkID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.ChunkDataPack)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(chunkID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ChunkDataPacks_ByChunkID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByChunkID'
type ChunkDataPacks_ByChunkID_Call struct {
	*mock.Call
}

// ByChunkID is a helper method to define mock.On call
//   - chunkID flow.Identifier
func (_e *ChunkDataPacks_Expecter) ByChunkID(chunkID interface{}) *ChunkDataPacks_ByChunkID_Call {
	return &ChunkDataPacks_ByChunkID_Call{Call: _e.mock.On("ByChunkID", chunkID)}
}

func (_c *ChunkDataPacks_ByChunkID_Call) Run(run func(chunkID flow.Identifier)) *ChunkDataPacks_ByChunkID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ChunkDataPacks_ByChunkID_Call) Return(chunkDataPack *flow.ChunkDataPack, err error) *ChunkDataPacks_ByChunkID_Call {
	_c.Call.Return(chunkDataPack, err)
	return _c
}

func (_c *ChunkDataPacks_ByChunkID_Call) RunAndReturn(run func(chunkID flow.Identifier) (*flow.ChunkDataPack, error)) *ChunkDataPacks_ByChunkID_Call {
	_c.Call.Return(run)
	return _c
}

// Store provides a mock function for the type ChunkDataPacks
func (_mock *ChunkDataPacks) Store(cs []*flow.ChunkDataPack) (func(lctx lockctx.Proof, protocolDBBatch storage.ReaderBatchWriter) error, error) {
	ret := _mock.Called(cs)

	if len(ret) == 0 {
		panic("no return value specified for Store")
	}

	var r0 func(lctx lockctx.Proof, protocolDBBatch storage.ReaderBatchWriter) error
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]*flow.ChunkDataPack) (func(lctx lockctx.Proof, protocolDBBatch storage.ReaderBatchWriter) error, error)); ok {
		return returnFunc(cs)
	}
	if returnFunc, ok := ret.Get(0).(func([]*flow.ChunkDataPack) func(lctx lockctx.Proof, protocolDBBatch storage.ReaderBatchWriter) error); ok {
		r0 = returnFunc(cs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(func(lctx lockctx.Proof, protocolDBBatch storage.ReaderBatchWriter) error)
		}
	}
	if returnFunc, ok := ret.Get(1).(func([]*flow.ChunkDataPack) error); ok {
		r1 = returnFunc(cs)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ChunkDataPacks_Store_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Store'
type ChunkDataPacks_Store_Call struct {
	*mock.Call
}

// Store is a helper method to define mock.On call
//   - cs []*flow.ChunkDataPack
func (_e *ChunkDataPacks_Expecter) Store(cs interface{}) *ChunkDataPacks_Store_Call {
	return &ChunkDataPacks_Store_Call{Call: _e.mock.On("Store", cs)}
}

func (_c *ChunkDataPacks_Store_Call) Run(run func(cs []*flow.ChunkDataPack)) *ChunkDataPacks_Store_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []*flow.ChunkDataPack
		if args[0] != nil {
			arg0 = args[0].([]*flow.ChunkDataPack)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ChunkDataPacks_Store_Call) Return(fn func(lctx lockctx.Proof, protocolDBBatch storage.ReaderBatchWriter) error, err error) *ChunkDataPacks_Store_Call {
	_c.Call.Return(fn, err)
	return _c
}

func (_c *ChunkDataPacks_Store_Call) RunAndReturn(run func(cs []*flow.ChunkDataPack) (func(lctx lockctx.Proof, protocolDBBatch storage.ReaderBatchWriter) error, error)) *ChunkDataPacks_Store_Call {
	_c.Call.Return(run)
	return _c
}

// NewStoredChunkDataPacks creates a new instance of StoredChunkDataPacks. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewStoredChunkDataPacks(t interface {
	mock.TestingT
	Cleanup(func())
}) *StoredChunkDataPacks {
	mock := &StoredChunkDataPacks{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// StoredChunkDataPacks is an autogenerated mock type for the StoredChunkDataPacks type
type StoredChunkDataPacks struct {
	mock.Mock
}

type StoredChunkDataPacks_Expecter struct {
	mock *mock.Mock
}

func (_m *StoredChunkDataPacks) EXPECT() *StoredChunkDataPacks_Expecter {
	return &StoredChunkDataPacks_Expecter{mock: &_m.Mock}
}

// BatchRemove provides a mock function for the type StoredChunkDataPacks
func (_mock *StoredChunkDataPacks) BatchRemove(chunkDataPackIDs []flow.Identifier, rw storage.ReaderBatchWriter) error {
	ret := _mock.Called(chunkDataPackIDs, rw)

	if len(ret) == 0 {
		panic("no return value specified for BatchRemove")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func([]flow.Identifier, storage.ReaderBatchWriter) error); ok {
		r0 = returnFunc(chunkDataPackIDs, rw)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// StoredChunkDataPacks_BatchRemove_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BatchRemove'
type StoredChunkDataPacks_BatchRemove_Call struct {
	*mock.Call
}

// BatchRemove is a helper method to define mock.On call
//   - chunkDataPackIDs []flow.Identifier
//   - rw storage.ReaderBatchWriter
func (_e *StoredChunkDataPacks_Expecter) BatchRemove(chunkDataPackIDs interface{}, rw interface{}) *StoredChunkDataPacks_BatchRemove_Call {
	return &StoredChunkDataPacks_BatchRemove_Call{Call: _e.mock.On("BatchRemove", chunkDataPackIDs, rw)}
}

func (_c *StoredChunkDataPacks_BatchRemove_Call) Run(run func(chunkDataPackIDs []flow.Identifier, rw storage.ReaderBatchWriter)) *StoredChunkDataPacks_BatchRemove_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []flow.Identifier
		if args[0] != nil {
			arg0 = args[0].([]flow.Identifier)
		}
		var arg1 storage.ReaderBatchWriter
		if args[1] != nil {
			arg1 = args[1].(storage.ReaderBatchWriter)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *StoredChunkDataPacks_BatchRemove_Call) Return(err error) *StoredChunkDataPacks_BatchRemove_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *StoredChunkDataPacks_BatchRemove_Call) RunAndReturn(run func(chunkDataPackIDs []flow.Identifier, rw storage.ReaderBatchWriter) error) *StoredChunkDataPacks_BatchRemove_Call {
	_c.Call.Return(run)
	return _c
}

// ByID provides a mock function for the type StoredChunkDataPacks
func (_mock *StoredChunkDataPacks) ByID(id flow.Identifier) (*storage.StoredChunkDataPack, error) {
	ret := _mock.Called(id)

	if len(ret) == 0 {
		panic("no return value specified for ByID")
	}

	var r0 *storage.StoredChunkDataPack
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (*storage.StoredChunkDataPack, error)); ok {
		return returnFunc(id)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) *storage.StoredChunkDataPack); ok {
		r0 = returnFunc(id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*storage.StoredChunkDataPack)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// StoredChunkDataPacks_ByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByID'
type StoredChunkDataPacks_ByID_Call struct {
	*mock.Call
}

// ByID is a helper method to define mock.On call
//   - id flow.Identifier
func (_e *StoredChunkDataPacks_Expecter) ByID(id interface{}) *StoredChunkDataPacks_ByID_Call {
	return &StoredChunkDataPacks_ByID_Call{Call: _e.mock.On("ByID", id)}
}

func (_c *StoredChunkDataPacks_ByID_Call) Run(run func(id flow.Identifier)) *StoredChunkDataPacks_ByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *StoredChunkDataPacks_ByID_Call) Return(storedChunkDataPack *storage.StoredChunkDataPack, err error) *StoredChunkDataPacks_ByID_Call {
	_c.Call.Return(storedChunkDataPack, err)
	return _c
}

func (_c *StoredChunkDataPacks_ByID_Call) RunAndReturn(run func(id flow.Identifier) (*storage.StoredChunkDataPack, error)) *StoredChunkDataPacks_ByID_Call {
	_c.Call.Return(run)
	return _c
}

// Remove provides a mock function for the type StoredChunkDataPacks
func (_mock *StoredChunkDataPacks) Remove(chunkDataPackIDs []flow.Identifier) error {
	ret := _mock.Called(chunkDataPackIDs)

	if len(ret) == 0 {
		panic("no return value specified for Remove")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func([]flow.Identifier) error); ok {
		r0 = returnFunc(chunkDataPackIDs)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// StoredChunkDataPacks_Remove_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Remove'
type StoredChunkDataPacks_Remove_Call struct {
	*mock.Call
}

// Remove is a helper method to define mock.On call
//   - chunkDataPackIDs []flow.Identifier
func (_e *StoredChunkDataPacks_Expecter) Remove(chunkDataPackIDs interface{}) *StoredChunkDataPacks_Remove_Call {
	return &StoredChunkDataPacks_Remove_Call{Call: _e.mock.On("Remove", chunkDataPackIDs)}
}

func (_c *StoredChunkDataPacks_Remove_Call) Run(run func(chunkDataPackIDs []flow.Identifier)) *StoredChunkDataPacks_Remove_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []flow.Identifier
		if args[0] != nil {
			arg0 = args[0].([]flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *StoredChunkDataPacks_Remove_Call) Return(err error) *StoredChunkDataPacks_Remove_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *StoredChunkDataPacks_Remove_Call) RunAndReturn(run func(chunkDataPackIDs []flow.Identifier) error) *StoredChunkDataPacks_Remove_Call {
	_c.Call.Return(run)
	return _c
}

// StoreChunkDataPacks provides a mock function for the type StoredChunkDataPacks
func (_mock *StoredChunkDataPacks) StoreChunkDataPacks(cs []*storage.StoredChunkDataPack) ([]flow.Identifier, error) {
	ret := _mock.Called(cs)

	if len(ret) == 0 {
		panic("no return value specified for StoreChunkDataPacks")
	}

	var r0 []flow.Identifier
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]*storage.StoredChunkDataPack) ([]flow.Identifier, error)); ok {
		return returnFunc(cs)
	}
	if returnFunc, ok := ret.Get(0).(func([]*storage.StoredChunkDataPack) []flow.Identifier); ok {
		r0 = returnFunc(cs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]flow.Identifier)
		}
	}
	if returnFunc, ok := ret.Get(1).(func([]*storage.StoredChunkDataPack) error); ok {
		r1 = returnFunc(cs)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// StoredChunkDataPacks_StoreChunkDataPacks_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StoreChunkDataPacks'
type StoredChunkDataPacks_StoreChunkDataPacks_Call struct {
	*mock.Call
}

// StoreChunkDataPacks is a helper method to define mock.On call
//   - cs []*storage.StoredChunkDataPack
func (_e *StoredChunkDataPacks_Expecter) StoreChunkDataPacks(cs interface{}) *StoredChunkDataPacks_StoreChunkDataPacks_Call {
	return &StoredChunkDataPacks_StoreChunkDataPacks_Call{Call: _e.mock.On("StoreChunkDataPacks", cs)}
}

func (_c *StoredChunkDataPacks_StoreChunkDataPacks_Call) Run(run func(cs []*storage.StoredChunkDataPack)) *StoredChunkDataPacks_StoreChunkDataPacks_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []*storage.StoredChunkDataPack
		if args[0] != nil {
			arg0 = args[0].([]*storage.StoredChunkDataPack)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *StoredChunkDataPacks_StoreChunkDataPacks_Call) Return(identifiers []flow.Identifier, err error) *StoredChunkDataPacks_StoreChunkDataPacks_Call {
	_c.Call.Return(identifiers, err)
	return _c
}

func (_c *StoredChunkDataPacks_StoreChunkDataPacks_Call) RunAndReturn(run func(cs []*storage.StoredChunkDataPack) ([]flow.Identifier, error)) *StoredChunkDataPacks_StoreChunkDataPacks_Call {
	_c.Call.Return(run)
	return _c
}

// NewChunksQueue creates a new instance of ChunksQueue. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewChunksQueue(t interface {
	mock.TestingT
	Cleanup(func())
}) *ChunksQueue {
	mock := &ChunksQueue{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// ChunksQueue is an autogenerated mock type for the ChunksQueue type
type ChunksQueue struct {
	mock.Mock
}

type ChunksQueue_Expecter struct {
	mock *mock.Mock
}

func (_m *ChunksQueue) EXPECT() *ChunksQueue_Expecter {
	return &ChunksQueue_Expecter{mock: &_m.Mock}
}

// AtIndex provides a mock function for the type ChunksQueue
func (_mock *ChunksQueue) AtIndex(index uint64) (*chunks.Locator, error) {
	ret := _mock.Called(index)

	if len(ret) == 0 {
		panic("no return value specified for AtIndex")
	}

	var r0 *chunks.Locator
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(uint64) (*chunks.Locator, error)); ok {
		return returnFunc(index)
	}
	if returnFunc, ok := ret.Get(0).(func(uint64) *chunks.Locator); ok {
		r0 = returnFunc(index)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*chunks.Locator)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(uint64) error); ok {
		r1 = returnFunc(index)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ChunksQueue_AtIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AtIndex'
type ChunksQueue_AtIndex_Call struct {
	*mock.Call
}

// AtIndex is a helper method to define mock.On call
//   - index uint64
func (_e *ChunksQueue_Expecter) AtIndex(index interface{}) *ChunksQueue_AtIndex_Call {
	return &ChunksQueue_AtIndex_Call{Call: _e.mock.On("AtIndex", index)}
}

func (_c *ChunksQueue_AtIndex_Call) Run(run func(index uint64)) *ChunksQueue_AtIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ChunksQueue_AtIndex_Call) Return(locator *chunks.Locator, err error) *ChunksQueue_AtIndex_Call {
	_c.Call.Return(locator, err)
	return _c
}

func (_c *ChunksQueue_AtIndex_Call) RunAndReturn(run func(index uint64) (*chunks.Locator, error)) *ChunksQueue_AtIndex_Call {
	_c.Call.Return(run)
	return _c
}

// LatestIndex provides a mock function for the type ChunksQueue
func (_mock *ChunksQueue) LatestIndex() (uint64, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for LatestIndex")
	}

	var r0 uint64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (uint64, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() uint64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint64)
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ChunksQueue_LatestIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LatestIndex'
type ChunksQueue_LatestIndex_Call struct {
	*mock.Call
}

// LatestIndex is a helper method to define mock.On call
func (_e *ChunksQueue_Expecter) LatestIndex() *ChunksQueue_LatestIndex_Call {
	return &ChunksQueue_LatestIndex_Call{Call: _e.mock.On("LatestIndex")}
}

func (_c *ChunksQueue_LatestIndex_Call) Run(run func()) *ChunksQueue_LatestIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ChunksQueue_LatestIndex_Call) Return(v uint64, err error) *ChunksQueue_LatestIndex_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *ChunksQueue_LatestIndex_Call) RunAndReturn(run func() (uint64, error)) *ChunksQueue_LatestIndex_Call {
	_c.Call.Return(run)
	return _c
}

// StoreChunkLocator provides a mock function for the type ChunksQueue
func (_mock *ChunksQueue) StoreChunkLocator(locator *chunks.Locator) (bool, error) {
	ret := _mock.Called(locator)

	if len(ret) == 0 {
		panic("no return value specified for StoreChunkLocator")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*chunks.Locator) (bool, error)); ok {
		return returnFunc(locator)
	}
	if returnFunc, ok := ret.Get(0).(func(*chunks.Locator) bool); ok {
		r0 = returnFunc(locator)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(*chunks.Locator) error); ok {
		r1 = returnFunc(locator)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ChunksQueue_StoreChunkLocator_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StoreChunkLocator'
type ChunksQueue_StoreChunkLocator_Call struct {
	*mock.Call
}

// StoreChunkLocator is a helper method to define mock.On call
//   - locator *chunks.Locator
func (_e *ChunksQueue_Expecter) StoreChunkLocator(locator interface{}) *ChunksQueue_StoreChunkLocator_Call {
	return &ChunksQueue_StoreChunkLocator_Call{Call: _e.mock.On("StoreChunkLocator", locator)}
}

func (_c *ChunksQueue_StoreChunkLocator_Call) Run(run func(locator *chunks.Locator)) *ChunksQueue_StoreChunkLocator_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *chunks.Locator
		if args[0] != nil {
			arg0 = args[0].(*chunks.Locator)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ChunksQueue_StoreChunkLocator_Call) Return(b bool, err error) *ChunksQueue_StoreChunkLocator_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *ChunksQueue_StoreChunkLocator_Call) RunAndReturn(run func(locator *chunks.Locator) (bool, error)) *ChunksQueue_StoreChunkLocator_Call {
	_c.Call.Return(run)
	return _c
}

// NewClusterBlocks creates a new instance of ClusterBlocks. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewClusterBlocks(t interface {
	mock.TestingT
	Cleanup(func())
}) *ClusterBlocks {
	mock := &ClusterBlocks{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// ClusterBlocks is an autogenerated mock type for the ClusterBlocks type
type ClusterBlocks struct {
	mock.Mock
}

type ClusterBlocks_Expecter struct {
	mock *mock.Mock
}

func (_m *ClusterBlocks) EXPECT() *ClusterBlocks_Expecter {
	return &ClusterBlocks_Expecter{mock: &_m.Mock}
}

// ProposalByHeight provides a mock function for the type ClusterBlocks
func (_mock *ClusterBlocks) ProposalByHeight(height uint64) (*cluster.Proposal, error) {
	ret := _mock.Called(height)

	if len(ret) == 0 {
		panic("no return value specified for ProposalByHeight")
	}

	var r0 *cluster.Proposal
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(uint64) (*cluster.Proposal, error)); ok {
		return returnFunc(height)
	}
	if returnFunc, ok := ret.Get(0).(func(uint64) *cluster.Proposal); ok {
		r0 = returnFunc(height)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cluster.Proposal)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(uint64) error); ok {
		r1 = returnFunc(height)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ClusterBlocks_ProposalByHeight_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ProposalByHeight'
type ClusterBlocks_ProposalByHeight_Call struct {
	*mock.Call
}

// ProposalByHeight is a helper method to define mock.On call
//   - height uint64
func (_e *ClusterBlocks_Expecter) ProposalByHeight(height interface{}) *ClusterBlocks_ProposalByHeight_Call {
	return &ClusterBlocks_ProposalByHeight_Call{Call: _e.mock.On("ProposalByHeight", height)}
}

func (_c *ClusterBlocks_ProposalByHeight_Call) Run(run func(height uint64)) *ClusterBlocks_ProposalByHeight_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ClusterBlocks_ProposalByHeight_Call) Return(proposal *cluster.Proposal, err error) *ClusterBlocks_ProposalByHeight_Call {
	_c.Call.Return(proposal, err)
	return _c
}

func (_c *ClusterBlocks_ProposalByHeight_Call) RunAndReturn(run func(height uint64) (*cluster.Proposal, error)) *ClusterBlocks_ProposalByHeight_Call {
	_c.Call.Return(run)
	return _c
}

// ProposalByID provides a mock function for the type ClusterBlocks
func (_mock *ClusterBlocks) ProposalByID(blockID flow.Identifier) (*cluster.Proposal, error) {
	ret := _mock.Called(blockID)

	if len(ret) == 0 {
		panic("no return value specified for ProposalByID")
	}

	var r0 *cluster.Proposal
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (*cluster.Proposal, error)); ok {
		return returnFunc(blockID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) *cluster.Proposal); ok {
		r0 = returnFunc(blockID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cluster.Proposal)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(blockID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ClusterBlocks_ProposalByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ProposalByID'
type ClusterBlocks_ProposalByID_Call struct {
	*mock.Call
}

// ProposalByID is a helper method to define mock.On call
//   - blockID flow.Identifier
func (_e *ClusterBlocks_Expecter) ProposalByID(blockID interface{}) *ClusterBlocks_ProposalByID_Call {
	return &ClusterBlocks_ProposalByID_Call{Call: _e.mock.On("ProposalByID", blockID)}
}

func (_c *ClusterBlocks_ProposalByID_Call) Run(run func(blockID flow.Identifier)) *ClusterBlocks_ProposalByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ClusterBlocks_ProposalByID_Call) Return(proposal *cluster.Proposal, err error) *ClusterBlocks_ProposalByID_Call {
	_c.Call.Return(proposal, err)
	return _c
}

func (_c *ClusterBlocks_ProposalByID_Call) RunAndReturn(run func(blockID flow.Identifier) (*cluster.Proposal, error)) *ClusterBlocks_ProposalByID_Call {
	_c.Call.Return(run)
	return _c
}

// NewClusterPayloads creates a new instance of ClusterPayloads. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewClusterPayloads(t interface {
	mock.TestingT
	Cleanup(func())
}) *ClusterPayloads {
	mock := &ClusterPayloads{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// ClusterPayloads is an autogenerated mock type for the ClusterPayloads type
type ClusterPayloads struct {
	mock.Mock
}

type ClusterPayloads_Expecter struct {
	mock *mock.Mock
}

func (_m *ClusterPayloads) EXPECT() *ClusterPayloads_Expecter {
	return &ClusterPayloads_Expecter{mock: &_m.Mock}
}

// ByBlockID provides a mock function for the type ClusterPayloads
func (_mock *ClusterPayloads) ByBlockID(blockID flow.Identifier) (*cluster.Payload, error) {
	ret := _mock.Called(blockID)

	if len(ret) == 0 {
		panic("no return value specified for ByBlockID")
	}

	var r0 *cluster.Payload
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (*cluster.Payload, error)); ok {
		return returnFunc(blockID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) *cluster.Payload); ok {
		r0 = returnFunc(blockID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cluster.Payload)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(blockID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ClusterPayloads_ByBlockID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByBlockID'
type ClusterPayloads_ByBlockID_Call struct {
	*mock.Call
}

// ByBlockID is a helper method to define mock.On call
//   - blockID flow.Identifier
func (_e *ClusterPayloads_Expecter) ByBlockID(blockID interface{}) *ClusterPayloads_ByBlockID_Call {
	return &ClusterPayloads_ByBlockID_Call{Call: _e.mock.On("ByBlockID", blockID)}
}

func (_c *ClusterPayloads_ByBlockID_Call) Run(run func(blockID flow.Identifier)) *ClusterPayloads_ByBlockID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ClusterPayloads_ByBlockID_Call) Return(payload *cluster.Payload, err error) *ClusterPayloads_ByBlockID_Call {
	_c.Call.Return(payload, err)
	return _c
}

func (_c *ClusterPayloads_ByBlockID_Call) RunAndReturn(run func(blockID flow.Identifier) (*cluster.Payload, error)) *ClusterPayloads_ByBlockID_Call {
	_c.Call.Return(run)
	return _c
}

// NewCollectionsReader creates a new instance of CollectionsReader. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewCollectionsReader(t interface {
	mock.TestingT
	Cleanup(func())
}) *CollectionsReader {
	mock := &CollectionsReader{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// CollectionsReader is an autogenerated mock type for the CollectionsReader type
type CollectionsReader struct {
	mock.Mock
}

type CollectionsReader_Expecter struct {
	mock *mock.Mock
}

func (_m *CollectionsReader) EXPECT() *CollectionsReader_Expecter {
	return &CollectionsReader_Expecter{mock: &_m.Mock}
}

// ByID provides a mock function for the type CollectionsReader
func (_mock *CollectionsReader) ByID(collID flow.Identifier) (*flow.Collection, error) {
	ret := _mock.Called(collID)

	if len(ret) == 0 {
		panic("no return value specified for ByID")
	}

	var r0 *flow.Collection
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (*flow.Collection, error)); ok {
		return returnFunc(collID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) *flow.Collection); ok {
		r0 = returnFunc(collID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.Collection)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(collID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// CollectionsReader_ByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByID'
type CollectionsReader_ByID_Call struct {
	*mock.Call
}

// ByID is a helper method to define mock.On call
//   - collID flow.Identifier
func (_e *CollectionsReader_Expecter) ByID(collID interface{}) *CollectionsReader_ByID_Call {
	return &CollectionsReader_ByID_Call{Call: _e.mock.On("ByID", collID)}
}

func (_c *CollectionsReader_ByID_Call) Run(run func(collID flow.Identifier)) *CollectionsReader_ByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *CollectionsReader_ByID_Call) Return(collection *flow.Collection, err error) *CollectionsReader_ByID_Call {
	_c.Call.Return(collection, err)
	return _c
}

func (_c *CollectionsReader_ByID_Call) RunAndReturn(run func(collID flow.Identifier) (*flow.Collection, error)) *CollectionsReader_ByID_Call {
	_c.Call.Return(run)
	return _c
}

// LightByID provides a mock function for the type CollectionsReader
func (_mock *CollectionsReader) LightByID(collID flow.Identifier) (*flow.LightCollection, error) {
	ret := _mock.Called(collID)

	if len(ret) == 0 {
		panic("no return value specified for LightByID")
	}

	var r0 *flow.LightCollection
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (*flow.LightCollection, error)); ok {
		return returnFunc(collID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) *flow.LightCollection); ok {
		r0 = returnFunc(collID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.LightCollection)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(collID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// CollectionsReader_LightByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LightByID'
type CollectionsReader_LightByID_Call struct {
	*mock.Call
}

// LightByID is a helper method to define mock.On call
//   - collID flow.Identifier
func (_e *CollectionsReader_Expecter) LightByID(collID interface{}) *CollectionsReader_LightByID_Call {
	return &CollectionsReader_LightByID_Call{Call: _e.mock.On("LightByID", collID)}
}

func (_c *CollectionsReader_LightByID_Call) Run(run func(collID flow.Identifier)) *CollectionsReader_LightByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *CollectionsReader_LightByID_Call) Return(lightCollection *flow.LightCollection, err error) *CollectionsReader_LightByID_Call {
	_c.Call.Return(lightCollection, err)
	return _c
}

func (_c *CollectionsReader_LightByID_Call) RunAndReturn(run func(collID flow.Identifier) (*flow.LightCollection, error)) *CollectionsReader_LightByID_Call {
	_c.Call.Return(run)
	return _c
}

// LightByTransactionID provides a mock function for the type CollectionsReader
func (_mock *CollectionsReader) LightByTransactionID(txID flow.Identifier) (*flow.LightCollection, error) {
	ret := _mock.Called(txID)

	if len(ret) == 0 {
		panic("no return value specified for LightByTransactionID")
	}

	var r0 *flow.LightCollection
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (*flow.LightCollection, error)); ok {
		return returnFunc(txID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) *flow.LightCollection); ok {
		r0 = returnFunc(txID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.LightCollection)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(txID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// CollectionsReader_LightByTransactionID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LightByTransactionID'
type CollectionsReader_LightByTransactionID_Call struct {
	*mock.Call
}

// LightByTransactionID is a helper method to define mock.On call
//   - txID flow.Identifier
func (_e *CollectionsReader_Expecter) LightByTransactionID(txID interface{}) *CollectionsReader_LightByTransactionID_Call {
	return &CollectionsReader_LightByTransactionID_Call{Call: _e.mock.On("LightByTransactionID", txID)}
}

func (_c *CollectionsReader_LightByTransactionID_Call) Run(run func(txID flow.Identifier)) *CollectionsReader_LightByTransactionID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *CollectionsReader_LightByTransactionID_Call) Return(lightCollection *flow.LightCollection, err error) *CollectionsReader_LightByTransactionID_Call {
	_c.Call.Return(lightCollection, err)
	return _c
}

func (_c *CollectionsReader_LightByTransactionID_Call) RunAndReturn(run func(txID flow.Identifier) (*flow.LightCollection, error)) *CollectionsReader_LightByTransactionID_Call {
	_c.Call.Return(run)
	return _c
}

// NewCollections creates a new instance of Collections. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewCollections(t interface {
	mock.TestingT
	Cleanup(func())
}) *Collections {
	mock := &Collections{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Collections is an autogenerated mock type for the Collections type
type Collections struct {
	mock.Mock
}

type Collections_Expecter struct {
	mock *mock.Mock
}

func (_m *Collections) EXPECT() *Collections_Expecter {
	return &Collections_Expecter{mock: &_m.Mock}
}

// BatchStoreAndIndexByTransaction provides a mock function for the type Collections
func (_mock *Collections) BatchStoreAndIndexByTransaction(lctx lockctx.Proof, collection *flow.Collection, batch storage.ReaderBatchWriter) (*flow.LightCollection, error) {
	ret := _mock.Called(lctx, collection, batch)

	if len(ret) == 0 {
		panic("no return value specified for BatchStoreAndIndexByTransaction")
	}

	var r0 *flow.LightCollection
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(lockctx.Proof, *flow.Collection, storage.ReaderBatchWriter) (*flow.LightCollection, error)); ok {
		return returnFunc(lctx, collection, batch)
	}
	if returnFunc, ok := ret.Get(0).(func(lockctx.Proof, *flow.Collection, storage.ReaderBatchWriter) *flow.LightCollection); ok {
		r0 = returnFunc(lctx, collection, batch)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.LightCollection)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(lockctx.Proof, *flow.Collection, storage.ReaderBatchWriter) error); ok {
		r1 = returnFunc(lctx, collection, batch)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Collections_BatchStoreAndIndexByTransaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BatchStoreAndIndexByTransaction'
type Collections_BatchStoreAndIndexByTransaction_Call struct {
	*mock.Call
}

// BatchStoreAndIndexByTransaction is a helper method to define mock.On call
//   - lctx lockctx.Proof
//   - collection *flow.Collection
//   - batch storage.ReaderBatchWriter
func (_e *Collections_Expecter) BatchStoreAndIndexByTransaction(lctx interface{}, collection interface{}, batch interface{}) *Collections_BatchStoreAndIndexByTransaction_Call {
	return &Collections_BatchStoreAndIndexByTransaction_Call{Call: _e.mock.On("BatchStoreAndIndexByTransaction", lctx, collection, batch)}
}

func (_c *Collections_BatchStoreAndIndexByTransaction_Call) Run(run func(lctx lockctx.Proof, collection *flow.Collection, batch storage.ReaderBatchWriter)) *Collections_BatchStoreAndIndexByTransaction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 lockctx.Proof
		if args[0] != nil {
			arg0 = args[0].(lockctx.Proof)
		}
		var arg1 *flow.Collection
		if args[1] != nil {
			arg1 = args[1].(*flow.Collection)
		}
		var arg2 storage.ReaderBatchWriter
		if args[2] != nil {
			arg2 = args[2].(storage.ReaderBatchWriter)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Collections_BatchStoreAndIndexByTransaction_Call) Return(lightCollection *flow.LightCollection, err error) *Collections_BatchStoreAndIndexByTransaction_Call {
	_c.Call.Return(lightCollection, err)
	return _c
}

func (_c *Collections_BatchStoreAndIndexByTransaction_Call) RunAndReturn(run func(lctx lockctx.Proof, collection *flow.Collection, batch storage.ReaderBatchWriter) (*flow.LightCollection, error)) *Collections_BatchStoreAndIndexByTransaction_Call {
	_c.Call.Return(run)
	return _c
}

// ByID provides a mock function for the type Collections
func (_mock *Collections) ByID(collID flow.Identifier) (*flow.Collection, error) {
	ret := _mock.Called(collID)

	if len(ret) == 0 {
		panic("no return value specified for ByID")
	}

	var r0 *flow.Collection
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (*flow.Collection, error)); ok {
		return returnFunc(collID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) *flow.Collection); ok {
		r0 = returnFunc(collID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.Collection)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(collID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Collections_ByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByID'
type Collections_ByID_Call struct {
	*mock.Call
}

// ByID is a helper method to define mock.On call
//   - collID flow.Identifier
func (_e *Collections_Expecter) ByID(collID interface{}) *Collections_ByID_Call {
	return &Collections_ByID_Call{Call: _e.mock.On("ByID", collID)}
}

func (_c *Collections_ByID_Call) Run(run func(collID flow.Identifier)) *Collections_ByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Collections_ByID_Call) Return(collection *flow.Collection, err error) *Collections_ByID_Call {
	_c.Call.Return(collection, err)
	return _c
}

func (_c *Collections_ByID_Call) RunAndReturn(run func(collID flow.Identifier) (*flow.Collection, error)) *Collections_ByID_Call {
	_c.Call.Return(run)
	return _c
}

// LightByID provides a mock function for the type Collections
func (_mock *Collections) LightByID(collID flow.Identifier) (*flow.LightCollection, error) {
	ret := _mock.Called(collID)

	if len(ret) == 0 {
		panic("no return value specified for LightByID")
	}

	var r0 *flow.LightCollection
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (*flow.LightCollection, error)); ok {
		return returnFunc(collID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) *flow.LightCollection); ok {
		r0 = returnFunc(collID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.LightCollection)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(collID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Collections_LightByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LightByID'
type Collections_LightByID_Call struct {
	*mock.Call
}

// LightByID is a helper method to define mock.On call
//   - collID flow.Identifier
func (_e *Collections_Expecter) LightByID(collID interface{}) *Collections_LightByID_Call {
	return &Collections_LightByID_Call{Call: _e.mock.On("LightByID", collID)}
}

func (_c *Collections_LightByID_Call) Run(run func(collID flow.Identifier)) *Collections_LightByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Collections_LightByID_Call) Return(lightCollection *flow.LightCollection, err error) *Collections_LightByID_Call {
	_c.Call.Return(lightCollection, err)
	return _c
}

func (_c *Collections_LightByID_Call) RunAndReturn(run func(collID flow.Identifier) (*flow.LightCollection, error)) *Collections_LightByID_Call {
	_c.Call.Return(run)
	return _c
}

// LightByTransactionID provides a mock function for the type Collections
func (_mock *Collections) LightByTransactionID(txID flow.Identifier) (*flow.LightCollection, error) {
	ret := _mock.Called(txID)

	if len(ret) == 0 {
		panic("no return value specified for LightByTransactionID")
	}

	var r0 *flow.LightCollection
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (*flow.LightCollection, error)); ok {
		return returnFunc(txID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) *flow.LightCollection); ok {
		r0 = returnFunc(txID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.LightCollection)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(txID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Collections_LightByTransactionID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LightByTransactionID'
type Collections_LightByTransactionID_Call struct {
	*mock.Call
}

// LightByTransactionID is a helper method to define mock.On call
//   - txID flow.Identifier
func (_e *Collections_Expecter) LightByTransactionID(txID interface{}) *Collections_LightByTransactionID_Call {
	return &Collections_LightByTransactionID_Call{Call: _e.mock.On("LightByTransactionID", txID)}
}

func (_c *Collections_LightByTransactionID_Call) Run(run func(txID flow.Identifier)) *Collections_LightByTransactionID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Collections_LightByTransactionID_Call) Return(lightCollection *flow.LightCollection, err error) *Collections_LightByTransactionID_Call {
	_c.Call.Return(lightCollection, err)
	return _c
}

func (_c *Collections_LightByTransactionID_Call) RunAndReturn(run func(txID flow.Identifier) (*flow.LightCollection, error)) *Collections_LightByTransactionID_Call {
	_c.Call.Return(run)
	return _c
}

// Remove provides a mock function for the type Collections
func (_mock *Collections) Remove(collID flow.Identifier) error {
	ret := _mock.Called(collID)

	if len(ret) == 0 {
		panic("no return value specified for Remove")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) error); ok {
		r0 = returnFunc(collID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Collections_Remove_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Remove'
type Collections_Remove_Call struct {
	*mock.Call
}

// Remove is a helper method to define mock.On call
//   - collID flow.Identifier
func (_e *Collections_Expecter) Remove(collID interface{}) *Collections_Remove_Call {
	return &Collections_Remove_Call{Call: _e.mock.On("Remove", collID)}
}

func (_c *Collections_Remove_Call) Run(run func(collID flow.Identifier)) *Collections_Remove_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Collections_Remove_Call) Return(err error) *Collections_Remove_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Collections_Remove_Call) RunAndReturn(run func(collID flow.Identifier) error) *Collections_Remove_Call {
	_c.Call.Return(run)
	return _c
}

// Store provides a mock function for the type Collections
func (_mock *Collections) Store(collection *flow.Collection) (*flow.LightCollection, error) {
	ret := _mock.Called(collection)

	if len(ret) == 0 {
		panic("no return value specified for Store")
	}

	var r0 *flow.LightCollection
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*flow.Collection) (*flow.LightCollection, error)); ok {
		return returnFunc(collection)
	}
	if returnFunc, ok := ret.Get(0).(func(*flow.Collection) *flow.LightCollection); ok {
		r0 = returnFunc(collection)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.LightCollection)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*flow.Collection) error); ok {
		r1 = returnFunc(collection)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Collections_Store_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Store'
type Collections_Store_Call struct {
	*mock.Call
}

// Store is a helper method to define mock.On call
//   - collection *flow.Collection
func (_e *Collections_Expecter) Store(collection interface{}) *Collections_Store_Call {
	return &Collections_Store_Call{Call: _e.mock.On("Store", collection)}
}

func (_c *Collections_Store_Call) Run(run func(collection *flow.Collection)) *Collections_Store_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *flow.Collection
		if args[0] != nil {
			arg0 = args[0].(*flow.Collection)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Collections_Store_Call) Return(lightCollection *flow.LightCollection, err error) *Collections_Store_Call {
	_c.Call.Return(lightCollection, err)
	return _c
}

func (_c *Collections_Store_Call) RunAndReturn(run func(collection *flow.Collection) (*flow.LightCollection, error)) *Collections_Store_Call {
	_c.Call.Return(run)
	return _c
}

// StoreAndIndexByTransaction provides a mock function for the type Collections
func (_mock *Collections) StoreAndIndexByTransaction(lctx lockctx.Proof, collection *flow.Collection) (*flow.LightCollection, error) {
	ret := _mock.Called(lctx, collection)

	if len(ret) == 0 {
		panic("no return value specified for StoreAndIndexByTransaction")
	}

	var r0 *flow.LightCollection
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(lockctx.Proof, *flow.Collection) (*flow.LightCollection, error)); ok {
		return returnFunc(lctx, collection)
	}
	if returnFunc, ok := ret.Get(0).(func(lockctx.Proof, *flow.Collection) *flow.LightCollection); ok {
		r0 = returnFunc(lctx, collection)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.LightCollection)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(lockctx.Proof, *flow.Collection) error); ok {
		r1 = returnFunc(lctx, collection)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Collections_StoreAndIndexByTransaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StoreAndIndexByTransaction'
type Collections_StoreAndIndexByTransaction_Call struct {
	*mock.Call
}

// StoreAndIndexByTransaction is a helper method to define mock.On call
//   - lctx lockctx.Proof
//   - collection *flow.Collection
func (_e *Collections_Expecter) StoreAndIndexByTransaction(lctx interface{}, collection interface{}) *Collections_StoreAndIndexByTransaction_Call {
	return &Collections_StoreAndIndexByTransaction_Call{Call: _e.mock.On("StoreAndIndexByTransaction", lctx, collection)}
}

func (_c *Collections_StoreAndIndexByTransaction_Call) Run(run func(lctx lockctx.Proof, collection *flow.Collection)) *Collections_StoreAndIndexByTransaction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 lockctx.Proof
		if args[0] != nil {
			arg0 = args[0].(lockctx.Proof)
		}
		var arg1 *flow.Collection
		if args[1] != nil {
			arg1 = args[1].(*flow.Collection)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Collections_StoreAndIndexByTransaction_Call) Return(lightCollection *flow.LightCollection, err error) *Collections_StoreAndIndexByTransaction_Call {
	_c.Call.Return(lightCollection, err)
	return _c
}

func (_c *Collections_StoreAndIndexByTransaction_Call) RunAndReturn(run func(lctx lockctx.Proof, collection *flow.Collection) (*flow.LightCollection, error)) *Collections_StoreAndIndexByTransaction_Call {
	_c.Call.Return(run)
	return _c
}

// NewCommitsReader creates a new instance of CommitsReader. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewCommitsReader(t interface {
	mock.TestingT
	Cleanup(func())
}) *CommitsReader {
	mock := &CommitsReader{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// CommitsReader is an autogenerated mock type for the CommitsReader type
type CommitsReader struct {
	mock.Mock
}

type CommitsReader_Expecter struct {
	mock *mock.Mock
}

func (_m *CommitsReader) EXPECT() *CommitsReader_Expecter {
	return &CommitsReader_Expecter{mock: &_m.Mock}
}

// ByBlockID provides a mock function for the type CommitsReader
func (_mock *CommitsReader) ByBlockID(blockID flow.Identifier) (flow.StateCommitment, error) {
	ret := _mock.Called(blockID)

	if len(ret) == 0 {
		panic("no return value specified for ByBlockID")
	}

	var r0 flow.StateCommitment
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (flow.StateCommitment, error)); ok {
		return returnFunc(blockID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) flow.StateCommitment); ok {
		r0 = returnFunc(blockID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.StateCommitment)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(blockID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// CommitsReader_ByBlockID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByBlockID'
type CommitsReader_ByBlockID_Call struct {
	*mock.Call
}

// ByBlockID is a helper method to define mock.On call
//   - blockID flow.Identifier
func (_e *CommitsReader_Expecter) ByBlockID(blockID interface{}) *CommitsReader_ByBlockID_Call {
	return &CommitsReader_ByBlockID_Call{Call: _e.mock.On("ByBlockID", blockID)}
}

func (_c *CommitsReader_ByBlockID_Call) Run(run func(blockID flow.Identifier)) *CommitsReader_ByBlockID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *CommitsReader_ByBlockID_Call) Return(stateCommitment flow.StateCommitment, err error) *CommitsReader_ByBlockID_Call {
	_c.Call.Return(stateCommitment, err)
	return _c
}

func (_c *CommitsReader_ByBlockID_Call) RunAndReturn(run func(blockID flow.Identifier) (flow.StateCommitment, error)) *CommitsReader_ByBlockID_Call {
	_c.Call.Return(run)
	return _c
}

// NewCommits creates a new instance of Commits. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewCommits(t interface {
	mock.TestingT
	Cleanup(func())
}) *Commits {
	mock := &Commits{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Commits is an autogenerated mock type for the Commits type
type Commits struct {
	mock.Mock
}

type Commits_Expecter struct {
	mock *mock.Mock
}

func (_m *Commits) EXPECT() *Commits_Expecter {
	return &Commits_Expecter{mock: &_m.Mock}
}

// BatchRemoveByBlockID provides a mock function for the type Commits
func (_mock *Commits) BatchRemoveByBlockID(blockID flow.Identifier, batch storage.ReaderBatchWriter) error {
	ret := _mock.Called(blockID, batch)

	if len(ret) == 0 {
		panic("no return value specified for BatchRemoveByBlockID")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, storage.ReaderBatchWriter) error); ok {
		r0 = returnFunc(blockID, batch)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Commits_BatchRemoveByBlockID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BatchRemoveByBlockID'
type Commits_BatchRemoveByBlockID_Call struct {
	*mock.Call
}

// BatchRemoveByBlockID is a helper method to define mock.On call
//   - blockID flow.Identifier
//   - batch storage.ReaderBatchWriter
func (_e *Commits_Expecter) BatchRemoveByBlockID(blockID interface{}, batch interface{}) *Commits_BatchRemoveByBlockID_Call {
	return &Commits_BatchRemoveByBlockID_Call{Call: _e.mock.On("BatchRemoveByBlockID", blockID, batch)}
}

func (_c *Commits_BatchRemoveByBlockID_Call) Run(run func(blockID flow.Identifier, batch storage.ReaderBatchWriter)) *Commits_BatchRemoveByBlockID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		var arg1 storage.ReaderBatchWriter
		if args[1] != nil {
			arg1 = args[1].(storage.ReaderBatchWriter)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Commits_BatchRemoveByBlockID_Call) Return(err error) *Commits_BatchRemoveByBlockID_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Commits_BatchRemoveByBlockID_Call) RunAndReturn(run func(blockID flow.Identifier, batch storage.ReaderBatchWriter) error) *Commits_BatchRemoveByBlockID_Call {
	_c.Call.Return(run)
	return _c
}

// BatchStore provides a mock function for the type Commits
func (_mock *Commits) BatchStore(lctx lockctx.Proof, blockID flow.Identifier, commit flow.StateCommitment, batch storage.ReaderBatchWriter) error {
	ret := _mock.Called(lctx, blockID, commit, batch)

	if len(ret) == 0 {
		panic("no return value specified for BatchStore")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(lockctx.Proof, flow.Identifier, flow.StateCommitment, storage.ReaderBatchWriter) error); ok {
		r0 = returnFunc(lctx, blockID, commit, batch)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Commits_BatchStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BatchStore'
type Commits_BatchStore_Call struct {
	*mock.Call
}

// BatchStore is a helper method to define mock.On call
//   - lctx lockctx.Proof
//   - blockID flow.Identifier
//   - commit flow.StateCommitment
//   - batch storage.ReaderBatchWriter
func (_e *Commits_Expecter) BatchStore(lctx interface{}, blockID interface{}, commit interface{}, batch interface{}) *Commits_BatchStore_Call {
	return &Commits_BatchStore_Call{Call: _e.mock.On("BatchStore", lctx, blockID, commit, batch)}
}

func (_c *Commits_BatchStore_Call) Run(run func(lctx lockctx.Proof, blockID flow.Identifier, commit flow.StateCommitment, batch storage.ReaderBatchWriter)) *Commits_BatchStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 lockctx.Proof
		if args[0] != nil {
			arg0 = args[0].(lockctx.Proof)
		}
		var arg1 flow.Identifier
		if args[1] != nil {
			arg1 = args[1].(flow.Identifier)
		}
		var arg2 flow.StateCommitment
		if args[2] != nil {
			arg2 = args[2].(flow.StateCommitment)
		}
		var arg3 storage.ReaderBatchWriter
		if args[3] != nil {
			arg3 = args[3].(storage.ReaderBatchWriter)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *Commits_BatchStore_Call) Return(err error) *Commits_BatchStore_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Commits_BatchStore_Call) RunAndReturn(run func(lctx lockctx.Proof, blockID flow.Identifier, commit flow.StateCommitment, batch storage.ReaderBatchWriter) error) *Commits_BatchStore_Call {
	_c.Call.Return(run)
	return _c
}

// ByBlockID provides a mock function for the type Commits
func (_mock *Commits) ByBlockID(blockID flow.Identifier) (flow.StateCommitment, error) {
	ret := _mock.Called(blockID)

	if len(ret) == 0 {
		panic("no return value specified for ByBlockID")
	}

	var r0 flow.StateCommitment
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (flow.StateCommitment, error)); ok {
		return returnFunc(blockID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) flow.StateCommitment); ok {
		r0 = returnFunc(blockID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.StateCommitment)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(blockID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Commits_ByBlockID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByBlockID'
type Commits_ByBlockID_Call struct {
	*mock.Call
}

// ByBlockID is a helper method to define mock.On call
//   - blockID flow.Identifier
func (_e *Commits_Expecter) ByBlockID(blockID interface{}) *Commits_ByBlockID_Call {
	return &Commits_ByBlockID_Call{Call: _e.mock.On("ByBlockID", blockID)}
}

func (_c *Commits_ByBlockID_Call) Run(run func(blockID flow.Identifier)) *Commits_ByBlockID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Commits_ByBlockID_Call) Return(stateCommitment flow.StateCommitment, err error) *Commits_ByBlockID_Call {
	_c.Call.Return(stateCommitment, err)
	return _c
}

func (_c *Commits_ByBlockID_Call) RunAndReturn(run func(blockID flow.Identifier) (flow.StateCommitment, error)) *Commits_ByBlockID_Call {
	_c.Call.Return(run)
	return _c
}

// NewComputationResultUploadStatus creates a new instance of ComputationResultUploadStatus. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewComputationResultUploadStatus(t interface {
	mock.TestingT
	Cleanup(func())
}) *ComputationResultUploadStatus {
	mock := &ComputationResultUploadStatus{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// ComputationResultUploadStatus is an autogenerated mock type for the ComputationResultUploadStatus type
type ComputationResultUploadStatus struct {
	mock.Mock
}

type ComputationResultUploadStatus_Expecter struct {
	mock *mock.Mock
}

func (_m *ComputationResultUploadStatus) EXPECT() *ComputationResultUploadStatus_Expecter {
	return &ComputationResultUploadStatus_Expecter{mock: &_m.Mock}
}

// ByID provides a mock function for the type ComputationResultUploadStatus
func (_mock *ComputationResultUploadStatus) ByID(blockID flow.Identifier) (bool, error) {
	ret := _mock.Called(blockID)

	if len(ret) == 0 {
		panic("no return value specified for ByID")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (bool, error)); ok {
		return returnFunc(blockID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) bool); ok {
		r0 = returnFunc(blockID)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(blockID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ComputationResultUploadStatus_ByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByID'
type ComputationResultUploadStatus_ByID_Call struct {
	*mock.Call
}

// ByID is a helper method to define mock.On call
//   - blockID flow.Identifier
func (_e *ComputationResultUploadStatus_Expecter) ByID(blockID interface{}) *ComputationResultUploadStatus_ByID_Call {
	return &ComputationResultUploadStatus_ByID_Call{Call: _e.mock.On("ByID", blockID)}
}

func (_c *ComputationResultUploadStatus_ByID_Call) Run(run func(blockID flow.Identifier)) *ComputationResultUploadStatus_ByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ComputationResultUploadStatus_ByID_Call) Return(b bool, err error) *ComputationResultUploadStatus_ByID_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *ComputationResultUploadStatus_ByID_Call) RunAndReturn(run func(blockID flow.Identifier) (bool, error)) *ComputationResultUploadStatus_ByID_Call {
	_c.Call.Return(run)
	return _c
}

// GetIDsByUploadStatus provides a mock function for the type ComputationResultUploadStatus
func (_mock *ComputationResultUploadStatus) GetIDsByUploadStatus(targetUploadStatus bool) ([]flow.Identifier, error) {
	ret := _mock.Called(targetUploadStatus)

	if len(ret) == 0 {
		panic("no return value specified for GetIDsByUploadStatus")
	}

	var r0 []flow.Identifier
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(bool) ([]flow.Identifier, error)); ok {
		return returnFunc(targetUploadStatus)
	}
	if returnFunc, ok := ret.Get(0).(func(bool) []flow.Identifier); ok {
		r0 = returnFunc(targetUploadStatus)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]flow.Identifier)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(bool) error); ok {
		r1 = returnFunc(targetUploadStatus)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ComputationResultUploadStatus_GetIDsByUploadStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetIDsByUploadStatus'
type ComputationResultUploadStatus_GetIDsByUploadStatus_Call struct {
	*mock.Call
}

// GetIDsByUploadStatus is a helper method to define mock.On call
//   - targetUploadStatus bool
func (_e *ComputationResultUploadStatus_Expecter) GetIDsByUploadStatus(targetUploadStatus interface{}) *ComputationResultUploadStatus_GetIDsByUploadStatus_Call {
	return &ComputationResultUploadStatus_GetIDsByUploadStatus_Call{Call: _e.mock.On("GetIDsByUploadStatus", targetUploadStatus)}
}

func (_c *ComputationResultUploadStatus_GetIDsByUploadStatus_Call) Run(run func(targetUploadStatus bool)) *ComputationResultUploadStatus_GetIDsByUploadStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 bool
		if args[0] != nil {
			arg0 = args[0].(bool)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ComputationResultUploadStatus_GetIDsByUploadStatus_Call) Return(identifiers []flow.Identifier, err error) *ComputationResultUploadStatus_GetIDsByUploadStatus_Call {
	_c.Call.Return(identifiers, err)
	return _c
}

func (_c *ComputationResultUploadStatus_GetIDsByUploadStatus_Call) RunAndReturn(run func(targetUploadStatus bool) ([]flow.Identifier, error)) *ComputationResultUploadStatus_GetIDsByUploadStatus_Call {
	_c.Call.Return(run)
	return _c
}

// Remove provides a mock function for the type ComputationResultUploadStatus
func (_mock *ComputationResultUploadStatus) Remove(blockID flow.Identifier) error {
	ret := _mock.Called(blockID)

	if len(ret) == 0 {
		panic("no return value specified for Remove")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) error); ok {
		r0 = returnFunc(blockID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ComputationResultUploadStatus_Remove_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Remove'
type ComputationResultUploadStatus_Remove_Call struct {
	*mock.Call
}

// Remove is a helper method to define mock.On call
//   - blockID flow.Identifier
func (_e *ComputationResultUploadStatus_Expecter) Remove(blockID interface{}) *ComputationResultUploadStatus_Remove_Call {
	return &ComputationResultUploadStatus_Remove_Call{Call: _e.mock.On("Remove", blockID)}
}

func (_c *ComputationResultUploadStatus_Remove_Call) Run(run func(blockID flow.Identifier)) *ComputationResultUploadStatus_Remove_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ComputationResultUploadStatus_Remove_Call) Return(err error) *ComputationResultUploadStatus_Remove_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ComputationResultUploadStatus_Remove_Call) RunAndReturn(run func(blockID flow.Identifier) error) *ComputationResultUploadStatus_Remove_Call {
	_c.Call.Return(run)
	return _c
}

// Upsert provides a mock function for the type ComputationResultUploadStatus
func (_mock *ComputationResultUploadStatus) Upsert(blockID flow.Identifier, wasUploadCompleted bool) error {
	ret := _mock.Called(blockID, wasUploadCompleted)

	if len(ret) == 0 {
		panic("no return value specified for Upsert")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, bool) error); ok {
		r0 = returnFunc(blockID, wasUploadCompleted)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ComputationResultUploadStatus_Upsert_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Upsert'
type ComputationResultUploadStatus_Upsert_Call struct {
	*mock.Call
}

// Upsert is a helper method to define mock.On call
//   - blockID flow.Identifier
//   - wasUploadCompleted bool
func (_e *ComputationResultUploadStatus_Expecter) Upsert(blockID interface{}, wasUploadCompleted interface{}) *ComputationResultUploadStatus_Upsert_Call {
	return &ComputationResultUploadStatus_Upsert_Call{Call: _e.mock.On("Upsert", blockID, wasUploadCompleted)}
}

func (_c *ComputationResultUploadStatus_Upsert_Call) Run(run func(blockID flow.Identifier, wasUploadCompleted bool)) *ComputationResultUploadStatus_Upsert_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		var arg1 bool
		if args[1] != nil {
			arg1 = args[1].(bool)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ComputationResultUploadStatus_Upsert_Call) Return(err error) *ComputationResultUploadStatus_Upsert_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ComputationResultUploadStatus_Upsert_Call) RunAndReturn(run func(blockID flow.Identifier, wasUploadCompleted bool) error) *ComputationResultUploadStatus_Upsert_Call {
	_c.Call.Return(run)
	return _c
}

// NewConsumerProgressInitializer creates a new instance of ConsumerProgressInitializer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewConsumerProgressInitializer(t interface {
	mock.TestingT
	Cleanup(func())
}) *ConsumerProgressInitializer {
	mock := &ConsumerProgressInitializer{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// ConsumerProgressInitializer is an autogenerated mock type for the ConsumerProgressInitializer type
type ConsumerProgressInitializer struct {
	mock.Mock
}

type ConsumerProgressInitializer_Expecter struct {
	mock *mock.Mock
}

func (_m *ConsumerProgressInitializer) EXPECT() *ConsumerProgressInitializer_Expecter {
	return &ConsumerProgressInitializer_Expecter{mock: &_m.Mock}
}

// Initialize provides a mock function for the type ConsumerProgressInitializer
func (_mock *ConsumerProgressInitializer) Initialize(defaultIndex uint64) (storage.ConsumerProgress, error) {
	ret := _mock.Called(defaultIndex)

	if len(ret) == 0 {
		panic("no return value specified for Initialize")
	}

	var r0 storage.ConsumerProgress
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(uint64) (storage.ConsumerProgress, error)); ok {
		return returnFunc(defaultIndex)
	}
	if returnFunc, ok := ret.Get(0).(func(uint64) storage.ConsumerProgress); ok {
		r0 = returnFunc(defaultIndex)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(storage.ConsumerProgress)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(uint64) error); ok {
		r1 = returnFunc(defaultIndex)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ConsumerProgressInitializer_Initialize_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Initialize'
type ConsumerProgressInitializer_Initialize_Call struct {
	*mock.Call
}

// Initialize is a helper method to define mock.On call
//   - defaultIndex uint64
func (_e *ConsumerProgressInitializer_Expecter) Initialize(defaultIndex interface{}) *ConsumerProgressInitializer_Initialize_Call {
	return &ConsumerProgressInitializer_Initialize_Call{Call: _e.mock.On("Initialize", defaultIndex)}
}

func (_c *ConsumerProgressInitializer_Initialize_Call) Run(run func(defaultIndex uint64)) *ConsumerProgressInitializer_Initialize_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ConsumerProgressInitializer_Initialize_Call) Return(consumerProgress storage.ConsumerProgress, err error) *ConsumerProgressInitializer_Initialize_Call {
	_c.Call.Return(consumerProgress, err)
	return _c
}

func (_c *ConsumerProgressInitializer_Initialize_Call) RunAndReturn(run func(defaultIndex uint64) (storage.ConsumerProgress, error)) *ConsumerProgressInitializer_Initialize_Call {
	_c.Call.Return(run)
	return _c
}

// NewConsumerProgress creates a new instance of ConsumerProgress. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewConsumerProgress(t interface {
	mock.TestingT
	Cleanup(func())
}) *ConsumerProgress {
	mock := &ConsumerProgress{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// ConsumerProgress is an autogenerated mock type for the ConsumerProgress type
type ConsumerProgress struct {
	mock.Mock
}

type ConsumerProgress_Expecter struct {
	mock *mock.Mock
}

func (_m *ConsumerProgress) EXPECT() *ConsumerProgress_Expecter {
	return &ConsumerProgress_Expecter{mock: &_m.Mock}
}

// BatchSetProcessedIndex provides a mock function for the type ConsumerProgress
func (_mock *ConsumerProgress) BatchSetProcessedIndex(processed uint64, batch storage.ReaderBatchWriter) error {
	ret := _mock.Called(processed, batch)

	if len(ret) == 0 {
		panic("no return value specified for BatchSetProcessedIndex")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(uint64, storage.ReaderBatchWriter) error); ok {
		r0 = returnFunc(processed, batch)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ConsumerProgress_BatchSetProcessedIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BatchSetProcessedIndex'
type ConsumerProgress_BatchSetProcessedIndex_Call struct {
	*mock.Call
}

// BatchSetProcessedIndex is a helper method to define mock.On call
//   - processed uint64
//   - batch storage.ReaderBatchWriter
func (_e *ConsumerProgress_Expecter) BatchSetProcessedIndex(processed interface{}, batch interface{}) *ConsumerProgress_BatchSetProcessedIndex_Call {
	return &ConsumerProgress_BatchSetProcessedIndex_Call{Call: _e.mock.On("BatchSetProcessedIndex", processed, batch)}
}

func (_c *ConsumerProgress_BatchSetProcessedIndex_Call) Run(run func(processed uint64, batch storage.ReaderBatchWriter)) *ConsumerProgress_BatchSetProcessedIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		var arg1 storage.ReaderBatchWriter
		if args[1] != nil {
			arg1 = args[1].(storage.ReaderBatchWriter)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ConsumerProgress_BatchSetProcessedIndex_Call) Return(err error) *ConsumerProgress_BatchSetProcessedIndex_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ConsumerProgress_BatchSetProcessedIndex_Call) RunAndReturn(run func(processed uint64, batch storage.ReaderBatchWriter) error) *ConsumerProgress_BatchSetProcessedIndex_Call {
	_c.Call.Return(run)
	return _c
}

// ProcessedIndex provides a mock function for the type ConsumerProgress
func (_mock *ConsumerProgress) ProcessedIndex() (uint64, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for ProcessedIndex")
	}

	var r0 uint64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (uint64, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() uint64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint64)
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ConsumerProgress_ProcessedIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ProcessedIndex'
type ConsumerProgress_ProcessedIndex_Call struct {
	*mock.Call
}

// ProcessedIndex is a helper method to define mock.On call
func (_e *ConsumerProgress_Expecter) ProcessedIndex() *ConsumerProgress_ProcessedIndex_Call {
	return &ConsumerProgress_ProcessedIndex_Call{Call: _e.mock.On("ProcessedIndex")}
}

func (_c *ConsumerProgress_ProcessedIndex_Call) Run(run func()) *ConsumerProgress_ProcessedIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ConsumerProgress_ProcessedIndex_Call) Return(v uint64, err error) *ConsumerProgress_ProcessedIndex_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *ConsumerProgress_ProcessedIndex_Call) RunAndReturn(run func() (uint64, error)) *ConsumerProgress_ProcessedIndex_Call {
	_c.Call.Return(run)
	return _c
}

// SetProcessedIndex provides a mock function for the type ConsumerProgress
func (_mock *ConsumerProgress) SetProcessedIndex(processed uint64) error {
	ret := _mock.Called(processed)

	if len(ret) == 0 {
		panic("no return value specified for SetProcessedIndex")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(uint64) error); ok {
		r0 = returnFunc(processed)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ConsumerProgress_SetProcessedIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetProcessedIndex'
type ConsumerProgress_SetProcessedIndex_Call struct {
	*mock.Call
}

// SetProcessedIndex is a helper method to define mock.On call
//   - processed uint64
func (_e *ConsumerProgress_Expecter) SetProcessedIndex(processed interface{}) *ConsumerProgress_SetProcessedIndex_Call {
	return &ConsumerProgress_SetProcessedIndex_Call{Call: _e.mock.On("SetProcessedIndex", processed)}
}

func (_c *ConsumerProgress_SetProcessedIndex_Call) Run(run func(processed uint64)) *ConsumerProgress_SetProcessedIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ConsumerProgress_SetProcessedIndex_Call) Return(err error) *ConsumerProgress_SetProcessedIndex_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ConsumerProgress_SetProcessedIndex_Call) RunAndReturn(run func(processed uint64) error) *ConsumerProgress_SetProcessedIndex_Call {
	_c.Call.Return(run)
	return _c
}

// NewSafeBeaconKeys creates a new instance of SafeBeaconKeys. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewSafeBeaconKeys(t interface {
	mock.TestingT
	Cleanup(func())
}) *SafeBeaconKeys {
	mock := &SafeBeaconKeys{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// SafeBeaconKeys is an autogenerated mock type for the SafeBeaconKeys type
type SafeBeaconKeys struct {
	mock.Mock
}

type SafeBeaconKeys_Expecter struct {
	mock *mock.Mock
}

func (_m *SafeBeaconKeys) EXPECT() *SafeBeaconKeys_Expecter {
	return &SafeBeaconKeys_Expecter{mock: &_m.Mock}
}

// RetrieveMyBeaconPrivateKey provides a mock function for the type SafeBeaconKeys
func (_mock *SafeBeaconKeys) RetrieveMyBeaconPrivateKey(epochCounter uint64) (crypto.PrivateKey, bool, error) {
	ret := _mock.Called(epochCounter)

	if len(ret) == 0 {
		panic("no return value specified for RetrieveMyBeaconPrivateKey")
	}

	var r0 crypto.PrivateKey
	var r1 bool
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(uint64) (crypto.PrivateKey, bool, error)); ok {
		return returnFunc(epochCounter)
	}
	if returnFunc, ok := ret.Get(0).(func(uint64) crypto.PrivateKey); ok {
		r0 = returnFunc(epochCounter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(crypto.PrivateKey)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(uint64) bool); ok {
		r1 = returnFunc(epochCounter)
	} else {
		r1 = ret.Get(1).(bool)
	}
	if returnFunc, ok := ret.Get(2).(func(uint64) error); ok {
		r2 = returnFunc(epochCounter)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// SafeBeaconKeys_RetrieveMyBeaconPrivateKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RetrieveMyBeaconPrivateKey'
type SafeBeaconKeys_RetrieveMyBeaconPrivateKey_Call struct {
	*mock.Call
}

// RetrieveMyBeaconPrivateKey is a helper method to define mock.On call
//   - epochCounter uint64
func (_e *SafeBeaconKeys_Expecter) RetrieveMyBeaconPrivateKey(epochCounter interface{}) *SafeBeaconKeys_RetrieveMyBeaconPrivateKey_Call {
	return &SafeBeaconKeys_RetrieveMyBeaconPrivateKey_Call{Call: _e.mock.On("RetrieveMyBeaconPrivateKey", epochCounter)}
}

func (_c *SafeBeaconKeys_RetrieveMyBeaconPrivateKey_Call) Run(run func(epochCounter uint64)) *SafeBeaconKeys_RetrieveMyBeaconPrivateKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *SafeBeaconKeys_RetrieveMyBeaconPrivateKey_Call) Return(key crypto.PrivateKey, safe bool, err error) *SafeBeaconKeys_RetrieveMyBeaconPrivateKey_Call {
	_c.Call.Return(key, safe, err)
	return _c
}

func (_c *SafeBeaconKeys_RetrieveMyBeaconPrivateKey_Call) RunAndReturn(run func(epochCounter uint64) (crypto.PrivateKey, bool, error)) *SafeBeaconKeys_RetrieveMyBeaconPrivateKey_Call {
	_c.Call.Return(run)
	return _c
}

// NewDKGStateReader creates a new instance of DKGStateReader. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewDKGStateReader(t interface {
	mock.TestingT
	Cleanup(func())
}) *DKGStateReader {
	mock := &DKGStateReader{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// DKGStateReader is an autogenerated mock type for the DKGStateReader type
type DKGStateReader struct {
	mock.Mock
}

type DKGStateReader_Expecter struct {
	mock *mock.Mock
}

func (_m *DKGStateReader) EXPECT() *DKGStateReader_Expecter {
	return &DKGStateReader_Expecter{mock: &_m.Mock}
}

// GetDKGState provides a mock function for the type DKGStateReader
func (_mock *DKGStateReader) GetDKGState(epochCounter uint64) (flow.DKGState, error) {
	ret := _mock.Called(epochCounter)

	if len(ret) == 0 {
		panic("no return value specified for GetDKGState")
	}

	var r0 flow.DKGState
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(uint64) (flow.DKGState, error)); ok {
		return returnFunc(epochCounter)
	}
	if returnFunc, ok := ret.Get(0).(func(uint64) flow.DKGState); ok {
		r0 = returnFunc(epochCounter)
	} else {
		r0 = ret.Get(0).(flow.DKGState)
	}
	if returnFunc, ok := ret.Get(1).(func(uint64) error); ok {
		r1 = returnFunc(epochCounter)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// DKGStateReader_GetDKGState_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDKGState'
type DKGStateReader_GetDKGState_Call struct {
	*mock.Call
}

// GetDKGState is a helper method to define mock.On call
//   - epochCounter uint64
func (_e *DKGStateReader_Expecter) GetDKGState(epochCounter interface{}) *DKGStateReader_GetDKGState_Call {
	return &DKGStateReader_GetDKGState_Call{Call: _e.mock.On("GetDKGState", epochCounter)}
}

func (_c *DKGStateReader_GetDKGState_Call) Run(run func(epochCounter uint64)) *DKGStateReader_GetDKGState_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *DKGStateReader_GetDKGState_Call) Return(dKGState flow.DKGState, err error) *DKGStateReader_GetDKGState_Call {
	_c.Call.Return(dKGState, err)
	return _c
}

func (_c *DKGStateReader_GetDKGState_Call) RunAndReturn(run func(epochCounter uint64) (flow.DKGState, error)) *DKGStateReader_GetDKGState_Call {
	_c.Call.Return(run)
	return _c
}

// IsDKGStarted provides a mock function for the type DKGStateReader
func (_mock *DKGStateReader) IsDKGStarted(epochCounter uint64) (bool, error) {
	ret := _mock.Called(epochCounter)

	if len(ret) == 0 {
		panic("no return value specified for IsDKGStarted")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(uint64) (bool, error)); ok {
		return returnFunc(epochCounter)
	}
	if returnFunc, ok := ret.Get(0).(func(uint64) bool); ok {
		r0 = returnFunc(epochCounter)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(uint64) error); ok {
		r1 = returnFunc(epochCounter)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// DKGStateReader_IsDKGStarted_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsDKGStarted'
type DKGStateReader_IsDKGStarted_Call struct {
	*mock.Call
}

// IsDKGStarted is a helper method to define mock.On call
//   - epochCounter uint64
func (_e *DKGStateReader_Expecter) IsDKGStarted(epochCounter interface{}) *DKGStateReader_IsDKGStarted_Call {
	return &DKGStateReader_IsDKGStarted_Call{Call: _e.mock.On("IsDKGStarted", epochCounter)}
}

func (_c *DKGStateReader_IsDKGStarted_Call) Run(run func(epochCounter uint64)) *DKGStateReader_IsDKGStarted_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *DKGStateReader_IsDKGStarted_Call) Return(b bool, err error) *DKGStateReader_IsDKGStarted_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *DKGStateReader_IsDKGStarted_Call) RunAndReturn(run func(epochCounter uint64) (bool, error)) *DKGStateReader_IsDKGStarted_Call {
	_c.Call.Return(run)
	return _c
}

// RetrieveMyBeaconPrivateKey provides a mock function for the type DKGStateReader
func (_mock *DKGStateReader) RetrieveMyBeaconPrivateKey(epochCounter uint64) (crypto.PrivateKey, bool, error) {
	ret := _mock.Called(epochCounter)

	if len(ret) == 0 {
		panic("no return value specified for RetrieveMyBeaconPrivateKey")
	}

	var r0 crypto.PrivateKey
	var r1 bool
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(uint64) (crypto.PrivateKey, bool, error)); ok {
		return returnFunc(epochCounter)
	}
	if returnFunc, ok := ret.Get(0).(func(uint64) crypto.PrivateKey); ok {
		r0 = returnFunc(epochCounter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(crypto.PrivateKey)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(uint64) bool); ok {
		r1 = returnFunc(epochCounter)
	} else {
		r1 = ret.Get(1).(bool)
	}
	if returnFunc, ok := ret.Get(2).(func(uint64) error); ok {
		r2 = returnFunc(epochCounter)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// DKGStateReader_RetrieveMyBeaconPrivateKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RetrieveMyBeaconPrivateKey'
type DKGStateReader_RetrieveMyBeaconPrivateKey_Call struct {
	*mock.Call
}

// RetrieveMyBeaconPrivateKey is a helper method to define mock.On call
//   - epochCounter uint64
func (_e *DKGStateReader_Expecter) RetrieveMyBeaconPrivateKey(epochCounter interface{}) *DKGStateReader_RetrieveMyBeaconPrivateKey_Call {
	return &DKGStateReader_RetrieveMyBeaconPrivateKey_Call{Call: _e.mock.On("RetrieveMyBeaconPrivateKey", epochCounter)}
}

func (_c *DKGStateReader_RetrieveMyBeaconPrivateKey_Call) Run(run func(epochCounter uint64)) *DKGStateReader_RetrieveMyBeaconPrivateKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *DKGStateReader_RetrieveMyBeaconPrivateKey_Call) Return(key crypto.PrivateKey, safe bool, err error) *DKGStateReader_RetrieveMyBeaconPrivateKey_Call {
	_c.Call.Return(key, safe, err)
	return _c
}

func (_c *DKGStateReader_RetrieveMyBeaconPrivateKey_Call) RunAndReturn(run func(epochCounter uint64) (crypto.PrivateKey, bool, error)) *DKGStateReader_RetrieveMyBeaconPrivateKey_Call {
	_c.Call.Return(run)
	return _c
}

// UnsafeRetrieveMyBeaconPrivateKey provides a mock function for the type DKGStateReader
func (_mock *DKGStateReader) UnsafeRetrieveMyBeaconPrivateKey(epochCounter uint64) (crypto.PrivateKey, error) {
	ret := _mock.Called(epochCounter)

	if len(ret) == 0 {
		panic("no return value specified for UnsafeRetrieveMyBeaconPrivateKey")
	}

	var r0 crypto.PrivateKey
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(uint64) (crypto.PrivateKey, error)); ok {
		return returnFunc(epochCounter)
	}
	if returnFunc, ok := ret.Get(0).(func(uint64) crypto.PrivateKey); ok {
		r0 = returnFunc(epochCounter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(crypto.PrivateKey)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(uint64) error); ok {
		r1 = returnFunc(epochCounter)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// DKGStateReader_UnsafeRetrieveMyBeaconPrivateKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnsafeRetrieveMyBeaconPrivateKey'
type DKGStateReader_UnsafeRetrieveMyBeaconPrivateKey_Call struct {
	*mock.Call
}

// UnsafeRetrieveMyBeaconPrivateKey is a helper method to define mock.On call
//   - epochCounter uint64
func (_e *DKGStateReader_Expecter) UnsafeRetrieveMyBeaconPrivateKey(epochCounter interface{}) *DKGStateReader_UnsafeRetrieveMyBeaconPrivateKey_Call {
	return &DKGStateReader_UnsafeRetrieveMyBeaconPrivateKey_Call{Call: _e.mock.On("UnsafeRetrieveMyBeaconPrivateKey", epochCounter)}
}

func (_c *DKGStateReader_UnsafeRetrieveMyBeaconPrivateKey_Call) Run(run func(epochCounter uint64)) *DKGStateReader_UnsafeRetrieveMyBeaconPrivateKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *DKGStateReader_UnsafeRetrieveMyBeaconPrivateKey_Call) Return(privateKey crypto.PrivateKey, err error) *DKGStateReader_UnsafeRetrieveMyBeaconPrivateKey_Call {
	_c.Call.Return(privateKey, err)
	return _c
}

func (_c *DKGStateReader_UnsafeRetrieveMyBeaconPrivateKey_Call) RunAndReturn(run func(epochCounter uint64) (crypto.PrivateKey, error)) *DKGStateReader_UnsafeRetrieveMyBeaconPrivateKey_Call {
	_c.Call.Return(run)
	return _c
}

// NewDKGState creates a new instance of DKGState. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewDKGState(t interface {
	mock.TestingT
	Cleanup(func())
}) *DKGState {
	mock := &DKGState{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// DKGState is an autogenerated mock type for the DKGState type
type DKGState struct {
	mock.Mock
}

type DKGState_Expecter struct {
	mock *mock.Mock
}

func (_m *DKGState) EXPECT() *DKGState_Expecter {
	return &DKGState_Expecter{mock: &_m.Mock}
}

// CommitMyBeaconPrivateKey provides a mock function for the type DKGState
func (_mock *DKGState) CommitMyBeaconPrivateKey(epochCounter uint64, commit *flow.EpochCommit) error {
	ret := _mock.Called(epochCounter, commit)

	if len(ret) == 0 {
		panic("no return value specified for CommitMyBeaconPrivateKey")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(uint64, *flow.EpochCommit) error); ok {
		r0 = returnFunc(epochCounter, commit)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// DKGState_CommitMyBeaconPrivateKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CommitMyBeaconPrivateKey'
type DKGState_CommitMyBeaconPrivateKey_Call struct {
	*mock.Call
}

// CommitMyBeaconPrivateKey is a helper method to define mock.On call
//   - epochCounter uint64
//   - commit *flow.EpochCommit
func (_e *DKGState_Expecter) CommitMyBeaconPrivateKey(epochCounter interface{}, commit interface{}) *DKGState_CommitMyBeaconPrivateKey_Call {
	return &DKGState_CommitMyBeaconPrivateKey_Call{Call: _e.mock.On("CommitMyBeaconPrivateKey", epochCounter, commit)}
}

func (_c *DKGState_CommitMyBeaconPrivateKey_Call) Run(run func(epochCounter uint64, commit *flow.EpochCommit)) *DKGState_CommitMyBeaconPrivateKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		var arg1 *flow.EpochCommit
		if args[1] != nil {
			arg1 = args[1].(*flow.EpochCommit)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *DKGState_CommitMyBeaconPrivateKey_Call) Return(err error) *DKGState_CommitMyBeaconPrivateKey_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *DKGState_CommitMyBeaconPrivateKey_Call) RunAndReturn(run func(epochCounter uint64, commit *flow.EpochCommit) error) *DKGState_CommitMyBeaconPrivateKey_Call {
	_c.Call.Return(run)
	return _c
}

// GetDKGState provides a mock function for the type DKGState
func (_mock *DKGState) GetDKGState(epochCounter uint64) (flow.DKGState, error) {
	ret := _mock.Called(epochCounter)

	if len(ret) == 0 {
		panic("no return value specified for GetDKGState")
	}

	var r0 flow.DKGState
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(uint64) (flow.DKGState, error)); ok {
		return returnFunc(epochCounter)
	}
	if returnFunc, ok := ret.Get(0).(func(uint64) flow.DKGState); ok {
		r0 = returnFunc(epochCounter)
	} else {
		r0 = ret.Get(0).(flow.DKGState)
	}
	if returnFunc, ok := ret.Get(1).(func(uint64) error); ok {
		r1 = returnFunc(epochCounter)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// DKGState_GetDKGState_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDKGState'
type DKGState_GetDKGState_Call struct {
	*mock.Call
}

// GetDKGState is a helper method to define mock.On call
//   - epochCounter uint64
func (_e *DKGState_Expecter) GetDKGState(epochCounter interface{}) *DKGState_GetDKGState_Call {
	return &DKGState_GetDKGState_Call{Call: _e.mock.On("GetDKGState", epochCounter)}
}

func (_c *DKGState_GetDKGState_Call) Run(run func(epochCounter uint64)) *DKGState_GetDKGState_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *DKGState_GetDKGState_Call) Return(dKGState flow.DKGState, err error) *DKGState_GetDKGState_Call {
	_c.Call.Return(dKGState, err)
	return _c
}

func (_c *DKGState_GetDKGState_Call) RunAndReturn(run func(epochCounter uint64) (flow.DKGState, error)) *DKGState_GetDKGState_Call {
	_c.Call.Return(run)
	return _c
}

// InsertMyBeaconPrivateKey provides a mock function for the type DKGState
func (_mock *DKGState) InsertMyBeaconPrivateKey(epochCounter uint64, key crypto.PrivateKey) error {
	ret := _mock.Called(epochCounter, key)

	if len(ret) == 0 {
		panic("no return value specified for InsertMyBeaconPrivateKey")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(uint64, crypto.PrivateKey) error); ok {
		r0 = returnFunc(epochCounter, key)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// DKGState_InsertMyBeaconPrivateKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InsertMyBeaconPrivateKey'
type DKGState_InsertMyBeaconPrivateKey_Call struct {
	*mock.Call
}

// InsertMyBeaconPrivateKey is a helper method to define mock.On call
//   - epochCounter uint64
//   - key crypto.PrivateKey
func (_e *DKGState_Expecter) InsertMyBeaconPrivateKey(epochCounter interface{}, key interface{}) *DKGState_InsertMyBeaconPrivateKey_Call {
	return &DKGState_InsertMyBeaconPrivateKey_Call{Call: _e.mock.On("InsertMyBeaconPrivateKey", epochCounter, key)}
}

func (_c *DKGState_InsertMyBeaconPrivateKey_Call) Run(run func(epochCounter uint64, key crypto.PrivateKey)) *DKGState_InsertMyBeaconPrivateKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		var arg1 crypto.PrivateKey
		if args[1] != nil {
			arg1 = args[1].(crypto.PrivateKey)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *DKGState_InsertMyBeaconPrivateKey_Call) Return(err error) *DKGState_InsertMyBeaconPrivateKey_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *DKGState_InsertMyBeaconPrivateKey_Call) RunAndReturn(run func(epochCounter uint64, key crypto.PrivateKey) error) *DKGState_InsertMyBeaconPrivateKey_Call {
	_c.Call.Return(run)
	return _c
}

// IsDKGStarted provides a mock function for the type DKGState
func (_mock *DKGState) IsDKGStarted(epochCounter uint64) (bool, error) {
	ret := _mock.Called(epochCounter)

	if len(ret) == 0 {
		panic("no return value specified for IsDKGStarted")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(uint64) (bool, error)); ok {
		return returnFunc(epochCounter)
	}
	if returnFunc, ok := ret.Get(0).(func(uint64) bool); ok {
		r0 = returnFunc(epochCounter)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(uint64) error); ok {
		r1 = returnFunc(epochCounter)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// DKGState_IsDKGStarted_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsDKGStarted'
type DKGState_IsDKGStarted_Call struct {
	*mock.Call
}

// IsDKGStarted is a helper method to define mock.On call
//   - epochCounter uint64
func (_e *DKGState_Expecter) IsDKGStarted(epochCounter interface{}) *DKGState_IsDKGStarted_Call {
	return &DKGState_IsDKGStarted_Call{Call: _e.mock.On("IsDKGStarted", epochCounter)}
}

func (_c *DKGState_IsDKGStarted_Call) Run(run func(epochCounter uint64)) *DKGState_IsDKGStarted_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *DKGState_IsDKGStarted_Call) Return(b bool, err error) *DKGState_IsDKGStarted_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *DKGState_IsDKGStarted_Call) RunAndReturn(run func(epochCounter uint64) (bool, error)) *DKGState_IsDKGStarted_Call {
	_c.Call.Return(run)
	return _c
}

// RetrieveMyBeaconPrivateKey provides a mock function for the type DKGState
func (_mock *DKGState) RetrieveMyBeaconPrivateKey(epochCounter uint64) (crypto.PrivateKey, bool, error) {
	ret := _mock.Called(epochCounter)

	if len(ret) == 0 {
		panic("no return value specified for RetrieveMyBeaconPrivateKey")
	}

	var r0 crypto.PrivateKey
	var r1 bool
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(uint64) (crypto.PrivateKey, bool, error)); ok {
		return returnFunc(epochCounter)
	}
	if returnFunc, ok := ret.Get(0).(func(uint64) crypto.PrivateKey); ok {
		r0 = returnFunc(epochCounter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(crypto.PrivateKey)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(uint64) bool); ok {
		r1 = returnFunc(epochCounter)
	} else {
		r1 = ret.Get(1).(bool)
	}
	if returnFunc, ok := ret.Get(2).(func(uint64) error); ok {
		r2 = returnFunc(epochCounter)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// DKGState_RetrieveMyBeaconPrivateKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RetrieveMyBeaconPrivateKey'
type DKGState_RetrieveMyBeaconPrivateKey_Call struct {
	*mock.Call
}

// RetrieveMyBeaconPrivateKey is a helper method to define mock.On call
//   - epochCounter uint64
func (_e *DKGState_Expecter) RetrieveMyBeaconPrivateKey(epochCounter interface{}) *DKGState_RetrieveMyBeaconPrivateKey_Call {
	return &DKGState_RetrieveMyBeaconPrivateKey_Call{Call: _e.mock.On("RetrieveMyBeaconPrivateKey", epochCounter)}
}

func (_c *DKGState_RetrieveMyBeaconPrivateKey_Call) Run(run func(epochCounter uint64)) *DKGState_RetrieveMyBeaconPrivateKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *DKGState_RetrieveMyBeaconPrivateKey_Call) Return(key crypto.PrivateKey, safe bool, err error) *DKGState_RetrieveMyBeaconPrivateKey_Call {
	_c.Call.Return(key, safe, err)
	return _c
}

func (_c *DKGState_RetrieveMyBeaconPrivateKey_Call) RunAndReturn(run func(epochCounter uint64) (crypto.PrivateKey, bool, error)) *DKGState_RetrieveMyBeaconPrivateKey_Call {
	_c.Call.Return(run)
	return _c
}

// SetDKGState provides a mock function for the type DKGState
func (_mock *DKGState) SetDKGState(epochCounter uint64, newState flow.DKGState) error {
	ret := _mock.Called(epochCounter, newState)

	if len(ret) == 0 {
		panic("no return value specified for SetDKGState")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(uint64, flow.DKGState) error); ok {
		r0 = returnFunc(epochCounter, newState)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// DKGState_SetDKGState_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetDKGState'
type DKGState_SetDKGState_Call struct {
	*mock.Call
}

// SetDKGState is a helper method to define mock.On call
//   - epochCounter uint64
//   - newState flow.DKGState
func (_e *DKGState_Expecter) SetDKGState(epochCounter interface{}, newState interface{}) *DKGState_SetDKGState_Call {
	return &DKGState_SetDKGState_Call{Call: _e.mock.On("SetDKGState", epochCounter, newState)}
}

func (_c *DKGState_SetDKGState_Call) Run(run func(epochCounter uint64, newState flow.DKGState)) *DKGState_SetDKGState_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		var arg1 flow.DKGState
		if args[1] != nil {
			arg1 = args[1].(flow.DKGState)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *DKGState_SetDKGState_Call) Return(err error) *DKGState_SetDKGState_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *DKGState_SetDKGState_Call) RunAndReturn(run func(epochCounter uint64, newState flow.DKGState) error) *DKGState_SetDKGState_Call {
	_c.Call.Return(run)
	return _c
}

// UnsafeRetrieveMyBeaconPrivateKey provides a mock function for the type DKGState
func (_mock *DKGState) UnsafeRetrieveMyBeaconPrivateKey(epochCounter uint64) (crypto.PrivateKey, error) {
	ret := _mock.Called(epochCounter)

	if len(ret) == 0 {
		panic("no return value specified for UnsafeRetrieveMyBeaconPrivateKey")
	}

	var r0 crypto.PrivateKey
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(uint64) (crypto.PrivateKey, error)); ok {
		return returnFunc(epochCounter)
	}
	if returnFunc, ok := ret.Get(0).(func(uint64) crypto.PrivateKey); ok {
		r0 = returnFunc(epochCounter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(crypto.PrivateKey)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(uint64) error); ok {
		r1 = returnFunc(epochCounter)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// DKGState_UnsafeRetrieveMyBeaconPrivateKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnsafeRetrieveMyBeaconPrivateKey'
type DKGState_UnsafeRetrieveMyBeaconPrivateKey_Call struct {
	*mock.Call
}

// UnsafeRetrieveMyBeaconPrivateKey is a helper method to define mock.On call
//   - epochCounter uint64
func (_e *DKGState_Expecter) UnsafeRetrieveMyBeaconPrivateKey(epochCounter interface{}) *DKGState_UnsafeRetrieveMyBeaconPrivateKey_Call {
	return &DKGState_UnsafeRetrieveMyBeaconPrivateKey_Call{Call: _e.mock.On("UnsafeRetrieveMyBeaconPrivateKey", epochCounter)}
}

func (_c *DKGState_UnsafeRetrieveMyBeaconPrivateKey_Call) Run(run func(epochCounter uint64)) *DKGState_UnsafeRetrieveMyBeaconPrivateKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *DKGState_UnsafeRetrieveMyBeaconPrivateKey_Call) Return(privateKey crypto.PrivateKey, err error) *DKGState_UnsafeRetrieveMyBeaconPrivateKey_Call {
	_c.Call.Return(privateKey, err)
	return _c
}

func (_c *DKGState_UnsafeRetrieveMyBeaconPrivateKey_Call) RunAndReturn(run func(epochCounter uint64) (crypto.PrivateKey, error)) *DKGState_UnsafeRetrieveMyBeaconPrivateKey_Call {
	_c.Call.Return(run)
	return _c
}

// NewEpochRecoveryMyBeaconKey creates a new instance of EpochRecoveryMyBeaconKey. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewEpochRecoveryMyBeaconKey(t interface {
	mock.TestingT
	Cleanup(func())
}) *EpochRecoveryMyBeaconKey {
	mock := &EpochRecoveryMyBeaconKey{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// EpochRecoveryMyBeaconKey is an autogenerated mock type for the EpochRecoveryMyBeaconKey type
type EpochRecoveryMyBeaconKey struct {
	mock.Mock
}

type EpochRecoveryMyBeaconKey_Expecter struct {
	mock *mock.Mock
}

func (_m *EpochRecoveryMyBeaconKey) EXPECT() *EpochRecoveryMyBeaconKey_Expecter {
	return &EpochRecoveryMyBeaconKey_Expecter{mock: &_m.Mock}
}

// GetDKGState provides a mock function for the type EpochRecoveryMyBeaconKey
func (_mock *EpochRecoveryMyBeaconKey) GetDKGState(epochCounter uint64) (flow.DKGState, error) {
	ret := _mock.Called(epochCounter)

	if len(ret) == 0 {
		panic("no return value specified for GetDKGState")
	}

	var r0 flow.DKGState
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(uint64) (flow.DKGState, error)); ok {
		return returnFunc(epochCounter)
	}
	if returnFunc, ok := ret.Get(0).(func(uint64) flow.DKGState); ok {
		r0 = returnFunc(epochCounter)
	} else {
		r0 = ret.Get(0).(flow.DKGState)
	}
	if returnFunc, ok := ret.Get(1).(func(uint64) error); ok {
		r1 = returnFunc(epochCounter)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// EpochRecoveryMyBeaconKey_GetDKGState_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDKGState'
type EpochRecoveryMyBeaconKey_GetDKGState_Call struct {
	*mock.Call
}

// GetDKGState is a helper method to define mock.On call
//   - epochCounter uint64
func (_e *EpochRecoveryMyBeaconKey_Expecter) GetDKGState(epochCounter interface{}) *EpochRecoveryMyBeaconKey_GetDKGState_Call {
	return &EpochRecoveryMyBeaconKey_GetDKGState_Call{Call: _e.mock.On("GetDKGState", epochCounter)}
}

func (_c *EpochRecoveryMyBeaconKey_GetDKGState_Call) Run(run func(epochCounter uint64)) *EpochRecoveryMyBeaconKey_GetDKGState_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *EpochRecoveryMyBeaconKey_GetDKGState_Call) Return(dKGState flow.DKGState, err error) *EpochRecoveryMyBeaconKey_GetDKGState_Call {
	_c.Call.Return(dKGState, err)
	return _c
}

func (_c *EpochRecoveryMyBeaconKey_GetDKGState_Call) RunAndReturn(run func(epochCounter uint64) (flow.DKGState, error)) *EpochRecoveryMyBeaconKey_GetDKGState_Call {
	_c.Call.Return(run)
	return _c
}

// IsDKGStarted provides a mock function for the type EpochRecoveryMyBeaconKey
func (_mock *EpochRecoveryMyBeaconKey) IsDKGStarted(epochCounter uint64) (bool, error) {
	ret := _mock.Called(epochCounter)

	if len(ret) == 0 {
		panic("no return value specified for IsDKGStarted")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(uint64) (bool, error)); ok {
		return returnFunc(epochCounter)
	}
	if returnFunc, ok := ret.Get(0).(func(uint64) bool); ok {
		r0 = returnFunc(epochCounter)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(uint64) error); ok {
		r1 = returnFunc(epochCounter)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// EpochRecoveryMyBeaconKey_IsDKGStarted_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsDKGStarted'
type EpochRecoveryMyBeaconKey_IsDKGStarted_Call struct {
	*mock.Call
}

// IsDKGStarted is a helper method to define mock.On call
//   - epochCounter uint64
func (_e *EpochRecoveryMyBeaconKey_Expecter) IsDKGStarted(epochCounter interface{}) *EpochRecoveryMyBeaconKey_IsDKGStarted_Call {
	return &EpochRecoveryMyBeaconKey_IsDKGStarted_Call{Call: _e.mock.On("IsDKGStarted", epochCounter)}
}

func (_c *EpochRecoveryMyBeaconKey_IsDKGStarted_Call) Run(run func(epochCounter uint64)) *EpochRecoveryMyBeaconKey_IsDKGStarted_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *EpochRecoveryMyBeaconKey_IsDKGStarted_Call) Return(b bool, err error) *EpochRecoveryMyBeaconKey_IsDKGStarted_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *EpochRecoveryMyBeaconKey_IsDKGStarted_Call) RunAndReturn(run func(epochCounter uint64) (bool, error)) *EpochRecoveryMyBeaconKey_IsDKGStarted_Call {
	_c.Call.Return(run)
	return _c
}

// RetrieveMyBeaconPrivateKey provides a mock function for the type EpochRecoveryMyBeaconKey
func (_mock *EpochRecoveryMyBeaconKey) RetrieveMyBeaconPrivateKey(epochCounter uint64) (crypto.PrivateKey, bool, error) {
	ret := _mock.Called(epochCounter)

	if len(ret) == 0 {
		panic("no return value specified for RetrieveMyBeaconPrivateKey")
	}

	var r0 crypto.PrivateKey
	var r1 bool
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(uint64) (crypto.PrivateKey, bool, error)); ok {
		return returnFunc(epochCounter)
	}
	if returnFunc, ok := ret.Get(0).(func(uint64) crypto.PrivateKey); ok {
		r0 = returnFunc(epochCounter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(crypto.PrivateKey)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(uint64) bool); ok {
		r1 = returnFunc(epochCounter)
	} else {
		r1 = ret.Get(1).(bool)
	}
	if returnFunc, ok := ret.Get(2).(func(uint64) error); ok {
		r2 = returnFunc(epochCounter)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// EpochRecoveryMyBeaconKey_RetrieveMyBeaconPrivateKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RetrieveMyBeaconPrivateKey'
type EpochRecoveryMyBeaconKey_RetrieveMyBeaconPrivateKey_Call struct {
	*mock.Call
}

// RetrieveMyBeaconPrivateKey is a helper method to define mock.On call
//   - epochCounter uint64
func (_e *EpochRecoveryMyBeaconKey_Expecter) RetrieveMyBeaconPrivateKey(epochCounter interface{}) *EpochRecoveryMyBeaconKey_RetrieveMyBeaconPrivateKey_Call {
	return &EpochRecoveryMyBeaconKey_RetrieveMyBeaconPrivateKey_Call{Call: _e.mock.On("RetrieveMyBeaconPrivateKey", epochCounter)}
}

func (_c *EpochRecoveryMyBeaconKey_RetrieveMyBeaconPrivateKey_Call) Run(run func(epochCounter uint64)) *EpochRecoveryMyBeaconKey_RetrieveMyBeaconPrivateKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *EpochRecoveryMyBeaconKey_RetrieveMyBeaconPrivateKey_Call) Return(key crypto.PrivateKey, safe bool, err error) *EpochRecoveryMyBeaconKey_RetrieveMyBeaconPrivateKey_Call {
	_c.Call.Return(key, safe, err)
	return _c
}

func (_c *EpochRecoveryMyBeaconKey_RetrieveMyBeaconPrivateKey_Call) RunAndReturn(run func(epochCounter uint64) (crypto.PrivateKey, bool, error)) *EpochRecoveryMyBeaconKey_RetrieveMyBeaconPrivateKey_Call {
	_c.Call.Return(run)
	return _c
}

// UnsafeRetrieveMyBeaconPrivateKey provides a mock function for the type EpochRecoveryMyBeaconKey
func (_mock *EpochRecoveryMyBeaconKey) UnsafeRetrieveMyBeaconPrivateKey(epochCounter uint64) (crypto.PrivateKey, error) {
	ret := _mock.Called(epochCounter)

	if len(ret) == 0 {
		panic("no return value specified for UnsafeRetrieveMyBeaconPrivateKey")
	}

	var r0 crypto.PrivateKey
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(uint64) (crypto.PrivateKey, error)); ok {
		return returnFunc(epochCounter)
	}
	if returnFunc, ok := ret.Get(0).(func(uint64) crypto.PrivateKey); ok {
		r0 = returnFunc(epochCounter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(crypto.PrivateKey)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(uint64) error); ok {
		r1 = returnFunc(epochCounter)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// EpochRecoveryMyBeaconKey_UnsafeRetrieveMyBeaconPrivateKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnsafeRetrieveMyBeaconPrivateKey'
type EpochRecoveryMyBeaconKey_UnsafeRetrieveMyBeaconPrivateKey_Call struct {
	*mock.Call
}

// UnsafeRetrieveMyBeaconPrivateKey is a helper method to define mock.On call
//   - epochCounter uint64
func (_e *EpochRecoveryMyBeaconKey_Expecter) UnsafeRetrieveMyBeaconPrivateKey(epochCounter interface{}) *EpochRecoveryMyBeaconKey_UnsafeRetrieveMyBeaconPrivateKey_Call {
	return &EpochRecoveryMyBeaconKey_UnsafeRetrieveMyBeaconPrivateKey_Call{Call: _e.mock.On("UnsafeRetrieveMyBeaconPrivateKey", epochCounter)}
}

func (_c *EpochRecoveryMyBeaconKey_UnsafeRetrieveMyBeaconPrivateKey_Call) Run(run func(epochCounter uint64)) *EpochRecoveryMyBeaconKey_UnsafeRetrieveMyBeaconPrivateKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *EpochRecoveryMyBeaconKey_UnsafeRetrieveMyBeaconPrivateKey_Call) Return(privateKey crypto.PrivateKey, err error) *EpochRecoveryMyBeaconKey_UnsafeRetrieveMyBeaconPrivateKey_Call {
	_c.Call.Return(privateKey, err)
	return _c
}

func (_c *EpochRecoveryMyBeaconKey_UnsafeRetrieveMyBeaconPrivateKey_Call) RunAndReturn(run func(epochCounter uint64) (crypto.PrivateKey, error)) *EpochRecoveryMyBeaconKey_UnsafeRetrieveMyBeaconPrivateKey_Call {
	_c.Call.Return(run)
	return _c
}

// UpsertMyBeaconPrivateKey provides a mock function for the type EpochRecoveryMyBeaconKey
func (_mock *EpochRecoveryMyBeaconKey) UpsertMyBeaconPrivateKey(epochCounter uint64, key crypto.PrivateKey, commit *flow.EpochCommit) error {
	ret := _mock.Called(epochCounter, key, commit)

	if len(ret) == 0 {
		panic("no return value specified for UpsertMyBeaconPrivateKey")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(uint64, crypto.PrivateKey, *flow.EpochCommit) error); ok {
		r0 = returnFunc(epochCounter, key, commit)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// EpochRecoveryMyBeaconKey_UpsertMyBeaconPrivateKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpsertMyBeaconPrivateKey'
type EpochRecoveryMyBeaconKey_UpsertMyBeaconPrivateKey_Call struct {
	*mock.Call
}

// UpsertMyBeaconPrivateKey is a helper method to define mock.On call
//   - epochCounter uint64
//   - key crypto.PrivateKey
//   - commit *flow.EpochCommit
func (_e *EpochRecoveryMyBeaconKey_Expecter) UpsertMyBeaconPrivateKey(epochCounter interface{}, key interface{}, commit interface{}) *EpochRecoveryMyBeaconKey_UpsertMyBeaconPrivateKey_Call {
	return &EpochRecoveryMyBeaconKey_UpsertMyBeaconPrivateKey_Call{Call: _e.mock.On("UpsertMyBeaconPrivateKey", epochCounter, key, commit)}
}

func (_c *EpochRecoveryMyBeaconKey_UpsertMyBeaconPrivateKey_Call) Run(run func(epochCounter uint64, key crypto.PrivateKey, commit *flow.EpochCommit)) *EpochRecoveryMyBeaconKey_UpsertMyBeaconPrivateKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		var arg1 crypto.PrivateKey
		if args[1] != nil {
			arg1 = args[1].(crypto.PrivateKey)
		}
		var arg2 *flow.EpochCommit
		if args[2] != nil {
			arg2 = args[2].(*flow.EpochCommit)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *EpochRecoveryMyBeaconKey_UpsertMyBeaconPrivateKey_Call) Return(err error) *EpochRecoveryMyBeaconKey_UpsertMyBeaconPrivateKey_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *EpochRecoveryMyBeaconKey_UpsertMyBeaconPrivateKey_Call) RunAndReturn(run func(epochCounter uint64, key crypto.PrivateKey, commit *flow.EpochCommit) error) *EpochRecoveryMyBeaconKey_UpsertMyBeaconPrivateKey_Call {
	_c.Call.Return(run)
	return _c
}

// NewEpochCommits creates a new instance of EpochCommits. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewEpochCommits(t interface {
	mock.TestingT
	Cleanup(func())
}) *EpochCommits {
	mock := &EpochCommits{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// EpochCommits is an autogenerated mock type for the EpochCommits type
type EpochCommits struct {
	mock.Mock
}

type EpochCommits_Expecter struct {
	mock *mock.Mock
}

func (_m *EpochCommits) EXPECT() *EpochCommits_Expecter {
	return &EpochCommits_Expecter{mock: &_m.Mock}
}

// BatchStore provides a mock function for the type EpochCommits
func (_mock *EpochCommits) BatchStore(rw storage.ReaderBatchWriter, commit *flow.EpochCommit) error {
	ret := _mock.Called(rw, commit)

	if len(ret) == 0 {
		panic("no return value specified for BatchStore")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(storage.ReaderBatchWriter, *flow.EpochCommit) error); ok {
		r0 = returnFunc(rw, commit)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// EpochCommits_BatchStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BatchStore'
type EpochCommits_BatchStore_Call struct {
	*mock.Call
}

// BatchStore is a helper method to define mock.On call
//   - rw storage.ReaderBatchWriter
//   - commit *flow.EpochCommit
func (_e *EpochCommits_Expecter) BatchStore(rw interface{}, commit interface{}) *EpochCommits_BatchStore_Call {
	return &EpochCommits_BatchStore_Call{Call: _e.mock.On("BatchStore", rw, commit)}
}

func (_c *EpochCommits_BatchStore_Call) Run(run func(rw storage.ReaderBatchWriter, commit *flow.EpochCommit)) *EpochCommits_BatchStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 storage.ReaderBatchWriter
		if args[0] != nil {
			arg0 = args[0].(storage.ReaderBatchWriter)
		}
		var arg1 *flow.EpochCommit
		if args[1] != nil {
			arg1 = args[1].(*flow.EpochCommit)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *EpochCommits_BatchStore_Call) Return(err error) *EpochCommits_BatchStore_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *EpochCommits_BatchStore_Call) RunAndReturn(run func(rw storage.ReaderBatchWriter, commit *flow.EpochCommit) error) *EpochCommits_BatchStore_Call {
	_c.Call.Return(run)
	return _c
}

// ByID provides a mock function for the type EpochCommits
func (_mock *EpochCommits) ByID(identifier flow.Identifier) (*flow.EpochCommit, error) {
	ret := _mock.Called(identifier)

	if len(ret) == 0 {
		panic("no return value specified for ByID")
	}

	var r0 *flow.EpochCommit
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (*flow.EpochCommit, error)); ok {
		return returnFunc(identifier)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) *flow.EpochCommit); ok {
		r0 = returnFunc(identifier)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.EpochCommit)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(identifier)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// EpochCommits_ByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByID'
type EpochCommits_ByID_Call struct {
	*mock.Call
}

// ByID is a helper method to define mock.On call
//   - identifier flow.Identifier
func (_e *EpochCommits_Expecter) ByID(identifier interface{}) *EpochCommits_ByID_Call {
	return &EpochCommits_ByID_Call{Call: _e.mock.On("ByID", identifier)}
}

func (_c *EpochCommits_ByID_Call) Run(run func(identifier flow.Identifier)) *EpochCommits_ByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *EpochCommits_ByID_Call) Return(epochCommit *flow.EpochCommit, err error) *EpochCommits_ByID_Call {
	_c.Call.Return(epochCommit, err)
	return _c
}

func (_c *EpochCommits_ByID_Call) RunAndReturn(run func(identifier flow.Identifier) (*flow.EpochCommit, error)) *EpochCommits_ByID_Call {
	_c.Call.Return(run)
	return _c
}

// NewEpochProtocolStateEntries creates a new instance of EpochProtocolStateEntries. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewEpochProtocolStateEntries(t interface {
	mock.TestingT
	Cleanup(func())
}) *EpochProtocolStateEntries {
	mock := &EpochProtocolStateEntries{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// EpochProtocolStateEntries is an autogenerated mock type for the EpochProtocolStateEntries type
type EpochProtocolStateEntries struct {
	mock.Mock
}

type EpochProtocolStateEntries_Expecter struct {
	mock *mock.Mock
}

func (_m *EpochProtocolStateEntries) EXPECT() *EpochProtocolStateEntries_Expecter {
	return &EpochProtocolStateEntries_Expecter{mock: &_m.Mock}
}

// BatchIndex provides a mock function for the type EpochProtocolStateEntries
func (_mock *EpochProtocolStateEntries) BatchIndex(lctx lockctx.Proof, rw storage.ReaderBatchWriter, blockID flow.Identifier, epochProtocolStateID flow.Identifier) error {
	ret := _mock.Called(lctx, rw, blockID, epochProtocolStateID)

	if len(ret) == 0 {
		panic("no return value specified for BatchIndex")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(lockctx.Proof, storage.ReaderBatchWriter, flow.Identifier, flow.Identifier) error); ok {
		r0 = returnFunc(lctx, rw, blockID, epochProtocolStateID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// EpochProtocolStateEntries_BatchIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BatchIndex'
type EpochProtocolStateEntries_BatchIndex_Call struct {
	*mock.Call
}

// BatchIndex is a helper method to define mock.On call
//   - lctx lockctx.Proof
//   - rw storage.ReaderBatchWriter
//   - blockID flow.Identifier
//   - epochProtocolStateID flow.Identifier
func (_e *EpochProtocolStateEntries_Expecter) BatchIndex(lctx interface{}, rw interface{}, blockID interface{}, epochProtocolStateID interface{}) *EpochProtocolStateEntries_BatchIndex_Call {
	return &EpochProtocolStateEntries_BatchIndex_Call{Call: _e.mock.On("BatchIndex", lctx, rw, blockID, epochProtocolStateID)}
}

func (_c *EpochProtocolStateEntries_BatchIndex_Call) Run(run func(lctx lockctx.Proof, rw storage.ReaderBatchWriter, blockID flow.Identifier, epochProtocolStateID flow.Identifier)) *EpochProtocolStateEntries_BatchIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 lockctx.Proof
		if args[0] != nil {
			arg0 = args[0].(lockctx.Proof)
		}
		var arg1 storage.ReaderBatchWriter
		if args[1] != nil {
			arg1 = args[1].(storage.ReaderBatchWriter)
		}
		var arg2 flow.Identifier
		if args[2] != nil {
			arg2 = args[2].(flow.Identifier)
		}
		var arg3 flow.Identifier
		if args[3] != nil {
			arg3 = args[3].(flow.Identifier)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *EpochProtocolStateEntries_BatchIndex_Call) Return(err error) *EpochProtocolStateEntries_BatchIndex_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *EpochProtocolStateEntries_BatchIndex_Call) RunAndReturn(run func(lctx lockctx.Proof, rw storage.ReaderBatchWriter, blockID flow.Identifier, epochProtocolStateID flow.Identifier) error) *EpochProtocolStateEntries_BatchIndex_Call {
	_c.Call.Return(run)
	return _c
}

// BatchStore provides a mock function for the type EpochProtocolStateEntries
func (_mock *EpochProtocolStateEntries) BatchStore(w storage.Writer, epochProtocolStateID flow.Identifier, epochProtocolStateEntry *flow.MinEpochStateEntry) error {
	ret := _mock.Called(w, epochProtocolStateID, epochProtocolStateEntry)

	if len(ret) == 0 {
		panic("no return value specified for BatchStore")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(storage.Writer, flow.Identifier, *flow.MinEpochStateEntry) error); ok {
		r0 = returnFunc(w, epochProtocolStateID, epochProtocolStateEntry)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// EpochProtocolStateEntries_BatchStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BatchStore'
type EpochProtocolStateEntries_BatchStore_Call struct {
	*mock.Call
}

// BatchStore is a helper method to define mock.On call
//   - w storage.Writer
//   - epochProtocolStateID flow.Identifier
//   - epochProtocolStateEntry *flow.MinEpochStateEntry
func (_e *EpochProtocolStateEntries_Expecter) BatchStore(w interface{}, epochProtocolStateID interface{}, epochProtocolStateEntry interface{}) *EpochProtocolStateEntries_BatchStore_Call {
	return &EpochProtocolStateEntries_BatchStore_Call{Call: _e.mock.On("BatchStore", w, epochProtocolStateID, epochProtocolStateEntry)}
}

func (_c *EpochProtocolStateEntries_BatchStore_Call) Run(run func(w storage.Writer, epochProtocolStateID flow.Identifier, epochProtocolStateEntry *flow.MinEpochStateEntry)) *EpochProtocolStateEntries_BatchStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 storage.Writer
		if args[0] != nil {
			arg0 = args[0].(storage.Writer)
		}
		var arg1 flow.Identifier
		if args[1] != nil {
			arg1 = args[1].(flow.Identifier)
		}
		var arg2 *flow.MinEpochStateEntry
		if args[2] != nil {
			arg2 = args[2].(*flow.MinEpochStateEntry)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *EpochProtocolStateEntries_BatchStore_Call) Return(err error) *EpochProtocolStateEntries_BatchStore_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *EpochProtocolStateEntries_BatchStore_Call) RunAndReturn(run func(w storage.Writer, epochProtocolStateID flow.Identifier, epochProtocolStateEntry *flow.MinEpochStateEntry) error) *EpochProtocolStateEntries_BatchStore_Call {
	_c.Call.Return(run)
	return _c
}

// ByBlockID provides a mock function for the type EpochProtocolStateEntries
func (_mock *EpochProtocolStateEntries) ByBlockID(blockID flow.Identifier) (*flow.RichEpochStateEntry, error) {
	ret := _mock.Called(blockID)

	if len(ret) == 0 {
		panic("no return value specified for ByBlockID")
	}

	var r0 *flow.RichEpochStateEntry
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (*flow.RichEpochStateEntry, error)); ok {
		return returnFunc(blockID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) *flow.RichEpochStateEntry); ok {
		r0 = returnFunc(blockID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.RichEpochStateEntry)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(blockID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// EpochProtocolStateEntries_ByBlockID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByBlockID'
type EpochProtocolStateEntries_ByBlockID_Call struct {
	*mock.Call
}

// ByBlockID is a helper method to define mock.On call
//   - blockID flow.Identifier
func (_e *EpochProtocolStateEntries_Expecter) ByBlockID(blockID interface{}) *EpochProtocolStateEntries_ByBlockID_Call {
	return &EpochProtocolStateEntries_ByBlockID_Call{Call: _e.mock.On("ByBlockID", blockID)}
}

func (_c *EpochProtocolStateEntries_ByBlockID_Call) Run(run func(blockID flow.Identifier)) *EpochProtocolStateEntries_ByBlockID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *EpochProtocolStateEntries_ByBlockID_Call) Return(richEpochStateEntry *flow.RichEpochStateEntry, err error) *EpochProtocolStateEntries_ByBlockID_Call {
	_c.Call.Return(richEpochStateEntry, err)
	return _c
}

func (_c *EpochProtocolStateEntries_ByBlockID_Call) RunAndReturn(run func(blockID flow.Identifier) (*flow.RichEpochStateEntry, error)) *EpochProtocolStateEntries_ByBlockID_Call {
	_c.Call.Return(run)
	return _c
}

// ByID provides a mock function for the type EpochProtocolStateEntries
func (_mock *EpochProtocolStateEntries) ByID(id flow.Identifier) (*flow.RichEpochStateEntry, error) {
	ret := _mock.Called(id)

	if len(ret) == 0 {
		panic("no return value specified for ByID")
	}

	var r0 *flow.RichEpochStateEntry
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (*flow.RichEpochStateEntry, error)); ok {
		return returnFunc(id)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) *flow.RichEpochStateEntry); ok {
		r0 = returnFunc(id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.RichEpochStateEntry)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// EpochProtocolStateEntries_ByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByID'
type EpochProtocolStateEntries_ByID_Call struct {
	*mock.Call
}

// ByID is a helper method to define mock.On call
//   - id flow.Identifier
func (_e *EpochProtocolStateEntries_Expecter) ByID(id interface{}) *EpochProtocolStateEntries_ByID_Call {
	return &EpochProtocolStateEntries_ByID_Call{Call: _e.mock.On("ByID", id)}
}

func (_c *EpochProtocolStateEntries_ByID_Call) Run(run func(id flow.Identifier)) *EpochProtocolStateEntries_ByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *EpochProtocolStateEntries_ByID_Call) Return(richEpochStateEntry *flow.RichEpochStateEntry, err error) *EpochProtocolStateEntries_ByID_Call {
	_c.Call.Return(richEpochStateEntry, err)
	return _c
}

func (_c *EpochProtocolStateEntries_ByID_Call) RunAndReturn(run func(id flow.Identifier) (*flow.RichEpochStateEntry, error)) *EpochProtocolStateEntries_ByID_Call {
	_c.Call.Return(run)
	return _c
}

// NewEpochSetups creates a new instance of EpochSetups. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewEpochSetups(t interface {
	mock.TestingT
	Cleanup(func())
}) *EpochSetups {
	mock := &EpochSetups{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// EpochSetups is an autogenerated mock type for the EpochSetups type
type EpochSetups struct {
	mock.Mock
}

type EpochSetups_Expecter struct {
	mock *mock.Mock
}

func (_m *EpochSetups) EXPECT() *EpochSetups_Expecter {
	return &EpochSetups_Expecter{mock: &_m.Mock}
}

// BatchStore provides a mock function for the type EpochSetups
func (_mock *EpochSetups) BatchStore(rw storage.ReaderBatchWriter, setup *flow.EpochSetup) error {
	ret := _mock.Called(rw, setup)

	if len(ret) == 0 {
		panic("no return value specified for BatchStore")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(storage.ReaderBatchWriter, *flow.EpochSetup) error); ok {
		r0 = returnFunc(rw, setup)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// EpochSetups_BatchStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BatchStore'
type EpochSetups_BatchStore_Call struct {
	*mock.Call
}

// BatchStore is a helper method to define mock.On call
//   - rw storage.ReaderBatchWriter
//   - setup *flow.EpochSetup
func (_e *EpochSetups_Expecter) BatchStore(rw interface{}, setup interface{}) *EpochSetups_BatchStore_Call {
	return &EpochSetups_BatchStore_Call{Call: _e.mock.On("BatchStore", rw, setup)}
}

func (_c *EpochSetups_BatchStore_Call) Run(run func(rw storage.ReaderBatchWriter, setup *flow.EpochSetup)) *EpochSetups_BatchStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 storage.ReaderBatchWriter
		if args[0] != nil {
			arg0 = args[0].(storage.ReaderBatchWriter)
		}
		var arg1 *flow.EpochSetup
		if args[1] != nil {
			arg1 = args[1].(*flow.EpochSetup)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *EpochSetups_BatchStore_Call) Return(err error) *EpochSetups_BatchStore_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *EpochSetups_BatchStore_Call) RunAndReturn(run func(rw storage.ReaderBatchWriter, setup *flow.EpochSetup) error) *EpochSetups_BatchStore_Call {
	_c.Call.Return(run)
	return _c
}

// ByID provides a mock function for the type EpochSetups
func (_mock *EpochSetups) ByID(identifier flow.Identifier) (*flow.EpochSetup, error) {
	ret := _mock.Called(identifier)

	if len(ret) == 0 {
		panic("no return value specified for ByID")
	}

	var r0 *flow.EpochSetup
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (*flow.EpochSetup, error)); ok {
		return returnFunc(identifier)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) *flow.EpochSetup); ok {
		r0 = returnFunc(identifier)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.EpochSetup)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(identifier)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// EpochSetups_ByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByID'
type EpochSetups_ByID_Call struct {
	*mock.Call
}

// ByID is a helper method to define mock.On call
//   - identifier flow.Identifier
func (_e *EpochSetups_Expecter) ByID(identifier interface{}) *EpochSetups_ByID_Call {
	return &EpochSetups_ByID_Call{Call: _e.mock.On("ByID", identifier)}
}

func (_c *EpochSetups_ByID_Call) Run(run func(identifier flow.Identifier)) *EpochSetups_ByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *EpochSetups_ByID_Call) Return(epochSetup *flow.EpochSetup, err error) *EpochSetups_ByID_Call {
	_c.Call.Return(epochSetup, err)
	return _c
}

func (_c *EpochSetups_ByID_Call) RunAndReturn(run func(identifier flow.Identifier) (*flow.EpochSetup, error)) *EpochSetups_ByID_Call {
	_c.Call.Return(run)
	return _c
}

// NewEventsReader creates a new instance of EventsReader. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewEventsReader(t interface {
	mock.TestingT
	Cleanup(func())
}) *EventsReader {
	mock := &EventsReader{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// EventsReader is an autogenerated mock type for the EventsReader type
type EventsReader struct {
	mock.Mock
}

type EventsReader_Expecter struct {
	mock *mock.Mock
}

func (_m *EventsReader) EXPECT() *EventsReader_Expecter {
	return &EventsReader_Expecter{mock: &_m.Mock}
}

// ByBlockID provides a mock function for the type EventsReader
func (_mock *EventsReader) ByBlockID(blockID flow.Identifier) ([]flow.Event, error) {
	ret := _mock.Called(blockID)

	if len(ret) == 0 {
		panic("no return value specified for ByBlockID")
	}

	var r0 []flow.Event
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) ([]flow.Event, error)); ok {
		return returnFunc(blockID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) []flow.Event); ok {
		r0 = returnFunc(blockID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]flow.Event)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(blockID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// EventsReader_ByBlockID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByBlockID'
type EventsReader_ByBlockID_Call struct {
	*mock.Call
}

// ByBlockID is a helper method to define mock.On call
//   - blockID flow.Identifier
func (_e *EventsReader_Expecter) ByBlockID(blockID interface{}) *EventsReader_ByBlockID_Call {
	return &EventsReader_ByBlockID_Call{Call: _e.mock.On("ByBlockID", blockID)}
}

func (_c *EventsReader_ByBlockID_Call) Run(run func(blockID flow.Identifier)) *EventsReader_ByBlockID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *EventsReader_ByBlockID_Call) Return(events []flow.Event, err error) *EventsReader_ByBlockID_Call {
	_c.Call.Return(events, err)
	return _c
}

func (_c *EventsReader_ByBlockID_Call) RunAndReturn(run func(blockID flow.Identifier) ([]flow.Event, error)) *EventsReader_ByBlockID_Call {
	_c.Call.Return(run)
	return _c
}

// ByBlockIDEventType provides a mock function for the type EventsReader
func (_mock *EventsReader) ByBlockIDEventType(blockID flow.Identifier, eventType flow.EventType) ([]flow.Event, error) {
	ret := _mock.Called(blockID, eventType)

	if len(ret) == 0 {
		panic("no return value specified for ByBlockIDEventType")
	}

	var r0 []flow.Event
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, flow.EventType) ([]flow.Event, error)); ok {
		return returnFunc(blockID, eventType)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, flow.EventType) []flow.Event); ok {
		r0 = returnFunc(blockID, eventType)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]flow.Event)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier, flow.EventType) error); ok {
		r1 = returnFunc(blockID, eventType)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// EventsReader_ByBlockIDEventType_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByBlockIDEventType'
type EventsReader_ByBlockIDEventType_Call struct {
	*mock.Call
}

// ByBlockIDEventType is a helper method to define mock.On call
//   - blockID flow.Identifier
//   - eventType flow.EventType
func (_e *EventsReader_Expecter) ByBlockIDEventType(blockID interface{}, eventType interface{}) *EventsReader_ByBlockIDEventType_Call {
	return &EventsReader_ByBlockIDEventType_Call{Call: _e.mock.On("ByBlockIDEventType", blockID, eventType)}
}

func (_c *EventsReader_ByBlockIDEventType_Call) Run(run func(blockID flow.Identifier, eventType flow.EventType)) *EventsReader_ByBlockIDEventType_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		var arg1 flow.EventType
		if args[1] != nil {
			arg1 = args[1].(flow.EventType)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *EventsReader_ByBlockIDEventType_Call) Return(events []flow.Event, err error) *EventsReader_ByBlockIDEventType_Call {
	_c.Call.Return(events, err)
	return _c
}

func (_c *EventsReader_ByBlockIDEventType_Call) RunAndReturn(run func(blockID flow.Identifier, eventType flow.EventType) ([]flow.Event, error)) *EventsReader_ByBlockIDEventType_Call {
	_c.Call.Return(run)
	return _c
}

// ByBlockIDTransactionID provides a mock function for the type EventsReader
func (_mock *EventsReader) ByBlockIDTransactionID(blockID flow.Identifier, transactionID flow.Identifier) ([]flow.Event, error) {
	ret := _mock.Called(blockID, transactionID)

	if len(ret) == 0 {
		panic("no return value specified for ByBlockIDTransactionID")
	}

	var r0 []flow.Event
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, flow.Identifier) ([]flow.Event, error)); ok {
		return returnFunc(blockID, transactionID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, flow.Identifier) []flow.Event); ok {
		r0 = returnFunc(blockID, transactionID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]flow.Event)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier, flow.Identifier) error); ok {
		r1 = returnFunc(blockID, transactionID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// EventsReader_ByBlockIDTransactionID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByBlockIDTransactionID'
type EventsReader_ByBlockIDTransactionID_Call struct {
	*mock.Call
}

// ByBlockIDTransactionID is a helper method to define mock.On call
//   - blockID flow.Identifier
//   - transactionID flow.Identifier
func (_e *EventsReader_Expecter) ByBlockIDTransactionID(blockID interface{}, transactionID interface{}) *EventsReader_ByBlockIDTransactionID_Call {
	return &EventsReader_ByBlockIDTransactionID_Call{Call: _e.mock.On("ByBlockIDTransactionID", blockID, transactionID)}
}

func (_c *EventsReader_ByBlockIDTransactionID_Call) Run(run func(blockID flow.Identifier, transactionID flow.Identifier)) *EventsReader_ByBlockIDTransactionID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		var arg1 flow.Identifier
		if args[1] != nil {
			arg1 = args[1].(flow.Identifier)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *EventsReader_ByBlockIDTransactionID_Call) Return(events []flow.Event, err error) *EventsReader_ByBlockIDTransactionID_Call {
	_c.Call.Return(events, err)
	return _c
}

func (_c *EventsReader_ByBlockIDTransactionID_Call) RunAndReturn(run func(blockID flow.Identifier, transactionID flow.Identifier) ([]flow.Event, error)) *EventsReader_ByBlockIDTransactionID_Call {
	_c.Call.Return(run)
	return _c
}

// ByBlockIDTransactionIndex provides a mock function for the type EventsReader
func (_mock *EventsReader) ByBlockIDTransactionIndex(blockID flow.Identifier, txIndex uint32) ([]flow.Event, error) {
	ret := _mock.Called(blockID, txIndex)

	if len(ret) == 0 {
		panic("no return value specified for ByBlockIDTransactionIndex")
	}

	var r0 []flow.Event
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, uint32) ([]flow.Event, error)); ok {
		return returnFunc(blockID, txIndex)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, uint32) []flow.Event); ok {
		r0 = returnFunc(blockID, txIndex)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]flow.Event)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier, uint32) error); ok {
		r1 = returnFunc(blockID, txIndex)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// EventsReader_ByBlockIDTransactionIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByBlockIDTransactionIndex'
type EventsReader_ByBlockIDTransactionIndex_Call struct {
	*mock.Call
}

// ByBlockIDTransactionIndex is a helper method to define mock.On call
//   - blockID flow.Identifier
//   - txIndex uint32
func (_e *EventsReader_Expecter) ByBlockIDTransactionIndex(blockID interface{}, txIndex interface{}) *EventsReader_ByBlockIDTransactionIndex_Call {
	return &EventsReader_ByBlockIDTransactionIndex_Call{Call: _e.mock.On("ByBlockIDTransactionIndex", blockID, txIndex)}
}

func (_c *EventsReader_ByBlockIDTransactionIndex_Call) Run(run func(blockID flow.Identifier, txIndex uint32)) *EventsReader_ByBlockIDTransactionIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		var arg1 uint32
		if args[1] != nil {
			arg1 = args[1].(uint32)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *EventsReader_ByBlockIDTransactionIndex_Call) Return(events []flow.Event, err error) *EventsReader_ByBlockIDTransactionIndex_Call {
	_c.Call.Return(events, err)
	return _c
}

func (_c *EventsReader_ByBlockIDTransactionIndex_Call) RunAndReturn(run func(blockID flow.Identifier, txIndex uint32) ([]flow.Event, error)) *EventsReader_ByBlockIDTransactionIndex_Call {
	_c.Call.Return(run)
	return _c
}

// NewEvents creates a new instance of Events. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewEvents(t interface {
	mock.TestingT
	Cleanup(func())
}) *Events {
	mock := &Events{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Events is an autogenerated mock type for the Events type
type Events struct {
	mock.Mock
}

type Events_Expecter struct {
	mock *mock.Mock
}

func (_m *Events) EXPECT() *Events_Expecter {
	return &Events_Expecter{mock: &_m.Mock}
}

// BatchRemoveByBlockID provides a mock function for the type Events
func (_mock *Events) BatchRemoveByBlockID(blockID flow.Identifier, batch storage.ReaderBatchWriter) error {
	ret := _mock.Called(blockID, batch)

	if len(ret) == 0 {
		panic("no return value specified for BatchRemoveByBlockID")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, storage.ReaderBatchWriter) error); ok {
		r0 = returnFunc(blockID, batch)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Events_BatchRemoveByBlockID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BatchRemoveByBlockID'
type Events_BatchRemoveByBlockID_Call struct {
	*mock.Call
}

// BatchRemoveByBlockID is a helper method to define mock.On call
//   - blockID flow.Identifier
//   - batch storage.ReaderBatchWriter
func (_e *Events_Expecter) BatchRemoveByBlockID(blockID interface{}, batch interface{}) *Events_BatchRemoveByBlockID_Call {
	return &Events_BatchRemoveByBlockID_Call{Call: _e.mock.On("BatchRemoveByBlockID", blockID, batch)}
}

func (_c *Events_BatchRemoveByBlockID_Call) Run(run func(blockID flow.Identifier, batch storage.ReaderBatchWriter)) *Events_BatchRemoveByBlockID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		var arg1 storage.ReaderBatchWriter
		if args[1] != nil {
			arg1 = args[1].(storage.ReaderBatchWriter)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Events_BatchRemoveByBlockID_Call) Return(err error) *Events_BatchRemoveByBlockID_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Events_BatchRemoveByBlockID_Call) RunAndReturn(run func(blockID flow.Identifier, batch storage.ReaderBatchWriter) error) *Events_BatchRemoveByBlockID_Call {
	_c.Call.Return(run)
	return _c
}

// BatchStore provides a mock function for the type Events
func (_mock *Events) BatchStore(lctx lockctx.Proof, blockID flow.Identifier, events []flow.EventsList, batch storage.ReaderBatchWriter) error {
	ret := _mock.Called(lctx, blockID, events, batch)

	if len(ret) == 0 {
		panic("no return value specified for BatchStore")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(lockctx.Proof, flow.Identifier, []flow.EventsList, storage.ReaderBatchWriter) error); ok {
		r0 = returnFunc(lctx, blockID, events, batch)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Events_BatchStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BatchStore'
type Events_BatchStore_Call struct {
	*mock.Call
}

// BatchStore is a helper method to define mock.On call
//   - lctx lockctx.Proof
//   - blockID flow.Identifier
//   - events []flow.EventsList
//   - batch storage.ReaderBatchWriter
func (_e *Events_Expecter) BatchStore(lctx interface{}, blockID interface{}, events interface{}, batch interface{}) *Events_BatchStore_Call {
	return &Events_BatchStore_Call{Call: _e.mock.On("BatchStore", lctx, blockID, events, batch)}
}

func (_c *Events_BatchStore_Call) Run(run func(lctx lockctx.Proof, blockID flow.Identifier, events []flow.EventsList, batch storage.ReaderBatchWriter)) *Events_BatchStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 lockctx.Proof
		if args[0] != nil {
			arg0 = args[0].(lockctx.Proof)
		}
		var arg1 flow.Identifier
		if args[1] != nil {
			arg1 = args[1].(flow.Identifier)
		}
		var arg2 []flow.EventsList
		if args[2] != nil {
			arg2 = args[2].([]flow.EventsList)
		}
		var arg3 storage.ReaderBatchWriter
		if args[3] != nil {
			arg3 = args[3].(storage.ReaderBatchWriter)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *Events_BatchStore_Call) Return(err error) *Events_BatchStore_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Events_BatchStore_Call) RunAndReturn(run func(lctx lockctx.Proof, blockID flow.Identifier, events []flow.EventsList, batch storage.ReaderBatchWriter) error) *Events_BatchStore_Call {
	_c.Call.Return(run)
	return _c
}

// ByBlockID provides a mock function for the type Events
func (_mock *Events) ByBlockID(blockID flow.Identifier) ([]flow.Event, error) {
	ret := _mock.Called(blockID)

	if len(ret) == 0 {
		panic("no return value specified for ByBlockID")
	}

	var r0 []flow.Event
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) ([]flow.Event, error)); ok {
		return returnFunc(blockID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) []flow.Event); ok {
		r0 = returnFunc(blockID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]flow.Event)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(blockID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Events_ByBlockID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByBlockID'
type Events_ByBlockID_Call struct {
	*mock.Call
}

// ByBlockID is a helper method to define mock.On call
//   - blockID flow.Identifier
func (_e *Events_Expecter) ByBlockID(blockID interface{}) *Events_ByBlockID_Call {
	return &Events_ByBlockID_Call{Call: _e.mock.On("ByBlockID", blockID)}
}

func (_c *Events_ByBlockID_Call) Run(run func(blockID flow.Identifier)) *Events_ByBlockID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Events_ByBlockID_Call) Return(events []flow.Event, err error) *Events_ByBlockID_Call {
	_c.Call.Return(events, err)
	return _c
}

func (_c *Events_ByBlockID_Call) RunAndReturn(run func(blockID flow.Identifier) ([]flow.Event, error)) *Events_ByBlockID_Call {
	_c.Call.Return(run)
	return _c
}

// ByBlockIDEventType provides a mock function for the type Events
func (_mock *Events) ByBlockIDEventType(blockID flow.Identifier, eventType flow.EventType) ([]flow.Event, error) {
	ret := _mock.Called(blockID, eventType)

	if len(ret) == 0 {
		panic("no return value specified for ByBlockIDEventType")
	}

	var r0 []flow.Event
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, flow.EventType) ([]flow.Event, error)); ok {
		return returnFunc(blockID, eventType)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, flow.EventType) []flow.Event); ok {
		r0 = returnFunc(blockID, eventType)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]flow.Event)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier, flow.EventType) error); ok {
		r1 = returnFunc(blockID, eventType)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Events_ByBlockIDEventType_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByBlockIDEventType'
type Events_ByBlockIDEventType_Call struct {
	*mock.Call
}

// ByBlockIDEventType is a helper method to define mock.On call
//   - blockID flow.Identifier
//   - eventType flow.EventType
func (_e *Events_Expecter) ByBlockIDEventType(blockID interface{}, eventType interface{}) *Events_ByBlockIDEventType_Call {
	return &Events_ByBlockIDEventType_Call{Call: _e.mock.On("ByBlockIDEventType", blockID, eventType)}
}

func (_c *Events_ByBlockIDEventType_Call) Run(run func(blockID flow.Identifier, eventType flow.EventType)) *Events_ByBlockIDEventType_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		var arg1 flow.EventType
		if args[1] != nil {
			arg1 = args[1].(flow.EventType)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Events_ByBlockIDEventType_Call) Return(events []flow.Event, err error) *Events_ByBlockIDEventType_Call {
	_c.Call.Return(events, err)
	return _c
}

func (_c *Events_ByBlockIDEventType_Call) RunAndReturn(run func(blockID flow.Identifier, eventType flow.EventType) ([]flow.Event, error)) *Events_ByBlockIDEventType_Call {
	_c.Call.Return(run)
	return _c
}

// ByBlockIDTransactionID provides a mock function for the type Events
func (_mock *Events) ByBlockIDTransactionID(blockID flow.Identifier, transactionID flow.Identifier) ([]flow.Event, error) {
	ret := _mock.Called(blockID, transactionID)

	if len(ret) == 0 {
		panic("no return value specified for ByBlockIDTransactionID")
	}

	var r0 []flow.Event
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, flow.Identifier) ([]flow.Event, error)); ok {
		return returnFunc(blockID, transactionID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, flow.Identifier) []flow.Event); ok {
		r0 = returnFunc(blockID, transactionID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]flow.Event)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier, flow.Identifier) error); ok {
		r1 = returnFunc(blockID, transactionID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Events_ByBlockIDTransactionID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByBlockIDTransactionID'
type Events_ByBlockIDTransactionID_Call struct {
	*mock.Call
}

// ByBlockIDTransactionID is a helper method to define mock.On call
//   - blockID flow.Identifier
//   - transactionID flow.Identifier
func (_e *Events_Expecter) ByBlockIDTransactionID(blockID interface{}, transactionID interface{}) *Events_ByBlockIDTransactionID_Call {
	return &Events_ByBlockIDTransactionID_Call{Call: _e.mock.On("ByBlockIDTransactionID", blockID, transactionID)}
}

func (_c *Events_ByBlockIDTransactionID_Call) Run(run func(blockID flow.Identifier, transactionID flow.Identifier)) *Events_ByBlockIDTransactionID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		var arg1 flow.Identifier
		if args[1] != nil {
			arg1 = args[1].(flow.Identifier)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Events_ByBlockIDTransactionID_Call) Return(events []flow.Event, err error) *Events_ByBlockIDTransactionID_Call {
	_c.Call.Return(events, err)
	return _c
}

func (_c *Events_ByBlockIDTransactionID_Call) RunAndReturn(run func(blockID flow.Identifier, transactionID flow.Identifier) ([]flow.Event, error)) *Events_ByBlockIDTransactionID_Call {
	_c.Call.Return(run)
	return _c
}

// ByBlockIDTransactionIndex provides a mock function for the type Events
func (_mock *Events) ByBlockIDTransactionIndex(blockID flow.Identifier, txIndex uint32) ([]flow.Event, error) {
	ret := _mock.Called(blockID, txIndex)

	if len(ret) == 0 {
		panic("no return value specified for ByBlockIDTransactionIndex")
	}

	var r0 []flow.Event
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, uint32) ([]flow.Event, error)); ok {
		return returnFunc(blockID, txIndex)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, uint32) []flow.Event); ok {
		r0 = returnFunc(blockID, txIndex)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]flow.Event)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier, uint32) error); ok {
		r1 = returnFunc(blockID, txIndex)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Events_ByBlockIDTransactionIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByBlockIDTransactionIndex'
type Events_ByBlockIDTransactionIndex_Call struct {
	*mock.Call
}

// ByBlockIDTransactionIndex is a helper method to define mock.On call
//   - blockID flow.Identifier
//   - txIndex uint32
func (_e *Events_Expecter) ByBlockIDTransactionIndex(blockID interface{}, txIndex interface{}) *Events_ByBlockIDTransactionIndex_Call {
	return &Events_ByBlockIDTransactionIndex_Call{Call: _e.mock.On("ByBlockIDTransactionIndex", blockID, txIndex)}
}

func (_c *Events_ByBlockIDTransactionIndex_Call) Run(run func(blockID flow.Identifier, txIndex uint32)) *Events_ByBlockIDTransactionIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		var arg1 uint32
		if args[1] != nil {
			arg1 = args[1].(uint32)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Events_ByBlockIDTransactionIndex_Call) Return(events []flow.Event, err error) *Events_ByBlockIDTransactionIndex_Call {
	_c.Call.Return(events, err)
	return _c
}

func (_c *Events_ByBlockIDTransactionIndex_Call) RunAndReturn(run func(blockID flow.Identifier, txIndex uint32) ([]flow.Event, error)) *Events_ByBlockIDTransactionIndex_Call {
	_c.Call.Return(run)
	return _c
}

// NewServiceEvents creates a new instance of ServiceEvents. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewServiceEvents(t interface {
	mock.TestingT
	Cleanup(func())
}) *ServiceEvents {
	mock := &ServiceEvents{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// ServiceEvents is an autogenerated mock type for the ServiceEvents type
type ServiceEvents struct {
	mock.Mock
}

type ServiceEvents_Expecter struct {
	mock *mock.Mock
}

func (_m *ServiceEvents) EXPECT() *ServiceEvents_Expecter {
	return &ServiceEvents_Expecter{mock: &_m.Mock}
}

// BatchRemoveByBlockID provides a mock function for the type ServiceEvents
func (_mock *ServiceEvents) BatchRemoveByBlockID(blockID flow.Identifier, batch storage.ReaderBatchWriter) error {
	ret := _mock.Called(blockID, batch)

	if len(ret) == 0 {
		panic("no return value specified for BatchRemoveByBlockID")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, storage.ReaderBatchWriter) error); ok {
		r0 = returnFunc(blockID, batch)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ServiceEvents_BatchRemoveByBlockID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BatchRemoveByBlockID'
type ServiceEvents_BatchRemoveByBlockID_Call struct {
	*mock.Call
}

// BatchRemoveByBlockID is a helper method to define mock.On call
//   - blockID flow.Identifier
//   - batch storage.ReaderBatchWriter
func (_e *ServiceEvents_Expecter) BatchRemoveByBlockID(blockID interface{}, batch interface{}) *ServiceEvents_BatchRemoveByBlockID_Call {
	return &ServiceEvents_BatchRemoveByBlockID_Call{Call: _e.mock.On("BatchRemoveByBlockID", blockID, batch)}
}

func (_c *ServiceEvents_BatchRemoveByBlockID_Call) Run(run func(blockID flow.Identifier, batch storage.ReaderBatchWriter)) *ServiceEvents_BatchRemoveByBlockID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		var arg1 storage.ReaderBatchWriter
		if args[1] != nil {
			arg1 = args[1].(storage.ReaderBatchWriter)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ServiceEvents_BatchRemoveByBlockID_Call) Return(err error) *ServiceEvents_BatchRemoveByBlockID_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ServiceEvents_BatchRemoveByBlockID_Call) RunAndReturn(run func(blockID flow.Identifier, batch storage.ReaderBatchWriter) error) *ServiceEvents_BatchRemoveByBlockID_Call {
	_c.Call.Return(run)
	return _c
}

// BatchStore provides a mock function for the type ServiceEvents
func (_mock *ServiceEvents) BatchStore(lctx lockctx.Proof, blockID flow.Identifier, events []flow.Event, batch storage.ReaderBatchWriter) error {
	ret := _mock.Called(lctx, blockID, events, batch)

	if len(ret) == 0 {
		panic("no return value specified for BatchStore")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(lockctx.Proof, flow.Identifier, []flow.Event, storage.ReaderBatchWriter) error); ok {
		r0 = returnFunc(lctx, blockID, events, batch)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ServiceEvents_BatchStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BatchStore'
type ServiceEvents_BatchStore_Call struct {
	*mock.Call
}

// BatchStore is a helper method to define mock.On call
//   - lctx lockctx.Proof
//   - blockID flow.Identifier
//   - events []flow.Event
//   - batch storage.ReaderBatchWriter
func (_e *ServiceEvents_Expecter) BatchStore(lctx interface{}, blockID interface{}, events interface{}, batch interface{}) *ServiceEvents_BatchStore_Call {
	return &ServiceEvents_BatchStore_Call{Call: _e.mock.On("BatchStore", lctx, blockID, events, batch)}
}

func (_c *ServiceEvents_BatchStore_Call) Run(run func(lctx lockctx.Proof, blockID flow.Identifier, events []flow.Event, batch storage.ReaderBatchWriter)) *ServiceEvents_BatchStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 lockctx.Proof
		if args[0] != nil {
			arg0 = args[0].(lockctx.Proof)
		}
		var arg1 flow.Identifier
		if args[1] != nil {
			arg1 = args[1].(flow.Identifier)
		}
		var arg2 []flow.Event
		if args[2] != nil {
			arg2 = args[2].([]flow.Event)
		}
		var arg3 storage.ReaderBatchWriter
		if args[3] != nil {
			arg3 = args[3].(storage.ReaderBatchWriter)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *ServiceEvents_BatchStore_Call) Return(err error) *ServiceEvents_BatchStore_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ServiceEvents_BatchStore_Call) RunAndReturn(run func(lctx lockctx.Proof, blockID flow.Identifier, events []flow.Event, batch storage.ReaderBatchWriter) error) *ServiceEvents_BatchStore_Call {
	_c.Call.Return(run)
	return _c
}

// ByBlockID provides a mock function for the type ServiceEvents
func (_mock *ServiceEvents) ByBlockID(blockID flow.Identifier) ([]flow.Event, error) {
	ret := _mock.Called(blockID)

	if len(ret) == 0 {
		panic("no return value specified for ByBlockID")
	}

	var r0 []flow.Event
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) ([]flow.Event, error)); ok {
		return returnFunc(blockID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) []flow.Event); ok {
		r0 = returnFunc(blockID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]flow.Event)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(blockID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ServiceEvents_ByBlockID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByBlockID'
type ServiceEvents_ByBlockID_Call struct {
	*mock.Call
}

// ByBlockID is a helper method to define mock.On call
//   - blockID flow.Identifier
func (_e *ServiceEvents_Expecter) ByBlockID(blockID interface{}) *ServiceEvents_ByBlockID_Call {
	return &ServiceEvents_ByBlockID_Call{Call: _e.mock.On("ByBlockID", blockID)}
}

func (_c *ServiceEvents_ByBlockID_Call) Run(run func(blockID flow.Identifier)) *ServiceEvents_ByBlockID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ServiceEvents_ByBlockID_Call) Return(events []flow.Event, err error) *ServiceEvents_ByBlockID_Call {
	_c.Call.Return(events, err)
	return _c
}

func (_c *ServiceEvents_ByBlockID_Call) RunAndReturn(run func(blockID flow.Identifier) ([]flow.Event, error)) *ServiceEvents_ByBlockID_Call {
	_c.Call.Return(run)
	return _c
}

// NewExecutionForkEvidence creates a new instance of ExecutionForkEvidence. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewExecutionForkEvidence(t interface {
	mock.TestingT
	Cleanup(func())
}) *ExecutionForkEvidence {
	mock := &ExecutionForkEvidence{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// ExecutionForkEvidence is an autogenerated mock type for the ExecutionForkEvidence type
type ExecutionForkEvidence struct {
	mock.Mock
}

type ExecutionForkEvidence_Expecter struct {
	mock *mock.Mock
}

func (_m *ExecutionForkEvidence) EXPECT() *ExecutionForkEvidence_Expecter {
	return &ExecutionForkEvidence_Expecter{mock: &_m.Mock}
}

// Retrieve provides a mock function for the type ExecutionForkEvidence
func (_mock *ExecutionForkEvidence) Retrieve() ([]*flow.IncorporatedResultSeal, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Retrieve")
	}

	var r0 []*flow.IncorporatedResultSeal
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() ([]*flow.IncorporatedResultSeal, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() []*flow.IncorporatedResultSeal); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*flow.IncorporatedResultSeal)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ExecutionForkEvidence_Retrieve_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Retrieve'
type ExecutionForkEvidence_Retrieve_Call struct {
	*mock.Call
}

// Retrieve is a helper method to define mock.On call
func (_e *ExecutionForkEvidence_Expecter) Retrieve() *ExecutionForkEvidence_Retrieve_Call {
	return &ExecutionForkEvidence_Retrieve_Call{Call: _e.mock.On("Retrieve")}
}

func (_c *ExecutionForkEvidence_Retrieve_Call) Run(run func()) *ExecutionForkEvidence_Retrieve_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ExecutionForkEvidence_Retrieve_Call) Return(incorporatedResultSeals []*flow.IncorporatedResultSeal, err error) *ExecutionForkEvidence_Retrieve_Call {
	_c.Call.Return(incorporatedResultSeals, err)
	return _c
}

func (_c *ExecutionForkEvidence_Retrieve_Call) RunAndReturn(run func() ([]*flow.IncorporatedResultSeal, error)) *ExecutionForkEvidence_Retrieve_Call {
	_c.Call.Return(run)
	return _c
}

// StoreIfNotExists provides a mock function for the type ExecutionForkEvidence
func (_mock *ExecutionForkEvidence) StoreIfNotExists(lctx lockctx.Proof, conflictingSeals []*flow.IncorporatedResultSeal) error {
	ret := _mock.Called(lctx, conflictingSeals)

	if len(ret) == 0 {
		panic("no return value specified for StoreIfNotExists")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(lockctx.Proof, []*flow.IncorporatedResultSeal) error); ok {
		r0 = returnFunc(lctx, conflictingSeals)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ExecutionForkEvidence_StoreIfNotExists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StoreIfNotExists'
type ExecutionForkEvidence_StoreIfNotExists_Call struct {
	*mock.Call
}

// StoreIfNotExists is a helper method to define mock.On call
//   - lctx lockctx.Proof
//   - conflictingSeals []*flow.IncorporatedResultSeal
func (_e *ExecutionForkEvidence_Expecter) StoreIfNotExists(lctx interface{}, conflictingSeals interface{}) *ExecutionForkEvidence_StoreIfNotExists_Call {
	return &ExecutionForkEvidence_StoreIfNotExists_Call{Call: _e.mock.On("StoreIfNotExists", lctx, conflictingSeals)}
}

func (_c *ExecutionForkEvidence_StoreIfNotExists_Call) Run(run func(lctx lockctx.Proof, conflictingSeals []*flow.IncorporatedResultSeal)) *ExecutionForkEvidence_StoreIfNotExists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 lockctx.Proof
		if args[0] != nil {
			arg0 = args[0].(lockctx.Proof)
		}
		var arg1 []*flow.IncorporatedResultSeal
		if args[1] != nil {
			arg1 = args[1].([]*flow.IncorporatedResultSeal)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ExecutionForkEvidence_StoreIfNotExists_Call) Return(err error) *ExecutionForkEvidence_StoreIfNotExists_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ExecutionForkEvidence_StoreIfNotExists_Call) RunAndReturn(run func(lctx lockctx.Proof, conflictingSeals []*flow.IncorporatedResultSeal) error) *ExecutionForkEvidence_StoreIfNotExists_Call {
	_c.Call.Return(run)
	return _c
}

// NewGuarantees creates a new instance of Guarantees. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewGuarantees(t interface {
	mock.TestingT
	Cleanup(func())
}) *Guarantees {
	mock := &Guarantees{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Guarantees is an autogenerated mock type for the Guarantees type
type Guarantees struct {
	mock.Mock
}

type Guarantees_Expecter struct {
	mock *mock.Mock
}

func (_m *Guarantees) EXPECT() *Guarantees_Expecter {
	return &Guarantees_Expecter{mock: &_m.Mock}
}

// ByCollectionID provides a mock function for the type Guarantees
func (_mock *Guarantees) ByCollectionID(collID flow.Identifier) (*flow.CollectionGuarantee, error) {
	ret := _mock.Called(collID)

	if len(ret) == 0 {
		panic("no return value specified for ByCollectionID")
	}

	var r0 *flow.CollectionGuarantee
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (*flow.CollectionGuarantee, error)); ok {
		return returnFunc(collID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) *flow.CollectionGuarantee); ok {
		r0 = returnFunc(collID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.CollectionGuarantee)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(collID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Guarantees_ByCollectionID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByCollectionID'
type Guarantees_ByCollectionID_Call struct {
	*mock.Call
}

// ByCollectionID is a helper method to define mock.On call
//   - collID flow.Identifier
func (_e *Guarantees_Expecter) ByCollectionID(collID interface{}) *Guarantees_ByCollectionID_Call {
	return &Guarantees_ByCollectionID_Call{Call: _e.mock.On("ByCollectionID", collID)}
}

func (_c *Guarantees_ByCollectionID_Call) Run(run func(collID flow.Identifier)) *Guarantees_ByCollectionID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Guarantees_ByCollectionID_Call) Return(collectionGuarantee *flow.CollectionGuarantee, err error) *Guarantees_ByCollectionID_Call {
	_c.Call.Return(collectionGuarantee, err)
	return _c
}

func (_c *Guarantees_ByCollectionID_Call) RunAndReturn(run func(collID flow.Identifier) (*flow.CollectionGuarantee, error)) *Guarantees_ByCollectionID_Call {
	_c.Call.Return(run)
	return _c
}

// ByID provides a mock function for the type Guarantees
func (_mock *Guarantees) ByID(guaranteeID flow.Identifier) (*flow.CollectionGuarantee, error) {
	ret := _mock.Called(guaranteeID)

	if len(ret) == 0 {
		panic("no return value specified for ByID")
	}

	var r0 *flow.CollectionGuarantee
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (*flow.CollectionGuarantee, error)); ok {
		return returnFunc(guaranteeID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) *flow.CollectionGuarantee); ok {
		r0 = returnFunc(guaranteeID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.CollectionGuarantee)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(guaranteeID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Guarantees_ByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByID'
type Guarantees_ByID_Call struct {
	*mock.Call
}

// ByID is a helper method to define mock.On call
//   - guaranteeID flow.Identifier
func (_e *Guarantees_Expecter) ByID(guaranteeID interface{}) *Guarantees_ByID_Call {
	return &Guarantees_ByID_Call{Call: _e.mock.On("ByID", guaranteeID)}
}

func (_c *Guarantees_ByID_Call) Run(run func(guaranteeID flow.Identifier)) *Guarantees_ByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Guarantees_ByID_Call) Return(collectionGuarantee *flow.CollectionGuarantee, err error) *Guarantees_ByID_Call {
	_c.Call.Return(collectionGuarantee, err)
	return _c
}

func (_c *Guarantees_ByID_Call) RunAndReturn(run func(guaranteeID flow.Identifier) (*flow.CollectionGuarantee, error)) *Guarantees_ByID_Call {
	_c.Call.Return(run)
	return _c
}

// NewHeaders creates a new instance of Headers. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewHeaders(t interface {
	mock.TestingT
	Cleanup(func())
}) *Headers {
	mock := &Headers{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Headers is an autogenerated mock type for the Headers type
type Headers struct {
	mock.Mock
}

type Headers_Expecter struct {
	mock *mock.Mock
}

func (_m *Headers) EXPECT() *Headers_Expecter {
	return &Headers_Expecter{mock: &_m.Mock}
}

// BlockIDByHeight provides a mock function for the type Headers
func (_mock *Headers) BlockIDByHeight(height uint64) (flow.Identifier, error) {
	ret := _mock.Called(height)

	if len(ret) == 0 {
		panic("no return value specified for BlockIDByHeight")
	}

	var r0 flow.Identifier
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(uint64) (flow.Identifier, error)); ok {
		return returnFunc(height)
	}
	if returnFunc, ok := ret.Get(0).(func(uint64) flow.Identifier); ok {
		r0 = returnFunc(height)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.Identifier)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(uint64) error); ok {
		r1 = returnFunc(height)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Headers_BlockIDByHeight_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BlockIDByHeight'
type Headers_BlockIDByHeight_Call struct {
	*mock.Call
}

// BlockIDByHeight is a helper method to define mock.On call
//   - height uint64
func (_e *Headers_Expecter) BlockIDByHeight(height interface{}) *Headers_BlockIDByHeight_Call {
	return &Headers_BlockIDByHeight_Call{Call: _e.mock.On("BlockIDByHeight", height)}
}

func (_c *Headers_BlockIDByHeight_Call) Run(run func(height uint64)) *Headers_BlockIDByHeight_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Headers_BlockIDByHeight_Call) Return(identifier flow.Identifier, err error) *Headers_BlockIDByHeight_Call {
	_c.Call.Return(identifier, err)
	return _c
}

func (_c *Headers_BlockIDByHeight_Call) RunAndReturn(run func(height uint64) (flow.Identifier, error)) *Headers_BlockIDByHeight_Call {
	_c.Call.Return(run)
	return _c
}

// ByBlockID provides a mock function for the type Headers
func (_mock *Headers) ByBlockID(blockID flow.Identifier) (*flow.Header, error) {
	ret := _mock.Called(blockID)

	if len(ret) == 0 {
		panic("no return value specified for ByBlockID")
	}

	var r0 *flow.Header
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (*flow.Header, error)); ok {
		return returnFunc(blockID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) *flow.Header); ok {
		r0 = returnFunc(blockID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.Header)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(blockID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Headers_ByBlockID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByBlockID'
type Headers_ByBlockID_Call struct {
	*mock.Call
}

// ByBlockID is a helper method to define mock.On call
//   - blockID flow.Identifier
func (_e *Headers_Expecter) ByBlockID(blockID interface{}) *Headers_ByBlockID_Call {
	return &Headers_ByBlockID_Call{Call: _e.mock.On("ByBlockID", blockID)}
}

func (_c *Headers_ByBlockID_Call) Run(run func(blockID flow.Identifier)) *Headers_ByBlockID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Headers_ByBlockID_Call) Return(header *flow.Header, err error) *Headers_ByBlockID_Call {
	_c.Call.Return(header, err)
	return _c
}

func (_c *Headers_ByBlockID_Call) RunAndReturn(run func(blockID flow.Identifier) (*flow.Header, error)) *Headers_ByBlockID_Call {
	_c.Call.Return(run)
	return _c
}

// ByHeight provides a mock function for the type Headers
func (_mock *Headers) ByHeight(height uint64) (*flow.Header, error) {
	ret := _mock.Called(height)

	if len(ret) == 0 {
		panic("no return value specified for ByHeight")
	}

	var r0 *flow.Header
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(uint64) (*flow.Header, error)); ok {
		return returnFunc(height)
	}
	if returnFunc, ok := ret.Get(0).(func(uint64) *flow.Header); ok {
		r0 = returnFunc(height)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.Header)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(uint64) error); ok {
		r1 = returnFunc(height)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Headers_ByHeight_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByHeight'
type Headers_ByHeight_Call struct {
	*mock.Call
}

// ByHeight is a helper method to define mock.On call
//   - height uint64
func (_e *Headers_Expecter) ByHeight(height interface{}) *Headers_ByHeight_Call {
	return &Headers_ByHeight_Call{Call: _e.mock.On("ByHeight", height)}
}

func (_c *Headers_ByHeight_Call) Run(run func(height uint64)) *Headers_ByHeight_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Headers_ByHeight_Call) Return(header *flow.Header, err error) *Headers_ByHeight_Call {
	_c.Call.Return(header, err)
	return _c
}

func (_c *Headers_ByHeight_Call) RunAndReturn(run func(height uint64) (*flow.Header, error)) *Headers_ByHeight_Call {
	_c.Call.Return(run)
	return _c
}

// ByParentID provides a mock function for the type Headers
func (_mock *Headers) ByParentID(parentID flow.Identifier) ([]*flow.Header, error) {
	ret := _mock.Called(parentID)

	if len(ret) == 0 {
		panic("no return value specified for ByParentID")
	}

	var r0 []*flow.Header
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) ([]*flow.Header, error)); ok {
		return returnFunc(parentID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) []*flow.Header); ok {
		r0 = returnFunc(parentID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*flow.Header)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(parentID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Headers_ByParentID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByParentID'
type Headers_ByParentID_Call struct {
	*mock.Call
}

// ByParentID is a helper method to define mock.On call
//   - parentID flow.Identifier
func (_e *Headers_Expecter) ByParentID(parentID interface{}) *Headers_ByParentID_Call {
	return &Headers_ByParentID_Call{Call: _e.mock.On("ByParentID", parentID)}
}

func (_c *Headers_ByParentID_Call) Run(run func(parentID flow.Identifier)) *Headers_ByParentID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Headers_ByParentID_Call) Return(headers []*flow.Header, err error) *Headers_ByParentID_Call {
	_c.Call.Return(headers, err)
	return _c
}

func (_c *Headers_ByParentID_Call) RunAndReturn(run func(parentID flow.Identifier) ([]*flow.Header, error)) *Headers_ByParentID_Call {
	_c.Call.Return(run)
	return _c
}

// ByView provides a mock function for the type Headers
func (_mock *Headers) ByView(view uint64) (*flow.Header, error) {
	ret := _mock.Called(view)

	if len(ret) == 0 {
		panic("no return value specified for ByView")
	}

	var r0 *flow.Header
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(uint64) (*flow.Header, error)); ok {
		return returnFunc(view)
	}
	if returnFunc, ok := ret.Get(0).(func(uint64) *flow.Header); ok {
		r0 = returnFunc(view)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.Header)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(uint64) error); ok {
		r1 = returnFunc(view)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Headers_ByView_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByView'
type Headers_ByView_Call struct {
	*mock.Call
}

// ByView is a helper method to define mock.On call
//   - view uint64
func (_e *Headers_Expecter) ByView(view interface{}) *Headers_ByView_Call {
	return &Headers_ByView_Call{Call: _e.mock.On("ByView", view)}
}

func (_c *Headers_ByView_Call) Run(run func(view uint64)) *Headers_ByView_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Headers_ByView_Call) Return(header *flow.Header, err error) *Headers_ByView_Call {
	_c.Call.Return(header, err)
	return _c
}

func (_c *Headers_ByView_Call) RunAndReturn(run func(view uint64) (*flow.Header, error)) *Headers_ByView_Call {
	_c.Call.Return(run)
	return _c
}

// Exists provides a mock function for the type Headers
func (_mock *Headers) Exists(blockID flow.Identifier) (bool, error) {
	ret := _mock.Called(blockID)

	if len(ret) == 0 {
		panic("no return value specified for Exists")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (bool, error)); ok {
		return returnFunc(blockID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) bool); ok {
		r0 = returnFunc(blockID)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(blockID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Headers_Exists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exists'
type Headers_Exists_Call struct {
	*mock.Call
}

// Exists is a helper method to define mock.On call
//   - blockID flow.Identifier
func (_e *Headers_Expecter) Exists(blockID interface{}) *Headers_Exists_Call {
	return &Headers_Exists_Call{Call: _e.mock.On("Exists", blockID)}
}

func (_c *Headers_Exists_Call) Run(run func(blockID flow.Identifier)) *Headers_Exists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Headers_Exists_Call) Return(b bool, err error) *Headers_Exists_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *Headers_Exists_Call) RunAndReturn(run func(blockID flow.Identifier) (bool, error)) *Headers_Exists_Call {
	_c.Call.Return(run)
	return _c
}

// ProposalByBlockID provides a mock function for the type Headers
func (_mock *Headers) ProposalByBlockID(blockID flow.Identifier) (*flow.ProposalHeader, error) {
	ret := _mock.Called(blockID)

	if len(ret) == 0 {
		panic("no return value specified for ProposalByBlockID")
	}

	var r0 *flow.ProposalHeader
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (*flow.ProposalHeader, error)); ok {
		return returnFunc(blockID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) *flow.ProposalHeader); ok {
		r0 = returnFunc(blockID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.ProposalHeader)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(blockID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Headers_ProposalByBlockID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ProposalByBlockID'
type Headers_ProposalByBlockID_Call struct {
	*mock.Call
}

// ProposalByBlockID is a helper method to define mock.On call
//   - blockID flow.Identifier
func (_e *Headers_Expecter) ProposalByBlockID(blockID interface{}) *Headers_ProposalByBlockID_Call {
	return &Headers_ProposalByBlockID_Call{Call: _e.mock.On("ProposalByBlockID", blockID)}
}

func (_c *Headers_ProposalByBlockID_Call) Run(run func(blockID flow.Identifier)) *Headers_ProposalByBlockID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Headers_ProposalByBlockID_Call) Return(proposalHeader *flow.ProposalHeader, err error) *Headers_ProposalByBlockID_Call {
	_c.Call.Return(proposalHeader, err)
	return _c
}

func (_c *Headers_ProposalByBlockID_Call) RunAndReturn(run func(blockID flow.Identifier) (*flow.ProposalHeader, error)) *Headers_ProposalByBlockID_Call {
	_c.Call.Return(run)
	return _c
}

// NewHeightIndex creates a new instance of HeightIndex. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewHeightIndex(t interface {
	mock.TestingT
	Cleanup(func())
}) *HeightIndex {
	mock := &HeightIndex{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// HeightIndex is an autogenerated mock type for the HeightIndex type
type HeightIndex struct {
	mock.Mock
}

type HeightIndex_Expecter struct {
	mock *mock.Mock
}

func (_m *HeightIndex) EXPECT() *HeightIndex_Expecter {
	return &HeightIndex_Expecter{mock: &_m.Mock}
}

// FirstHeight provides a mock function for the type HeightIndex
func (_mock *HeightIndex) FirstHeight() (uint64, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for FirstHeight")
	}

	var r0 uint64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (uint64, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() uint64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint64)
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// HeightIndex_FirstHeight_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FirstHeight'
type HeightIndex_FirstHeight_Call struct {
	*mock.Call
}

// FirstHeight is a helper method to define mock.On call
func (_e *HeightIndex_Expecter) FirstHeight() *HeightIndex_FirstHeight_Call {
	return &HeightIndex_FirstHeight_Call{Call: _e.mock.On("FirstHeight")}
}

func (_c *HeightIndex_FirstHeight_Call) Run(run func()) *HeightIndex_FirstHeight_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *HeightIndex_FirstHeight_Call) Return(v uint64, err error) *HeightIndex_FirstHeight_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *HeightIndex_FirstHeight_Call) RunAndReturn(run func() (uint64, error)) *HeightIndex_FirstHeight_Call {
	_c.Call.Return(run)
	return _c
}

// LatestHeight provides a mock function for the type HeightIndex
func (_mock *HeightIndex) LatestHeight() (uint64, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for LatestHeight")
	}

	var r0 uint64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (uint64, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() uint64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint64)
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// HeightIndex_LatestHeight_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LatestHeight'
type HeightIndex_LatestHeight_Call struct {
	*mock.Call
}

// LatestHeight is a helper method to define mock.On call
func (_e *HeightIndex_Expecter) LatestHeight() *HeightIndex_LatestHeight_Call {
	return &HeightIndex_LatestHeight_Call{Call: _e.mock.On("LatestHeight")}
}

func (_c *HeightIndex_LatestHeight_Call) Run(run func()) *HeightIndex_LatestHeight_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *HeightIndex_LatestHeight_Call) Return(v uint64, err error) *HeightIndex_LatestHeight_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *HeightIndex_LatestHeight_Call) RunAndReturn(run func() (uint64, error)) *HeightIndex_LatestHeight_Call {
	_c.Call.Return(run)
	return _c
}

// SetLatestHeight provides a mock function for the type HeightIndex
func (_mock *HeightIndex) SetLatestHeight(height uint64) error {
	ret := _mock.Called(height)

	if len(ret) == 0 {
		panic("no return value specified for SetLatestHeight")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(uint64) error); ok {
		r0 = returnFunc(height)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// HeightIndex_SetLatestHeight_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetLatestHeight'
type HeightIndex_SetLatestHeight_Call struct {
	*mock.Call
}

// SetLatestHeight is a helper method to define mock.On call
//   - height uint64
func (_e *HeightIndex_Expecter) SetLatestHeight(height interface{}) *HeightIndex_SetLatestHeight_Call {
	return &HeightIndex_SetLatestHeight_Call{Call: _e.mock.On("SetLatestHeight", height)}
}

func (_c *HeightIndex_SetLatestHeight_Call) Run(run func(height uint64)) *HeightIndex_SetLatestHeight_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *HeightIndex_SetLatestHeight_Call) Return(err error) *HeightIndex_SetLatestHeight_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *HeightIndex_SetLatestHeight_Call) RunAndReturn(run func(height uint64) error) *HeightIndex_SetLatestHeight_Call {
	_c.Call.Return(run)
	return _c
}

// NewIndex creates a new instance of Index. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIndex(t interface {
	mock.TestingT
	Cleanup(func())
}) *Index {
	mock := &Index{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Index is an autogenerated mock type for the Index type
type Index struct {
	mock.Mock
}

type Index_Expecter struct {
	mock *mock.Mock
}

func (_m *Index) EXPECT() *Index_Expecter {
	return &Index_Expecter{mock: &_m.Mock}
}

// ByBlockID provides a mock function for the type Index
func (_mock *Index) ByBlockID(blockID flow.Identifier) (*flow.Index, error) {
	ret := _mock.Called(blockID)

	if len(ret) == 0 {
		panic("no return value specified for ByBlockID")
	}

	var r0 *flow.Index
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (*flow.Index, error)); ok {
		return returnFunc(blockID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) *flow.Index); ok {
		r0 = returnFunc(blockID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.Index)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(blockID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Index_ByBlockID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByBlockID'
type Index_ByBlockID_Call struct {
	*mock.Call
}

// ByBlockID is a helper method to define mock.On call
//   - blockID flow.Identifier
func (_e *Index_Expecter) ByBlockID(blockID interface{}) *Index_ByBlockID_Call {
	return &Index_ByBlockID_Call{Call: _e.mock.On("ByBlockID", blockID)}
}

func (_c *Index_ByBlockID_Call) Run(run func(blockID flow.Identifier)) *Index_ByBlockID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Index_ByBlockID_Call) Return(index *flow.Index, err error) *Index_ByBlockID_Call {
	_c.Call.Return(index, err)
	return _c
}

func (_c *Index_ByBlockID_Call) RunAndReturn(run func(blockID flow.Identifier) (*flow.Index, error)) *Index_ByBlockID_Call {
	_c.Call.Return(run)
	return _c
}

// NewLatestPersistedSealedResult creates a new instance of LatestPersistedSealedResult. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewLatestPersistedSealedResult(t interface {
	mock.TestingT
	Cleanup(func())
}) *LatestPersistedSealedResult {
	mock := &LatestPersistedSealedResult{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// LatestPersistedSealedResult is an autogenerated mock type for the LatestPersistedSealedResult type
type LatestPersistedSealedResult struct {
	mock.Mock
}

type LatestPersistedSealedResult_Expecter struct {
	mock *mock.Mock
}

func (_m *LatestPersistedSealedResult) EXPECT() *LatestPersistedSealedResult_Expecter {
	return &LatestPersistedSealedResult_Expecter{mock: &_m.Mock}
}

// BatchSet provides a mock function for the type LatestPersistedSealedResult
func (_mock *LatestPersistedSealedResult) BatchSet(resultID flow.Identifier, height uint64, batch storage.ReaderBatchWriter) error {
	ret := _mock.Called(resultID, height, batch)

	if len(ret) == 0 {
		panic("no return value specified for BatchSet")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, uint64, storage.ReaderBatchWriter) error); ok {
		r0 = returnFunc(resultID, height, batch)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// LatestPersistedSealedResult_BatchSet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BatchSet'
type LatestPersistedSealedResult_BatchSet_Call struct {
	*mock.Call
}

// BatchSet is a helper method to define mock.On call
//   - resultID flow.Identifier
//   - height uint64
//   - batch storage.ReaderBatchWriter
func (_e *LatestPersistedSealedResult_Expecter) BatchSet(resultID interface{}, height interface{}, batch interface{}) *LatestPersistedSealedResult_BatchSet_Call {
	return &LatestPersistedSealedResult_BatchSet_Call{Call: _e.mock.On("BatchSet", resultID, height, batch)}
}

func (_c *LatestPersistedSealedResult_BatchSet_Call) Run(run func(resultID flow.Identifier, height uint64, batch storage.ReaderBatchWriter)) *LatestPersistedSealedResult_BatchSet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		var arg1 uint64
		if args[1] != nil {
			arg1 = args[1].(uint64)
		}
		var arg2 storage.ReaderBatchWriter
		if args[2] != nil {
			arg2 = args[2].(storage.ReaderBatchWriter)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *LatestPersistedSealedResult_BatchSet_Call) Return(err error) *LatestPersistedSealedResult_BatchSet_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *LatestPersistedSealedResult_BatchSet_Call) RunAndReturn(run func(resultID flow.Identifier, height uint64, batch storage.ReaderBatchWriter) error) *LatestPersistedSealedResult_BatchSet_Call {
	_c.Call.Return(run)
	return _c
}

// Latest provides a mock function for the type LatestPersistedSealedResult
func (_mock *LatestPersistedSealedResult) Latest() (flow.Identifier, uint64) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Latest")
	}

	var r0 flow.Identifier
	var r1 uint64
	if returnFunc, ok := ret.Get(0).(func() (flow.Identifier, uint64)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() flow.Identifier); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.Identifier)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() uint64); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Get(1).(uint64)
	}
	return r0, r1
}

// LatestPersistedSealedResult_Latest_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Latest'
type LatestPersistedSealedResult_Latest_Call struct {
	*mock.Call
}

// Latest is a helper method to define mock.On call
func (_e *LatestPersistedSealedResult_Expecter) Latest() *LatestPersistedSealedResult_Latest_Call {
	return &LatestPersistedSealedResult_Latest_Call{Call: _e.mock.On("Latest")}
}

func (_c *LatestPersistedSealedResult_Latest_Call) Run(run func()) *LatestPersistedSealedResult_Latest_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *LatestPersistedSealedResult_Latest_Call) Return(identifier flow.Identifier, v uint64) *LatestPersistedSealedResult_Latest_Call {
	_c.Call.Return(identifier, v)
	return _c
}

func (_c *LatestPersistedSealedResult_Latest_Call) RunAndReturn(run func() (flow.Identifier, uint64)) *LatestPersistedSealedResult_Latest_Call {
	_c.Call.Return(run)
	return _c
}

// NewLedger creates a new instance of Ledger. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewLedger(t interface {
	mock.TestingT
	Cleanup(func())
}) *Ledger {
	mock := &Ledger{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Ledger is an autogenerated mock type for the Ledger type
type Ledger struct {
	mock.Mock
}

type Ledger_Expecter struct {
	mock *mock.Mock
}

func (_m *Ledger) EXPECT() *Ledger_Expecter {
	return &Ledger_Expecter{mock: &_m.Mock}
}

// EmptyStateCommitment provides a mock function for the type Ledger
func (_mock *Ledger) EmptyStateCommitment() flow.StateCommitment {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for EmptyStateCommitment")
	}

	var r0 flow.StateCommitment
	if returnFunc, ok := ret.Get(0).(func() flow.StateCommitment); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.StateCommitment)
		}
	}
	return r0
}

// Ledger_EmptyStateCommitment_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EmptyStateCommitment'
type Ledger_EmptyStateCommitment_Call struct {
	*mock.Call
}

// EmptyStateCommitment is a helper method to define mock.On call
func (_e *Ledger_Expecter) EmptyStateCommitment() *Ledger_EmptyStateCommitment_Call {
	return &Ledger_EmptyStateCommitment_Call{Call: _e.mock.On("EmptyStateCommitment")}
}

func (_c *Ledger_EmptyStateCommitment_Call) Run(run func()) *Ledger_EmptyStateCommitment_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Ledger_EmptyStateCommitment_Call) Return(stateCommitment flow.StateCommitment) *Ledger_EmptyStateCommitment_Call {
	_c.Call.Return(stateCommitment)
	return _c
}

func (_c *Ledger_EmptyStateCommitment_Call) RunAndReturn(run func() flow.StateCommitment) *Ledger_EmptyStateCommitment_Call {
	_c.Call.Return(run)
	return _c
}

// GetRegisters provides a mock function for the type Ledger
func (_mock *Ledger) GetRegisters(registerIDs []flow.RegisterID, stateCommitment flow.StateCommitment) ([]flow.RegisterValue, error) {
	ret := _mock.Called(registerIDs, stateCommitment)

	if len(ret) == 0 {
		panic("no return value specified for GetRegisters")
	}

	var r0 []flow.RegisterValue
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]flow.RegisterID, flow.StateCommitment) ([]flow.RegisterValue, error)); ok {
		return returnFunc(registerIDs, stateCommitment)
	}
	if returnFunc, ok := ret.Get(0).(func([]flow.RegisterID, flow.StateCommitment) []flow.RegisterValue); ok {
		r0 = returnFunc(registerIDs, stateCommitment)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]flow.RegisterValue)
		}
	}
	if returnFunc, ok := ret.Get(1).(func([]flow.RegisterID, flow.StateCommitment) error); ok {
		r1 = returnFunc(registerIDs, stateCommitment)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Ledger_GetRegisters_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRegisters'
type Ledger_GetRegisters_Call struct {
	*mock.Call
}

// GetRegisters is a helper method to define mock.On call
//   - registerIDs []flow.RegisterID
//   - stateCommitment flow.StateCommitment
func (_e *Ledger_Expecter) GetRegisters(registerIDs interface{}, stateCommitment interface{}) *Ledger_GetRegisters_Call {
	return &Ledger_GetRegisters_Call{Call: _e.mock.On("GetRegisters", registerIDs, stateCommitment)}
}

func (_c *Ledger_GetRegisters_Call) Run(run func(registerIDs []flow.RegisterID, stateCommitment flow.StateCommitment)) *Ledger_GetRegisters_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []flow.RegisterID
		if args[0] != nil {
			arg0 = args[0].([]flow.RegisterID)
		}
		var arg1 flow.StateCommitment
		if args[1] != nil {
			arg1 = args[1].(flow.StateCommitment)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Ledger_GetRegisters_Call) Return(values []flow.RegisterValue, err error) *Ledger_GetRegisters_Call {
	_c.Call.Return(values, err)
	return _c
}

func (_c *Ledger_GetRegisters_Call) RunAndReturn(run func(registerIDs []flow.RegisterID, stateCommitment flow.StateCommitment) ([]flow.RegisterValue, error)) *Ledger_GetRegisters_Call {
	_c.Call.Return(run)
	return _c
}

// GetRegistersWithProof provides a mock function for the type Ledger
func (_mock *Ledger) GetRegistersWithProof(registerIDs []flow.RegisterID, stateCommitment flow.StateCommitment) ([]flow.RegisterValue, []flow.StorageProof, error) {
	ret := _mock.Called(registerIDs, stateCommitment)

	if len(ret) == 0 {
		panic("no return value specified for GetRegistersWithProof")
	}

	var r0 []flow.RegisterValue
	var r1 []flow.StorageProof
	var r2 error
	if returnFunc, ok := ret.Get(0).(func([]flow.RegisterID, flow.StateCommitment) ([]flow.RegisterValue, []flow.StorageProof, error)); ok {
		return returnFunc(registerIDs, stateCommitment)
	}
	if returnFunc, ok := ret.Get(0).(func([]flow.RegisterID, flow.StateCommitment) []flow.RegisterValue); ok {
		r0 = returnFunc(registerIDs, stateCommitment)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]flow.RegisterValue)
		}
	}
	if returnFunc, ok := ret.Get(1).(func([]flow.RegisterID, flow.StateCommitment) []flow.StorageProof); ok {
		r1 = returnFunc(registerIDs, stateCommitment)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]flow.StorageProof)
		}
	}
	if returnFunc, ok := ret.Get(2).(func([]flow.RegisterID, flow.StateCommitment) error); ok {
		r2 = returnFunc(registerIDs, stateCommitment)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// Ledger_GetRegistersWithProof_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRegistersWithProof'
type Ledger_GetRegistersWithProof_Call struct {
	*mock.Call
}

// GetRegistersWithProof is a helper method to define mock.On call
//   - registerIDs []flow.RegisterID
//   - stateCommitment flow.StateCommitment
func (_e *Ledger_Expecter) GetRegistersWithProof(registerIDs interface{}, stateCommitment interface{}) *Ledger_GetRegistersWithProof_Call {
	return &Ledger_GetRegistersWithProof_Call{Call: _e.mock.On("GetRegistersWithProof", registerIDs, stateCommitment)}
}

func (_c *Ledger_GetRegistersWithProof_Call) Run(run func(registerIDs []flow.RegisterID, stateCommitment flow.StateCommitment)) *Ledger_GetRegistersWithProof_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []flow.RegisterID
		if args[0] != nil {
			arg0 = args[0].([]flow.RegisterID)
		}
		var arg1 flow.StateCommitment
		if args[1] != nil {
			arg1 = args[1].(flow.StateCommitment)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Ledger_GetRegistersWithProof_Call) Return(values []flow.RegisterValue, proofs []flow.StorageProof, err error) *Ledger_GetRegistersWithProof_Call {
	_c.Call.Return(values, proofs, err)
	return _c
}

func (_c *Ledger_GetRegistersWithProof_Call) RunAndReturn(run func(registerIDs []flow.RegisterID, stateCommitment flow.StateCommitment) ([]flow.RegisterValue, []flow.StorageProof, error)) *Ledger_GetRegistersWithProof_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateRegisters provides a mock function for the type Ledger
func (_mock *Ledger) UpdateRegisters(registerIDs []flow.RegisterID, values []flow.RegisterValue, stateCommitment flow.StateCommitment) (flow.StateCommitment, error) {
	ret := _mock.Called(registerIDs, values, stateCommitment)

	if len(ret) == 0 {
		panic("no return value specified for UpdateRegisters")
	}

	var r0 flow.StateCommitment
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]flow.RegisterID, []flow.RegisterValue, flow.StateCommitment) (flow.StateCommitment, error)); ok {
		return returnFunc(registerIDs, values, stateCommitment)
	}
	if returnFunc, ok := ret.Get(0).(func([]flow.RegisterID, []flow.RegisterValue, flow.StateCommitment) flow.StateCommitment); ok {
		r0 = returnFunc(registerIDs, values, stateCommitment)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.StateCommitment)
		}
	}
	if returnFunc, ok := ret.Get(1).(func([]flow.RegisterID, []flow.RegisterValue, flow.StateCommitment) error); ok {
		r1 = returnFunc(registerIDs, values, stateCommitment)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Ledger_UpdateRegisters_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateRegisters'
type Ledger_UpdateRegisters_Call struct {
	*mock.Call
}

// UpdateRegisters is a helper method to define mock.On call
//   - registerIDs []flow.RegisterID
//   - values []flow.RegisterValue
//   - stateCommitment flow.StateCommitment
func (_e *Ledger_Expecter) UpdateRegisters(registerIDs interface{}, values interface{}, stateCommitment interface{}) *Ledger_UpdateRegisters_Call {
	return &Ledger_UpdateRegisters_Call{Call: _e.mock.On("UpdateRegisters", registerIDs, values, stateCommitment)}
}

func (_c *Ledger_UpdateRegisters_Call) Run(run func(registerIDs []flow.RegisterID, values []flow.RegisterValue, stateCommitment flow.StateCommitment)) *Ledger_UpdateRegisters_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []flow.RegisterID
		if args[0] != nil {
			arg0 = args[0].([]flow.RegisterID)
		}
		var arg1 []flow.RegisterValue
		if args[1] != nil {
			arg1 = args[1].([]flow.RegisterValue)
		}
		var arg2 flow.StateCommitment
		if args[2] != nil {
			arg2 = args[2].(flow.StateCommitment)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Ledger_UpdateRegisters_Call) Return(newStateCommitment flow.StateCommitment, err error) *Ledger_UpdateRegisters_Call {
	_c.Call.Return(newStateCommitment, err)
	return _c
}

func (_c *Ledger_UpdateRegisters_Call) RunAndReturn(run func(registerIDs []flow.RegisterID, values []flow.RegisterValue, stateCommitment flow.StateCommitment) (flow.StateCommitment, error)) *Ledger_UpdateRegisters_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateRegistersWithProof provides a mock function for the type Ledger
func (_mock *Ledger) UpdateRegistersWithProof(registerIDs []flow.RegisterID, values []flow.RegisterValue, stateCommitment flow.StateCommitment) (flow.StateCommitment, []flow.StorageProof, error) {
	ret := _mock.Called(registerIDs, values, stateCommitment)

	if len(ret) == 0 {
		panic("no return value specified for UpdateRegistersWithProof")
	}

	var r0 flow.StateCommitment
	var r1 []flow.StorageProof
	var r2 error
	if returnFunc, ok := ret.Get(0).(func([]flow.RegisterID, []flow.RegisterValue, flow.StateCommitment) (flow.StateCommitment, []flow.StorageProof, error)); ok {
		return returnFunc(registerIDs, values, stateCommitment)
	}
	if returnFunc, ok := ret.Get(0).(func([]flow.RegisterID, []flow.RegisterValue, flow.StateCommitment) flow.StateCommitment); ok {
		r0 = returnFunc(registerIDs, values, stateCommitment)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.StateCommitment)
		}
	}
	if returnFunc, ok := ret.Get(1).(func([]flow.RegisterID, []flow.RegisterValue, flow.StateCommitment) []flow.StorageProof); ok {
		r1 = returnFunc(registerIDs, values, stateCommitment)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]flow.StorageProof)
		}
	}
	if returnFunc, ok := ret.Get(2).(func([]flow.RegisterID, []flow.RegisterValue, flow.StateCommitment) error); ok {
		r2 = returnFunc(registerIDs, values, stateCommitment)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// Ledger_UpdateRegistersWithProof_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateRegistersWithProof'
type Ledger_UpdateRegistersWithProof_Call struct {
	*mock.Call
}

// UpdateRegistersWithProof is a helper method to define mock.On call
//   - registerIDs []flow.RegisterID
//   - values []flow.RegisterValue
//   - stateCommitment flow.StateCommitment
func (_e *Ledger_Expecter) UpdateRegistersWithProof(registerIDs interface{}, values interface{}, stateCommitment interface{}) *Ledger_UpdateRegistersWithProof_Call {
	return &Ledger_UpdateRegistersWithProof_Call{Call: _e.mock.On("UpdateRegistersWithProof", registerIDs, values, stateCommitment)}
}

func (_c *Ledger_UpdateRegistersWithProof_Call) Run(run func(registerIDs []flow.RegisterID, values []flow.RegisterValue, stateCommitment flow.StateCommitment)) *Ledger_UpdateRegistersWithProof_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []flow.RegisterID
		if args[0] != nil {
			arg0 = args[0].([]flow.RegisterID)
		}
		var arg1 []flow.RegisterValue
		if args[1] != nil {
			arg1 = args[1].([]flow.RegisterValue)
		}
		var arg2 flow.StateCommitment
		if args[2] != nil {
			arg2 = args[2].(flow.StateCommitment)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Ledger_UpdateRegistersWithProof_Call) Return(newStateCommitment flow.StateCommitment, proofs []flow.StorageProof, err error) *Ledger_UpdateRegistersWithProof_Call {
	_c.Call.Return(newStateCommitment, proofs, err)
	return _c
}

func (_c *Ledger_UpdateRegistersWithProof_Call) RunAndReturn(run func(registerIDs []flow.RegisterID, values []flow.RegisterValue, stateCommitment flow.StateCommitment) (flow.StateCommitment, []flow.StorageProof, error)) *Ledger_UpdateRegistersWithProof_Call {
	_c.Call.Return(run)
	return _c
}

// NewLedgerVerifier creates a new instance of LedgerVerifier. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewLedgerVerifier(t interface {
	mock.TestingT
	Cleanup(func())
}) *LedgerVerifier {
	mock := &LedgerVerifier{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// LedgerVerifier is an autogenerated mock type for the LedgerVerifier type
type LedgerVerifier struct {
	mock.Mock
}

type LedgerVerifier_Expecter struct {
	mock *mock.Mock
}

func (_m *LedgerVerifier) EXPECT() *LedgerVerifier_Expecter {
	return &LedgerVerifier_Expecter{mock: &_m.Mock}
}

// VerifyRegistersProof provides a mock function for the type LedgerVerifier
func (_mock *LedgerVerifier) VerifyRegistersProof(registerIDs []flow.RegisterID, stateCommitment flow.StateCommitment, values []flow.RegisterValue, proof []flow.StorageProof) (bool, error) {
	ret := _mock.Called(registerIDs, stateCommitment, values, proof)

	if len(ret) == 0 {
		panic("no return value specified for VerifyRegistersProof")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]flow.RegisterID, flow.StateCommitment, []flow.RegisterValue, []flow.StorageProof) (bool, error)); ok {
		return returnFunc(registerIDs, stateCommitment, values, proof)
	}
	if returnFunc, ok := ret.Get(0).(func([]flow.RegisterID, flow.StateCommitment, []flow.RegisterValue, []flow.StorageProof) bool); ok {
		r0 = returnFunc(registerIDs, stateCommitment, values, proof)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func([]flow.RegisterID, flow.StateCommitment, []flow.RegisterValue, []flow.StorageProof) error); ok {
		r1 = returnFunc(registerIDs, stateCommitment, values, proof)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// LedgerVerifier_VerifyRegistersProof_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'VerifyRegistersProof'
type LedgerVerifier_VerifyRegistersProof_Call struct {
	*mock.Call
}

// VerifyRegistersProof is a helper method to define mock.On call
//   - registerIDs []flow.RegisterID
//   - stateCommitment flow.StateCommitment
//   - values []flow.RegisterValue
//   - proof []flow.StorageProof
func (_e *LedgerVerifier_Expecter) VerifyRegistersProof(registerIDs interface{}, stateCommitment interface{}, values interface{}, proof interface{}) *LedgerVerifier_VerifyRegistersProof_Call {
	return &LedgerVerifier_VerifyRegistersProof_Call{Call: _e.mock.On("VerifyRegistersProof", registerIDs, stateCommitment, values, proof)}
}

func (_c *LedgerVerifier_VerifyRegistersProof_Call) Run(run func(registerIDs []flow.RegisterID, stateCommitment flow.StateCommitment, values []flow.RegisterValue, proof []flow.StorageProof)) *LedgerVerifier_VerifyRegistersProof_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []flow.RegisterID
		if args[0] != nil {
			arg0 = args[0].([]flow.RegisterID)
		}
		var arg1 flow.StateCommitment
		if args[1] != nil {
			arg1 = args[1].(flow.StateCommitment)
		}
		var arg2 []flow.RegisterValue
		if args[2] != nil {
			arg2 = args[2].([]flow.RegisterValue)
		}
		var arg3 []flow.StorageProof
		if args[3] != nil {
			arg3 = args[3].([]flow.StorageProof)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *LedgerVerifier_VerifyRegistersProof_Call) Return(verified bool, err error) *LedgerVerifier_VerifyRegistersProof_Call {
	_c.Call.Return(verified, err)
	return _c
}

func (_c *LedgerVerifier_VerifyRegistersProof_Call) RunAndReturn(run func(registerIDs []flow.RegisterID, stateCommitment flow.StateCommitment, values []flow.RegisterValue, proof []flow.StorageProof) (bool, error)) *LedgerVerifier_VerifyRegistersProof_Call {
	_c.Call.Return(run)
	return _c
}

// NewLightTransactionResultsReader creates a new instance of LightTransactionResultsReader. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewLightTransactionResultsReader(t interface {
	mock.TestingT
	Cleanup(func())
}) *LightTransactionResultsReader {
	mock := &LightTransactionResultsReader{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// LightTransactionResultsReader is an autogenerated mock type for the LightTransactionResultsReader type
type LightTransactionResultsReader struct {
	mock.Mock
}

type LightTransactionResultsReader_Expecter struct {
	mock *mock.Mock
}

func (_m *LightTransactionResultsReader) EXPECT() *LightTransactionResultsReader_Expecter {
	return &LightTransactionResultsReader_Expecter{mock: &_m.Mock}
}

// ByBlockID provides a mock function for the type LightTransactionResultsReader
func (_mock *LightTransactionResultsReader) ByBlockID(id flow.Identifier) ([]flow.LightTransactionResult, error) {
	ret := _mock.Called(id)

	if len(ret) == 0 {
		panic("no return value specified for ByBlockID")
	}

	var r0 []flow.LightTransactionResult
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) ([]flow.LightTransactionResult, error)); ok {
		return returnFunc(id)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) []flow.LightTransactionResult); ok {
		r0 = returnFunc(id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]flow.LightTransactionResult)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// LightTransactionResultsReader_ByBlockID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByBlockID'
type LightTransactionResultsReader_ByBlockID_Call struct {
	*mock.Call
}

// ByBlockID is a helper method to define mock.On call
//   - id flow.Identifier
func (_e *LightTransactionResultsReader_Expecter) ByBlockID(id interface{}) *LightTransactionResultsReader_ByBlockID_Call {
	return &LightTransactionResultsReader_ByBlockID_Call{Call: _e.mock.On("ByBlockID", id)}
}

func (_c *LightTransactionResultsReader_ByBlockID_Call) Run(run func(id flow.Identifier)) *LightTransactionResultsReader_ByBlockID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *LightTransactionResultsReader_ByBlockID_Call) Return(lightTransactionResults []flow.LightTransactionResult, err error) *LightTransactionResultsReader_ByBlockID_Call {
	_c.Call.Return(lightTransactionResults, err)
	return _c
}

func (_c *LightTransactionResultsReader_ByBlockID_Call) RunAndReturn(run func(id flow.Identifier) ([]flow.LightTransactionResult, error)) *LightTransactionResultsReader_ByBlockID_Call {
	_c.Call.Return(run)
	return _c
}

// ByBlockIDTransactionID provides a mock function for the type LightTransactionResultsReader
func (_mock *LightTransactionResultsReader) ByBlockIDTransactionID(blockID flow.Identifier, transactionID flow.Identifier) (*flow.LightTransactionResult, error) {
	ret := _mock.Called(blockID, transactionID)

	if len(ret) == 0 {
		panic("no return value specified for ByBlockIDTransactionID")
	}

	var r0 *flow.LightTransactionResult
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, flow.Identifier) (*flow.LightTransactionResult, error)); ok {
		return returnFunc(blockID, transactionID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, flow.Identifier) *flow.LightTransactionResult); ok {
		r0 = returnFunc(blockID, transactionID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.LightTransactionResult)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier, flow.Identifier) error); ok {
		r1 = returnFunc(blockID, transactionID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// LightTransactionResultsReader_ByBlockIDTransactionID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByBlockIDTransactionID'
type LightTransactionResultsReader_ByBlockIDTransactionID_Call struct {
	*mock.Call
}

// ByBlockIDTransactionID is a helper method to define mock.On call
//   - blockID flow.Identifier
//   - transactionID flow.Identifier
func (_e *LightTransactionResultsReader_Expecter) ByBlockIDTransactionID(blockID interface{}, transactionID interface{}) *LightTransactionResultsReader_ByBlockIDTransactionID_Call {
	return &LightTransactionResultsReader_ByBlockIDTransactionID_Call{Call: _e.mock.On("ByBlockIDTransactionID", blockID, transactionID)}
}

func (_c *LightTransactionResultsReader_ByBlockIDTransactionID_Call) Run(run func(blockID flow.Identifier, transactionID flow.Identifier)) *LightTransactionResultsReader_ByBlockIDTransactionID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		var arg1 flow.Identifier
		if args[1] != nil {
			arg1 = args[1].(flow.Identifier)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *LightTransactionResultsReader_ByBlockIDTransactionID_Call) Return(lightTransactionResult *flow.LightTransactionResult, err error) *LightTransactionResultsReader_ByBlockIDTransactionID_Call {
	_c.Call.Return(lightTransactionResult, err)
	return _c
}

func (_c *LightTransactionResultsReader_ByBlockIDTransactionID_Call) RunAndReturn(run func(blockID flow.Identifier, transactionID flow.Identifier) (*flow.LightTransactionResult, error)) *LightTransactionResultsReader_ByBlockIDTransactionID_Call {
	_c.Call.Return(run)
	return _c
}

// ByBlockIDTransactionIndex provides a mock function for the type LightTransactionResultsReader
func (_mock *LightTransactionResultsReader) ByBlockIDTransactionIndex(blockID flow.Identifier, txIndex uint32) (*flow.LightTransactionResult, error) {
	ret := _mock.Called(blockID, txIndex)

	if len(ret) == 0 {
		panic("no return value specified for ByBlockIDTransactionIndex")
	}

	var r0 *flow.LightTransactionResult
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, uint32) (*flow.LightTransactionResult, error)); ok {
		return returnFunc(blockID, txIndex)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, uint32) *flow.LightTransactionResult); ok {
		r0 = returnFunc(blockID, txIndex)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.LightTransactionResult)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier, uint32) error); ok {
		r1 = returnFunc(blockID, txIndex)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// LightTransactionResultsReader_ByBlockIDTransactionIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByBlockIDTransactionIndex'
type LightTransactionResultsReader_ByBlockIDTransactionIndex_Call struct {
	*mock.Call
}

// ByBlockIDTransactionIndex is a helper method to define mock.On call
//   - blockID flow.Identifier
//   - txIndex uint32
func (_e *LightTransactionResultsReader_Expecter) ByBlockIDTransactionIndex(blockID interface{}, txIndex interface{}) *LightTransactionResultsReader_ByBlockIDTransactionIndex_Call {
	return &LightTransactionResultsReader_ByBlockIDTransactionIndex_Call{Call: _e.mock.On("ByBlockIDTransactionIndex", blockID, txIndex)}
}

func (_c *LightTransactionResultsReader_ByBlockIDTransactionIndex_Call) Run(run func(blockID flow.Identifier, txIndex uint32)) *LightTransactionResultsReader_ByBlockIDTransactionIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		var arg1 uint32
		if args[1] != nil {
			arg1 = args[1].(uint32)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *LightTransactionResultsReader_ByBlockIDTransactionIndex_Call) Return(lightTransactionResult *flow.LightTransactionResult, err error) *LightTransactionResultsReader_ByBlockIDTransactionIndex_Call {
	_c.Call.Return(lightTransactionResult, err)
	return _c
}

func (_c *LightTransactionResultsReader_ByBlockIDTransactionIndex_Call) RunAndReturn(run func(blockID flow.Identifier, txIndex uint32) (*flow.LightTransactionResult, error)) *LightTransactionResultsReader_ByBlockIDTransactionIndex_Call {
	_c.Call.Return(run)
	return _c
}

// NewLightTransactionResults creates a new instance of LightTransactionResults. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewLightTransactionResults(t interface {
	mock.TestingT
	Cleanup(func())
}) *LightTransactionResults {
	mock := &LightTransactionResults{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// LightTransactionResults is an autogenerated mock type for the LightTransactionResults type
type LightTransactionResults struct {
	mock.Mock
}

type LightTransactionResults_Expecter struct {
	mock *mock.Mock
}

func (_m *LightTransactionResults) EXPECT() *LightTransactionResults_Expecter {
	return &LightTransactionResults_Expecter{mock: &_m.Mock}
}

// BatchStore provides a mock function for the type LightTransactionResults
func (_mock *LightTransactionResults) BatchStore(lctx lockctx.Proof, rw storage.ReaderBatchWriter, blockID flow.Identifier, transactionResults []flow.LightTransactionResult) error {
	ret := _mock.Called(lctx, rw, blockID, transactionResults)

	if len(ret) == 0 {
		panic("no return value specified for BatchStore")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(lockctx.Proof, storage.ReaderBatchWriter, flow.Identifier, []flow.LightTransactionResult) error); ok {
		r0 = returnFunc(lctx, rw, blockID, transactionResults)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// LightTransactionResults_BatchStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BatchStore'
type LightTransactionResults_BatchStore_Call struct {
	*mock.Call
}

// BatchStore is a helper method to define mock.On call
//   - lctx lockctx.Proof
//   - rw storage.ReaderBatchWriter
//   - blockID flow.Identifier
//   - transactionResults []flow.LightTransactionResult
func (_e *LightTransactionResults_Expecter) BatchStore(lctx interface{}, rw interface{}, blockID interface{}, transactionResults interface{}) *LightTransactionResults_BatchStore_Call {
	return &LightTransactionResults_BatchStore_Call{Call: _e.mock.On("BatchStore", lctx, rw, blockID, transactionResults)}
}

func (_c *LightTransactionResults_BatchStore_Call) Run(run func(lctx lockctx.Proof, rw storage.ReaderBatchWriter, blockID flow.Identifier, transactionResults []flow.LightTransactionResult)) *LightTransactionResults_BatchStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 lockctx.Proof
		if args[0] != nil {
			arg0 = args[0].(lockctx.Proof)
		}
		var arg1 storage.ReaderBatchWriter
		if args[1] != nil {
			arg1 = args[1].(storage.ReaderBatchWriter)
		}
		var arg2 flow.Identifier
		if args[2] != nil {
			arg2 = args[2].(flow.Identifier)
		}
		var arg3 []flow.LightTransactionResult
		if args[3] != nil {
			arg3 = args[3].([]flow.LightTransactionResult)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *LightTransactionResults_BatchStore_Call) Return(err error) *LightTransactionResults_BatchStore_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *LightTransactionResults_BatchStore_Call) RunAndReturn(run func(lctx lockctx.Proof, rw storage.ReaderBatchWriter, blockID flow.Identifier, transactionResults []flow.LightTransactionResult) error) *LightTransactionResults_BatchStore_Call {
	_c.Call.Return(run)
	return _c
}

// ByBlockID provides a mock function for the type LightTransactionResults
func (_mock *LightTransactionResults) ByBlockID(id flow.Identifier) ([]flow.LightTransactionResult, error) {
	ret := _mock.Called(id)

	if len(ret) == 0 {
		panic("no return value specified for ByBlockID")
	}

	var r0 []flow.LightTransactionResult
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) ([]flow.LightTransactionResult, error)); ok {
		return returnFunc(id)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) []flow.LightTransactionResult); ok {
		r0 = returnFunc(id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]flow.LightTransactionResult)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// LightTransactionResults_ByBlockID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByBlockID'
type LightTransactionResults_ByBlockID_Call struct {
	*mock.Call
}

// ByBlockID is a helper method to define mock.On call
//   - id flow.Identifier
func (_e *LightTransactionResults_Expecter) ByBlockID(id interface{}) *LightTransactionResults_ByBlockID_Call {
	return &LightTransactionResults_ByBlockID_Call{Call: _e.mock.On("ByBlockID", id)}
}

func (_c *LightTransactionResults_ByBlockID_Call) Run(run func(id flow.Identifier)) *LightTransactionResults_ByBlockID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *LightTransactionResults_ByBlockID_Call) Return(lightTransactionResults []flow.LightTransactionResult, err error) *LightTransactionResults_ByBlockID_Call {
	_c.Call.Return(lightTransactionResults, err)
	return _c
}

func (_c *LightTransactionResults_ByBlockID_Call) RunAndReturn(run func(id flow.Identifier) ([]flow.LightTransactionResult, error)) *LightTransactionResults_ByBlockID_Call {
	_c.Call.Return(run)
	return _c
}

// ByBlockIDTransactionID provides a mock function for the type LightTransactionResults
func (_mock *LightTransactionResults) ByBlockIDTransactionID(blockID flow.Identifier, transactionID flow.Identifier) (*flow.LightTransactionResult, error) {
	ret := _mock.Called(blockID, transactionID)

	if len(ret) == 0 {
		panic("no return value specified for ByBlockIDTransactionID")
	}

	var r0 *flow.LightTransactionResult
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, flow.Identifier) (*flow.LightTransactionResult, error)); ok {
		return returnFunc(blockID, transactionID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, flow.Identifier) *flow.LightTransactionResult); ok {
		r0 = returnFunc(blockID, transactionID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.LightTransactionResult)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier, flow.Identifier) error); ok {
		r1 = returnFunc(blockID, transactionID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// LightTransactionResults_ByBlockIDTransactionID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByBlockIDTransactionID'
type LightTransactionResults_ByBlockIDTransactionID_Call struct {
	*mock.Call
}

// ByBlockIDTransactionID is a helper method to define mock.On call
//   - blockID flow.Identifier
//   - transactionID flow.Identifier
func (_e *LightTransactionResults_Expecter) ByBlockIDTransactionID(blockID interface{}, transactionID interface{}) *LightTransactionResults_ByBlockIDTransactionID_Call {
	return &LightTransactionResults_ByBlockIDTransactionID_Call{Call: _e.mock.On("ByBlockIDTransactionID", blockID, transactionID)}
}

func (_c *LightTransactionResults_ByBlockIDTransactionID_Call) Run(run func(blockID flow.Identifier, transactionID flow.Identifier)) *LightTransactionResults_ByBlockIDTransactionID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		var arg1 flow.Identifier
		if args[1] != nil {
			arg1 = args[1].(flow.Identifier)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *LightTransactionResults_ByBlockIDTransactionID_Call) Return(lightTransactionResult *flow.LightTransactionResult, err error) *LightTransactionResults_ByBlockIDTransactionID_Call {
	_c.Call.Return(lightTransactionResult, err)
	return _c
}

func (_c *LightTransactionResults_ByBlockIDTransactionID_Call) RunAndReturn(run func(blockID flow.Identifier, transactionID flow.Identifier) (*flow.LightTransactionResult, error)) *LightTransactionResults_ByBlockIDTransactionID_Call {
	_c.Call.Return(run)
	return _c
}

// ByBlockIDTransactionIndex provides a mock function for the type LightTransactionResults
func (_mock *LightTransactionResults) ByBlockIDTransactionIndex(blockID flow.Identifier, txIndex uint32) (*flow.LightTransactionResult, error) {
	ret := _mock.Called(blockID, txIndex)

	if len(ret) == 0 {
		panic("no return value specified for ByBlockIDTransactionIndex")
	}

	var r0 *flow.LightTransactionResult
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, uint32) (*flow.LightTransactionResult, error)); ok {
		return returnFunc(blockID, txIndex)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, uint32) *flow.LightTransactionResult); ok {
		r0 = returnFunc(blockID, txIndex)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.LightTransactionResult)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier, uint32) error); ok {
		r1 = returnFunc(blockID, txIndex)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// LightTransactionResults_ByBlockIDTransactionIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByBlockIDTransactionIndex'
type LightTransactionResults_ByBlockIDTransactionIndex_Call struct {
	*mock.Call
}

// ByBlockIDTransactionIndex is a helper method to define mock.On call
//   - blockID flow.Identifier
//   - txIndex uint32
func (_e *LightTransactionResults_Expecter) ByBlockIDTransactionIndex(blockID interface{}, txIndex interface{}) *LightTransactionResults_ByBlockIDTransactionIndex_Call {
	return &LightTransactionResults_ByBlockIDTransactionIndex_Call{Call: _e.mock.On("ByBlockIDTransactionIndex", blockID, txIndex)}
}

func (_c *LightTransactionResults_ByBlockIDTransactionIndex_Call) Run(run func(blockID flow.Identifier, txIndex uint32)) *LightTransactionResults_ByBlockIDTransactionIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		var arg1 uint32
		if args[1] != nil {
			arg1 = args[1].(uint32)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *LightTransactionResults_ByBlockIDTransactionIndex_Call) Return(lightTransactionResult *flow.LightTransactionResult, err error) *LightTransactionResults_ByBlockIDTransactionIndex_Call {
	_c.Call.Return(lightTransactionResult, err)
	return _c
}

func (_c *LightTransactionResults_ByBlockIDTransactionIndex_Call) RunAndReturn(run func(blockID flow.Identifier, txIndex uint32) (*flow.LightTransactionResult, error)) *LightTransactionResults_ByBlockIDTransactionIndex_Call {
	_c.Call.Return(run)
	return _c
}

// NewLockManager creates a new instance of LockManager. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewLockManager(t interface {
	mock.TestingT
	Cleanup(func())
}) *LockManager {
	mock := &LockManager{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// LockManager is an autogenerated mock type for the LockManager type
type LockManager struct {
	mock.Mock
}

type LockManager_Expecter struct {
	mock *mock.Mock
}

func (_m *LockManager) EXPECT() *LockManager_Expecter {
	return &LockManager_Expecter{mock: &_m.Mock}
}

// NewContext provides a mock function for the type LockManager
func (_mock *LockManager) NewContext() lockctx.Context {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for NewContext")
	}

	var r0 lockctx.Context
	if returnFunc, ok := ret.Get(0).(func() lockctx.Context); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(lockctx.Context)
		}
	}
	return r0
}

// LockManager_NewContext_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NewContext'
type LockManager_NewContext_Call struct {
	*mock.Call
}

// NewContext is a helper method to define mock.On call
func (_e *LockManager_Expecter) NewContext() *LockManager_NewContext_Call {
	return &LockManager_NewContext_Call{Call: _e.mock.On("NewContext")}
}

func (_c *LockManager_NewContext_Call) Run(run func()) *LockManager_NewContext_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *LockManager_NewContext_Call) Return(context lockctx.Context) *LockManager_NewContext_Call {
	_c.Call.Return(context)
	return _c
}

func (_c *LockManager_NewContext_Call) RunAndReturn(run func() lockctx.Context) *LockManager_NewContext_Call {
	_c.Call.Return(run)
	return _c
}

// NewNodeDisallowList creates a new instance of NodeDisallowList. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewNodeDisallowList(t interface {
	mock.TestingT
	Cleanup(func())
}) *NodeDisallowList {
	mock := &NodeDisallowList{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// NodeDisallowList is an autogenerated mock type for the NodeDisallowList type
type NodeDisallowList struct {
	mock.Mock
}

type NodeDisallowList_Expecter struct {
	mock *mock.Mock
}

func (_m *NodeDisallowList) EXPECT() *NodeDisallowList_Expecter {
	return &NodeDisallowList_Expecter{mock: &_m.Mock}
}

// Retrieve provides a mock function for the type NodeDisallowList
func (_mock *NodeDisallowList) Retrieve(disallowList *map[flow.Identifier]struct{}) error {
	ret := _mock.Called(disallowList)

	if len(ret) == 0 {
		panic("no return value specified for Retrieve")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*map[flow.Identifier]struct{}) error); ok {
		r0 = returnFunc(disallowList)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// NodeDisallowList_Retrieve_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Retrieve'
type NodeDisallowList_Retrieve_Call struct {
	*mock.Call
}

// Retrieve is a helper method to define mock.On call
//   - disallowList *map[flow.Identifier]struct{}
func (_e *NodeDisallowList_Expecter) Retrieve(disallowList interface{}) *NodeDisallowList_Retrieve_Call {
	return &NodeDisallowList_Retrieve_Call{Call: _e.mock.On("Retrieve", disallowList)}
}

func (_c *NodeDisallowList_Retrieve_Call) Run(run func(disallowList *map[flow.Identifier]struct{})) *NodeDisallowList_Retrieve_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *map[flow.Identifier]struct{}
		if args[0] != nil {
			arg0 = args[0].(*map[flow.Identifier]struct{})
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *NodeDisallowList_Retrieve_Call) Return(err error) *NodeDisallowList_Retrieve_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *NodeDisallowList_Retrieve_Call) RunAndReturn(run func(disallowList *map[flow.Identifier]struct{}) error) *NodeDisallowList_Retrieve_Call {
	_c.Call.Return(run)
	return _c
}

// Store provides a mock function for the type NodeDisallowList
func (_mock *NodeDisallowList) Store(disallowList map[flow.Identifier]struct{}) error {
	ret := _mock.Called(disallowList)

	if len(ret) == 0 {
		panic("no return value specified for Store")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(map[flow.Identifier]struct{}) error); ok {
		r0 = returnFunc(disallowList)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// NodeDisallowList_Store_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Store'
type NodeDisallowList_Store_Call struct {
	*mock.Call
}

// Store is a helper method to define mock.On call
//   - disallowList map[flow.Identifier]struct{}
func (_e *NodeDisallowList_Expecter) Store(disallowList interface{}) *NodeDisallowList_Store_Call {
	return &NodeDisallowList_Store_Call{Call: _e.mock.On("Store", disallowList)}
}

func (_c *NodeDisallowList_Store_Call) Run(run func(disallowList map[flow.Identifier]struct{})) *NodeDisallowList_Store_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 map[flow.Identifier]struct{}
		if args[0] != nil {
			arg0 = args[0].(map[flow.Identifier]struct{})
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *NodeDisallowList_Store_Call) Return(err error) *NodeDisallowList_Store_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *NodeDisallowList_Store_Call) RunAndReturn(run func(disallowList map[flow.Identifier]struct{}) error) *NodeDisallowList_Store_Call {
	_c.Call.Return(run)
	return _c
}

// NewIterator creates a new instance of Iterator. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIterator(t interface {
	mock.TestingT
	Cleanup(func())
}) *Iterator {
	mock := &Iterator{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Iterator is an autogenerated mock type for the Iterator type
type Iterator struct {
	mock.Mock
}

type Iterator_Expecter struct {
	mock *mock.Mock
}

func (_m *Iterator) EXPECT() *Iterator_Expecter {
	return &Iterator_Expecter{mock: &_m.Mock}
}

// Close provides a mock function for the type Iterator
func (_mock *Iterator) Close() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Close")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Iterator_Close_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Close'
type Iterator_Close_Call struct {
	*mock.Call
}

// Close is a helper method to define mock.On call
func (_e *Iterator_Expecter) Close() *Iterator_Close_Call {
	return &Iterator_Close_Call{Call: _e.mock.On("Close")}
}

func (_c *Iterator_Close_Call) Run(run func()) *Iterator_Close_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Iterator_Close_Call) Return(err error) *Iterator_Close_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Iterator_Close_Call) RunAndReturn(run func() error) *Iterator_Close_Call {
	_c.Call.Return(run)
	return _c
}

// First provides a mock function for the type Iterator
func (_mock *Iterator) First() bool {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for First")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func() bool); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// Iterator_First_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'First'
type Iterator_First_Call struct {
	*mock.Call
}

// First is a helper method to define mock.On call
func (_e *Iterator_Expecter) First() *Iterator_First_Call {
	return &Iterator_First_Call{Call: _e.mock.On("First")}
}

func (_c *Iterator_First_Call) Run(run func()) *Iterator_First_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Iterator_First_Call) Return(b bool) *Iterator_First_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *Iterator_First_Call) RunAndReturn(run func() bool) *Iterator_First_Call {
	_c.Call.Return(run)
	return _c
}

// IterItem provides a mock function for the type Iterator
func (_mock *Iterator) IterItem() storage.IterItem {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for IterItem")
	}

	var r0 storage.IterItem
	if returnFunc, ok := ret.Get(0).(func() storage.IterItem); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(storage.IterItem)
		}
	}
	return r0
}

// Iterator_IterItem_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IterItem'
type Iterator_IterItem_Call struct {
	*mock.Call
}

// IterItem is a helper method to define mock.On call
func (_e *Iterator_Expecter) IterItem() *Iterator_IterItem_Call {
	return &Iterator_IterItem_Call{Call: _e.mock.On("IterItem")}
}

func (_c *Iterator_IterItem_Call) Run(run func()) *Iterator_IterItem_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Iterator_IterItem_Call) Return(iterItem storage.IterItem) *Iterator_IterItem_Call {
	_c.Call.Return(iterItem)
	return _c
}

func (_c *Iterator_IterItem_Call) RunAndReturn(run func() storage.IterItem) *Iterator_IterItem_Call {
	_c.Call.Return(run)
	return _c
}

// Next provides a mock function for the type Iterator
func (_mock *Iterator) Next() {
	_mock.Called()
	return
}

// Iterator_Next_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Next'
type Iterator_Next_Call struct {
	*mock.Call
}

// Next is a helper method to define mock.On call
func (_e *Iterator_Expecter) Next() *Iterator_Next_Call {
	return &Iterator_Next_Call{Call: _e.mock.On("Next")}
}

func (_c *Iterator_Next_Call) Run(run func()) *Iterator_Next_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Iterator_Next_Call) Return() *Iterator_Next_Call {
	_c.Call.Return()
	return _c
}

func (_c *Iterator_Next_Call) RunAndReturn(run func()) *Iterator_Next_Call {
	_c.Run(run)
	return _c
}

// Valid provides a mock function for the type Iterator
func (_mock *Iterator) Valid() bool {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Valid")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func() bool); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// Iterator_Valid_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Valid'
type Iterator_Valid_Call struct {
	*mock.Call
}

// Valid is a helper method to define mock.On call
func (_e *Iterator_Expecter) Valid() *Iterator_Valid_Call {
	return &Iterator_Valid_Call{Call: _e.mock.On("Valid")}
}

func (_c *Iterator_Valid_Call) Run(run func()) *Iterator_Valid_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Iterator_Valid_Call) Return(b bool) *Iterator_Valid_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *Iterator_Valid_Call) RunAndReturn(run func() bool) *Iterator_Valid_Call {
	_c.Call.Return(run)
	return _c
}

// NewIterItem creates a new instance of IterItem. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIterItem(t interface {
	mock.TestingT
	Cleanup(func())
}) *IterItem {
	mock := &IterItem{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// IterItem is an autogenerated mock type for the IterItem type
type IterItem struct {
	mock.Mock
}

type IterItem_Expecter struct {
	mock *mock.Mock
}

func (_m *IterItem) EXPECT() *IterItem_Expecter {
	return &IterItem_Expecter{mock: &_m.Mock}
}

// Key provides a mock function for the type IterItem
func (_mock *IterItem) Key() []byte {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Key")
	}

	var r0 []byte
	if returnFunc, ok := ret.Get(0).(func() []byte); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}
	return r0
}

// IterItem_Key_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Key'
type IterItem_Key_Call struct {
	*mock.Call
}

// Key is a helper method to define mock.On call
func (_e *IterItem_Expecter) Key() *IterItem_Key_Call {
	return &IterItem_Key_Call{Call: _e.mock.On("Key")}
}

func (_c *IterItem_Key_Call) Run(run func()) *IterItem_Key_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *IterItem_Key_Call) Return(bytes []byte) *IterItem_Key_Call {
	_c.Call.Return(bytes)
	return _c
}

func (_c *IterItem_Key_Call) RunAndReturn(run func() []byte) *IterItem_Key_Call {
	_c.Call.Return(run)
	return _c
}

// KeyCopy provides a mock function for the type IterItem
func (_mock *IterItem) KeyCopy(dst []byte) []byte {
	ret := _mock.Called(dst)

	if len(ret) == 0 {
		panic("no return value specified for KeyCopy")
	}

	var r0 []byte
	if returnFunc, ok := ret.Get(0).(func([]byte) []byte); ok {
		r0 = returnFunc(dst)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}
	return r0
}

// IterItem_KeyCopy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'KeyCopy'
type IterItem_KeyCopy_Call struct {
	*mock.Call
}

// KeyCopy is a helper method to define mock.On call
//   - dst []byte
func (_e *IterItem_Expecter) KeyCopy(dst interface{}) *IterItem_KeyCopy_Call {
	return &IterItem_KeyCopy_Call{Call: _e.mock.On("KeyCopy", dst)}
}

func (_c *IterItem_KeyCopy_Call) Run(run func(dst []byte)) *IterItem_KeyCopy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []byte
		if args[0] != nil {
			arg0 = args[0].([]byte)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *IterItem_KeyCopy_Call) Return(bytes []byte) *IterItem_KeyCopy_Call {
	_c.Call.Return(bytes)
	return _c
}

func (_c *IterItem_KeyCopy_Call) RunAndReturn(run func(dst []byte) []byte) *IterItem_KeyCopy_Call {
	_c.Call.Return(run)
	return _c
}

// Value provides a mock function for the type IterItem
func (_mock *IterItem) Value(fn func(val []byte) error) error {
	ret := _mock.Called(fn)

	if len(ret) == 0 {
		panic("no return value specified for Value")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(func(val []byte) error) error); ok {
		r0 = returnFunc(fn)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// IterItem_Value_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Value'
type IterItem_Value_Call struct {
	*mock.Call
}

// Value is a helper method to define mock.On call
//   - fn func(val []byte) error
func (_e *IterItem_Expecter) Value(fn interface{}) *IterItem_Value_Call {
	return &IterItem_Value_Call{Call: _e.mock.On("Value", fn)}
}

func (_c *IterItem_Value_Call) Run(run func(fn func(val []byte) error)) *IterItem_Value_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 func(val []byte) error
		if args[0] != nil {
			arg0 = args[0].(func(val []byte) error)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *IterItem_Value_Call) Return(err error) *IterItem_Value_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *IterItem_Value_Call) RunAndReturn(run func(fn func(val []byte) error) error) *IterItem_Value_Call {
	_c.Call.Return(run)
	return _c
}

// NewSeeker creates a new instance of Seeker. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewSeeker(t interface {
	mock.TestingT
	Cleanup(func())
}) *Seeker {
	mock := &Seeker{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Seeker is an autogenerated mock type for the Seeker type
type Seeker struct {
	mock.Mock
}

type Seeker_Expecter struct {
	mock *mock.Mock
}

func (_m *Seeker) EXPECT() *Seeker_Expecter {
	return &Seeker_Expecter{mock: &_m.Mock}
}

// SeekLE provides a mock function for the type Seeker
func (_mock *Seeker) SeekLE(startPrefix []byte, key []byte) ([]byte, error) {
	ret := _mock.Called(startPrefix, key)

	if len(ret) == 0 {
		panic("no return value specified for SeekLE")
	}

	var r0 []byte
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]byte, []byte) ([]byte, error)); ok {
		return returnFunc(startPrefix, key)
	}
	if returnFunc, ok := ret.Get(0).(func([]byte, []byte) []byte); ok {
		r0 = returnFunc(startPrefix, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}
	if returnFunc, ok := ret.Get(1).(func([]byte, []byte) error); ok {
		r1 = returnFunc(startPrefix, key)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Seeker_SeekLE_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SeekLE'
type Seeker_SeekLE_Call struct {
	*mock.Call
}

// SeekLE is a helper method to define mock.On call
//   - startPrefix []byte
//   - key []byte
func (_e *Seeker_Expecter) SeekLE(startPrefix interface{}, key interface{}) *Seeker_SeekLE_Call {
	return &Seeker_SeekLE_Call{Call: _e.mock.On("SeekLE", startPrefix, key)}
}

func (_c *Seeker_SeekLE_Call) Run(run func(startPrefix []byte, key []byte)) *Seeker_SeekLE_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []byte
		if args[0] != nil {
			arg0 = args[0].([]byte)
		}
		var arg1 []byte
		if args[1] != nil {
			arg1 = args[1].([]byte)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Seeker_SeekLE_Call) Return(bytes []byte, err error) *Seeker_SeekLE_Call {
	_c.Call.Return(bytes, err)
	return _c
}

func (_c *Seeker_SeekLE_Call) RunAndReturn(run func(startPrefix []byte, key []byte) ([]byte, error)) *Seeker_SeekLE_Call {
	_c.Call.Return(run)
	return _c
}

// NewReader creates a new instance of Reader. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewReader(t interface {
	mock.TestingT
	Cleanup(func())
}) *Reader {
	mock := &Reader{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Reader is an autogenerated mock type for the Reader type
type Reader struct {
	mock.Mock
}

type Reader_Expecter struct {
	mock *mock.Mock
}

func (_m *Reader) EXPECT() *Reader_Expecter {
	return &Reader_Expecter{mock: &_m.Mock}
}

// Get provides a mock function for the type Reader
func (_mock *Reader) Get(key []byte) ([]byte, io.Closer, error) {
	ret := _mock.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 []byte
	var r1 io.Closer
	var r2 error
	if returnFunc, ok := ret.Get(0).(func([]byte) ([]byte, io.Closer, error)); ok {
		return returnFunc(key)
	}
	if returnFunc, ok := ret.Get(0).(func([]byte) []byte); ok {
		r0 = returnFunc(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}
	if returnFunc, ok := ret.Get(1).(func([]byte) io.Closer); ok {
		r1 = returnFunc(key)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(io.Closer)
		}
	}
	if returnFunc, ok := ret.Get(2).(func([]byte) error); ok {
		r2 = returnFunc(key)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// Reader_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type Reader_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - key []byte
func (_e *Reader_Expecter) Get(key interface{}) *Reader_Get_Call {
	return &Reader_Get_Call{Call: _e.mock.On("Get", key)}
}

func (_c *Reader_Get_Call) Run(run func(key []byte)) *Reader_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []byte
		if args[0] != nil {
			arg0 = args[0].([]byte)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Reader_Get_Call) Return(value []byte, closer io.Closer, err error) *Reader_Get_Call {
	_c.Call.Return(value, closer, err)
	return _c
}

func (_c *Reader_Get_Call) RunAndReturn(run func(key []byte) ([]byte, io.Closer, error)) *Reader_Get_Call {
	_c.Call.Return(run)
	return _c
}

// NewIter provides a mock function for the type Reader
func (_mock *Reader) NewIter(startPrefix []byte, endPrefix []byte, ops storage.IteratorOption) (storage.Iterator, error) {
	ret := _mock.Called(startPrefix, endPrefix, ops)

	if len(ret) == 0 {
		panic("no return value specified for NewIter")
	}

	var r0 storage.Iterator
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]byte, []byte, storage.IteratorOption) (storage.Iterator, error)); ok {
		return returnFunc(startPrefix, endPrefix, ops)
	}
	if returnFunc, ok := ret.Get(0).(func([]byte, []byte, storage.IteratorOption) storage.Iterator); ok {
		r0 = returnFunc(startPrefix, endPrefix, ops)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(storage.Iterator)
		}
	}
	if returnFunc, ok := ret.Get(1).(func([]byte, []byte, storage.IteratorOption) error); ok {
		r1 = returnFunc(startPrefix, endPrefix, ops)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Reader_NewIter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NewIter'
type Reader_NewIter_Call struct {
	*mock.Call
}

// NewIter is a helper method to define mock.On call
//   - startPrefix []byte
//   - endPrefix []byte
//   - ops storage.IteratorOption
func (_e *Reader_Expecter) NewIter(startPrefix interface{}, endPrefix interface{}, ops interface{}) *Reader_NewIter_Call {
	return &Reader_NewIter_Call{Call: _e.mock.On("NewIter", startPrefix, endPrefix, ops)}
}

func (_c *Reader_NewIter_Call) Run(run func(startPrefix []byte, endPrefix []byte, ops storage.IteratorOption)) *Reader_NewIter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []byte
		if args[0] != nil {
			arg0 = args[0].([]byte)
		}
		var arg1 []byte
		if args[1] != nil {
			arg1 = args[1].([]byte)
		}
		var arg2 storage.IteratorOption
		if args[2] != nil {
			arg2 = args[2].(storage.IteratorOption)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Reader_NewIter_Call) Return(iterator storage.Iterator, err error) *Reader_NewIter_Call {
	_c.Call.Return(iterator, err)
	return _c
}

func (_c *Reader_NewIter_Call) RunAndReturn(run func(startPrefix []byte, endPrefix []byte, ops storage.IteratorOption) (storage.Iterator, error)) *Reader_NewIter_Call {
	_c.Call.Return(run)
	return _c
}

// NewSeeker provides a mock function for the type Reader
func (_mock *Reader) NewSeeker() storage.Seeker {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for NewSeeker")
	}

	var r0 storage.Seeker
	if returnFunc, ok := ret.Get(0).(func() storage.Seeker); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(storage.Seeker)
		}
	}
	return r0
}

// Reader_NewSeeker_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NewSeeker'
type Reader_NewSeeker_Call struct {
	*mock.Call
}

// NewSeeker is a helper method to define mock.On call
func (_e *Reader_Expecter) NewSeeker() *Reader_NewSeeker_Call {
	return &Reader_NewSeeker_Call{Call: _e.mock.On("NewSeeker")}
}

func (_c *Reader_NewSeeker_Call) Run(run func()) *Reader_NewSeeker_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Reader_NewSeeker_Call) Return(seeker storage.Seeker) *Reader_NewSeeker_Call {
	_c.Call.Return(seeker)
	return _c
}

func (_c *Reader_NewSeeker_Call) RunAndReturn(run func() storage.Seeker) *Reader_NewSeeker_Call {
	_c.Call.Return(run)
	return _c
}

// NewWriter creates a new instance of Writer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewWriter(t interface {
	mock.TestingT
	Cleanup(func())
}) *Writer {
	mock := &Writer{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Writer is an autogenerated mock type for the Writer type
type Writer struct {
	mock.Mock
}

type Writer_Expecter struct {
	mock *mock.Mock
}

func (_m *Writer) EXPECT() *Writer_Expecter {
	return &Writer_Expecter{mock: &_m.Mock}
}

// Delete provides a mock function for the type Writer
func (_mock *Writer) Delete(key []byte) error {
	ret := _mock.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func([]byte) error); ok {
		r0 = returnFunc(key)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Writer_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type Writer_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - key []byte
func (_e *Writer_Expecter) Delete(key interface{}) *Writer_Delete_Call {
	return &Writer_Delete_Call{Call: _e.mock.On("Delete", key)}
}

func (_c *Writer_Delete_Call) Run(run func(key []byte)) *Writer_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []byte
		if args[0] != nil {
			arg0 = args[0].([]byte)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Writer_Delete_Call) Return(err error) *Writer_Delete_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Writer_Delete_Call) RunAndReturn(run func(key []byte) error) *Writer_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteByRange provides a mock function for the type Writer
func (_mock *Writer) DeleteByRange(globalReader storage.Reader, startPrefix []byte, endPrefix []byte) error {
	ret := _mock.Called(globalReader, startPrefix, endPrefix)

	if len(ret) == 0 {
		panic("no return value specified for DeleteByRange")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(storage.Reader, []byte, []byte) error); ok {
		r0 = returnFunc(globalReader, startPrefix, endPrefix)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Writer_DeleteByRange_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteByRange'
type Writer_DeleteByRange_Call struct {
	*mock.Call
}

// DeleteByRange is a helper method to define mock.On call
//   - globalReader storage.Reader
//   - startPrefix []byte
//   - endPrefix []byte
func (_e *Writer_Expecter) DeleteByRange(globalReader interface{}, startPrefix interface{}, endPrefix interface{}) *Writer_DeleteByRange_Call {
	return &Writer_DeleteByRange_Call{Call: _e.mock.On("DeleteByRange", globalReader, startPrefix, endPrefix)}
}

func (_c *Writer_DeleteByRange_Call) Run(run func(globalReader storage.Reader, startPrefix []byte, endPrefix []byte)) *Writer_DeleteByRange_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 storage.Reader
		if args[0] != nil {
			arg0 = args[0].(storage.Reader)
		}
		var arg1 []byte
		if args[1] != nil {
			arg1 = args[1].([]byte)
		}
		var arg2 []byte
		if args[2] != nil {
			arg2 = args[2].([]byte)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Writer_DeleteByRange_Call) Return(err error) *Writer_DeleteByRange_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Writer_DeleteByRange_Call) RunAndReturn(run func(globalReader storage.Reader, startPrefix []byte, endPrefix []byte) error) *Writer_DeleteByRange_Call {
	_c.Call.Return(run)
	return _c
}

// Set provides a mock function for the type Writer
func (_mock *Writer) Set(k []byte, v []byte) error {
	ret := _mock.Called(k, v)

	if len(ret) == 0 {
		panic("no return value specified for Set")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func([]byte, []byte) error); ok {
		r0 = returnFunc(k, v)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Writer_Set_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Set'
type Writer_Set_Call struct {
	*mock.Call
}

// Set is a helper method to define mock.On call
//   - k []byte
//   - v []byte
func (_e *Writer_Expecter) Set(k interface{}, v interface{}) *Writer_Set_Call {
	return &Writer_Set_Call{Call: _e.mock.On("Set", k, v)}
}

func (_c *Writer_Set_Call) Run(run func(k []byte, v []byte)) *Writer_Set_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []byte
		if args[0] != nil {
			arg0 = args[0].([]byte)
		}
		var arg1 []byte
		if args[1] != nil {
			arg1 = args[1].([]byte)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Writer_Set_Call) Return(err error) *Writer_Set_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Writer_Set_Call) RunAndReturn(run func(k []byte, v []byte) error) *Writer_Set_Call {
	_c.Call.Return(run)
	return _c
}

// NewReaderBatchWriter creates a new instance of ReaderBatchWriter. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewReaderBatchWriter(t interface {
	mock.TestingT
	Cleanup(func())
}) *ReaderBatchWriter {
	mock := &ReaderBatchWriter{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// ReaderBatchWriter is an autogenerated mock type for the ReaderBatchWriter type
type ReaderBatchWriter struct {
	mock.Mock
}

type ReaderBatchWriter_Expecter struct {
	mock *mock.Mock
}

func (_m *ReaderBatchWriter) EXPECT() *ReaderBatchWriter_Expecter {
	return &ReaderBatchWriter_Expecter{mock: &_m.Mock}
}

// AddCallback provides a mock function for the type ReaderBatchWriter
func (_mock *ReaderBatchWriter) AddCallback(fn func(error)) {
	_mock.Called(fn)
	return
}

// ReaderBatchWriter_AddCallback_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddCallback'
type ReaderBatchWriter_AddCallback_Call struct {
	*mock.Call
}

// AddCallback is a helper method to define mock.On call
//   - fn func(error)
func (_e *ReaderBatchWriter_Expecter) AddCallback(fn interface{}) *ReaderBatchWriter_AddCallback_Call {
	return &ReaderBatchWriter_AddCallback_Call{Call: _e.mock.On("AddCallback", fn)}
}

func (_c *ReaderBatchWriter_AddCallback_Call) Run(run func(fn func(error))) *ReaderBatchWriter_AddCallback_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 func(error)
		if args[0] != nil {
			arg0 = args[0].(func(error))
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ReaderBatchWriter_AddCallback_Call) Return() *ReaderBatchWriter_AddCallback_Call {
	_c.Call.Return()
	return _c
}

func (_c *ReaderBatchWriter_AddCallback_Call) RunAndReturn(run func(fn func(error))) *ReaderBatchWriter_AddCallback_Call {
	_c.Run(run)
	return _c
}

// GlobalReader provides a mock function for the type ReaderBatchWriter
func (_mock *ReaderBatchWriter) GlobalReader() storage.Reader {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GlobalReader")
	}

	var r0 storage.Reader
	if returnFunc, ok := ret.Get(0).(func() storage.Reader); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(storage.Reader)
		}
	}
	return r0
}

// ReaderBatchWriter_GlobalReader_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GlobalReader'
type ReaderBatchWriter_GlobalReader_Call struct {
	*mock.Call
}

// GlobalReader is a helper method to define mock.On call
func (_e *ReaderBatchWriter_Expecter) GlobalReader() *ReaderBatchWriter_GlobalReader_Call {
	return &ReaderBatchWriter_GlobalReader_Call{Call: _e.mock.On("GlobalReader")}
}

func (_c *ReaderBatchWriter_GlobalReader_Call) Run(run func()) *ReaderBatchWriter_GlobalReader_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ReaderBatchWriter_GlobalReader_Call) Return(reader storage.Reader) *ReaderBatchWriter_GlobalReader_Call {
	_c.Call.Return(reader)
	return _c
}

func (_c *ReaderBatchWriter_GlobalReader_Call) RunAndReturn(run func() storage.Reader) *ReaderBatchWriter_GlobalReader_Call {
	_c.Call.Return(run)
	return _c
}

// ScopedValue provides a mock function for the type ReaderBatchWriter
func (_mock *ReaderBatchWriter) ScopedValue(key string) (any, bool) {
	ret := _mock.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for ScopedValue")
	}

	var r0 any
	var r1 bool
	if returnFunc, ok := ret.Get(0).(func(string) (any, bool)); ok {
		return returnFunc(key)
	}
	if returnFunc, ok := ret.Get(0).(func(string) any); ok {
		r0 = returnFunc(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(any)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string) bool); ok {
		r1 = returnFunc(key)
	} else {
		r1 = ret.Get(1).(bool)
	}
	return r0, r1
}

// ReaderBatchWriter_ScopedValue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ScopedValue'
type ReaderBatchWriter_ScopedValue_Call struct {
	*mock.Call
}

// ScopedValue is a helper method to define mock.On call
//   - key string
func (_e *ReaderBatchWriter_Expecter) ScopedValue(key interface{}) *ReaderBatchWriter_ScopedValue_Call {
	return &ReaderBatchWriter_ScopedValue_Call{Call: _e.mock.On("ScopedValue", key)}
}

func (_c *ReaderBatchWriter_ScopedValue_Call) Run(run func(key string)) *ReaderBatchWriter_ScopedValue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ReaderBatchWriter_ScopedValue_Call) Return(v any, b bool) *ReaderBatchWriter_ScopedValue_Call {
	_c.Call.Return(v, b)
	return _c
}

func (_c *ReaderBatchWriter_ScopedValue_Call) RunAndReturn(run func(key string) (any, bool)) *ReaderBatchWriter_ScopedValue_Call {
	_c.Call.Return(run)
	return _c
}

// SetScopedValue provides a mock function for the type ReaderBatchWriter
func (_mock *ReaderBatchWriter) SetScopedValue(key string, value any) {
	_mock.Called(key, value)
	return
}

// ReaderBatchWriter_SetScopedValue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetScopedValue'
type ReaderBatchWriter_SetScopedValue_Call struct {
	*mock.Call
}

// SetScopedValue is a helper method to define mock.On call
//   - key string
//   - value any
func (_e *ReaderBatchWriter_Expecter) SetScopedValue(key interface{}, value interface{}) *ReaderBatchWriter_SetScopedValue_Call {
	return &ReaderBatchWriter_SetScopedValue_Call{Call: _e.mock.On("SetScopedValue", key, value)}
}

func (_c *ReaderBatchWriter_SetScopedValue_Call) Run(run func(key string, value any)) *ReaderBatchWriter_SetScopedValue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 any
		if args[1] != nil {
			arg1 = args[1].(any)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ReaderBatchWriter_SetScopedValue_Call) Return() *ReaderBatchWriter_SetScopedValue_Call {
	_c.Call.Return()
	return _c
}

func (_c *ReaderBatchWriter_SetScopedValue_Call) RunAndReturn(run func(key string, value any)) *ReaderBatchWriter_SetScopedValue_Call {
	_c.Run(run)
	return _c
}

// Writer provides a mock function for the type ReaderBatchWriter
func (_mock *ReaderBatchWriter) Writer() storage.Writer {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Writer")
	}

	var r0 storage.Writer
	if returnFunc, ok := ret.Get(0).(func() storage.Writer); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(storage.Writer)
		}
	}
	return r0
}

// ReaderBatchWriter_Writer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Writer'
type ReaderBatchWriter_Writer_Call struct {
	*mock.Call
}

// Writer is a helper method to define mock.On call
func (_e *ReaderBatchWriter_Expecter) Writer() *ReaderBatchWriter_Writer_Call {
	return &ReaderBatchWriter_Writer_Call{Call: _e.mock.On("Writer")}
}

func (_c *ReaderBatchWriter_Writer_Call) Run(run func()) *ReaderBatchWriter_Writer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ReaderBatchWriter_Writer_Call) Return(writer storage.Writer) *ReaderBatchWriter_Writer_Call {
	_c.Call.Return(writer)
	return _c
}

func (_c *ReaderBatchWriter_Writer_Call) RunAndReturn(run func() storage.Writer) *ReaderBatchWriter_Writer_Call {
	_c.Call.Return(run)
	return _c
}

// NewDB creates a new instance of DB. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewDB(t interface {
	mock.TestingT
	Cleanup(func())
}) *DB {
	mock := &DB{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// DB is an autogenerated mock type for the DB type
type DB struct {
	mock.Mock
}

type DB_Expecter struct {
	mock *mock.Mock
}

func (_m *DB) EXPECT() *DB_Expecter {
	return &DB_Expecter{mock: &_m.Mock}
}

// Close provides a mock function for the type DB
func (_mock *DB) Close() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Close")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// DB_Close_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Close'
type DB_Close_Call struct {
	*mock.Call
}

// Close is a helper method to define mock.On call
func (_e *DB_Expecter) Close() *DB_Close_Call {
	return &DB_Close_Call{Call: _e.mock.On("Close")}
}

func (_c *DB_Close_Call) Run(run func()) *DB_Close_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *DB_Close_Call) Return(err error) *DB_Close_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *DB_Close_Call) RunAndReturn(run func() error) *DB_Close_Call {
	_c.Call.Return(run)
	return _c
}

// NewBatch provides a mock function for the type DB
func (_mock *DB) NewBatch() storage.Batch {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for NewBatch")
	}

	var r0 storage.Batch
	if returnFunc, ok := ret.Get(0).(func() storage.Batch); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(storage.Batch)
		}
	}
	return r0
}

// DB_NewBatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NewBatch'
type DB_NewBatch_Call struct {
	*mock.Call
}

// NewBatch is a helper method to define mock.On call
func (_e *DB_Expecter) NewBatch() *DB_NewBatch_Call {
	return &DB_NewBatch_Call{Call: _e.mock.On("NewBatch")}
}

func (_c *DB_NewBatch_Call) Run(run func()) *DB_NewBatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *DB_NewBatch_Call) Return(batch storage.Batch) *DB_NewBatch_Call {
	_c.Call.Return(batch)
	return _c
}

func (_c *DB_NewBatch_Call) RunAndReturn(run func() storage.Batch) *DB_NewBatch_Call {
	_c.Call.Return(run)
	return _c
}

// Reader provides a mock function for the type DB
func (_mock *DB) Reader() storage.Reader {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Reader")
	}

	var r0 storage.Reader
	if returnFunc, ok := ret.Get(0).(func() storage.Reader); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(storage.Reader)
		}
	}
	return r0
}

// DB_Reader_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Reader'
type DB_Reader_Call struct {
	*mock.Call
}

// Reader is a helper method to define mock.On call
func (_e *DB_Expecter) Reader() *DB_Reader_Call {
	return &DB_Reader_Call{Call: _e.mock.On("Reader")}
}

func (_c *DB_Reader_Call) Run(run func()) *DB_Reader_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *DB_Reader_Call) Return(reader storage.Reader) *DB_Reader_Call {
	_c.Call.Return(reader)
	return _c
}

func (_c *DB_Reader_Call) RunAndReturn(run func() storage.Reader) *DB_Reader_Call {
	_c.Call.Return(run)
	return _c
}

// WithReaderBatchWriter provides a mock function for the type DB
func (_mock *DB) WithReaderBatchWriter(fn func(storage.ReaderBatchWriter) error) error {
	ret := _mock.Called(fn)

	if len(ret) == 0 {
		panic("no return value specified for WithReaderBatchWriter")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(func(storage.ReaderBatchWriter) error) error); ok {
		r0 = returnFunc(fn)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// DB_WithReaderBatchWriter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithReaderBatchWriter'
type DB_WithReaderBatchWriter_Call struct {
	*mock.Call
}

// WithReaderBatchWriter is a helper method to define mock.On call
//   - fn func(storage.ReaderBatchWriter) error
func (_e *DB_Expecter) WithReaderBatchWriter(fn interface{}) *DB_WithReaderBatchWriter_Call {
	return &DB_WithReaderBatchWriter_Call{Call: _e.mock.On("WithReaderBatchWriter", fn)}
}

func (_c *DB_WithReaderBatchWriter_Call) Run(run func(fn func(storage.ReaderBatchWriter) error)) *DB_WithReaderBatchWriter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 func(storage.ReaderBatchWriter) error
		if args[0] != nil {
			arg0 = args[0].(func(storage.ReaderBatchWriter) error)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *DB_WithReaderBatchWriter_Call) Return(err error) *DB_WithReaderBatchWriter_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *DB_WithReaderBatchWriter_Call) RunAndReturn(run func(fn func(storage.ReaderBatchWriter) error) error) *DB_WithReaderBatchWriter_Call {
	_c.Call.Return(run)
	return _c
}

// NewBatch creates a new instance of Batch. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewBatch(t interface {
	mock.TestingT
	Cleanup(func())
}) *Batch {
	mock := &Batch{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Batch is an autogenerated mock type for the Batch type
type Batch struct {
	mock.Mock
}

type Batch_Expecter struct {
	mock *mock.Mock
}

func (_m *Batch) EXPECT() *Batch_Expecter {
	return &Batch_Expecter{mock: &_m.Mock}
}

// AddCallback provides a mock function for the type Batch
func (_mock *Batch) AddCallback(fn func(error)) {
	_mock.Called(fn)
	return
}

// Batch_AddCallback_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddCallback'
type Batch_AddCallback_Call struct {
	*mock.Call
}

// AddCallback is a helper method to define mock.On call
//   - fn func(error)
func (_e *Batch_Expecter) AddCallback(fn interface{}) *Batch_AddCallback_Call {
	return &Batch_AddCallback_Call{Call: _e.mock.On("AddCallback", fn)}
}

func (_c *Batch_AddCallback_Call) Run(run func(fn func(error))) *Batch_AddCallback_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 func(error)
		if args[0] != nil {
			arg0 = args[0].(func(error))
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Batch_AddCallback_Call) Return() *Batch_AddCallback_Call {
	_c.Call.Return()
	return _c
}

func (_c *Batch_AddCallback_Call) RunAndReturn(run func(fn func(error))) *Batch_AddCallback_Call {
	_c.Run(run)
	return _c
}

// Close provides a mock function for the type Batch
func (_mock *Batch) Close() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Close")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Batch_Close_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Close'
type Batch_Close_Call struct {
	*mock.Call
}

// Close is a helper method to define mock.On call
func (_e *Batch_Expecter) Close() *Batch_Close_Call {
	return &Batch_Close_Call{Call: _e.mock.On("Close")}
}

func (_c *Batch_Close_Call) Run(run func()) *Batch_Close_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Batch_Close_Call) Return(err error) *Batch_Close_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Batch_Close_Call) RunAndReturn(run func() error) *Batch_Close_Call {
	_c.Call.Return(run)
	return _c
}

// Commit provides a mock function for the type Batch
func (_mock *Batch) Commit() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Commit")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Batch_Commit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Commit'
type Batch_Commit_Call struct {
	*mock.Call
}

// Commit is a helper method to define mock.On call
func (_e *Batch_Expecter) Commit() *Batch_Commit_Call {
	return &Batch_Commit_Call{Call: _e.mock.On("Commit")}
}

func (_c *Batch_Commit_Call) Run(run func()) *Batch_Commit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Batch_Commit_Call) Return(err error) *Batch_Commit_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Batch_Commit_Call) RunAndReturn(run func() error) *Batch_Commit_Call {
	_c.Call.Return(run)
	return _c
}

// GlobalReader provides a mock function for the type Batch
func (_mock *Batch) GlobalReader() storage.Reader {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GlobalReader")
	}

	var r0 storage.Reader
	if returnFunc, ok := ret.Get(0).(func() storage.Reader); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(storage.Reader)
		}
	}
	return r0
}

// Batch_GlobalReader_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GlobalReader'
type Batch_GlobalReader_Call struct {
	*mock.Call
}

// GlobalReader is a helper method to define mock.On call
func (_e *Batch_Expecter) GlobalReader() *Batch_GlobalReader_Call {
	return &Batch_GlobalReader_Call{Call: _e.mock.On("GlobalReader")}
}

func (_c *Batch_GlobalReader_Call) Run(run func()) *Batch_GlobalReader_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Batch_GlobalReader_Call) Return(reader storage.Reader) *Batch_GlobalReader_Call {
	_c.Call.Return(reader)
	return _c
}

func (_c *Batch_GlobalReader_Call) RunAndReturn(run func() storage.Reader) *Batch_GlobalReader_Call {
	_c.Call.Return(run)
	return _c
}

// ScopedValue provides a mock function for the type Batch
func (_mock *Batch) ScopedValue(key string) (any, bool) {
	ret := _mock.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for ScopedValue")
	}

	var r0 any
	var r1 bool
	if returnFunc, ok := ret.Get(0).(func(string) (any, bool)); ok {
		return returnFunc(key)
	}
	if returnFunc, ok := ret.Get(0).(func(string) any); ok {
		r0 = returnFunc(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(any)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string) bool); ok {
		r1 = returnFunc(key)
	} else {
		r1 = ret.Get(1).(bool)
	}
	return r0, r1
}

// Batch_ScopedValue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ScopedValue'
type Batch_ScopedValue_Call struct {
	*mock.Call
}

// ScopedValue is a helper method to define mock.On call
//   - key string
func (_e *Batch_Expecter) ScopedValue(key interface{}) *Batch_ScopedValue_Call {
	return &Batch_ScopedValue_Call{Call: _e.mock.On("ScopedValue", key)}
}

func (_c *Batch_ScopedValue_Call) Run(run func(key string)) *Batch_ScopedValue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Batch_ScopedValue_Call) Return(v any, b bool) *Batch_ScopedValue_Call {
	_c.Call.Return(v, b)
	return _c
}

func (_c *Batch_ScopedValue_Call) RunAndReturn(run func(key string) (any, bool)) *Batch_ScopedValue_Call {
	_c.Call.Return(run)
	return _c
}

// SetScopedValue provides a mock function for the type Batch
func (_mock *Batch) SetScopedValue(key string, value any) {
	_mock.Called(key, value)
	return
}

// Batch_SetScopedValue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetScopedValue'
type Batch_SetScopedValue_Call struct {
	*mock.Call
}

// SetScopedValue is a helper method to define mock.On call
//   - key string
//   - value any
func (_e *Batch_Expecter) SetScopedValue(key interface{}, value interface{}) *Batch_SetScopedValue_Call {
	return &Batch_SetScopedValue_Call{Call: _e.mock.On("SetScopedValue", key, value)}
}

func (_c *Batch_SetScopedValue_Call) Run(run func(key string, value any)) *Batch_SetScopedValue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 any
		if args[1] != nil {
			arg1 = args[1].(any)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Batch_SetScopedValue_Call) Return() *Batch_SetScopedValue_Call {
	_c.Call.Return()
	return _c
}

func (_c *Batch_SetScopedValue_Call) RunAndReturn(run func(key string, value any)) *Batch_SetScopedValue_Call {
	_c.Run(run)
	return _c
}

// Writer provides a mock function for the type Batch
func (_mock *Batch) Writer() storage.Writer {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Writer")
	}

	var r0 storage.Writer
	if returnFunc, ok := ret.Get(0).(func() storage.Writer); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(storage.Writer)
		}
	}
	return r0
}

// Batch_Writer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Writer'
type Batch_Writer_Call struct {
	*mock.Call
}

// Writer is a helper method to define mock.On call
func (_e *Batch_Expecter) Writer() *Batch_Writer_Call {
	return &Batch_Writer_Call{Call: _e.mock.On("Writer")}
}

func (_c *Batch_Writer_Call) Run(run func()) *Batch_Writer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Batch_Writer_Call) Return(writer storage.Writer) *Batch_Writer_Call {
	_c.Call.Return(writer)
	return _c
}

func (_c *Batch_Writer_Call) RunAndReturn(run func() storage.Writer) *Batch_Writer_Call {
	_c.Call.Return(run)
	return _c
}

// NewPayloads creates a new instance of Payloads. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewPayloads(t interface {
	mock.TestingT
	Cleanup(func())
}) *Payloads {
	mock := &Payloads{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Payloads is an autogenerated mock type for the Payloads type
type Payloads struct {
	mock.Mock
}

type Payloads_Expecter struct {
	mock *mock.Mock
}

func (_m *Payloads) EXPECT() *Payloads_Expecter {
	return &Payloads_Expecter{mock: &_m.Mock}
}

// ByBlockID provides a mock function for the type Payloads
func (_mock *Payloads) ByBlockID(blockID flow.Identifier) (*flow.Payload, error) {
	ret := _mock.Called(blockID)

	if len(ret) == 0 {
		panic("no return value specified for ByBlockID")
	}

	var r0 *flow.Payload
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (*flow.Payload, error)); ok {
		return returnFunc(blockID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) *flow.Payload); ok {
		r0 = returnFunc(blockID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.Payload)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(blockID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Payloads_ByBlockID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByBlockID'
type Payloads_ByBlockID_Call struct {
	*mock.Call
}

// ByBlockID is a helper method to define mock.On call
//   - blockID flow.Identifier
func (_e *Payloads_Expecter) ByBlockID(blockID interface{}) *Payloads_ByBlockID_Call {
	return &Payloads_ByBlockID_Call{Call: _e.mock.On("ByBlockID", blockID)}
}

func (_c *Payloads_ByBlockID_Call) Run(run func(blockID flow.Identifier)) *Payloads_ByBlockID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Payloads_ByBlockID_Call) Return(payload *flow.Payload, err error) *Payloads_ByBlockID_Call {
	_c.Call.Return(payload, err)
	return _c
}

func (_c *Payloads_ByBlockID_Call) RunAndReturn(run func(blockID flow.Identifier) (*flow.Payload, error)) *Payloads_ByBlockID_Call {
	_c.Call.Return(run)
	return _c
}

// NewProtocolKVStore creates a new instance of ProtocolKVStore. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewProtocolKVStore(t interface {
	mock.TestingT
	Cleanup(func())
}) *ProtocolKVStore {
	mock := &ProtocolKVStore{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// ProtocolKVStore is an autogenerated mock type for the ProtocolKVStore type
type ProtocolKVStore struct {
	mock.Mock
}

type ProtocolKVStore_Expecter struct {
	mock *mock.Mock
}

func (_m *ProtocolKVStore) EXPECT() *ProtocolKVStore_Expecter {
	return &ProtocolKVStore_Expecter{mock: &_m.Mock}
}

// BatchIndex provides a mock function for the type ProtocolKVStore
func (_mock *ProtocolKVStore) BatchIndex(lctx lockctx.Proof, rw storage.ReaderBatchWriter, blockID flow.Identifier, stateID flow.Identifier) error {
	ret := _mock.Called(lctx, rw, blockID, stateID)

	if len(ret) == 0 {
		panic("no return value specified for BatchIndex")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(lockctx.Proof, storage.ReaderBatchWriter, flow.Identifier, flow.Identifier) error); ok {
		r0 = returnFunc(lctx, rw, blockID, stateID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ProtocolKVStore_BatchIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BatchIndex'
type ProtocolKVStore_BatchIndex_Call struct {
	*mock.Call
}

// BatchIndex is a helper method to define mock.On call
//   - lctx lockctx.Proof
//   - rw storage.ReaderBatchWriter
//   - blockID flow.Identifier
//   - stateID flow.Identifier
func (_e *ProtocolKVStore_Expecter) BatchIndex(lctx interface{}, rw interface{}, blockID interface{}, stateID interface{}) *ProtocolKVStore_BatchIndex_Call {
	return &ProtocolKVStore_BatchIndex_Call{Call: _e.mock.On("BatchIndex", lctx, rw, blockID, stateID)}
}

func (_c *ProtocolKVStore_BatchIndex_Call) Run(run func(lctx lockctx.Proof, rw storage.ReaderBatchWriter, blockID flow.Identifier, stateID flow.Identifier)) *ProtocolKVStore_BatchIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 lockctx.Proof
		if args[0] != nil {
			arg0 = args[0].(lockctx.Proof)
		}
		var arg1 storage.ReaderBatchWriter
		if args[1] != nil {
			arg1 = args[1].(storage.ReaderBatchWriter)
		}
		var arg2 flow.Identifier
		if args[2] != nil {
			arg2 = args[2].(flow.Identifier)
		}
		var arg3 flow.Identifier
		if args[3] != nil {
			arg3 = args[3].(flow.Identifier)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *ProtocolKVStore_BatchIndex_Call) Return(err error) *ProtocolKVStore_BatchIndex_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ProtocolKVStore_BatchIndex_Call) RunAndReturn(run func(lctx lockctx.Proof, rw storage.ReaderBatchWriter, blockID flow.Identifier, stateID flow.Identifier) error) *ProtocolKVStore_BatchIndex_Call {
	_c.Call.Return(run)
	return _c
}

// BatchStore provides a mock function for the type ProtocolKVStore
func (_mock *ProtocolKVStore) BatchStore(rw storage.ReaderBatchWriter, stateID flow.Identifier, data *flow.PSKeyValueStoreData) error {
	ret := _mock.Called(rw, stateID, data)

	if len(ret) == 0 {
		panic("no return value specified for BatchStore")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(storage.ReaderBatchWriter, flow.Identifier, *flow.PSKeyValueStoreData) error); ok {
		r0 = returnFunc(rw, stateID, data)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ProtocolKVStore_BatchStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BatchStore'
type ProtocolKVStore_BatchStore_Call struct {
	*mock.Call
}

// BatchStore is a helper method to define mock.On call
//   - rw storage.ReaderBatchWriter
//   - stateID flow.Identifier
//   - data *flow.PSKeyValueStoreData
func (_e *ProtocolKVStore_Expecter) BatchStore(rw interface{}, stateID interface{}, data interface{}) *ProtocolKVStore_BatchStore_Call {
	return &ProtocolKVStore_BatchStore_Call{Call: _e.mock.On("BatchStore", rw, stateID, data)}
}

func (_c *ProtocolKVStore_BatchStore_Call) Run(run func(rw storage.ReaderBatchWriter, stateID flow.Identifier, data *flow.PSKeyValueStoreData)) *ProtocolKVStore_BatchStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 storage.ReaderBatchWriter
		if args[0] != nil {
			arg0 = args[0].(storage.ReaderBatchWriter)
		}
		var arg1 flow.Identifier
		if args[1] != nil {
			arg1 = args[1].(flow.Identifier)
		}
		var arg2 *flow.PSKeyValueStoreData
		if args[2] != nil {
			arg2 = args[2].(*flow.PSKeyValueStoreData)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *ProtocolKVStore_BatchStore_Call) Return(err error) *ProtocolKVStore_BatchStore_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ProtocolKVStore_BatchStore_Call) RunAndReturn(run func(rw storage.ReaderBatchWriter, stateID flow.Identifier, data *flow.PSKeyValueStoreData) error) *ProtocolKVStore_BatchStore_Call {
	_c.Call.Return(run)
	return _c
}

// ByBlockID provides a mock function for the type ProtocolKVStore
func (_mock *ProtocolKVStore) ByBlockID(blockID flow.Identifier) (*flow.PSKeyValueStoreData, error) {
	ret := _mock.Called(blockID)

	if len(ret) == 0 {
		panic("no return value specified for ByBlockID")
	}

	var r0 *flow.PSKeyValueStoreData
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (*flow.PSKeyValueStoreData, error)); ok {
		return returnFunc(blockID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) *flow.PSKeyValueStoreData); ok {
		r0 = returnFunc(blockID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.PSKeyValueStoreData)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(blockID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ProtocolKVStore_ByBlockID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByBlockID'
type ProtocolKVStore_ByBlockID_Call struct {
	*mock.Call
}

// ByBlockID is a helper method to define mock.On call
//   - blockID flow.Identifier
func (_e *ProtocolKVStore_Expecter) ByBlockID(blockID interface{}) *ProtocolKVStore_ByBlockID_Call {
	return &ProtocolKVStore_ByBlockID_Call{Call: _e.mock.On("ByBlockID", blockID)}
}

func (_c *ProtocolKVStore_ByBlockID_Call) Run(run func(blockID flow.Identifier)) *ProtocolKVStore_ByBlockID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ProtocolKVStore_ByBlockID_Call) Return(pSKeyValueStoreData *flow.PSKeyValueStoreData, err error) *ProtocolKVStore_ByBlockID_Call {
	_c.Call.Return(pSKeyValueStoreData, err)
	return _c
}

func (_c *ProtocolKVStore_ByBlockID_Call) RunAndReturn(run func(blockID flow.Identifier) (*flow.PSKeyValueStoreData, error)) *ProtocolKVStore_ByBlockID_Call {
	_c.Call.Return(run)
	return _c
}

// ByID provides a mock function for the type ProtocolKVStore
func (_mock *ProtocolKVStore) ByID(id flow.Identifier) (*flow.PSKeyValueStoreData, error) {
	ret := _mock.Called(id)

	if len(ret) == 0 {
		panic("no return value specified for ByID")
	}

	var r0 *flow.PSKeyValueStoreData
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (*flow.PSKeyValueStoreData, error)); ok {
		return returnFunc(id)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) *flow.PSKeyValueStoreData); ok {
		r0 = returnFunc(id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.PSKeyValueStoreData)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ProtocolKVStore_ByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByID'
type ProtocolKVStore_ByID_Call struct {
	*mock.Call
}

// ByID is a helper method to define mock.On call
//   - id flow.Identifier
func (_e *ProtocolKVStore_Expecter) ByID(id interface{}) *ProtocolKVStore_ByID_Call {
	return &ProtocolKVStore_ByID_Call{Call: _e.mock.On("ByID", id)}
}

func (_c *ProtocolKVStore_ByID_Call) Run(run func(id flow.Identifier)) *ProtocolKVStore_ByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ProtocolKVStore_ByID_Call) Return(pSKeyValueStoreData *flow.PSKeyValueStoreData, err error) *ProtocolKVStore_ByID_Call {
	_c.Call.Return(pSKeyValueStoreData, err)
	return _c
}

func (_c *ProtocolKVStore_ByID_Call) RunAndReturn(run func(id flow.Identifier) (*flow.PSKeyValueStoreData, error)) *ProtocolKVStore_ByID_Call {
	_c.Call.Return(run)
	return _c
}

// NewQuorumCertificates creates a new instance of QuorumCertificates. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewQuorumCertificates(t interface {
	mock.TestingT
	Cleanup(func())
}) *QuorumCertificates {
	mock := &QuorumCertificates{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// QuorumCertificates is an autogenerated mock type for the QuorumCertificates type
type QuorumCertificates struct {
	mock.Mock
}

type QuorumCertificates_Expecter struct {
	mock *mock.Mock
}

func (_m *QuorumCertificates) EXPECT() *QuorumCertificates_Expecter {
	return &QuorumCertificates_Expecter{mock: &_m.Mock}
}

// BatchStore provides a mock function for the type QuorumCertificates
func (_mock *QuorumCertificates) BatchStore(proof lockctx.Proof, readerBatchWriter storage.ReaderBatchWriter, quorumCertificate *flow.QuorumCertificate) error {
	ret := _mock.Called(proof, readerBatchWriter, quorumCertificate)

	if len(ret) == 0 {
		panic("no return value specified for BatchStore")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(lockctx.Proof, storage.ReaderBatchWriter, *flow.QuorumCertificate) error); ok {
		r0 = returnFunc(proof, readerBatchWriter, quorumCertificate)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// QuorumCertificates_BatchStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BatchStore'
type QuorumCertificates_BatchStore_Call struct {
	*mock.Call
}

// BatchStore is a helper method to define mock.On call
//   - proof lockctx.Proof
//   - readerBatchWriter storage.ReaderBatchWriter
//   - quorumCertificate *flow.QuorumCertificate
func (_e *QuorumCertificates_Expecter) BatchStore(proof interface{}, readerBatchWriter interface{}, quorumCertificate interface{}) *QuorumCertificates_BatchStore_Call {
	return &QuorumCertificates_BatchStore_Call{Call: _e.mock.On("BatchStore", proof, readerBatchWriter, quorumCertificate)}
}

func (_c *QuorumCertificates_BatchStore_Call) Run(run func(proof lockctx.Proof, readerBatchWriter storage.ReaderBatchWriter, quorumCertificate *flow.QuorumCertificate)) *QuorumCertificates_BatchStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 lockctx.Proof
		if args[0] != nil {
			arg0 = args[0].(lockctx.Proof)
		}
		var arg1 storage.ReaderBatchWriter
		if args[1] != nil {
			arg1 = args[1].(storage.ReaderBatchWriter)
		}
		var arg2 *flow.QuorumCertificate
		if args[2] != nil {
			arg2 = args[2].(*flow.QuorumCertificate)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *QuorumCertificates_BatchStore_Call) Return(err error) *QuorumCertificates_BatchStore_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *QuorumCertificates_BatchStore_Call) RunAndReturn(run func(proof lockctx.Proof, readerBatchWriter storage.ReaderBatchWriter, quorumCertificate *flow.QuorumCertificate) error) *QuorumCertificates_BatchStore_Call {
	_c.Call.Return(run)
	return _c
}

// ByBlockID provides a mock function for the type QuorumCertificates
func (_mock *QuorumCertificates) ByBlockID(blockID flow.Identifier) (*flow.QuorumCertificate, error) {
	ret := _mock.Called(blockID)

	if len(ret) == 0 {
		panic("no return value specified for ByBlockID")
	}

	var r0 *flow.QuorumCertificate
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (*flow.QuorumCertificate, error)); ok {
		return returnFunc(blockID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) *flow.QuorumCertificate); ok {
		r0 = returnFunc(blockID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.QuorumCertificate)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(blockID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// QuorumCertificates_ByBlockID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByBlockID'
type QuorumCertificates_ByBlockID_Call struct {
	*mock.Call
}

// ByBlockID is a helper method to define mock.On call
//   - blockID flow.Identifier
func (_e *QuorumCertificates_Expecter) ByBlockID(blockID interface{}) *QuorumCertificates_ByBlockID_Call {
	return &QuorumCertificates_ByBlockID_Call{Call: _e.mock.On("ByBlockID", blockID)}
}

func (_c *QuorumCertificates_ByBlockID_Call) Run(run func(blockID flow.Identifier)) *QuorumCertificates_ByBlockID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *QuorumCertificates_ByBlockID_Call) Return(quorumCertificate *flow.QuorumCertificate, err error) *QuorumCertificates_ByBlockID_Call {
	_c.Call.Return(quorumCertificate, err)
	return _c
}

func (_c *QuorumCertificates_ByBlockID_Call) RunAndReturn(run func(blockID flow.Identifier) (*flow.QuorumCertificate, error)) *QuorumCertificates_ByBlockID_Call {
	_c.Call.Return(run)
	return _c
}

// NewExecutionReceipts creates a new instance of ExecutionReceipts. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewExecutionReceipts(t interface {
	mock.TestingT
	Cleanup(func())
}) *ExecutionReceipts {
	mock := &ExecutionReceipts{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// ExecutionReceipts is an autogenerated mock type for the ExecutionReceipts type
type ExecutionReceipts struct {
	mock.Mock
}

type ExecutionReceipts_Expecter struct {
	mock *mock.Mock
}

func (_m *ExecutionReceipts) EXPECT() *ExecutionReceipts_Expecter {
	return &ExecutionReceipts_Expecter{mock: &_m.Mock}
}

// BatchStore provides a mock function for the type ExecutionReceipts
func (_mock *ExecutionReceipts) BatchStore(receipt *flow.ExecutionReceipt, batch storage.ReaderBatchWriter) error {
	ret := _mock.Called(receipt, batch)

	if len(ret) == 0 {
		panic("no return value specified for BatchStore")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*flow.ExecutionReceipt, storage.ReaderBatchWriter) error); ok {
		r0 = returnFunc(receipt, batch)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ExecutionReceipts_BatchStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BatchStore'
type ExecutionReceipts_BatchStore_Call struct {
	*mock.Call
}

// BatchStore is a helper method to define mock.On call
//   - receipt *flow.ExecutionReceipt
//   - batch storage.ReaderBatchWriter
func (_e *ExecutionReceipts_Expecter) BatchStore(receipt interface{}, batch interface{}) *ExecutionReceipts_BatchStore_Call {
	return &ExecutionReceipts_BatchStore_Call{Call: _e.mock.On("BatchStore", receipt, batch)}
}

func (_c *ExecutionReceipts_BatchStore_Call) Run(run func(receipt *flow.ExecutionReceipt, batch storage.ReaderBatchWriter)) *ExecutionReceipts_BatchStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *flow.ExecutionReceipt
		if args[0] != nil {
			arg0 = args[0].(*flow.ExecutionReceipt)
		}
		var arg1 storage.ReaderBatchWriter
		if args[1] != nil {
			arg1 = args[1].(storage.ReaderBatchWriter)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ExecutionReceipts_BatchStore_Call) Return(err error) *ExecutionReceipts_BatchStore_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ExecutionReceipts_BatchStore_Call) RunAndReturn(run func(receipt *flow.ExecutionReceipt, batch storage.ReaderBatchWriter) error) *ExecutionReceipts_BatchStore_Call {
	_c.Call.Return(run)
	return _c
}

// ByBlockID provides a mock function for the type ExecutionReceipts
func (_mock *ExecutionReceipts) ByBlockID(blockID flow.Identifier) (flow.ExecutionReceiptList, error) {
	ret := _mock.Called(blockID)

	if len(ret) == 0 {
		panic("no return value specified for ByBlockID")
	}

	var r0 flow.ExecutionReceiptList
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (flow.ExecutionReceiptList, error)); ok {
		return returnFunc(blockID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) flow.ExecutionReceiptList); ok {
		r0 = returnFunc(blockID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.ExecutionReceiptList)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(blockID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ExecutionReceipts_ByBlockID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByBlockID'
type ExecutionReceipts_ByBlockID_Call struct {
	*mock.Call
}

// ByBlockID is a helper method to define mock.On call
//   - blockID flow.Identifier
func (_e *ExecutionReceipts_Expecter) ByBlockID(blockID interface{}) *ExecutionReceipts_ByBlockID_Call {
	return &ExecutionReceipts_ByBlockID_Call{Call: _e.mock.On("ByBlockID", blockID)}
}

func (_c *ExecutionReceipts_ByBlockID_Call) Run(run func(blockID flow.Identifier)) *ExecutionReceipts_ByBlockID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ExecutionReceipts_ByBlockID_Call) Return(executionReceiptList flow.ExecutionReceiptList, err error) *ExecutionReceipts_ByBlockID_Call {
	_c.Call.Return(executionReceiptList, err)
	return _c
}

func (_c *ExecutionReceipts_ByBlockID_Call) RunAndReturn(run func(blockID flow.Identifier) (flow.ExecutionReceiptList, error)) *ExecutionReceipts_ByBlockID_Call {
	_c.Call.Return(run)
	return _c
}

// ByID provides a mock function for the type ExecutionReceipts
func (_mock *ExecutionReceipts) ByID(receiptID flow.Identifier) (*flow.ExecutionReceipt, error) {
	ret := _mock.Called(receiptID)

	if len(ret) == 0 {
		panic("no return value specified for ByID")
	}

	var r0 *flow.ExecutionReceipt
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (*flow.ExecutionReceipt, error)); ok {
		return returnFunc(receiptID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) *flow.ExecutionReceipt); ok {
		r0 = returnFunc(receiptID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.ExecutionReceipt)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(receiptID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ExecutionReceipts_ByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByID'
type ExecutionReceipts_ByID_Call struct {
	*mock.Call
}

// ByID is a helper method to define mock.On call
//   - receiptID flow.Identifier
func (_e *ExecutionReceipts_Expecter) ByID(receiptID interface{}) *ExecutionReceipts_ByID_Call {
	return &ExecutionReceipts_ByID_Call{Call: _e.mock.On("ByID", receiptID)}
}

func (_c *ExecutionReceipts_ByID_Call) Run(run func(receiptID flow.Identifier)) *ExecutionReceipts_ByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ExecutionReceipts_ByID_Call) Return(executionReceipt *flow.ExecutionReceipt, err error) *ExecutionReceipts_ByID_Call {
	_c.Call.Return(executionReceipt, err)
	return _c
}

func (_c *ExecutionReceipts_ByID_Call) RunAndReturn(run func(receiptID flow.Identifier) (*flow.ExecutionReceipt, error)) *ExecutionReceipts_ByID_Call {
	_c.Call.Return(run)
	return _c
}

// Store provides a mock function for the type ExecutionReceipts
func (_mock *ExecutionReceipts) Store(receipt *flow.ExecutionReceipt) error {
	ret := _mock.Called(receipt)

	if len(ret) == 0 {
		panic("no return value specified for Store")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*flow.ExecutionReceipt) error); ok {
		r0 = returnFunc(receipt)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ExecutionReceipts_Store_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Store'
type ExecutionReceipts_Store_Call struct {
	*mock.Call
}

// Store is a helper method to define mock.On call
//   - receipt *flow.ExecutionReceipt
func (_e *ExecutionReceipts_Expecter) Store(receipt interface{}) *ExecutionReceipts_Store_Call {
	return &ExecutionReceipts_Store_Call{Call: _e.mock.On("Store", receipt)}
}

func (_c *ExecutionReceipts_Store_Call) Run(run func(receipt *flow.ExecutionReceipt)) *ExecutionReceipts_Store_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *flow.ExecutionReceipt
		if args[0] != nil {
			arg0 = args[0].(*flow.ExecutionReceipt)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ExecutionReceipts_Store_Call) Return(err error) *ExecutionReceipts_Store_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ExecutionReceipts_Store_Call) RunAndReturn(run func(receipt *flow.ExecutionReceipt) error) *ExecutionReceipts_Store_Call {
	_c.Call.Return(run)
	return _c
}

// NewMyExecutionReceipts creates a new instance of MyExecutionReceipts. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMyExecutionReceipts(t interface {
	mock.TestingT
	Cleanup(func())
}) *MyExecutionReceipts {
	mock := &MyExecutionReceipts{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MyExecutionReceipts is an autogenerated mock type for the MyExecutionReceipts type
type MyExecutionReceipts struct {
	mock.Mock
}

type MyExecutionReceipts_Expecter struct {
	mock *mock.Mock
}

func (_m *MyExecutionReceipts) EXPECT() *MyExecutionReceipts_Expecter {
	return &MyExecutionReceipts_Expecter{mock: &_m.Mock}
}

// BatchRemoveIndexByBlockID provides a mock function for the type MyExecutionReceipts
func (_mock *MyExecutionReceipts) BatchRemoveIndexByBlockID(blockID flow.Identifier, batch storage.ReaderBatchWriter) error {
	ret := _mock.Called(blockID, batch)

	if len(ret) == 0 {
		panic("no return value specified for BatchRemoveIndexByBlockID")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, storage.ReaderBatchWriter) error); ok {
		r0 = returnFunc(blockID, batch)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MyExecutionReceipts_BatchRemoveIndexByBlockID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BatchRemoveIndexByBlockID'
type MyExecutionReceipts_BatchRemoveIndexByBlockID_Call struct {
	*mock.Call
}

// BatchRemoveIndexByBlockID is a helper method to define mock.On call
//   - blockID flow.Identifier
//   - batch storage.ReaderBatchWriter
func (_e *MyExecutionReceipts_Expecter) BatchRemoveIndexByBlockID(blockID interface{}, batch interface{}) *MyExecutionReceipts_BatchRemoveIndexByBlockID_Call {
	return &MyExecutionReceipts_BatchRemoveIndexByBlockID_Call{Call: _e.mock.On("BatchRemoveIndexByBlockID", blockID, batch)}
}

func (_c *MyExecutionReceipts_BatchRemoveIndexByBlockID_Call) Run(run func(blockID flow.Identifier, batch storage.ReaderBatchWriter)) *MyExecutionReceipts_BatchRemoveIndexByBlockID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		var arg1 storage.ReaderBatchWriter
		if args[1] != nil {
			arg1 = args[1].(storage.ReaderBatchWriter)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MyExecutionReceipts_BatchRemoveIndexByBlockID_Call) Return(err error) *MyExecutionReceipts_BatchRemoveIndexByBlockID_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MyExecutionReceipts_BatchRemoveIndexByBlockID_Call) RunAndReturn(run func(blockID flow.Identifier, batch storage.ReaderBatchWriter) error) *MyExecutionReceipts_BatchRemoveIndexByBlockID_Call {
	_c.Call.Return(run)
	return _c
}

// BatchStoreMyReceipt provides a mock function for the type MyExecutionReceipts
func (_mock *MyExecutionReceipts) BatchStoreMyReceipt(lctx lockctx.Proof, receipt *flow.ExecutionReceipt, batch storage.ReaderBatchWriter) error {
	ret := _mock.Called(lctx, receipt, batch)

	if len(ret) == 0 {
		panic("no return value specified for BatchStoreMyReceipt")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(lockctx.Proof, *flow.ExecutionReceipt, storage.ReaderBatchWriter) error); ok {
		r0 = returnFunc(lctx, receipt, batch)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MyExecutionReceipts_BatchStoreMyReceipt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BatchStoreMyReceipt'
type MyExecutionReceipts_BatchStoreMyReceipt_Call struct {
	*mock.Call
}

// BatchStoreMyReceipt is a helper method to define mock.On call
//   - lctx lockctx.Proof
//   - receipt *flow.ExecutionReceipt
//   - batch storage.ReaderBatchWriter
func (_e *MyExecutionReceipts_Expecter) BatchStoreMyReceipt(lctx interface{}, receipt interface{}, batch interface{}) *MyExecutionReceipts_BatchStoreMyReceipt_Call {
	return &MyExecutionReceipts_BatchStoreMyReceipt_Call{Call: _e.mock.On("BatchStoreMyReceipt", lctx, receipt, batch)}
}

func (_c *MyExecutionReceipts_BatchStoreMyReceipt_Call) Run(run func(lctx lockctx.Proof, receipt *flow.ExecutionReceipt, batch storage.ReaderBatchWriter)) *MyExecutionReceipts_BatchStoreMyReceipt_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 lockctx.Proof
		if args[0] != nil {
			arg0 = args[0].(lockctx.Proof)
		}
		var arg1 *flow.ExecutionReceipt
		if args[1] != nil {
			arg1 = args[1].(*flow.ExecutionReceipt)
		}
		var arg2 storage.ReaderBatchWriter
		if args[2] != nil {
			arg2 = args[2].(storage.ReaderBatchWriter)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MyExecutionReceipts_BatchStoreMyReceipt_Call) Return(err error) *MyExecutionReceipts_BatchStoreMyReceipt_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MyExecutionReceipts_BatchStoreMyReceipt_Call) RunAndReturn(run func(lctx lockctx.Proof, receipt *flow.ExecutionReceipt, batch storage.ReaderBatchWriter) error) *MyExecutionReceipts_BatchStoreMyReceipt_Call {
	_c.Call.Return(run)
	return _c
}

// MyReceipt provides a mock function for the type MyExecutionReceipts
func (_mock *MyExecutionReceipts) MyReceipt(blockID flow.Identifier) (*flow.ExecutionReceipt, error) {
	ret := _mock.Called(blockID)

	if len(ret) == 0 {
		panic("no return value specified for MyReceipt")
	}

	var r0 *flow.ExecutionReceipt
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (*flow.ExecutionReceipt, error)); ok {
		return returnFunc(blockID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) *flow.ExecutionReceipt); ok {
		r0 = returnFunc(blockID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.ExecutionReceipt)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(blockID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MyExecutionReceipts_MyReceipt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MyReceipt'
type MyExecutionReceipts_MyReceipt_Call struct {
	*mock.Call
}

// MyReceipt is a helper method to define mock.On call
//   - blockID flow.Identifier
func (_e *MyExecutionReceipts_Expecter) MyReceipt(blockID interface{}) *MyExecutionReceipts_MyReceipt_Call {
	return &MyExecutionReceipts_MyReceipt_Call{Call: _e.mock.On("MyReceipt", blockID)}
}

func (_c *MyExecutionReceipts_MyReceipt_Call) Run(run func(blockID flow.Identifier)) *MyExecutionReceipts_MyReceipt_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MyExecutionReceipts_MyReceipt_Call) Return(executionReceipt *flow.ExecutionReceipt, err error) *MyExecutionReceipts_MyReceipt_Call {
	_c.Call.Return(executionReceipt, err)
	return _c
}

func (_c *MyExecutionReceipts_MyReceipt_Call) RunAndReturn(run func(blockID flow.Identifier) (*flow.ExecutionReceipt, error)) *MyExecutionReceipts_MyReceipt_Call {
	_c.Call.Return(run)
	return _c
}

// NewRegisterIndexReader creates a new instance of RegisterIndexReader. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewRegisterIndexReader(t interface {
	mock.TestingT
	Cleanup(func())
}) *RegisterIndexReader {
	mock := &RegisterIndexReader{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// RegisterIndexReader is an autogenerated mock type for the RegisterIndexReader type
type RegisterIndexReader struct {
	mock.Mock
}

type RegisterIndexReader_Expecter struct {
	mock *mock.Mock
}

func (_m *RegisterIndexReader) EXPECT() *RegisterIndexReader_Expecter {
	return &RegisterIndexReader_Expecter{mock: &_m.Mock}
}

// FirstHeight provides a mock function for the type RegisterIndexReader
func (_mock *RegisterIndexReader) FirstHeight() uint64 {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for FirstHeight")
	}

	var r0 uint64
	if returnFunc, ok := ret.Get(0).(func() uint64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint64)
	}
	return r0
}

// RegisterIndexReader_FirstHeight_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FirstHeight'
type RegisterIndexReader_FirstHeight_Call struct {
	*mock.Call
}

// FirstHeight is a helper method to define mock.On call
func (_e *RegisterIndexReader_Expecter) FirstHeight() *RegisterIndexReader_FirstHeight_Call {
	return &RegisterIndexReader_FirstHeight_Call{Call: _e.mock.On("FirstHeight")}
}

func (_c *RegisterIndexReader_FirstHeight_Call) Run(run func()) *RegisterIndexReader_FirstHeight_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *RegisterIndexReader_FirstHeight_Call) Return(v uint64) *RegisterIndexReader_FirstHeight_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *RegisterIndexReader_FirstHeight_Call) RunAndReturn(run func() uint64) *RegisterIndexReader_FirstHeight_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function for the type RegisterIndexReader
func (_mock *RegisterIndexReader) Get(ID flow.RegisterID, height uint64) (flow.RegisterValue, error) {
	ret := _mock.Called(ID, height)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 flow.RegisterValue
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.RegisterID, uint64) (flow.RegisterValue, error)); ok {
		return returnFunc(ID, height)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.RegisterID, uint64) flow.RegisterValue); ok {
		r0 = returnFunc(ID, height)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.RegisterValue)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.RegisterID, uint64) error); ok {
		r1 = returnFunc(ID, height)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// RegisterIndexReader_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type RegisterIndexReader_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - ID flow.RegisterID
//   - height uint64
func (_e *RegisterIndexReader_Expecter) Get(ID interface{}, height interface{}) *RegisterIndexReader_Get_Call {
	return &RegisterIndexReader_Get_Call{Call: _e.mock.On("Get", ID, height)}
}

func (_c *RegisterIndexReader_Get_Call) Run(run func(ID flow.RegisterID, height uint64)) *RegisterIndexReader_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.RegisterID
		if args[0] != nil {
			arg0 = args[0].(flow.RegisterID)
		}
		var arg1 uint64
		if args[1] != nil {
			arg1 = args[1].(uint64)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *RegisterIndexReader_Get_Call) Return(v flow.RegisterValue, err error) *RegisterIndexReader_Get_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *RegisterIndexReader_Get_Call) RunAndReturn(run func(ID flow.RegisterID, height uint64) (flow.RegisterValue, error)) *RegisterIndexReader_Get_Call {
	_c.Call.Return(run)
	return _c
}

// LatestHeight provides a mock function for the type RegisterIndexReader
func (_mock *RegisterIndexReader) LatestHeight() uint64 {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for LatestHeight")
	}

	var r0 uint64
	if returnFunc, ok := ret.Get(0).(func() uint64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint64)
	}
	return r0
}

// RegisterIndexReader_LatestHeight_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LatestHeight'
type RegisterIndexReader_LatestHeight_Call struct {
	*mock.Call
}

// LatestHeight is a helper method to define mock.On call
func (_e *RegisterIndexReader_Expecter) LatestHeight() *RegisterIndexReader_LatestHeight_Call {
	return &RegisterIndexReader_LatestHeight_Call{Call: _e.mock.On("LatestHeight")}
}

func (_c *RegisterIndexReader_LatestHeight_Call) Run(run func()) *RegisterIndexReader_LatestHeight_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *RegisterIndexReader_LatestHeight_Call) Return(v uint64) *RegisterIndexReader_LatestHeight_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *RegisterIndexReader_LatestHeight_Call) RunAndReturn(run func() uint64) *RegisterIndexReader_LatestHeight_Call {
	_c.Call.Return(run)
	return _c
}

// NewRegisterIndex creates a new instance of RegisterIndex. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewRegisterIndex(t interface {
	mock.TestingT
	Cleanup(func())
}) *RegisterIndex {
	mock := &RegisterIndex{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// RegisterIndex is an autogenerated mock type for the RegisterIndex type
type RegisterIndex struct {
	mock.Mock
}

type RegisterIndex_Expecter struct {
	mock *mock.Mock
}

func (_m *RegisterIndex) EXPECT() *RegisterIndex_Expecter {
	return &RegisterIndex_Expecter{mock: &_m.Mock}
}

// FirstHeight provides a mock function for the type RegisterIndex
func (_mock *RegisterIndex) FirstHeight() uint64 {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for FirstHeight")
	}

	var r0 uint64
	if returnFunc, ok := ret.Get(0).(func() uint64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint64)
	}
	return r0
}

// RegisterIndex_FirstHeight_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FirstHeight'
type RegisterIndex_FirstHeight_Call struct {
	*mock.Call
}

// FirstHeight is a helper method to define mock.On call
func (_e *RegisterIndex_Expecter) FirstHeight() *RegisterIndex_FirstHeight_Call {
	return &RegisterIndex_FirstHeight_Call{Call: _e.mock.On("FirstHeight")}
}

func (_c *RegisterIndex_FirstHeight_Call) Run(run func()) *RegisterIndex_FirstHeight_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *RegisterIndex_FirstHeight_Call) Return(v uint64) *RegisterIndex_FirstHeight_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *RegisterIndex_FirstHeight_Call) RunAndReturn(run func() uint64) *RegisterIndex_FirstHeight_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function for the type RegisterIndex
func (_mock *RegisterIndex) Get(ID flow.RegisterID, height uint64) (flow.RegisterValue, error) {
	ret := _mock.Called(ID, height)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 flow.RegisterValue
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.RegisterID, uint64) (flow.RegisterValue, error)); ok {
		return returnFunc(ID, height)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.RegisterID, uint64) flow.RegisterValue); ok {
		r0 = returnFunc(ID, height)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.RegisterValue)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.RegisterID, uint64) error); ok {
		r1 = returnFunc(ID, height)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// RegisterIndex_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type RegisterIndex_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - ID flow.RegisterID
//   - height uint64
func (_e *RegisterIndex_Expecter) Get(ID interface{}, height interface{}) *RegisterIndex_Get_Call {
	return &RegisterIndex_Get_Call{Call: _e.mock.On("Get", ID, height)}
}

func (_c *RegisterIndex_Get_Call) Run(run func(ID flow.RegisterID, height uint64)) *RegisterIndex_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.RegisterID
		if args[0] != nil {
			arg0 = args[0].(flow.RegisterID)
		}
		var arg1 uint64
		if args[1] != nil {
			arg1 = args[1].(uint64)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *RegisterIndex_Get_Call) Return(v flow.RegisterValue, err error) *RegisterIndex_Get_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *RegisterIndex_Get_Call) RunAndReturn(run func(ID flow.RegisterID, height uint64) (flow.RegisterValue, error)) *RegisterIndex_Get_Call {
	_c.Call.Return(run)
	return _c
}

// LatestHeight provides a mock function for the type RegisterIndex
func (_mock *RegisterIndex) LatestHeight() uint64 {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for LatestHeight")
	}

	var r0 uint64
	if returnFunc, ok := ret.Get(0).(func() uint64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint64)
	}
	return r0
}

// RegisterIndex_LatestHeight_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LatestHeight'
type RegisterIndex_LatestHeight_Call struct {
	*mock.Call
}

// LatestHeight is a helper method to define mock.On call
func (_e *RegisterIndex_Expecter) LatestHeight() *RegisterIndex_LatestHeight_Call {
	return &RegisterIndex_LatestHeight_Call{Call: _e.mock.On("LatestHeight")}
}

func (_c *RegisterIndex_LatestHeight_Call) Run(run func()) *RegisterIndex_LatestHeight_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *RegisterIndex_LatestHeight_Call) Return(v uint64) *RegisterIndex_LatestHeight_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *RegisterIndex_LatestHeight_Call) RunAndReturn(run func() uint64) *RegisterIndex_LatestHeight_Call {
	_c.Call.Return(run)
	return _c
}

// Store provides a mock function for the type RegisterIndex
func (_mock *RegisterIndex) Store(entries flow.RegisterEntries, height uint64) error {
	ret := _mock.Called(entries, height)

	if len(ret) == 0 {
		panic("no return value specified for Store")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(flow.RegisterEntries, uint64) error); ok {
		r0 = returnFunc(entries, height)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// RegisterIndex_Store_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Store'
type RegisterIndex_Store_Call struct {
	*mock.Call
}

// Store is a helper method to define mock.On call
//   - entries flow.RegisterEntries
//   - height uint64
func (_e *RegisterIndex_Expecter) Store(entries interface{}, height interface{}) *RegisterIndex_Store_Call {
	return &RegisterIndex_Store_Call{Call: _e.mock.On("Store", entries, height)}
}

func (_c *RegisterIndex_Store_Call) Run(run func(entries flow.RegisterEntries, height uint64)) *RegisterIndex_Store_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.RegisterEntries
		if args[0] != nil {
			arg0 = args[0].(flow.RegisterEntries)
		}
		var arg1 uint64
		if args[1] != nil {
			arg1 = args[1].(uint64)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *RegisterIndex_Store_Call) Return(err error) *RegisterIndex_Store_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *RegisterIndex_Store_Call) RunAndReturn(run func(entries flow.RegisterEntries, height uint64) error) *RegisterIndex_Store_Call {
	_c.Call.Return(run)
	return _c
}

// NewExecutionResultsReader creates a new instance of ExecutionResultsReader. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewExecutionResultsReader(t interface {
	mock.TestingT
	Cleanup(func())
}) *ExecutionResultsReader {
	mock := &ExecutionResultsReader{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// ExecutionResultsReader is an autogenerated mock type for the ExecutionResultsReader type
type ExecutionResultsReader struct {
	mock.Mock
}

type ExecutionResultsReader_Expecter struct {
	mock *mock.Mock
}

func (_m *ExecutionResultsReader) EXPECT() *ExecutionResultsReader_Expecter {
	return &ExecutionResultsReader_Expecter{mock: &_m.Mock}
}

// ByBlockID provides a mock function for the type ExecutionResultsReader
func (_mock *ExecutionResultsReader) ByBlockID(blockID flow.Identifier) (*flow.ExecutionResult, error) {
	ret := _mock.Called(blockID)

	if len(ret) == 0 {
		panic("no return value specified for ByBlockID")
	}

	var r0 *flow.ExecutionResult
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (*flow.ExecutionResult, error)); ok {
		return returnFunc(blockID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) *flow.ExecutionResult); ok {
		r0 = returnFunc(blockID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.ExecutionResult)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(blockID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ExecutionResultsReader_ByBlockID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByBlockID'
type ExecutionResultsReader_ByBlockID_Call struct {
	*mock.Call
}

// ByBlockID is a helper method to define mock.On call
//   - blockID flow.Identifier
func (_e *ExecutionResultsReader_Expecter) ByBlockID(blockID interface{}) *ExecutionResultsReader_ByBlockID_Call {
	return &ExecutionResultsReader_ByBlockID_Call{Call: _e.mock.On("ByBlockID", blockID)}
}

func (_c *ExecutionResultsReader_ByBlockID_Call) Run(run func(blockID flow.Identifier)) *ExecutionResultsReader_ByBlockID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ExecutionResultsReader_ByBlockID_Call) Return(executionResult *flow.ExecutionResult, err error) *ExecutionResultsReader_ByBlockID_Call {
	_c.Call.Return(executionResult, err)
	return _c
}

func (_c *ExecutionResultsReader_ByBlockID_Call) RunAndReturn(run func(blockID flow.Identifier) (*flow.ExecutionResult, error)) *ExecutionResultsReader_ByBlockID_Call {
	_c.Call.Return(run)
	return _c
}

// ByID provides a mock function for the type ExecutionResultsReader
func (_mock *ExecutionResultsReader) ByID(resultID flow.Identifier) (*flow.ExecutionResult, error) {
	ret := _mock.Called(resultID)

	if len(ret) == 0 {
		panic("no return value specified for ByID")
	}

	var r0 *flow.ExecutionResult
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (*flow.ExecutionResult, error)); ok {
		return returnFunc(resultID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) *flow.ExecutionResult); ok {
		r0 = returnFunc(resultID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.ExecutionResult)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(resultID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ExecutionResultsReader_ByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByID'
type ExecutionResultsReader_ByID_Call struct {
	*mock.Call
}

// ByID is a helper method to define mock.On call
//   - resultID flow.Identifier
func (_e *ExecutionResultsReader_Expecter) ByID(resultID interface{}) *ExecutionResultsReader_ByID_Call {
	return &ExecutionResultsReader_ByID_Call{Call: _e.mock.On("ByID", resultID)}
}

func (_c *ExecutionResultsReader_ByID_Call) Run(run func(resultID flow.Identifier)) *ExecutionResultsReader_ByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ExecutionResultsReader_ByID_Call) Return(executionResult *flow.ExecutionResult, err error) *ExecutionResultsReader_ByID_Call {
	_c.Call.Return(executionResult, err)
	return _c
}

func (_c *ExecutionResultsReader_ByID_Call) RunAndReturn(run func(resultID flow.Identifier) (*flow.ExecutionResult, error)) *ExecutionResultsReader_ByID_Call {
	_c.Call.Return(run)
	return _c
}

// IDByBlockID provides a mock function for the type ExecutionResultsReader
func (_mock *ExecutionResultsReader) IDByBlockID(blockID flow.Identifier) (flow.Identifier, error) {
	ret := _mock.Called(blockID)

	if len(ret) == 0 {
		panic("no return value specified for IDByBlockID")
	}

	var r0 flow.Identifier
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (flow.Identifier, error)); ok {
		return returnFunc(blockID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) flow.Identifier); ok {
		r0 = returnFunc(blockID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.Identifier)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(blockID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ExecutionResultsReader_IDByBlockID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IDByBlockID'
type ExecutionResultsReader_IDByBlockID_Call struct {
	*mock.Call
}

// IDByBlockID is a helper method to define mock.On call
//   - blockID flow.Identifier
func (_e *ExecutionResultsReader_Expecter) IDByBlockID(blockID interface{}) *ExecutionResultsReader_IDByBlockID_Call {
	return &ExecutionResultsReader_IDByBlockID_Call{Call: _e.mock.On("IDByBlockID", blockID)}
}

func (_c *ExecutionResultsReader_IDByBlockID_Call) Run(run func(blockID flow.Identifier)) *ExecutionResultsReader_IDByBlockID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ExecutionResultsReader_IDByBlockID_Call) Return(identifier flow.Identifier, err error) *ExecutionResultsReader_IDByBlockID_Call {
	_c.Call.Return(identifier, err)
	return _c
}

func (_c *ExecutionResultsReader_IDByBlockID_Call) RunAndReturn(run func(blockID flow.Identifier) (flow.Identifier, error)) *ExecutionResultsReader_IDByBlockID_Call {
	_c.Call.Return(run)
	return _c
}

// NewExecutionResults creates a new instance of ExecutionResults. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewExecutionResults(t interface {
	mock.TestingT
	Cleanup(func())
}) *ExecutionResults {
	mock := &ExecutionResults{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// ExecutionResults is an autogenerated mock type for the ExecutionResults type
type ExecutionResults struct {
	mock.Mock
}

type ExecutionResults_Expecter struct {
	mock *mock.Mock
}

func (_m *ExecutionResults) EXPECT() *ExecutionResults_Expecter {
	return &ExecutionResults_Expecter{mock: &_m.Mock}
}

// BatchIndex provides a mock function for the type ExecutionResults
func (_mock *ExecutionResults) BatchIndex(lctx lockctx.Proof, rw storage.ReaderBatchWriter, blockID flow.Identifier, resultID flow.Identifier) error {
	ret := _mock.Called(lctx, rw, blockID, resultID)

	if len(ret) == 0 {
		panic("no return value specified for BatchIndex")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(lockctx.Proof, storage.ReaderBatchWriter, flow.Identifier, flow.Identifier) error); ok {
		r0 = returnFunc(lctx, rw, blockID, resultID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ExecutionResults_BatchIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BatchIndex'
type ExecutionResults_BatchIndex_Call struct {
	*mock.Call
}

// BatchIndex is a helper method to define mock.On call
//   - lctx lockctx.Proof
//   - rw storage.ReaderBatchWriter
//   - blockID flow.Identifier
//   - resultID flow.Identifier
func (_e *ExecutionResults_Expecter) BatchIndex(lctx interface{}, rw interface{}, blockID interface{}, resultID interface{}) *ExecutionResults_BatchIndex_Call {
	return &ExecutionResults_BatchIndex_Call{Call: _e.mock.On("BatchIndex", lctx, rw, blockID, resultID)}
}

func (_c *ExecutionResults_BatchIndex_Call) Run(run func(lctx lockctx.Proof, rw storage.ReaderBatchWriter, blockID flow.Identifier, resultID flow.Identifier)) *ExecutionResults_BatchIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 lockctx.Proof
		if args[0] != nil {
			arg0 = args[0].(lockctx.Proof)
		}
		var arg1 storage.ReaderBatchWriter
		if args[1] != nil {
			arg1 = args[1].(storage.ReaderBatchWriter)
		}
		var arg2 flow.Identifier
		if args[2] != nil {
			arg2 = args[2].(flow.Identifier)
		}
		var arg3 flow.Identifier
		if args[3] != nil {
			arg3 = args[3].(flow.Identifier)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *ExecutionResults_BatchIndex_Call) Return(err error) *ExecutionResults_BatchIndex_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ExecutionResults_BatchIndex_Call) RunAndReturn(run func(lctx lockctx.Proof, rw storage.ReaderBatchWriter, blockID flow.Identifier, resultID flow.Identifier) error) *ExecutionResults_BatchIndex_Call {
	_c.Call.Return(run)
	return _c
}

// BatchRemoveIndexByBlockID provides a mock function for the type ExecutionResults
func (_mock *ExecutionResults) BatchRemoveIndexByBlockID(blockID flow.Identifier, batch storage.ReaderBatchWriter) error {
	ret := _mock.Called(blockID, batch)

	if len(ret) == 0 {
		panic("no return value specified for BatchRemoveIndexByBlockID")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, storage.ReaderBatchWriter) error); ok {
		r0 = returnFunc(blockID, batch)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ExecutionResults_BatchRemoveIndexByBlockID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BatchRemoveIndexByBlockID'
type ExecutionResults_BatchRemoveIndexByBlockID_Call struct {
	*mock.Call
}

// BatchRemoveIndexByBlockID is a helper method to define mock.On call
//   - blockID flow.Identifier
//   - batch storage.ReaderBatchWriter
func (_e *ExecutionResults_Expecter) BatchRemoveIndexByBlockID(blockID interface{}, batch interface{}) *ExecutionResults_BatchRemoveIndexByBlockID_Call {
	return &ExecutionResults_BatchRemoveIndexByBlockID_Call{Call: _e.mock.On("BatchRemoveIndexByBlockID", blockID, batch)}
}

func (_c *ExecutionResults_BatchRemoveIndexByBlockID_Call) Run(run func(blockID flow.Identifier, batch storage.ReaderBatchWriter)) *ExecutionResults_BatchRemoveIndexByBlockID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		var arg1 storage.ReaderBatchWriter
		if args[1] != nil {
			arg1 = args[1].(storage.ReaderBatchWriter)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ExecutionResults_BatchRemoveIndexByBlockID_Call) Return(err error) *ExecutionResults_BatchRemoveIndexByBlockID_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ExecutionResults_BatchRemoveIndexByBlockID_Call) RunAndReturn(run func(blockID flow.Identifier, batch storage.ReaderBatchWriter) error) *ExecutionResults_BatchRemoveIndexByBlockID_Call {
	_c.Call.Return(run)
	return _c
}

// BatchStore provides a mock function for the type ExecutionResults
func (_mock *ExecutionResults) BatchStore(result *flow.ExecutionResult, batch storage.ReaderBatchWriter) error {
	ret := _mock.Called(result, batch)

	if len(ret) == 0 {
		panic("no return value specified for BatchStore")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*flow.ExecutionResult, storage.ReaderBatchWriter) error); ok {
		r0 = returnFunc(result, batch)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ExecutionResults_BatchStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BatchStore'
type ExecutionResults_BatchStore_Call struct {
	*mock.Call
}

// BatchStore is a helper method to define mock.On call
//   - result *flow.ExecutionResult
//   - batch storage.ReaderBatchWriter
func (_e *ExecutionResults_Expecter) BatchStore(result interface{}, batch interface{}) *ExecutionResults_BatchStore_Call {
	return &ExecutionResults_BatchStore_Call{Call: _e.mock.On("BatchStore", result, batch)}
}

func (_c *ExecutionResults_BatchStore_Call) Run(run func(result *flow.ExecutionResult, batch storage.ReaderBatchWriter)) *ExecutionResults_BatchStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *flow.ExecutionResult
		if args[0] != nil {
			arg0 = args[0].(*flow.ExecutionResult)
		}
		var arg1 storage.ReaderBatchWriter
		if args[1] != nil {
			arg1 = args[1].(storage.ReaderBatchWriter)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ExecutionResults_BatchStore_Call) Return(err error) *ExecutionResults_BatchStore_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ExecutionResults_BatchStore_Call) RunAndReturn(run func(result *flow.ExecutionResult, batch storage.ReaderBatchWriter) error) *ExecutionResults_BatchStore_Call {
	_c.Call.Return(run)
	return _c
}

// ByBlockID provides a mock function for the type ExecutionResults
func (_mock *ExecutionResults) ByBlockID(blockID flow.Identifier) (*flow.ExecutionResult, error) {
	ret := _mock.Called(blockID)

	if len(ret) == 0 {
		panic("no return value specified for ByBlockID")
	}

	var r0 *flow.ExecutionResult
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (*flow.ExecutionResult, error)); ok {
		return returnFunc(blockID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) *flow.ExecutionResult); ok {
		r0 = returnFunc(blockID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.ExecutionResult)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(blockID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ExecutionResults_ByBlockID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByBlockID'
type ExecutionResults_ByBlockID_Call struct {
	*mock.Call
}

// ByBlockID is a helper method to define mock.On call
//   - blockID flow.Identifier
func (_e *ExecutionResults_Expecter) ByBlockID(blockID interface{}) *ExecutionResults_ByBlockID_Call {
	return &ExecutionResults_ByBlockID_Call{Call: _e.mock.On("ByBlockID", blockID)}
}

func (_c *ExecutionResults_ByBlockID_Call) Run(run func(blockID flow.Identifier)) *ExecutionResults_ByBlockID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ExecutionResults_ByBlockID_Call) Return(executionResult *flow.ExecutionResult, err error) *ExecutionResults_ByBlockID_Call {
	_c.Call.Return(executionResult, err)
	return _c
}

func (_c *ExecutionResults_ByBlockID_Call) RunAndReturn(run func(blockID flow.Identifier) (*flow.ExecutionResult, error)) *ExecutionResults_ByBlockID_Call {
	_c.Call.Return(run)
	return _c
}

// ByID provides a mock function for the type ExecutionResults
func (_mock *ExecutionResults) ByID(resultID flow.Identifier) (*flow.ExecutionResult, error) {
	ret := _mock.Called(resultID)

	if len(ret) == 0 {
		panic("no return value specified for ByID")
	}

	var r0 *flow.ExecutionResult
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (*flow.ExecutionResult, error)); ok {
		return returnFunc(resultID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) *flow.ExecutionResult); ok {
		r0 = returnFunc(resultID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.ExecutionResult)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(resultID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ExecutionResults_ByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByID'
type ExecutionResults_ByID_Call struct {
	*mock.Call
}

// ByID is a helper method to define mock.On call
//   - resultID flow.Identifier
func (_e *ExecutionResults_Expecter) ByID(resultID interface{}) *ExecutionResults_ByID_Call {
	return &ExecutionResults_ByID_Call{Call: _e.mock.On("ByID", resultID)}
}

func (_c *ExecutionResults_ByID_Call) Run(run func(resultID flow.Identifier)) *ExecutionResults_ByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ExecutionResults_ByID_Call) Return(executionResult *flow.ExecutionResult, err error) *ExecutionResults_ByID_Call {
	_c.Call.Return(executionResult, err)
	return _c
}

func (_c *ExecutionResults_ByID_Call) RunAndReturn(run func(resultID flow.Identifier) (*flow.ExecutionResult, error)) *ExecutionResults_ByID_Call {
	_c.Call.Return(run)
	return _c
}

// IDByBlockID provides a mock function for the type ExecutionResults
func (_mock *ExecutionResults) IDByBlockID(blockID flow.Identifier) (flow.Identifier, error) {
	ret := _mock.Called(blockID)

	if len(ret) == 0 {
		panic("no return value specified for IDByBlockID")
	}

	var r0 flow.Identifier
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (flow.Identifier, error)); ok {
		return returnFunc(blockID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) flow.Identifier); ok {
		r0 = returnFunc(blockID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.Identifier)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(blockID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ExecutionResults_IDByBlockID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IDByBlockID'
type ExecutionResults_IDByBlockID_Call struct {
	*mock.Call
}

// IDByBlockID is a helper method to define mock.On call
//   - blockID flow.Identifier
func (_e *ExecutionResults_Expecter) IDByBlockID(blockID interface{}) *ExecutionResults_IDByBlockID_Call {
	return &ExecutionResults_IDByBlockID_Call{Call: _e.mock.On("IDByBlockID", blockID)}
}

func (_c *ExecutionResults_IDByBlockID_Call) Run(run func(blockID flow.Identifier)) *ExecutionResults_IDByBlockID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ExecutionResults_IDByBlockID_Call) Return(identifier flow.Identifier, err error) *ExecutionResults_IDByBlockID_Call {
	_c.Call.Return(identifier, err)
	return _c
}

func (_c *ExecutionResults_IDByBlockID_Call) RunAndReturn(run func(blockID flow.Identifier) (flow.Identifier, error)) *ExecutionResults_IDByBlockID_Call {
	_c.Call.Return(run)
	return _c
}

// NewScheduledTransactionsReader creates a new instance of ScheduledTransactionsReader. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewScheduledTransactionsReader(t interface {
	mock.TestingT
	Cleanup(func())
}) *ScheduledTransactionsReader {
	mock := &ScheduledTransactionsReader{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// ScheduledTransactionsReader is an autogenerated mock type for the ScheduledTransactionsReader type
type ScheduledTransactionsReader struct {
	mock.Mock
}

type ScheduledTransactionsReader_Expecter struct {
	mock *mock.Mock
}

func (_m *ScheduledTransactionsReader) EXPECT() *ScheduledTransactionsReader_Expecter {
	return &ScheduledTransactionsReader_Expecter{mock: &_m.Mock}
}

// BlockIDByTransactionID provides a mock function for the type ScheduledTransactionsReader
func (_mock *ScheduledTransactionsReader) BlockIDByTransactionID(txID flow.Identifier) (flow.Identifier, error) {
	ret := _mock.Called(txID)

	if len(ret) == 0 {
		panic("no return value specified for BlockIDByTransactionID")
	}

	var r0 flow.Identifier
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (flow.Identifier, error)); ok {
		return returnFunc(txID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) flow.Identifier); ok {
		r0 = returnFunc(txID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.Identifier)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(txID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ScheduledTransactionsReader_BlockIDByTransactionID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BlockIDByTransactionID'
type ScheduledTransactionsReader_BlockIDByTransactionID_Call struct {
	*mock.Call
}

// BlockIDByTransactionID is a helper method to define mock.On call
//   - txID flow.Identifier
func (_e *ScheduledTransactionsReader_Expecter) BlockIDByTransactionID(txID interface{}) *ScheduledTransactionsReader_BlockIDByTransactionID_Call {
	return &ScheduledTransactionsReader_BlockIDByTransactionID_Call{Call: _e.mock.On("BlockIDByTransactionID", txID)}
}

func (_c *ScheduledTransactionsReader_BlockIDByTransactionID_Call) Run(run func(txID flow.Identifier)) *ScheduledTransactionsReader_BlockIDByTransactionID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ScheduledTransactionsReader_BlockIDByTransactionID_Call) Return(identifier flow.Identifier, err error) *ScheduledTransactionsReader_BlockIDByTransactionID_Call {
	_c.Call.Return(identifier, err)
	return _c
}

func (_c *ScheduledTransactionsReader_BlockIDByTransactionID_Call) RunAndReturn(run func(txID flow.Identifier) (flow.Identifier, error)) *ScheduledTransactionsReader_BlockIDByTransactionID_Call {
	_c.Call.Return(run)
	return _c
}

// TransactionIDByID provides a mock function for the type ScheduledTransactionsReader
func (_mock *ScheduledTransactionsReader) TransactionIDByID(scheduledTxID uint64) (flow.Identifier, error) {
	ret := _mock.Called(scheduledTxID)

	if len(ret) == 0 {
		panic("no return value specified for TransactionIDByID")
	}

	var r0 flow.Identifier
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(uint64) (flow.Identifier, error)); ok {
		return returnFunc(scheduledTxID)
	}
	if returnFunc, ok := ret.Get(0).(func(uint64) flow.Identifier); ok {
		r0 = returnFunc(scheduledTxID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.Identifier)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(uint64) error); ok {
		r1 = returnFunc(scheduledTxID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ScheduledTransactionsReader_TransactionIDByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TransactionIDByID'
type ScheduledTransactionsReader_TransactionIDByID_Call struct {
	*mock.Call
}

// TransactionIDByID is a helper method to define mock.On call
//   - scheduledTxID uint64
func (_e *ScheduledTransactionsReader_Expecter) TransactionIDByID(scheduledTxID interface{}) *ScheduledTransactionsReader_TransactionIDByID_Call {
	return &ScheduledTransactionsReader_TransactionIDByID_Call{Call: _e.mock.On("TransactionIDByID", scheduledTxID)}
}

func (_c *ScheduledTransactionsReader_TransactionIDByID_Call) Run(run func(scheduledTxID uint64)) *ScheduledTransactionsReader_TransactionIDByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ScheduledTransactionsReader_TransactionIDByID_Call) Return(identifier flow.Identifier, err error) *ScheduledTransactionsReader_TransactionIDByID_Call {
	_c.Call.Return(identifier, err)
	return _c
}

func (_c *ScheduledTransactionsReader_TransactionIDByID_Call) RunAndReturn(run func(scheduledTxID uint64) (flow.Identifier, error)) *ScheduledTransactionsReader_TransactionIDByID_Call {
	_c.Call.Return(run)
	return _c
}

// NewScheduledTransactions creates a new instance of ScheduledTransactions. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewScheduledTransactions(t interface {
	mock.TestingT
	Cleanup(func())
}) *ScheduledTransactions {
	mock := &ScheduledTransactions{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// ScheduledTransactions is an autogenerated mock type for the ScheduledTransactions type
type ScheduledTransactions struct {
	mock.Mock
}

type ScheduledTransactions_Expecter struct {
	mock *mock.Mock
}

func (_m *ScheduledTransactions) EXPECT() *ScheduledTransactions_Expecter {
	return &ScheduledTransactions_Expecter{mock: &_m.Mock}
}

// BatchIndex provides a mock function for the type ScheduledTransactions
func (_mock *ScheduledTransactions) BatchIndex(lctx lockctx.Proof, blockID flow.Identifier, txID flow.Identifier, scheduledTxID uint64, batch storage.ReaderBatchWriter) error {
	ret := _mock.Called(lctx, blockID, txID, scheduledTxID, batch)

	if len(ret) == 0 {
		panic("no return value specified for BatchIndex")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(lockctx.Proof, flow.Identifier, flow.Identifier, uint64, storage.ReaderBatchWriter) error); ok {
		r0 = returnFunc(lctx, blockID, txID, scheduledTxID, batch)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ScheduledTransactions_BatchIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BatchIndex'
type ScheduledTransactions_BatchIndex_Call struct {
	*mock.Call
}

// BatchIndex is a helper method to define mock.On call
//   - lctx lockctx.Proof
//   - blockID flow.Identifier
//   - txID flow.Identifier
//   - scheduledTxID uint64
//   - batch storage.ReaderBatchWriter
func (_e *ScheduledTransactions_Expecter) BatchIndex(lctx interface{}, blockID interface{}, txID interface{}, scheduledTxID interface{}, batch interface{}) *ScheduledTransactions_BatchIndex_Call {
	return &ScheduledTransactions_BatchIndex_Call{Call: _e.mock.On("BatchIndex", lctx, blockID, txID, scheduledTxID, batch)}
}

func (_c *ScheduledTransactions_BatchIndex_Call) Run(run func(lctx lockctx.Proof, blockID flow.Identifier, txID flow.Identifier, scheduledTxID uint64, batch storage.ReaderBatchWriter)) *ScheduledTransactions_BatchIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 lockctx.Proof
		if args[0] != nil {
			arg0 = args[0].(lockctx.Proof)
		}
		var arg1 flow.Identifier
		if args[1] != nil {
			arg1 = args[1].(flow.Identifier)
		}
		var arg2 flow.Identifier
		if args[2] != nil {
			arg2 = args[2].(flow.Identifier)
		}
		var arg3 uint64
		if args[3] != nil {
			arg3 = args[3].(uint64)
		}
		var arg4 storage.ReaderBatchWriter
		if args[4] != nil {
			arg4 = args[4].(storage.ReaderBatchWriter)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *ScheduledTransactions_BatchIndex_Call) Return(err error) *ScheduledTransactions_BatchIndex_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ScheduledTransactions_BatchIndex_Call) RunAndReturn(run func(lctx lockctx.Proof, blockID flow.Identifier, txID flow.Identifier, scheduledTxID uint64, batch storage.ReaderBatchWriter) error) *ScheduledTransactions_BatchIndex_Call {
	_c.Call.Return(run)
	return _c
}

// BlockIDByTransactionID provides a mock function for the type ScheduledTransactions
func (_mock *ScheduledTransactions) BlockIDByTransactionID(txID flow.Identifier) (flow.Identifier, error) {
	ret := _mock.Called(txID)

	if len(ret) == 0 {
		panic("no return value specified for BlockIDByTransactionID")
	}

	var r0 flow.Identifier
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (flow.Identifier, error)); ok {
		return returnFunc(txID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) flow.Identifier); ok {
		r0 = returnFunc(txID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.Identifier)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(txID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ScheduledTransactions_BlockIDByTransactionID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BlockIDByTransactionID'
type ScheduledTransactions_BlockIDByTransactionID_Call struct {
	*mock.Call
}

// BlockIDByTransactionID is a helper method to define mock.On call
//   - txID flow.Identifier
func (_e *ScheduledTransactions_Expecter) BlockIDByTransactionID(txID interface{}) *ScheduledTransactions_BlockIDByTransactionID_Call {
	return &ScheduledTransactions_BlockIDByTransactionID_Call{Call: _e.mock.On("BlockIDByTransactionID", txID)}
}

func (_c *ScheduledTransactions_BlockIDByTransactionID_Call) Run(run func(txID flow.Identifier)) *ScheduledTransactions_BlockIDByTransactionID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ScheduledTransactions_BlockIDByTransactionID_Call) Return(identifier flow.Identifier, err error) *ScheduledTransactions_BlockIDByTransactionID_Call {
	_c.Call.Return(identifier, err)
	return _c
}

func (_c *ScheduledTransactions_BlockIDByTransactionID_Call) RunAndReturn(run func(txID flow.Identifier) (flow.Identifier, error)) *ScheduledTransactions_BlockIDByTransactionID_Call {
	_c.Call.Return(run)
	return _c
}

// TransactionIDByID provides a mock function for the type ScheduledTransactions
func (_mock *ScheduledTransactions) TransactionIDByID(scheduledTxID uint64) (flow.Identifier, error) {
	ret := _mock.Called(scheduledTxID)

	if len(ret) == 0 {
		panic("no return value specified for TransactionIDByID")
	}

	var r0 flow.Identifier
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(uint64) (flow.Identifier, error)); ok {
		return returnFunc(scheduledTxID)
	}
	if returnFunc, ok := ret.Get(0).(func(uint64) flow.Identifier); ok {
		r0 = returnFunc(scheduledTxID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.Identifier)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(uint64) error); ok {
		r1 = returnFunc(scheduledTxID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ScheduledTransactions_TransactionIDByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TransactionIDByID'
type ScheduledTransactions_TransactionIDByID_Call struct {
	*mock.Call
}

// TransactionIDByID is a helper method to define mock.On call
//   - scheduledTxID uint64
func (_e *ScheduledTransactions_Expecter) TransactionIDByID(scheduledTxID interface{}) *ScheduledTransactions_TransactionIDByID_Call {
	return &ScheduledTransactions_TransactionIDByID_Call{Call: _e.mock.On("TransactionIDByID", scheduledTxID)}
}

func (_c *ScheduledTransactions_TransactionIDByID_Call) Run(run func(scheduledTxID uint64)) *ScheduledTransactions_TransactionIDByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ScheduledTransactions_TransactionIDByID_Call) Return(identifier flow.Identifier, err error) *ScheduledTransactions_TransactionIDByID_Call {
	_c.Call.Return(identifier, err)
	return _c
}

func (_c *ScheduledTransactions_TransactionIDByID_Call) RunAndReturn(run func(scheduledTxID uint64) (flow.Identifier, error)) *ScheduledTransactions_TransactionIDByID_Call {
	_c.Call.Return(run)
	return _c
}

// NewSeals creates a new instance of Seals. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewSeals(t interface {
	mock.TestingT
	Cleanup(func())
}) *Seals {
	mock := &Seals{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Seals is an autogenerated mock type for the Seals type
type Seals struct {
	mock.Mock
}

type Seals_Expecter struct {
	mock *mock.Mock
}

func (_m *Seals) EXPECT() *Seals_Expecter {
	return &Seals_Expecter{mock: &_m.Mock}
}

// ByID provides a mock function for the type Seals
func (_mock *Seals) ByID(sealID flow.Identifier) (*flow.Seal, error) {
	ret := _mock.Called(sealID)

	if len(ret) == 0 {
		panic("no return value specified for ByID")
	}

	var r0 *flow.Seal
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (*flow.Seal, error)); ok {
		return returnFunc(sealID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) *flow.Seal); ok {
		r0 = returnFunc(sealID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.Seal)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(sealID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Seals_ByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByID'
type Seals_ByID_Call struct {
	*mock.Call
}

// ByID is a helper method to define mock.On call
//   - sealID flow.Identifier
func (_e *Seals_Expecter) ByID(sealID interface{}) *Seals_ByID_Call {
	return &Seals_ByID_Call{Call: _e.mock.On("ByID", sealID)}
}

func (_c *Seals_ByID_Call) Run(run func(sealID flow.Identifier)) *Seals_ByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Seals_ByID_Call) Return(seal *flow.Seal, err error) *Seals_ByID_Call {
	_c.Call.Return(seal, err)
	return _c
}

func (_c *Seals_ByID_Call) RunAndReturn(run func(sealID flow.Identifier) (*flow.Seal, error)) *Seals_ByID_Call {
	_c.Call.Return(run)
	return _c
}

// FinalizedSealForBlock provides a mock function for the type Seals
func (_mock *Seals) FinalizedSealForBlock(blockID flow.Identifier) (*flow.Seal, error) {
	ret := _mock.Called(blockID)

	if len(ret) == 0 {
		panic("no return value specified for FinalizedSealForBlock")
	}

	var r0 *flow.Seal
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (*flow.Seal, error)); ok {
		return returnFunc(blockID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) *flow.Seal); ok {
		r0 = returnFunc(blockID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.Seal)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(blockID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Seals_FinalizedSealForBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FinalizedSealForBlock'
type Seals_FinalizedSealForBlock_Call struct {
	*mock.Call
}

// FinalizedSealForBlock is a helper method to define mock.On call
//   - blockID flow.Identifier
func (_e *Seals_Expecter) FinalizedSealForBlock(blockID interface{}) *Seals_FinalizedSealForBlock_Call {
	return &Seals_FinalizedSealForBlock_Call{Call: _e.mock.On("FinalizedSealForBlock", blockID)}
}

func (_c *Seals_FinalizedSealForBlock_Call) Run(run func(blockID flow.Identifier)) *Seals_FinalizedSealForBlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Seals_FinalizedSealForBlock_Call) Return(seal *flow.Seal, err error) *Seals_FinalizedSealForBlock_Call {
	_c.Call.Return(seal, err)
	return _c
}

func (_c *Seals_FinalizedSealForBlock_Call) RunAndReturn(run func(blockID flow.Identifier) (*flow.Seal, error)) *Seals_FinalizedSealForBlock_Call {
	_c.Call.Return(run)
	return _c
}

// HighestInFork provides a mock function for the type Seals
func (_mock *Seals) HighestInFork(blockID flow.Identifier) (*flow.Seal, error) {
	ret := _mock.Called(blockID)

	if len(ret) == 0 {
		panic("no return value specified for HighestInFork")
	}

	var r0 *flow.Seal
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (*flow.Seal, error)); ok {
		return returnFunc(blockID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) *flow.Seal); ok {
		r0 = returnFunc(blockID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.Seal)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(blockID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Seals_HighestInFork_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HighestInFork'
type Seals_HighestInFork_Call struct {
	*mock.Call
}

// HighestInFork is a helper method to define mock.On call
//   - blockID flow.Identifier
func (_e *Seals_Expecter) HighestInFork(blockID interface{}) *Seals_HighestInFork_Call {
	return &Seals_HighestInFork_Call{Call: _e.mock.On("HighestInFork", blockID)}
}

func (_c *Seals_HighestInFork_Call) Run(run func(blockID flow.Identifier)) *Seals_HighestInFork_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Seals_HighestInFork_Call) Return(seal *flow.Seal, err error) *Seals_HighestInFork_Call {
	_c.Call.Return(seal, err)
	return _c
}

func (_c *Seals_HighestInFork_Call) RunAndReturn(run func(blockID flow.Identifier) (*flow.Seal, error)) *Seals_HighestInFork_Call {
	_c.Call.Return(run)
	return _c
}

// Store provides a mock function for the type Seals
func (_mock *Seals) Store(seal *flow.Seal) error {
	ret := _mock.Called(seal)

	if len(ret) == 0 {
		panic("no return value specified for Store")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*flow.Seal) error); ok {
		r0 = returnFunc(seal)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Seals_Store_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Store'
type Seals_Store_Call struct {
	*mock.Call
}

// Store is a helper method to define mock.On call
//   - seal *flow.Seal
func (_e *Seals_Expecter) Store(seal interface{}) *Seals_Store_Call {
	return &Seals_Store_Call{Call: _e.mock.On("Store", seal)}
}

func (_c *Seals_Store_Call) Run(run func(seal *flow.Seal)) *Seals_Store_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *flow.Seal
		if args[0] != nil {
			arg0 = args[0].(*flow.Seal)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Seals_Store_Call) Return(err error) *Seals_Store_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Seals_Store_Call) RunAndReturn(run func(seal *flow.Seal) error) *Seals_Store_Call {
	_c.Call.Return(run)
	return _c
}

// NewTransactionResultErrorMessagesReader creates a new instance of TransactionResultErrorMessagesReader. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewTransactionResultErrorMessagesReader(t interface {
	mock.TestingT
	Cleanup(func())
}) *TransactionResultErrorMessagesReader {
	mock := &TransactionResultErrorMessagesReader{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// TransactionResultErrorMessagesReader is an autogenerated mock type for the TransactionResultErrorMessagesReader type
type TransactionResultErrorMessagesReader struct {
	mock.Mock
}

type TransactionResultErrorMessagesReader_Expecter struct {
	mock *mock.Mock
}

func (_m *TransactionResultErrorMessagesReader) EXPECT() *TransactionResultErrorMessagesReader_Expecter {
	return &TransactionResultErrorMessagesReader_Expecter{mock: &_m.Mock}
}

// ByBlockID provides a mock function for the type TransactionResultErrorMessagesReader
func (_mock *TransactionResultErrorMessagesReader) ByBlockID(id flow.Identifier) ([]flow.TransactionResultErrorMessage, error) {
	ret := _mock.Called(id)

	if len(ret) == 0 {
		panic("no return value specified for ByBlockID")
	}

	var r0 []flow.TransactionResultErrorMessage
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) ([]flow.TransactionResultErrorMessage, error)); ok {
		return returnFunc(id)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) []flow.TransactionResultErrorMessage); ok {
		r0 = returnFunc(id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]flow.TransactionResultErrorMessage)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// TransactionResultErrorMessagesReader_ByBlockID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByBlockID'
type TransactionResultErrorMessagesReader_ByBlockID_Call struct {
	*mock.Call
}

// ByBlockID is a helper method to define mock.On call
//   - id flow.Identifier
func (_e *TransactionResultErrorMessagesReader_Expecter) ByBlockID(id interface{}) *TransactionResultErrorMessagesReader_ByBlockID_Call {
	return &TransactionResultErrorMessagesReader_ByBlockID_Call{Call: _e.mock.On("ByBlockID", id)}
}

func (_c *TransactionResultErrorMessagesReader_ByBlockID_Call) Run(run func(id flow.Identifier)) *TransactionResultErrorMessagesReader_ByBlockID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *TransactionResultErrorMessagesReader_ByBlockID_Call) Return(transactionResultErrorMessages []flow.TransactionResultErrorMessage, err error) *TransactionResultErrorMessagesReader_ByBlockID_Call {
	_c.Call.Return(transactionResultErrorMessages, err)
	return _c
}

func (_c *TransactionResultErrorMessagesReader_ByBlockID_Call) RunAndReturn(run func(id flow.Identifier) ([]flow.TransactionResultErrorMessage, error)) *TransactionResultErrorMessagesReader_ByBlockID_Call {
	_c.Call.Return(run)
	return _c
}

// ByBlockIDTransactionID provides a mock function for the type TransactionResultErrorMessagesReader
func (_mock *TransactionResultErrorMessagesReader) ByBlockIDTransactionID(blockID flow.Identifier, transactionID flow.Identifier) (*flow.TransactionResultErrorMessage, error) {
	ret := _mock.Called(blockID, transactionID)

	if len(ret) == 0 {
		panic("no return value specified for ByBlockIDTransactionID")
	}

	var r0 *flow.TransactionResultErrorMessage
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, flow.Identifier) (*flow.TransactionResultErrorMessage, error)); ok {
		return returnFunc(blockID, transactionID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, flow.Identifier) *flow.TransactionResultErrorMessage); ok {
		r0 = returnFunc(blockID, transactionID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.TransactionResultErrorMessage)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier, flow.Identifier) error); ok {
		r1 = returnFunc(blockID, transactionID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// TransactionResultErrorMessagesReader_ByBlockIDTransactionID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByBlockIDTransactionID'
type TransactionResultErrorMessagesReader_ByBlockIDTransactionID_Call struct {
	*mock.Call
}

// ByBlockIDTransactionID is a helper method to define mock.On call
//   - blockID flow.Identifier
//   - transactionID flow.Identifier
func (_e *TransactionResultErrorMessagesReader_Expecter) ByBlockIDTransactionID(blockID interface{}, transactionID interface{}) *TransactionResultErrorMessagesReader_ByBlockIDTransactionID_Call {
	return &TransactionResultErrorMessagesReader_ByBlockIDTransactionID_Call{Call: _e.mock.On("ByBlockIDTransactionID", blockID, transactionID)}
}

func (_c *TransactionResultErrorMessagesReader_ByBlockIDTransactionID_Call) Run(run func(blockID flow.Identifier, transactionID flow.Identifier)) *TransactionResultErrorMessagesReader_ByBlockIDTransactionID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		var arg1 flow.Identifier
		if args[1] != nil {
			arg1 = args[1].(flow.Identifier)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *TransactionResultErrorMessagesReader_ByBlockIDTransactionID_Call) Return(transactionResultErrorMessage *flow.TransactionResultErrorMessage, err error) *TransactionResultErrorMessagesReader_ByBlockIDTransactionID_Call {
	_c.Call.Return(transactionResultErrorMessage, err)
	return _c
}

func (_c *TransactionResultErrorMessagesReader_ByBlockIDTransactionID_Call) RunAndReturn(run func(blockID flow.Identifier, transactionID flow.Identifier) (*flow.TransactionResultErrorMessage, error)) *TransactionResultErrorMessagesReader_ByBlockIDTransactionID_Call {
	_c.Call.Return(run)
	return _c
}

// ByBlockIDTransactionIndex provides a mock function for the type TransactionResultErrorMessagesReader
func (_mock *TransactionResultErrorMessagesReader) ByBlockIDTransactionIndex(blockID flow.Identifier, txIndex uint32) (*flow.TransactionResultErrorMessage, error) {
	ret := _mock.Called(blockID, txIndex)

	if len(ret) == 0 {
		panic("no return value specified for ByBlockIDTransactionIndex")
	}

	var r0 *flow.TransactionResultErrorMessage
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, uint32) (*flow.TransactionResultErrorMessage, error)); ok {
		return returnFunc(blockID, txIndex)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, uint32) *flow.TransactionResultErrorMessage); ok {
		r0 = returnFunc(blockID, txIndex)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.TransactionResultErrorMessage)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier, uint32) error); ok {
		r1 = returnFunc(blockID, txIndex)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// TransactionResultErrorMessagesReader_ByBlockIDTransactionIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByBlockIDTransactionIndex'
type TransactionResultErrorMessagesReader_ByBlockIDTransactionIndex_Call struct {
	*mock.Call
}

// ByBlockIDTransactionIndex is a helper method to define mock.On call
//   - blockID flow.Identifier
//   - txIndex uint32
func (_e *TransactionResultErrorMessagesReader_Expecter) ByBlockIDTransactionIndex(blockID interface{}, txIndex interface{}) *TransactionResultErrorMessagesReader_ByBlockIDTransactionIndex_Call {
	return &TransactionResultErrorMessagesReader_ByBlockIDTransactionIndex_Call{Call: _e.mock.On("ByBlockIDTransactionIndex", blockID, txIndex)}
}

func (_c *TransactionResultErrorMessagesReader_ByBlockIDTransactionIndex_Call) Run(run func(blockID flow.Identifier, txIndex uint32)) *TransactionResultErrorMessagesReader_ByBlockIDTransactionIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		var arg1 uint32
		if args[1] != nil {
			arg1 = args[1].(uint32)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *TransactionResultErrorMessagesReader_ByBlockIDTransactionIndex_Call) Return(transactionResultErrorMessage *flow.TransactionResultErrorMessage, err error) *TransactionResultErrorMessagesReader_ByBlockIDTransactionIndex_Call {
	_c.Call.Return(transactionResultErrorMessage, err)
	return _c
}

func (_c *TransactionResultErrorMessagesReader_ByBlockIDTransactionIndex_Call) RunAndReturn(run func(blockID flow.Identifier, txIndex uint32) (*flow.TransactionResultErrorMessage, error)) *TransactionResultErrorMessagesReader_ByBlockIDTransactionIndex_Call {
	_c.Call.Return(run)
	return _c
}

// Exists provides a mock function for the type TransactionResultErrorMessagesReader
func (_mock *TransactionResultErrorMessagesReader) Exists(blockID flow.Identifier) (bool, error) {
	ret := _mock.Called(blockID)

	if len(ret) == 0 {
		panic("no return value specified for Exists")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (bool, error)); ok {
		return returnFunc(blockID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) bool); ok {
		r0 = returnFunc(blockID)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(blockID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// TransactionResultErrorMessagesReader_Exists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exists'
type TransactionResultErrorMessagesReader_Exists_Call struct {
	*mock.Call
}

// Exists is a helper method to define mock.On call
//   - blockID flow.Identifier
func (_e *TransactionResultErrorMessagesReader_Expecter) Exists(blockID interface{}) *TransactionResultErrorMessagesReader_Exists_Call {
	return &TransactionResultErrorMessagesReader_Exists_Call{Call: _e.mock.On("Exists", blockID)}
}

func (_c *TransactionResultErrorMessagesReader_Exists_Call) Run(run func(blockID flow.Identifier)) *TransactionResultErrorMessagesReader_Exists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *TransactionResultErrorMessagesReader_Exists_Call) Return(b bool, err error) *TransactionResultErrorMessagesReader_Exists_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *TransactionResultErrorMessagesReader_Exists_Call) RunAndReturn(run func(blockID flow.Identifier) (bool, error)) *TransactionResultErrorMessagesReader_Exists_Call {
	_c.Call.Return(run)
	return _c
}

// NewTransactionResultErrorMessages creates a new instance of TransactionResultErrorMessages. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewTransactionResultErrorMessages(t interface {
	mock.TestingT
	Cleanup(func())
}) *TransactionResultErrorMessages {
	mock := &TransactionResultErrorMessages{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// TransactionResultErrorMessages is an autogenerated mock type for the TransactionResultErrorMessages type
type TransactionResultErrorMessages struct {
	mock.Mock
}

type TransactionResultErrorMessages_Expecter struct {
	mock *mock.Mock
}

func (_m *TransactionResultErrorMessages) EXPECT() *TransactionResultErrorMessages_Expecter {
	return &TransactionResultErrorMessages_Expecter{mock: &_m.Mock}
}

// BatchStore provides a mock function for the type TransactionResultErrorMessages
func (_mock *TransactionResultErrorMessages) BatchStore(lctx lockctx.Proof, rw storage.ReaderBatchWriter, blockID flow.Identifier, transactionResultErrorMessages []flow.TransactionResultErrorMessage) error {
	ret := _mock.Called(lctx, rw, blockID, transactionResultErrorMessages)

	if len(ret) == 0 {
		panic("no return value specified for BatchStore")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(lockctx.Proof, storage.ReaderBatchWriter, flow.Identifier, []flow.TransactionResultErrorMessage) error); ok {
		r0 = returnFunc(lctx, rw, blockID, transactionResultErrorMessages)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// TransactionResultErrorMessages_BatchStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BatchStore'
type TransactionResultErrorMessages_BatchStore_Call struct {
	*mock.Call
}

// BatchStore is a helper method to define mock.On call
//   - lctx lockctx.Proof
//   - rw storage.ReaderBatchWriter
//   - blockID flow.Identifier
//   - transactionResultErrorMessages []flow.TransactionResultErrorMessage
func (_e *TransactionResultErrorMessages_Expecter) BatchStore(lctx interface{}, rw interface{}, blockID interface{}, transactionResultErrorMessages interface{}) *TransactionResultErrorMessages_BatchStore_Call {
	return &TransactionResultErrorMessages_BatchStore_Call{Call: _e.mock.On("BatchStore", lctx, rw, blockID, transactionResultErrorMessages)}
}

func (_c *TransactionResultErrorMessages_BatchStore_Call) Run(run func(lctx lockctx.Proof, rw storage.ReaderBatchWriter, blockID flow.Identifier, transactionResultErrorMessages []flow.TransactionResultErrorMessage)) *TransactionResultErrorMessages_BatchStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 lockctx.Proof
		if args[0] != nil {
			arg0 = args[0].(lockctx.Proof)
		}
		var arg1 storage.ReaderBatchWriter
		if args[1] != nil {
			arg1 = args[1].(storage.ReaderBatchWriter)
		}
		var arg2 flow.Identifier
		if args[2] != nil {
			arg2 = args[2].(flow.Identifier)
		}
		var arg3 []flow.TransactionResultErrorMessage
		if args[3] != nil {
			arg3 = args[3].([]flow.TransactionResultErrorMessage)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *TransactionResultErrorMessages_BatchStore_Call) Return(err error) *TransactionResultErrorMessages_BatchStore_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *TransactionResultErrorMessages_BatchStore_Call) RunAndReturn(run func(lctx lockctx.Proof, rw storage.ReaderBatchWriter, blockID flow.Identifier, transactionResultErrorMessages []flow.TransactionResultErrorMessage) error) *TransactionResultErrorMessages_BatchStore_Call {
	_c.Call.Return(run)
	return _c
}

// ByBlockID provides a mock function for the type TransactionResultErrorMessages
func (_mock *TransactionResultErrorMessages) ByBlockID(id flow.Identifier) ([]flow.TransactionResultErrorMessage, error) {
	ret := _mock.Called(id)

	if len(ret) == 0 {
		panic("no return value specified for ByBlockID")
	}

	var r0 []flow.TransactionResultErrorMessage
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) ([]flow.TransactionResultErrorMessage, error)); ok {
		return returnFunc(id)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) []flow.TransactionResultErrorMessage); ok {
		r0 = returnFunc(id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]flow.TransactionResultErrorMessage)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// TransactionResultErrorMessages_ByBlockID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByBlockID'
type TransactionResultErrorMessages_ByBlockID_Call struct {
	*mock.Call
}

// ByBlockID is a helper method to define mock.On call
//   - id flow.Identifier
func (_e *TransactionResultErrorMessages_Expecter) ByBlockID(id interface{}) *TransactionResultErrorMessages_ByBlockID_Call {
	return &TransactionResultErrorMessages_ByBlockID_Call{Call: _e.mock.On("ByBlockID", id)}
}

func (_c *TransactionResultErrorMessages_ByBlockID_Call) Run(run func(id flow.Identifier)) *TransactionResultErrorMessages_ByBlockID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *TransactionResultErrorMessages_ByBlockID_Call) Return(transactionResultErrorMessages []flow.TransactionResultErrorMessage, err error) *TransactionResultErrorMessages_ByBlockID_Call {
	_c.Call.Return(transactionResultErrorMessages, err)
	return _c
}

func (_c *TransactionResultErrorMessages_ByBlockID_Call) RunAndReturn(run func(id flow.Identifier) ([]flow.TransactionResultErrorMessage, error)) *TransactionResultErrorMessages_ByBlockID_Call {
	_c.Call.Return(run)
	return _c
}

// ByBlockIDTransactionID provides a mock function for the type TransactionResultErrorMessages
func (_mock *TransactionResultErrorMessages) ByBlockIDTransactionID(blockID flow.Identifier, transactionID flow.Identifier) (*flow.TransactionResultErrorMessage, error) {
	ret := _mock.Called(blockID, transactionID)

	if len(ret) == 0 {
		panic("no return value specified for ByBlockIDTransactionID")
	}

	var r0 *flow.TransactionResultErrorMessage
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, flow.Identifier) (*flow.TransactionResultErrorMessage, error)); ok {
		return returnFunc(blockID, transactionID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, flow.Identifier) *flow.TransactionResultErrorMessage); ok {
		r0 = returnFunc(blockID, transactionID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.TransactionResultErrorMessage)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier, flow.Identifier) error); ok {
		r1 = returnFunc(blockID, transactionID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// TransactionResultErrorMessages_ByBlockIDTransactionID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByBlockIDTransactionID'
type TransactionResultErrorMessages_ByBlockIDTransactionID_Call struct {
	*mock.Call
}

// ByBlockIDTransactionID is a helper method to define mock.On call
//   - blockID flow.Identifier
//   - transactionID flow.Identifier
func (_e *TransactionResultErrorMessages_Expecter) ByBlockIDTransactionID(blockID interface{}, transactionID interface{}) *TransactionResultErrorMessages_ByBlockIDTransactionID_Call {
	return &TransactionResultErrorMessages_ByBlockIDTransactionID_Call{Call: _e.mock.On("ByBlockIDTransactionID", blockID, transactionID)}
}

func (_c *TransactionResultErrorMessages_ByBlockIDTransactionID_Call) Run(run func(blockID flow.Identifier, transactionID flow.Identifier)) *TransactionResultErrorMessages_ByBlockIDTransactionID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		var arg1 flow.Identifier
		if args[1] != nil {
			arg1 = args[1].(flow.Identifier)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *TransactionResultErrorMessages_ByBlockIDTransactionID_Call) Return(transactionResultErrorMessage *flow.TransactionResultErrorMessage, err error) *TransactionResultErrorMessages_ByBlockIDTransactionID_Call {
	_c.Call.Return(transactionResultErrorMessage, err)
	return _c
}

func (_c *TransactionResultErrorMessages_ByBlockIDTransactionID_Call) RunAndReturn(run func(blockID flow.Identifier, transactionID flow.Identifier) (*flow.TransactionResultErrorMessage, error)) *TransactionResultErrorMessages_ByBlockIDTransactionID_Call {
	_c.Call.Return(run)
	return _c
}

// ByBlockIDTransactionIndex provides a mock function for the type TransactionResultErrorMessages
func (_mock *TransactionResultErrorMessages) ByBlockIDTransactionIndex(blockID flow.Identifier, txIndex uint32) (*flow.TransactionResultErrorMessage, error) {
	ret := _mock.Called(blockID, txIndex)

	if len(ret) == 0 {
		panic("no return value specified for ByBlockIDTransactionIndex")
	}

	var r0 *flow.TransactionResultErrorMessage
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, uint32) (*flow.TransactionResultErrorMessage, error)); ok {
		return returnFunc(blockID, txIndex)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, uint32) *flow.TransactionResultErrorMessage); ok {
		r0 = returnFunc(blockID, txIndex)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.TransactionResultErrorMessage)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier, uint32) error); ok {
		r1 = returnFunc(blockID, txIndex)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// TransactionResultErrorMessages_ByBlockIDTransactionIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByBlockIDTransactionIndex'
type TransactionResultErrorMessages_ByBlockIDTransactionIndex_Call struct {
	*mock.Call
}

// ByBlockIDTransactionIndex is a helper method to define mock.On call
//   - blockID flow.Identifier
//   - txIndex uint32
func (_e *TransactionResultErrorMessages_Expecter) ByBlockIDTransactionIndex(blockID interface{}, txIndex interface{}) *TransactionResultErrorMessages_ByBlockIDTransactionIndex_Call {
	return &TransactionResultErrorMessages_ByBlockIDTransactionIndex_Call{Call: _e.mock.On("ByBlockIDTransactionIndex", blockID, txIndex)}
}

func (_c *TransactionResultErrorMessages_ByBlockIDTransactionIndex_Call) Run(run func(blockID flow.Identifier, txIndex uint32)) *TransactionResultErrorMessages_ByBlockIDTransactionIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		var arg1 uint32
		if args[1] != nil {
			arg1 = args[1].(uint32)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *TransactionResultErrorMessages_ByBlockIDTransactionIndex_Call) Return(transactionResultErrorMessage *flow.TransactionResultErrorMessage, err error) *TransactionResultErrorMessages_ByBlockIDTransactionIndex_Call {
	_c.Call.Return(transactionResultErrorMessage, err)
	return _c
}

func (_c *TransactionResultErrorMessages_ByBlockIDTransactionIndex_Call) RunAndReturn(run func(blockID flow.Identifier, txIndex uint32) (*flow.TransactionResultErrorMessage, error)) *TransactionResultErrorMessages_ByBlockIDTransactionIndex_Call {
	_c.Call.Return(run)
	return _c
}

// Exists provides a mock function for the type TransactionResultErrorMessages
func (_mock *TransactionResultErrorMessages) Exists(blockID flow.Identifier) (bool, error) {
	ret := _mock.Called(blockID)

	if len(ret) == 0 {
		panic("no return value specified for Exists")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (bool, error)); ok {
		return returnFunc(blockID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) bool); ok {
		r0 = returnFunc(blockID)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(blockID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// TransactionResultErrorMessages_Exists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exists'
type TransactionResultErrorMessages_Exists_Call struct {
	*mock.Call
}

// Exists is a helper method to define mock.On call
//   - blockID flow.Identifier
func (_e *TransactionResultErrorMessages_Expecter) Exists(blockID interface{}) *TransactionResultErrorMessages_Exists_Call {
	return &TransactionResultErrorMessages_Exists_Call{Call: _e.mock.On("Exists", blockID)}
}

func (_c *TransactionResultErrorMessages_Exists_Call) Run(run func(blockID flow.Identifier)) *TransactionResultErrorMessages_Exists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *TransactionResultErrorMessages_Exists_Call) Return(b bool, err error) *TransactionResultErrorMessages_Exists_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *TransactionResultErrorMessages_Exists_Call) RunAndReturn(run func(blockID flow.Identifier) (bool, error)) *TransactionResultErrorMessages_Exists_Call {
	_c.Call.Return(run)
	return _c
}

// Store provides a mock function for the type TransactionResultErrorMessages
func (_mock *TransactionResultErrorMessages) Store(lctx lockctx.Proof, blockID flow.Identifier, transactionResultErrorMessages []flow.TransactionResultErrorMessage) error {
	ret := _mock.Called(lctx, blockID, transactionResultErrorMessages)

	if len(ret) == 0 {
		panic("no return value specified for Store")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(lockctx.Proof, flow.Identifier, []flow.TransactionResultErrorMessage) error); ok {
		r0 = returnFunc(lctx, blockID, transactionResultErrorMessages)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// TransactionResultErrorMessages_Store_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Store'
type TransactionResultErrorMessages_Store_Call struct {
	*mock.Call
}

// Store is a helper method to define mock.On call
//   - lctx lockctx.Proof
//   - blockID flow.Identifier
//   - transactionResultErrorMessages []flow.TransactionResultErrorMessage
func (_e *TransactionResultErrorMessages_Expecter) Store(lctx interface{}, blockID interface{}, transactionResultErrorMessages interface{}) *TransactionResultErrorMessages_Store_Call {
	return &TransactionResultErrorMessages_Store_Call{Call: _e.mock.On("Store", lctx, blockID, transactionResultErrorMessages)}
}

func (_c *TransactionResultErrorMessages_Store_Call) Run(run func(lctx lockctx.Proof, blockID flow.Identifier, transactionResultErrorMessages []flow.TransactionResultErrorMessage)) *TransactionResultErrorMessages_Store_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 lockctx.Proof
		if args[0] != nil {
			arg0 = args[0].(lockctx.Proof)
		}
		var arg1 flow.Identifier
		if args[1] != nil {
			arg1 = args[1].(flow.Identifier)
		}
		var arg2 []flow.TransactionResultErrorMessage
		if args[2] != nil {
			arg2 = args[2].([]flow.TransactionResultErrorMessage)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *TransactionResultErrorMessages_Store_Call) Return(err error) *TransactionResultErrorMessages_Store_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *TransactionResultErrorMessages_Store_Call) RunAndReturn(run func(lctx lockctx.Proof, blockID flow.Identifier, transactionResultErrorMessages []flow.TransactionResultErrorMessage) error) *TransactionResultErrorMessages_Store_Call {
	_c.Call.Return(run)
	return _c
}

// NewTransactionResultsReader creates a new instance of TransactionResultsReader. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewTransactionResultsReader(t interface {
	mock.TestingT
	Cleanup(func())
}) *TransactionResultsReader {
	mock := &TransactionResultsReader{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// TransactionResultsReader is an autogenerated mock type for the TransactionResultsReader type
type TransactionResultsReader struct {
	mock.Mock
}

type TransactionResultsReader_Expecter struct {
	mock *mock.Mock
}

func (_m *TransactionResultsReader) EXPECT() *TransactionResultsReader_Expecter {
	return &TransactionResultsReader_Expecter{mock: &_m.Mock}
}

// ByBlockID provides a mock function for the type TransactionResultsReader
func (_mock *TransactionResultsReader) ByBlockID(id flow.Identifier) ([]flow.TransactionResult, error) {
	ret := _mock.Called(id)

	if len(ret) == 0 {
		panic("no return value specified for ByBlockID")
	}

	var r0 []flow.TransactionResult
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) ([]flow.TransactionResult, error)); ok {
		return returnFunc(id)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) []flow.TransactionResult); ok {
		r0 = returnFunc(id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]flow.TransactionResult)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// TransactionResultsReader_ByBlockID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByBlockID'
type TransactionResultsReader_ByBlockID_Call struct {
	*mock.Call
}

// ByBlockID is a helper method to define mock.On call
//   - id flow.Identifier
func (_e *TransactionResultsReader_Expecter) ByBlockID(id interface{}) *TransactionResultsReader_ByBlockID_Call {
	return &TransactionResultsReader_ByBlockID_Call{Call: _e.mock.On("ByBlockID", id)}
}

func (_c *TransactionResultsReader_ByBlockID_Call) Run(run func(id flow.Identifier)) *TransactionResultsReader_ByBlockID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *TransactionResultsReader_ByBlockID_Call) Return(transactionResults []flow.TransactionResult, err error) *TransactionResultsReader_ByBlockID_Call {
	_c.Call.Return(transactionResults, err)
	return _c
}

func (_c *TransactionResultsReader_ByBlockID_Call) RunAndReturn(run func(id flow.Identifier) ([]flow.TransactionResult, error)) *TransactionResultsReader_ByBlockID_Call {
	_c.Call.Return(run)
	return _c
}

// ByBlockIDTransactionID provides a mock function for the type TransactionResultsReader
func (_mock *TransactionResultsReader) ByBlockIDTransactionID(blockID flow.Identifier, transactionID flow.Identifier) (*flow.TransactionResult, error) {
	ret := _mock.Called(blockID, transactionID)

	if len(ret) == 0 {
		panic("no return value specified for ByBlockIDTransactionID")
	}

	var r0 *flow.TransactionResult
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, flow.Identifier) (*flow.TransactionResult, error)); ok {
		return returnFunc(blockID, transactionID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, flow.Identifier) *flow.TransactionResult); ok {
		r0 = returnFunc(blockID, transactionID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.TransactionResult)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier, flow.Identifier) error); ok {
		r1 = returnFunc(blockID, transactionID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// TransactionResultsReader_ByBlockIDTransactionID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByBlockIDTransactionID'
type TransactionResultsReader_ByBlockIDTransactionID_Call struct {
	*mock.Call
}

// ByBlockIDTransactionID is a helper method to define mock.On call
//   - blockID flow.Identifier
//   - transactionID flow.Identifier
func (_e *TransactionResultsReader_Expecter) ByBlockIDTransactionID(blockID interface{}, transactionID interface{}) *TransactionResultsReader_ByBlockIDTransactionID_Call {
	return &TransactionResultsReader_ByBlockIDTransactionID_Call{Call: _e.mock.On("ByBlockIDTransactionID", blockID, transactionID)}
}

func (_c *TransactionResultsReader_ByBlockIDTransactionID_Call) Run(run func(blockID flow.Identifier, transactionID flow.Identifier)) *TransactionResultsReader_ByBlockIDTransactionID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		var arg1 flow.Identifier
		if args[1] != nil {
			arg1 = args[1].(flow.Identifier)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *TransactionResultsReader_ByBlockIDTransactionID_Call) Return(transactionResult *flow.TransactionResult, err error) *TransactionResultsReader_ByBlockIDTransactionID_Call {
	_c.Call.Return(transactionResult, err)
	return _c
}

func (_c *TransactionResultsReader_ByBlockIDTransactionID_Call) RunAndReturn(run func(blockID flow.Identifier, transactionID flow.Identifier) (*flow.TransactionResult, error)) *TransactionResultsReader_ByBlockIDTransactionID_Call {
	_c.Call.Return(run)
	return _c
}

// ByBlockIDTransactionIndex provides a mock function for the type TransactionResultsReader
func (_mock *TransactionResultsReader) ByBlockIDTransactionIndex(blockID flow.Identifier, txIndex uint32) (*flow.TransactionResult, error) {
	ret := _mock.Called(blockID, txIndex)

	if len(ret) == 0 {
		panic("no return value specified for ByBlockIDTransactionIndex")
	}

	var r0 *flow.TransactionResult
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, uint32) (*flow.TransactionResult, error)); ok {
		return returnFunc(blockID, txIndex)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, uint32) *flow.TransactionResult); ok {
		r0 = returnFunc(blockID, txIndex)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.TransactionResult)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier, uint32) error); ok {
		r1 = returnFunc(blockID, txIndex)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// TransactionResultsReader_ByBlockIDTransactionIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByBlockIDTransactionIndex'
type TransactionResultsReader_ByBlockIDTransactionIndex_Call struct {
	*mock.Call
}

// ByBlockIDTransactionIndex is a helper method to define mock.On call
//   - blockID flow.Identifier
//   - txIndex uint32
func (_e *TransactionResultsReader_Expecter) ByBlockIDTransactionIndex(blockID interface{}, txIndex interface{}) *TransactionResultsReader_ByBlockIDTransactionIndex_Call {
	return &TransactionResultsReader_ByBlockIDTransactionIndex_Call{Call: _e.mock.On("ByBlockIDTransactionIndex", blockID, txIndex)}
}

func (_c *TransactionResultsReader_ByBlockIDTransactionIndex_Call) Run(run func(blockID flow.Identifier, txIndex uint32)) *TransactionResultsReader_ByBlockIDTransactionIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		var arg1 uint32
		if args[1] != nil {
			arg1 = args[1].(uint32)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *TransactionResultsReader_ByBlockIDTransactionIndex_Call) Return(transactionResult *flow.TransactionResult, err error) *TransactionResultsReader_ByBlockIDTransactionIndex_Call {
	_c.Call.Return(transactionResult, err)
	return _c
}

func (_c *TransactionResultsReader_ByBlockIDTransactionIndex_Call) RunAndReturn(run func(blockID flow.Identifier, txIndex uint32) (*flow.TransactionResult, error)) *TransactionResultsReader_ByBlockIDTransactionIndex_Call {
	_c.Call.Return(run)
	return _c
}

// NewTransactionResults creates a new instance of TransactionResults. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewTransactionResults(t interface {
	mock.TestingT
	Cleanup(func())
}) *TransactionResults {
	mock := &TransactionResults{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// TransactionResults is an autogenerated mock type for the TransactionResults type
type TransactionResults struct {
	mock.Mock
}

type TransactionResults_Expecter struct {
	mock *mock.Mock
}

func (_m *TransactionResults) EXPECT() *TransactionResults_Expecter {
	return &TransactionResults_Expecter{mock: &_m.Mock}
}

// BatchRemoveByBlockID provides a mock function for the type TransactionResults
func (_mock *TransactionResults) BatchRemoveByBlockID(id flow.Identifier, batch storage.ReaderBatchWriter) error {
	ret := _mock.Called(id, batch)

	if len(ret) == 0 {
		panic("no return value specified for BatchRemoveByBlockID")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, storage.ReaderBatchWriter) error); ok {
		r0 = returnFunc(id, batch)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// TransactionResults_BatchRemoveByBlockID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BatchRemoveByBlockID'
type TransactionResults_BatchRemoveByBlockID_Call struct {
	*mock.Call
}

// BatchRemoveByBlockID is a helper method to define mock.On call
//   - id flow.Identifier
//   - batch storage.ReaderBatchWriter
func (_e *TransactionResults_Expecter) BatchRemoveByBlockID(id interface{}, batch interface{}) *TransactionResults_BatchRemoveByBlockID_Call {
	return &TransactionResults_BatchRemoveByBlockID_Call{Call: _e.mock.On("BatchRemoveByBlockID", id, batch)}
}

func (_c *TransactionResults_BatchRemoveByBlockID_Call) Run(run func(id flow.Identifier, batch storage.ReaderBatchWriter)) *TransactionResults_BatchRemoveByBlockID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		var arg1 storage.ReaderBatchWriter
		if args[1] != nil {
			arg1 = args[1].(storage.ReaderBatchWriter)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *TransactionResults_BatchRemoveByBlockID_Call) Return(err error) *TransactionResults_BatchRemoveByBlockID_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *TransactionResults_BatchRemoveByBlockID_Call) RunAndReturn(run func(id flow.Identifier, batch storage.ReaderBatchWriter) error) *TransactionResults_BatchRemoveByBlockID_Call {
	_c.Call.Return(run)
	return _c
}

// BatchStore provides a mock function for the type TransactionResults
func (_mock *TransactionResults) BatchStore(lctx lockctx.Proof, rw storage.ReaderBatchWriter, blockID flow.Identifier, transactionResults []flow.TransactionResult) error {
	ret := _mock.Called(lctx, rw, blockID, transactionResults)

	if len(ret) == 0 {
		panic("no return value specified for BatchStore")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(lockctx.Proof, storage.ReaderBatchWriter, flow.Identifier, []flow.TransactionResult) error); ok {
		r0 = returnFunc(lctx, rw, blockID, transactionResults)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// TransactionResults_BatchStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BatchStore'
type TransactionResults_BatchStore_Call struct {
	*mock.Call
}

// BatchStore is a helper method to define mock.On call
//   - lctx lockctx.Proof
//   - rw storage.ReaderBatchWriter
//   - blockID flow.Identifier
//   - transactionResults []flow.TransactionResult
func (_e *TransactionResults_Expecter) BatchStore(lctx interface{}, rw interface{}, blockID interface{}, transactionResults interface{}) *TransactionResults_BatchStore_Call {
	return &TransactionResults_BatchStore_Call{Call: _e.mock.On("BatchStore", lctx, rw, blockID, transactionResults)}
}

func (_c *TransactionResults_BatchStore_Call) Run(run func(lctx lockctx.Proof, rw storage.ReaderBatchWriter, blockID flow.Identifier, transactionResults []flow.TransactionResult)) *TransactionResults_BatchStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 lockctx.Proof
		if args[0] != nil {
			arg0 = args[0].(lockctx.Proof)
		}
		var arg1 storage.ReaderBatchWriter
		if args[1] != nil {
			arg1 = args[1].(storage.ReaderBatchWriter)
		}
		var arg2 flow.Identifier
		if args[2] != nil {
			arg2 = args[2].(flow.Identifier)
		}
		var arg3 []flow.TransactionResult
		if args[3] != nil {
			arg3 = args[3].([]flow.TransactionResult)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *TransactionResults_BatchStore_Call) Return(err error) *TransactionResults_BatchStore_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *TransactionResults_BatchStore_Call) RunAndReturn(run func(lctx lockctx.Proof, rw storage.ReaderBatchWriter, blockID flow.Identifier, transactionResults []flow.TransactionResult) error) *TransactionResults_BatchStore_Call {
	_c.Call.Return(run)
	return _c
}

// ByBlockID provides a mock function for the type TransactionResults
func (_mock *TransactionResults) ByBlockID(id flow.Identifier) ([]flow.TransactionResult, error) {
	ret := _mock.Called(id)

	if len(ret) == 0 {
		panic("no return value specified for ByBlockID")
	}

	var r0 []flow.TransactionResult
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) ([]flow.TransactionResult, error)); ok {
		return returnFunc(id)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) []flow.TransactionResult); ok {
		r0 = returnFunc(id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]flow.TransactionResult)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// TransactionResults_ByBlockID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByBlockID'
type TransactionResults_ByBlockID_Call struct {
	*mock.Call
}

// ByBlockID is a helper method to define mock.On call
//   - id flow.Identifier
func (_e *TransactionResults_Expecter) ByBlockID(id interface{}) *TransactionResults_ByBlockID_Call {
	return &TransactionResults_ByBlockID_Call{Call: _e.mock.On("ByBlockID", id)}
}

func (_c *TransactionResults_ByBlockID_Call) Run(run func(id flow.Identifier)) *TransactionResults_ByBlockID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *TransactionResults_ByBlockID_Call) Return(transactionResults []flow.TransactionResult, err error) *TransactionResults_ByBlockID_Call {
	_c.Call.Return(transactionResults, err)
	return _c
}

func (_c *TransactionResults_ByBlockID_Call) RunAndReturn(run func(id flow.Identifier) ([]flow.TransactionResult, error)) *TransactionResults_ByBlockID_Call {
	_c.Call.Return(run)
	return _c
}

// ByBlockIDTransactionID provides a mock function for the type TransactionResults
func (_mock *TransactionResults) ByBlockIDTransactionID(blockID flow.Identifier, transactionID flow.Identifier) (*flow.TransactionResult, error) {
	ret := _mock.Called(blockID, transactionID)

	if len(ret) == 0 {
		panic("no return value specified for ByBlockIDTransactionID")
	}

	var r0 *flow.TransactionResult
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, flow.Identifier) (*flow.TransactionResult, error)); ok {
		return returnFunc(blockID, transactionID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, flow.Identifier) *flow.TransactionResult); ok {
		r0 = returnFunc(blockID, transactionID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.TransactionResult)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier, flow.Identifier) error); ok {
		r1 = returnFunc(blockID, transactionID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// TransactionResults_ByBlockIDTransactionID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByBlockIDTransactionID'
type TransactionResults_ByBlockIDTransactionID_Call struct {
	*mock.Call
}

// ByBlockIDTransactionID is a helper method to define mock.On call
//   - blockID flow.Identifier
//   - transactionID flow.Identifier
func (_e *TransactionResults_Expecter) ByBlockIDTransactionID(blockID interface{}, transactionID interface{}) *TransactionResults_ByBlockIDTransactionID_Call {
	return &TransactionResults_ByBlockIDTransactionID_Call{Call: _e.mock.On("ByBlockIDTransactionID", blockID, transactionID)}
}

func (_c *TransactionResults_ByBlockIDTransactionID_Call) Run(run func(blockID flow.Identifier, transactionID flow.Identifier)) *TransactionResults_ByBlockIDTransactionID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		var arg1 flow.Identifier
		if args[1] != nil {
			arg1 = args[1].(flow.Identifier)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *TransactionResults_ByBlockIDTransactionID_Call) Return(transactionResult *flow.TransactionResult, err error) *TransactionResults_ByBlockIDTransactionID_Call {
	_c.Call.Return(transactionResult, err)
	return _c
}

func (_c *TransactionResults_ByBlockIDTransactionID_Call) RunAndReturn(run func(blockID flow.Identifier, transactionID flow.Identifier) (*flow.TransactionResult, error)) *TransactionResults_ByBlockIDTransactionID_Call {
	_c.Call.Return(run)
	return _c
}

// ByBlockIDTransactionIndex provides a mock function for the type TransactionResults
func (_mock *TransactionResults) ByBlockIDTransactionIndex(blockID flow.Identifier, txIndex uint32) (*flow.TransactionResult, error) {
	ret := _mock.Called(blockID, txIndex)

	if len(ret) == 0 {
		panic("no return value specified for ByBlockIDTransactionIndex")
	}

	var r0 *flow.TransactionResult
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, uint32) (*flow.TransactionResult, error)); ok {
		return returnFunc(blockID, txIndex)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, uint32) *flow.TransactionResult); ok {
		r0 = returnFunc(blockID, txIndex)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.TransactionResult)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier, uint32) error); ok {
		r1 = returnFunc(blockID, txIndex)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// TransactionResults_ByBlockIDTransactionIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByBlockIDTransactionIndex'
type TransactionResults_ByBlockIDTransactionIndex_Call struct {
	*mock.Call
}

// ByBlockIDTransactionIndex is a helper method to define mock.On call
//   - blockID flow.Identifier
//   - txIndex uint32
func (_e *TransactionResults_Expecter) ByBlockIDTransactionIndex(blockID interface{}, txIndex interface{}) *TransactionResults_ByBlockIDTransactionIndex_Call {
	return &TransactionResults_ByBlockIDTransactionIndex_Call{Call: _e.mock.On("ByBlockIDTransactionIndex", blockID, txIndex)}
}

func (_c *TransactionResults_ByBlockIDTransactionIndex_Call) Run(run func(blockID flow.Identifier, txIndex uint32)) *TransactionResults_ByBlockIDTransactionIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		var arg1 uint32
		if args[1] != nil {
			arg1 = args[1].(uint32)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *TransactionResults_ByBlockIDTransactionIndex_Call) Return(transactionResult *flow.TransactionResult, err error) *TransactionResults_ByBlockIDTransactionIndex_Call {
	_c.Call.Return(transactionResult, err)
	return _c
}

func (_c *TransactionResults_ByBlockIDTransactionIndex_Call) RunAndReturn(run func(blockID flow.Identifier, txIndex uint32) (*flow.TransactionResult, error)) *TransactionResults_ByBlockIDTransactionIndex_Call {
	_c.Call.Return(run)
	return _c
}

// NewTransactionsReader creates a new instance of TransactionsReader. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewTransactionsReader(t interface {
	mock.TestingT
	Cleanup(func())
}) *TransactionsReader {
	mock := &TransactionsReader{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// TransactionsReader is an autogenerated mock type for the TransactionsReader type
type TransactionsReader struct {
	mock.Mock
}

type TransactionsReader_Expecter struct {
	mock *mock.Mock
}

func (_m *TransactionsReader) EXPECT() *TransactionsReader_Expecter {
	return &TransactionsReader_Expecter{mock: &_m.Mock}
}

// ByID provides a mock function for the type TransactionsReader
func (_mock *TransactionsReader) ByID(txID flow.Identifier) (*flow.TransactionBody, error) {
	ret := _mock.Called(txID)

	if len(ret) == 0 {
		panic("no return value specified for ByID")
	}

	var r0 *flow.TransactionBody
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (*flow.TransactionBody, error)); ok {
		return returnFunc(txID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) *flow.TransactionBody); ok {
		r0 = returnFunc(txID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.TransactionBody)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(txID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// TransactionsReader_ByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByID'
type TransactionsReader_ByID_Call struct {
	*mock.Call
}

// ByID is a helper method to define mock.On call
//   - txID flow.Identifier
func (_e *TransactionsReader_Expecter) ByID(txID interface{}) *TransactionsReader_ByID_Call {
	return &TransactionsReader_ByID_Call{Call: _e.mock.On("ByID", txID)}
}

func (_c *TransactionsReader_ByID_Call) Run(run func(txID flow.Identifier)) *TransactionsReader_ByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *TransactionsReader_ByID_Call) Return(transactionBody *flow.TransactionBody, err error) *TransactionsReader_ByID_Call {
	_c.Call.Return(transactionBody, err)
	return _c
}

func (_c *TransactionsReader_ByID_Call) RunAndReturn(run func(txID flow.Identifier) (*flow.TransactionBody, error)) *TransactionsReader_ByID_Call {
	_c.Call.Return(run)
	return _c
}

// NewTransactions creates a new instance of Transactions. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewTransactions(t interface {
	mock.TestingT
	Cleanup(func())
}) *Transactions {
	mock := &Transactions{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Transactions is an autogenerated mock type for the Transactions type
type Transactions struct {
	mock.Mock
}

type Transactions_Expecter struct {
	mock *mock.Mock
}

func (_m *Transactions) EXPECT() *Transactions_Expecter {
	return &Transactions_Expecter{mock: &_m.Mock}
}

// BatchStore provides a mock function for the type Transactions
func (_mock *Transactions) BatchStore(tx *flow.TransactionBody, batch storage.ReaderBatchWriter) error {
	ret := _mock.Called(tx, batch)

	if len(ret) == 0 {
		panic("no return value specified for BatchStore")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*flow.TransactionBody, storage.ReaderBatchWriter) error); ok {
		r0 = returnFunc(tx, batch)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Transactions_BatchStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BatchStore'
type Transactions_BatchStore_Call struct {
	*mock.Call
}

// BatchStore is a helper method to define mock.On call
//   - tx *flow.TransactionBody
//   - batch storage.ReaderBatchWriter
func (_e *Transactions_Expecter) BatchStore(tx interface{}, batch interface{}) *Transactions_BatchStore_Call {
	return &Transactions_BatchStore_Call{Call: _e.mock.On("BatchStore", tx, batch)}
}

func (_c *Transactions_BatchStore_Call) Run(run func(tx *flow.TransactionBody, batch storage.ReaderBatchWriter)) *Transactions_BatchStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *flow.TransactionBody
		if args[0] != nil {
			arg0 = args[0].(*flow.TransactionBody)
		}
		var arg1 storage.ReaderBatchWriter
		if args[1] != nil {
			arg1 = args[1].(storage.ReaderBatchWriter)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Transactions_BatchStore_Call) Return(err error) *Transactions_BatchStore_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Transactions_BatchStore_Call) RunAndReturn(run func(tx *flow.TransactionBody, batch storage.ReaderBatchWriter) error) *Transactions_BatchStore_Call {
	_c.Call.Return(run)
	return _c
}

// ByID provides a mock function for the type Transactions
func (_mock *Transactions) ByID(txID flow.Identifier) (*flow.TransactionBody, error) {
	ret := _mock.Called(txID)

	if len(ret) == 0 {
		panic("no return value specified for ByID")
	}

	var r0 *flow.TransactionBody
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (*flow.TransactionBody, error)); ok {
		return returnFunc(txID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) *flow.TransactionBody); ok {
		r0 = returnFunc(txID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.TransactionBody)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(txID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Transactions_ByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByID'
type Transactions_ByID_Call struct {
	*mock.Call
}

// ByID is a helper method to define mock.On call
//   - txID flow.Identifier
func (_e *Transactions_Expecter) ByID(txID interface{}) *Transactions_ByID_Call {
	return &Transactions_ByID_Call{Call: _e.mock.On("ByID", txID)}
}

func (_c *Transactions_ByID_Call) Run(run func(txID flow.Identifier)) *Transactions_ByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Transactions_ByID_Call) Return(transactionBody *flow.TransactionBody, err error) *Transactions_ByID_Call {
	_c.Call.Return(transactionBody, err)
	return _c
}

func (_c *Transactions_ByID_Call) RunAndReturn(run func(txID flow.Identifier) (*flow.TransactionBody, error)) *Transactions_ByID_Call {
	_c.Call.Return(run)
	return _c
}

// Store provides a mock function for the type Transactions
func (_mock *Transactions) Store(tx *flow.TransactionBody) error {
	ret := _mock.Called(tx)

	if len(ret) == 0 {
		panic("no return value specified for Store")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*flow.TransactionBody) error); ok {
		r0 = returnFunc(tx)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Transactions_Store_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Store'
type Transactions_Store_Call struct {
	*mock.Call
}

// Store is a helper method to define mock.On call
//   - tx *flow.TransactionBody
func (_e *Transactions_Expecter) Store(tx interface{}) *Transactions_Store_Call {
	return &Transactions_Store_Call{Call: _e.mock.On("Store", tx)}
}

func (_c *Transactions_Store_Call) Run(run func(tx *flow.TransactionBody)) *Transactions_Store_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *flow.TransactionBody
		if args[0] != nil {
			arg0 = args[0].(*flow.TransactionBody)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Transactions_Store_Call) Return(err error) *Transactions_Store_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Transactions_Store_Call) RunAndReturn(run func(tx *flow.TransactionBody) error) *Transactions_Store_Call {
	_c.Call.Return(run)
	return _c
}

// NewVersionBeacons creates a new instance of VersionBeacons. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewVersionBeacons(t interface {
	mock.TestingT
	Cleanup(func())
}) *VersionBeacons {
	mock := &VersionBeacons{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// VersionBeacons is an autogenerated mock type for the VersionBeacons type
type VersionBeacons struct {
	mock.Mock
}

type VersionBeacons_Expecter struct {
	mock *mock.Mock
}

func (_m *VersionBeacons) EXPECT() *VersionBeacons_Expecter {
	return &VersionBeacons_Expecter{mock: &_m.Mock}
}

// Highest provides a mock function for the type VersionBeacons
func (_mock *VersionBeacons) Highest(belowOrEqualTo uint64) (*flow.SealedVersionBeacon, error) {
	ret := _mock.Called(belowOrEqualTo)

	if len(ret) == 0 {
		panic("no return value specified for Highest")
	}

	var r0 *flow.SealedVersionBeacon
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(uint64) (*flow.SealedVersionBeacon, error)); ok {
		return returnFunc(belowOrEqualTo)
	}
	if returnFunc, ok := ret.Get(0).(func(uint64) *flow.SealedVersionBeacon); ok {
		r0 = returnFunc(belowOrEqualTo)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.SealedVersionBeacon)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(uint64) error); ok {
		r1 = returnFunc(belowOrEqualTo)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// VersionBeacons_Highest_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Highest'
type VersionBeacons_Highest_Call struct {
	*mock.Call
}

// Highest is a helper method to define mock.On call
//   - belowOrEqualTo uint64
func (_e *VersionBeacons_Expecter) Highest(belowOrEqualTo interface{}) *VersionBeacons_Highest_Call {
	return &VersionBeacons_Highest_Call{Call: _e.mock.On("Highest", belowOrEqualTo)}
}

func (_c *VersionBeacons_Highest_Call) Run(run func(belowOrEqualTo uint64)) *VersionBeacons_Highest_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *VersionBeacons_Highest_Call) Return(sealedVersionBeacon *flow.SealedVersionBeacon, err error) *VersionBeacons_Highest_Call {
	_c.Call.Return(sealedVersionBeacon, err)
	return _c
}

func (_c *VersionBeacons_Highest_Call) RunAndReturn(run func(belowOrEqualTo uint64) (*flow.SealedVersionBeacon, error)) *VersionBeacons_Highest_Call {
	_c.Call.Return(run)
	return _c
}
