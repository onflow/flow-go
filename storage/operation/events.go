package operation

import (
	"fmt"

	"github.com/jordanschalm/lockctx"

	"github.com/onflow/flow-go/model/flow"
	"github.com/onflow/flow-go/storage"
)

func eventPrefix(prefix byte, blockID flow.Identifier, event flow.Event) []byte {
	return MakePrefix(prefix, blockID, event.TransactionID, event.TransactionIndex, event.EventIndex)
}

// InsertBlockEvents stores all events for a given block in the database.
// Requires LockInsertEvent to be held for thread safety.
// This function iterates through all events in the provided EventsList and stores each event individually.
// It returns [storage.ErrAlreadyExists] if events for the block already exist.
func InsertBlockEvents(lctx lockctx.Proof, rw storage.ReaderBatchWriter, blockID flow.Identifier, events []flow.EventsList) error {
	if !lctx.HoldsLock(storage.LockInsertEvent) {
		return fmt.Errorf("InsertBlockEvents requires LockInsertEvent to be held")
	}

	// Check if events for the block already exist
	// We can exit early if we find one existing event E, assuming that the process which wrote E in the past
	// correctly inserted all other events for the block containing E.
	// This function only inserts new events; it does not sanity check existing events or ever overwrite events.
	prefix := MakePrefix(codeEvent, blockID)
	checkExists := func(key []byte) error {
		return fmt.Errorf("event with key %x already exists under prefix %x: %w", key, prefix, storage.ErrAlreadyExists)
	}

	err := IterateKeysByPrefixRange(rw.GlobalReader(), prefix, prefix, checkExists)
	if err != nil {
		return err
	}

	writer := rw.Writer()

	for _, eventsList := range events {
		for _, event := range eventsList {
			err := insertEvent(writer, blockID, event)
			if err != nil {
				return fmt.Errorf("cannot batch insert event: %w", err)
			}
		}
	}

	return nil
}

// insertEvent stores a regular event in the database.
// The event is stored with a key that includes the block ID, transaction ID, transaction index, and event index.
func insertEvent(w storage.Writer, blockID flow.Identifier, event flow.Event) error {
	return UpsertByKey(w, eventPrefix(codeEvent, blockID, event), event)
}

// InsertBlockServiceEvents stores all service events for a given block in the database.
// Requires LockInsertServiceEvent to be held for thread safety.
// This function iterates through all service events in the provided list and stores each event individually.
// Service events are special events generated by the system (e.g., account creation, contract deployment).
// It returns [storage.ErrAlreadyExists] if events for the block already exist.
func InsertBlockServiceEvents(lctx lockctx.Proof, rw storage.ReaderBatchWriter, blockID flow.Identifier, events []flow.Event) error {
	if !lctx.HoldsLock(storage.LockInsertServiceEvent) {
		return fmt.Errorf("InsertBlockServiceEvents requires LockInsertServiceEvent to be held")
	}

	// Check if events for the block already exist
	// We can exit early if we find one existing event E, assuming that the process which wrote E in the past
	// correctly inserted all other events for the block containing E.
	// This function only inserts new events; it does not sanity check existing events or ever overwrite events.
	prefix := MakePrefix(codeServiceEvent, blockID)
	checkExists := func(key []byte) error {
		return fmt.Errorf("event with key %x already exists under prefix %x: %w", key, prefix, storage.ErrAlreadyExists)
	}

	err := IterateKeysByPrefixRange(rw.GlobalReader(), prefix, prefix, checkExists)
	if err != nil {
		return err
	}

	writer := rw.Writer()

	for _, event := range events {
		err := insertServiceEvent(writer, blockID, event)
		if err != nil {
			return fmt.Errorf("cannot batch insert service event: %w", err)
		}
	}

	return nil
}

// insertServiceEvent stores a service event in the database.
// The event is stored with a key that includes the block ID, transaction ID, transaction index, and event index.
func insertServiceEvent(w storage.Writer, blockID flow.Identifier, event flow.Event) error {
	return UpsertByKey(w, eventPrefix(codeServiceEvent, blockID, event), event)
}

func RetrieveEvents(r storage.Reader, blockID flow.Identifier, transactionID flow.Identifier, events *[]flow.Event) error {
	iterationFunc := eventIterationFunc(events)
	return TraverseByPrefix(r, MakePrefix(codeEvent, blockID, transactionID), iterationFunc, storage.DefaultIteratorOptions())
}

func LookupEventsByBlockID(r storage.Reader, blockID flow.Identifier, events *[]flow.Event) error {
	iterationFunc := eventIterationFunc(events)
	return TraverseByPrefix(r, MakePrefix(codeEvent, blockID), iterationFunc, storage.DefaultIteratorOptions())
}

func LookupServiceEventsByBlockID(r storage.Reader, blockID flow.Identifier, events *[]flow.Event) error {
	iterationFunc := eventIterationFunc(events)
	return TraverseByPrefix(r, MakePrefix(codeServiceEvent, blockID), iterationFunc, storage.DefaultIteratorOptions())
}

func LookupEventsByBlockIDEventType(r storage.Reader, blockID flow.Identifier, eventType flow.EventType, events *[]flow.Event) error {
	iterationFunc := eventFilterIterationFunc(events, eventType)
	return TraverseByPrefix(r, MakePrefix(codeEvent, blockID), iterationFunc, storage.DefaultIteratorOptions())
}

// RemoveServiceEventsByBlockID removes all service events associated with the given block ID.
// This operation is typically used during block rollback or cleanup scenarios.
// It removes all service events that were generated for the specified block.
//
// Error returns:
//   - generic error in case of unexpected database error
func RemoveServiceEventsByBlockID(r storage.Reader, w storage.Writer, blockID flow.Identifier) error {
	return RemoveByKeyPrefix(r, w, MakePrefix(codeServiceEvent, blockID))
}

// RemoveEventsByBlockID removes all regular events associated with the given block ID.
// This operation is typically used during block rollback or cleanup scenarios.
// It removes all regular events that were generated for the specified block.
//
// Error returns:
//   - generic error in case of unexpected database error
func RemoveEventsByBlockID(r storage.Reader, w storage.Writer, blockID flow.Identifier) error {
	return RemoveByKeyPrefix(r, w, MakePrefix(codeEvent, blockID))
}

// eventIterationFunc returns an in iteration function which returns all events found during traversal or iteration
func eventIterationFunc(events *[]flow.Event) IterationFunc {
	return func(keyCopy []byte, getValue func(destVal any) error) (bail bool, err error) {
		var event flow.Event
		err = getValue(&event)
		if err != nil {
			return true, err
		}
		*events = append(*events, event)
		return false, nil
	}
}

// eventFilterIterationFunc returns an iteration function which filters the result by the given event type in the handleFunc
func eventFilterIterationFunc(events *[]flow.Event, eventType flow.EventType) IterationFunc {
	return func(keyCopy []byte, getValue func(destVal any) error) (bail bool, err error) {
		var event flow.Event
		err = getValue(&event)
		if err != nil {
			return true, err
		}
		// filter out all events not of type eventType
		if event.Type == eventType {
			*events = append(*events, event)
		}
		return false, nil
	}
}
