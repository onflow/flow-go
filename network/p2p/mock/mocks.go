// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mock

import (
	"context"
	"time"

	"github.com/libp2p/go-libp2p-kbucket"
	"github.com/libp2p/go-libp2p-pubsub"
	"github.com/libp2p/go-libp2p-pubsub/pb"
	"github.com/libp2p/go-libp2p/core/connmgr"
	"github.com/libp2p/go-libp2p/core/control"
	"github.com/libp2p/go-libp2p/core/host"
	"github.com/libp2p/go-libp2p/core/network"
	"github.com/libp2p/go-libp2p/core/peer"
	"github.com/libp2p/go-libp2p/core/protocol"
	"github.com/libp2p/go-libp2p/core/routing"
	"github.com/multiformats/go-multiaddr"
	"github.com/multiformats/go-multiaddr-dns"
	"github.com/onflow/flow-go/model/flow"
	"github.com/onflow/flow-go/module/component"
	"github.com/onflow/flow-go/module/irrecoverable"
	network0 "github.com/onflow/flow-go/network"
	"github.com/onflow/flow-go/network/channels"
	"github.com/onflow/flow-go/network/p2p"
	"github.com/onflow/flow-go/network/p2p/unicast/protocols"
	mock "github.com/stretchr/testify/mock"
)

// NewGossipSubBuilder creates a new instance of GossipSubBuilder. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewGossipSubBuilder(t interface {
	mock.TestingT
	Cleanup(func())
}) *GossipSubBuilder {
	mock := &GossipSubBuilder{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// GossipSubBuilder is an autogenerated mock type for the GossipSubBuilder type
type GossipSubBuilder struct {
	mock.Mock
}

type GossipSubBuilder_Expecter struct {
	mock *mock.Mock
}

func (_m *GossipSubBuilder) EXPECT() *GossipSubBuilder_Expecter {
	return &GossipSubBuilder_Expecter{mock: &_m.Mock}
}

// Build provides a mock function for the type GossipSubBuilder
func (_mock *GossipSubBuilder) Build(signalerContext irrecoverable.SignalerContext) (p2p.PubSubAdapter, error) {
	ret := _mock.Called(signalerContext)

	if len(ret) == 0 {
		panic("no return value specified for Build")
	}

	var r0 p2p.PubSubAdapter
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(irrecoverable.SignalerContext) (p2p.PubSubAdapter, error)); ok {
		return returnFunc(signalerContext)
	}
	if returnFunc, ok := ret.Get(0).(func(irrecoverable.SignalerContext) p2p.PubSubAdapter); ok {
		r0 = returnFunc(signalerContext)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(p2p.PubSubAdapter)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(irrecoverable.SignalerContext) error); ok {
		r1 = returnFunc(signalerContext)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// GossipSubBuilder_Build_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Build'
type GossipSubBuilder_Build_Call struct {
	*mock.Call
}

// Build is a helper method to define mock.On call
//   - signalerContext irrecoverable.SignalerContext
func (_e *GossipSubBuilder_Expecter) Build(signalerContext interface{}) *GossipSubBuilder_Build_Call {
	return &GossipSubBuilder_Build_Call{Call: _e.mock.On("Build", signalerContext)}
}

func (_c *GossipSubBuilder_Build_Call) Run(run func(signalerContext irrecoverable.SignalerContext)) *GossipSubBuilder_Build_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 irrecoverable.SignalerContext
		if args[0] != nil {
			arg0 = args[0].(irrecoverable.SignalerContext)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *GossipSubBuilder_Build_Call) Return(pubSubAdapter p2p.PubSubAdapter, err error) *GossipSubBuilder_Build_Call {
	_c.Call.Return(pubSubAdapter, err)
	return _c
}

func (_c *GossipSubBuilder_Build_Call) RunAndReturn(run func(signalerContext irrecoverable.SignalerContext) (p2p.PubSubAdapter, error)) *GossipSubBuilder_Build_Call {
	_c.Call.Return(run)
	return _c
}

// EnableGossipSubScoringWithOverride provides a mock function for the type GossipSubBuilder
func (_mock *GossipSubBuilder) EnableGossipSubScoringWithOverride(peerScoringConfigOverride *p2p.PeerScoringConfigOverride) {
	_mock.Called(peerScoringConfigOverride)
	return
}

// GossipSubBuilder_EnableGossipSubScoringWithOverride_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnableGossipSubScoringWithOverride'
type GossipSubBuilder_EnableGossipSubScoringWithOverride_Call struct {
	*mock.Call
}

// EnableGossipSubScoringWithOverride is a helper method to define mock.On call
//   - peerScoringConfigOverride *p2p.PeerScoringConfigOverride
func (_e *GossipSubBuilder_Expecter) EnableGossipSubScoringWithOverride(peerScoringConfigOverride interface{}) *GossipSubBuilder_EnableGossipSubScoringWithOverride_Call {
	return &GossipSubBuilder_EnableGossipSubScoringWithOverride_Call{Call: _e.mock.On("EnableGossipSubScoringWithOverride", peerScoringConfigOverride)}
}

func (_c *GossipSubBuilder_EnableGossipSubScoringWithOverride_Call) Run(run func(peerScoringConfigOverride *p2p.PeerScoringConfigOverride)) *GossipSubBuilder_EnableGossipSubScoringWithOverride_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *p2p.PeerScoringConfigOverride
		if args[0] != nil {
			arg0 = args[0].(*p2p.PeerScoringConfigOverride)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *GossipSubBuilder_EnableGossipSubScoringWithOverride_Call) Return() *GossipSubBuilder_EnableGossipSubScoringWithOverride_Call {
	_c.Call.Return()
	return _c
}

func (_c *GossipSubBuilder_EnableGossipSubScoringWithOverride_Call) RunAndReturn(run func(peerScoringConfigOverride *p2p.PeerScoringConfigOverride)) *GossipSubBuilder_EnableGossipSubScoringWithOverride_Call {
	_c.Run(run)
	return _c
}

// OverrideDefaultRpcInspectorFactory provides a mock function for the type GossipSubBuilder
func (_mock *GossipSubBuilder) OverrideDefaultRpcInspectorFactory(gossipSubRpcInspectorFactoryFunc p2p.GossipSubRpcInspectorFactoryFunc) {
	_mock.Called(gossipSubRpcInspectorFactoryFunc)
	return
}

// GossipSubBuilder_OverrideDefaultRpcInspectorFactory_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OverrideDefaultRpcInspectorFactory'
type GossipSubBuilder_OverrideDefaultRpcInspectorFactory_Call struct {
	*mock.Call
}

// OverrideDefaultRpcInspectorFactory is a helper method to define mock.On call
//   - gossipSubRpcInspectorFactoryFunc p2p.GossipSubRpcInspectorFactoryFunc
func (_e *GossipSubBuilder_Expecter) OverrideDefaultRpcInspectorFactory(gossipSubRpcInspectorFactoryFunc interface{}) *GossipSubBuilder_OverrideDefaultRpcInspectorFactory_Call {
	return &GossipSubBuilder_OverrideDefaultRpcInspectorFactory_Call{Call: _e.mock.On("OverrideDefaultRpcInspectorFactory", gossipSubRpcInspectorFactoryFunc)}
}

func (_c *GossipSubBuilder_OverrideDefaultRpcInspectorFactory_Call) Run(run func(gossipSubRpcInspectorFactoryFunc p2p.GossipSubRpcInspectorFactoryFunc)) *GossipSubBuilder_OverrideDefaultRpcInspectorFactory_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 p2p.GossipSubRpcInspectorFactoryFunc
		if args[0] != nil {
			arg0 = args[0].(p2p.GossipSubRpcInspectorFactoryFunc)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *GossipSubBuilder_OverrideDefaultRpcInspectorFactory_Call) Return() *GossipSubBuilder_OverrideDefaultRpcInspectorFactory_Call {
	_c.Call.Return()
	return _c
}

func (_c *GossipSubBuilder_OverrideDefaultRpcInspectorFactory_Call) RunAndReturn(run func(gossipSubRpcInspectorFactoryFunc p2p.GossipSubRpcInspectorFactoryFunc)) *GossipSubBuilder_OverrideDefaultRpcInspectorFactory_Call {
	_c.Run(run)
	return _c
}

// OverrideDefaultValidateQueueSize provides a mock function for the type GossipSubBuilder
func (_mock *GossipSubBuilder) OverrideDefaultValidateQueueSize(n int) {
	_mock.Called(n)
	return
}

// GossipSubBuilder_OverrideDefaultValidateQueueSize_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OverrideDefaultValidateQueueSize'
type GossipSubBuilder_OverrideDefaultValidateQueueSize_Call struct {
	*mock.Call
}

// OverrideDefaultValidateQueueSize is a helper method to define mock.On call
//   - n int
func (_e *GossipSubBuilder_Expecter) OverrideDefaultValidateQueueSize(n interface{}) *GossipSubBuilder_OverrideDefaultValidateQueueSize_Call {
	return &GossipSubBuilder_OverrideDefaultValidateQueueSize_Call{Call: _e.mock.On("OverrideDefaultValidateQueueSize", n)}
}

func (_c *GossipSubBuilder_OverrideDefaultValidateQueueSize_Call) Run(run func(n int)) *GossipSubBuilder_OverrideDefaultValidateQueueSize_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 int
		if args[0] != nil {
			arg0 = args[0].(int)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *GossipSubBuilder_OverrideDefaultValidateQueueSize_Call) Return() *GossipSubBuilder_OverrideDefaultValidateQueueSize_Call {
	_c.Call.Return()
	return _c
}

func (_c *GossipSubBuilder_OverrideDefaultValidateQueueSize_Call) RunAndReturn(run func(n int)) *GossipSubBuilder_OverrideDefaultValidateQueueSize_Call {
	_c.Run(run)
	return _c
}

// SetGossipSubConfigFunc provides a mock function for the type GossipSubBuilder
func (_mock *GossipSubBuilder) SetGossipSubConfigFunc(gossipSubAdapterConfigFunc p2p.GossipSubAdapterConfigFunc) {
	_mock.Called(gossipSubAdapterConfigFunc)
	return
}

// GossipSubBuilder_SetGossipSubConfigFunc_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetGossipSubConfigFunc'
type GossipSubBuilder_SetGossipSubConfigFunc_Call struct {
	*mock.Call
}

// SetGossipSubConfigFunc is a helper method to define mock.On call
//   - gossipSubAdapterConfigFunc p2p.GossipSubAdapterConfigFunc
func (_e *GossipSubBuilder_Expecter) SetGossipSubConfigFunc(gossipSubAdapterConfigFunc interface{}) *GossipSubBuilder_SetGossipSubConfigFunc_Call {
	return &GossipSubBuilder_SetGossipSubConfigFunc_Call{Call: _e.mock.On("SetGossipSubConfigFunc", gossipSubAdapterConfigFunc)}
}

func (_c *GossipSubBuilder_SetGossipSubConfigFunc_Call) Run(run func(gossipSubAdapterConfigFunc p2p.GossipSubAdapterConfigFunc)) *GossipSubBuilder_SetGossipSubConfigFunc_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 p2p.GossipSubAdapterConfigFunc
		if args[0] != nil {
			arg0 = args[0].(p2p.GossipSubAdapterConfigFunc)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *GossipSubBuilder_SetGossipSubConfigFunc_Call) Return() *GossipSubBuilder_SetGossipSubConfigFunc_Call {
	_c.Call.Return()
	return _c
}

func (_c *GossipSubBuilder_SetGossipSubConfigFunc_Call) RunAndReturn(run func(gossipSubAdapterConfigFunc p2p.GossipSubAdapterConfigFunc)) *GossipSubBuilder_SetGossipSubConfigFunc_Call {
	_c.Run(run)
	return _c
}

// SetGossipSubFactory provides a mock function for the type GossipSubBuilder
func (_mock *GossipSubBuilder) SetGossipSubFactory(gossipSubFactoryFunc p2p.GossipSubFactoryFunc) {
	_mock.Called(gossipSubFactoryFunc)
	return
}

// GossipSubBuilder_SetGossipSubFactory_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetGossipSubFactory'
type GossipSubBuilder_SetGossipSubFactory_Call struct {
	*mock.Call
}

// SetGossipSubFactory is a helper method to define mock.On call
//   - gossipSubFactoryFunc p2p.GossipSubFactoryFunc
func (_e *GossipSubBuilder_Expecter) SetGossipSubFactory(gossipSubFactoryFunc interface{}) *GossipSubBuilder_SetGossipSubFactory_Call {
	return &GossipSubBuilder_SetGossipSubFactory_Call{Call: _e.mock.On("SetGossipSubFactory", gossipSubFactoryFunc)}
}

func (_c *GossipSubBuilder_SetGossipSubFactory_Call) Run(run func(gossipSubFactoryFunc p2p.GossipSubFactoryFunc)) *GossipSubBuilder_SetGossipSubFactory_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 p2p.GossipSubFactoryFunc
		if args[0] != nil {
			arg0 = args[0].(p2p.GossipSubFactoryFunc)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *GossipSubBuilder_SetGossipSubFactory_Call) Return() *GossipSubBuilder_SetGossipSubFactory_Call {
	_c.Call.Return()
	return _c
}

func (_c *GossipSubBuilder_SetGossipSubFactory_Call) RunAndReturn(run func(gossipSubFactoryFunc p2p.GossipSubFactoryFunc)) *GossipSubBuilder_SetGossipSubFactory_Call {
	_c.Run(run)
	return _c
}

// SetHost provides a mock function for the type GossipSubBuilder
func (_mock *GossipSubBuilder) SetHost(host1 host.Host) {
	_mock.Called(host1)
	return
}

// GossipSubBuilder_SetHost_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetHost'
type GossipSubBuilder_SetHost_Call struct {
	*mock.Call
}

// SetHost is a helper method to define mock.On call
//   - host1 host.Host
func (_e *GossipSubBuilder_Expecter) SetHost(host1 interface{}) *GossipSubBuilder_SetHost_Call {
	return &GossipSubBuilder_SetHost_Call{Call: _e.mock.On("SetHost", host1)}
}

func (_c *GossipSubBuilder_SetHost_Call) Run(run func(host1 host.Host)) *GossipSubBuilder_SetHost_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 host.Host
		if args[0] != nil {
			arg0 = args[0].(host.Host)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *GossipSubBuilder_SetHost_Call) Return() *GossipSubBuilder_SetHost_Call {
	_c.Call.Return()
	return _c
}

func (_c *GossipSubBuilder_SetHost_Call) RunAndReturn(run func(host1 host.Host)) *GossipSubBuilder_SetHost_Call {
	_c.Run(run)
	return _c
}

// SetRoutingSystem provides a mock function for the type GossipSubBuilder
func (_mock *GossipSubBuilder) SetRoutingSystem(routing1 routing.Routing) {
	_mock.Called(routing1)
	return
}

// GossipSubBuilder_SetRoutingSystem_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetRoutingSystem'
type GossipSubBuilder_SetRoutingSystem_Call struct {
	*mock.Call
}

// SetRoutingSystem is a helper method to define mock.On call
//   - routing1 routing.Routing
func (_e *GossipSubBuilder_Expecter) SetRoutingSystem(routing1 interface{}) *GossipSubBuilder_SetRoutingSystem_Call {
	return &GossipSubBuilder_SetRoutingSystem_Call{Call: _e.mock.On("SetRoutingSystem", routing1)}
}

func (_c *GossipSubBuilder_SetRoutingSystem_Call) Run(run func(routing1 routing.Routing)) *GossipSubBuilder_SetRoutingSystem_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 routing.Routing
		if args[0] != nil {
			arg0 = args[0].(routing.Routing)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *GossipSubBuilder_SetRoutingSystem_Call) Return() *GossipSubBuilder_SetRoutingSystem_Call {
	_c.Call.Return()
	return _c
}

func (_c *GossipSubBuilder_SetRoutingSystem_Call) RunAndReturn(run func(routing1 routing.Routing)) *GossipSubBuilder_SetRoutingSystem_Call {
	_c.Run(run)
	return _c
}

// SetSubscriptionFilter provides a mock function for the type GossipSubBuilder
func (_mock *GossipSubBuilder) SetSubscriptionFilter(subscriptionFilter pubsub.SubscriptionFilter) {
	_mock.Called(subscriptionFilter)
	return
}

// GossipSubBuilder_SetSubscriptionFilter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetSubscriptionFilter'
type GossipSubBuilder_SetSubscriptionFilter_Call struct {
	*mock.Call
}

// SetSubscriptionFilter is a helper method to define mock.On call
//   - subscriptionFilter pubsub.SubscriptionFilter
func (_e *GossipSubBuilder_Expecter) SetSubscriptionFilter(subscriptionFilter interface{}) *GossipSubBuilder_SetSubscriptionFilter_Call {
	return &GossipSubBuilder_SetSubscriptionFilter_Call{Call: _e.mock.On("SetSubscriptionFilter", subscriptionFilter)}
}

func (_c *GossipSubBuilder_SetSubscriptionFilter_Call) Run(run func(subscriptionFilter pubsub.SubscriptionFilter)) *GossipSubBuilder_SetSubscriptionFilter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 pubsub.SubscriptionFilter
		if args[0] != nil {
			arg0 = args[0].(pubsub.SubscriptionFilter)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *GossipSubBuilder_SetSubscriptionFilter_Call) Return() *GossipSubBuilder_SetSubscriptionFilter_Call {
	_c.Call.Return()
	return _c
}

func (_c *GossipSubBuilder_SetSubscriptionFilter_Call) RunAndReturn(run func(subscriptionFilter pubsub.SubscriptionFilter)) *GossipSubBuilder_SetSubscriptionFilter_Call {
	_c.Run(run)
	return _c
}

// NewNodeBuilder creates a new instance of NodeBuilder. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewNodeBuilder(t interface {
	mock.TestingT
	Cleanup(func())
}) *NodeBuilder {
	mock := &NodeBuilder{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// NodeBuilder is an autogenerated mock type for the NodeBuilder type
type NodeBuilder struct {
	mock.Mock
}

type NodeBuilder_Expecter struct {
	mock *mock.Mock
}

func (_m *NodeBuilder) EXPECT() *NodeBuilder_Expecter {
	return &NodeBuilder_Expecter{mock: &_m.Mock}
}

// Build provides a mock function for the type NodeBuilder
func (_mock *NodeBuilder) Build() (p2p.LibP2PNode, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Build")
	}

	var r0 p2p.LibP2PNode
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (p2p.LibP2PNode, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() p2p.LibP2PNode); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(p2p.LibP2PNode)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// NodeBuilder_Build_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Build'
type NodeBuilder_Build_Call struct {
	*mock.Call
}

// Build is a helper method to define mock.On call
func (_e *NodeBuilder_Expecter) Build() *NodeBuilder_Build_Call {
	return &NodeBuilder_Build_Call{Call: _e.mock.On("Build")}
}

func (_c *NodeBuilder_Build_Call) Run(run func()) *NodeBuilder_Build_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *NodeBuilder_Build_Call) Return(libP2PNode p2p.LibP2PNode, err error) *NodeBuilder_Build_Call {
	_c.Call.Return(libP2PNode, err)
	return _c
}

func (_c *NodeBuilder_Build_Call) RunAndReturn(run func() (p2p.LibP2PNode, error)) *NodeBuilder_Build_Call {
	_c.Call.Return(run)
	return _c
}

// OverrideDefaultRpcInspectorFactory provides a mock function for the type NodeBuilder
func (_mock *NodeBuilder) OverrideDefaultRpcInspectorFactory(gossipSubRpcInspectorFactoryFunc p2p.GossipSubRpcInspectorFactoryFunc) p2p.NodeBuilder {
	ret := _mock.Called(gossipSubRpcInspectorFactoryFunc)

	if len(ret) == 0 {
		panic("no return value specified for OverrideDefaultRpcInspectorFactory")
	}

	var r0 p2p.NodeBuilder
	if returnFunc, ok := ret.Get(0).(func(p2p.GossipSubRpcInspectorFactoryFunc) p2p.NodeBuilder); ok {
		r0 = returnFunc(gossipSubRpcInspectorFactoryFunc)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(p2p.NodeBuilder)
		}
	}
	return r0
}

// NodeBuilder_OverrideDefaultRpcInspectorFactory_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OverrideDefaultRpcInspectorFactory'
type NodeBuilder_OverrideDefaultRpcInspectorFactory_Call struct {
	*mock.Call
}

// OverrideDefaultRpcInspectorFactory is a helper method to define mock.On call
//   - gossipSubRpcInspectorFactoryFunc p2p.GossipSubRpcInspectorFactoryFunc
func (_e *NodeBuilder_Expecter) OverrideDefaultRpcInspectorFactory(gossipSubRpcInspectorFactoryFunc interface{}) *NodeBuilder_OverrideDefaultRpcInspectorFactory_Call {
	return &NodeBuilder_OverrideDefaultRpcInspectorFactory_Call{Call: _e.mock.On("OverrideDefaultRpcInspectorFactory", gossipSubRpcInspectorFactoryFunc)}
}

func (_c *NodeBuilder_OverrideDefaultRpcInspectorFactory_Call) Run(run func(gossipSubRpcInspectorFactoryFunc p2p.GossipSubRpcInspectorFactoryFunc)) *NodeBuilder_OverrideDefaultRpcInspectorFactory_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 p2p.GossipSubRpcInspectorFactoryFunc
		if args[0] != nil {
			arg0 = args[0].(p2p.GossipSubRpcInspectorFactoryFunc)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *NodeBuilder_OverrideDefaultRpcInspectorFactory_Call) Return(nodeBuilder p2p.NodeBuilder) *NodeBuilder_OverrideDefaultRpcInspectorFactory_Call {
	_c.Call.Return(nodeBuilder)
	return _c
}

func (_c *NodeBuilder_OverrideDefaultRpcInspectorFactory_Call) RunAndReturn(run func(gossipSubRpcInspectorFactoryFunc p2p.GossipSubRpcInspectorFactoryFunc) p2p.NodeBuilder) *NodeBuilder_OverrideDefaultRpcInspectorFactory_Call {
	_c.Call.Return(run)
	return _c
}

// OverrideDefaultValidateQueueSize provides a mock function for the type NodeBuilder
func (_mock *NodeBuilder) OverrideDefaultValidateQueueSize(n int) p2p.NodeBuilder {
	ret := _mock.Called(n)

	if len(ret) == 0 {
		panic("no return value specified for OverrideDefaultValidateQueueSize")
	}

	var r0 p2p.NodeBuilder
	if returnFunc, ok := ret.Get(0).(func(int) p2p.NodeBuilder); ok {
		r0 = returnFunc(n)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(p2p.NodeBuilder)
		}
	}
	return r0
}

// NodeBuilder_OverrideDefaultValidateQueueSize_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OverrideDefaultValidateQueueSize'
type NodeBuilder_OverrideDefaultValidateQueueSize_Call struct {
	*mock.Call
}

// OverrideDefaultValidateQueueSize is a helper method to define mock.On call
//   - n int
func (_e *NodeBuilder_Expecter) OverrideDefaultValidateQueueSize(n interface{}) *NodeBuilder_OverrideDefaultValidateQueueSize_Call {
	return &NodeBuilder_OverrideDefaultValidateQueueSize_Call{Call: _e.mock.On("OverrideDefaultValidateQueueSize", n)}
}

func (_c *NodeBuilder_OverrideDefaultValidateQueueSize_Call) Run(run func(n int)) *NodeBuilder_OverrideDefaultValidateQueueSize_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 int
		if args[0] != nil {
			arg0 = args[0].(int)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *NodeBuilder_OverrideDefaultValidateQueueSize_Call) Return(nodeBuilder p2p.NodeBuilder) *NodeBuilder_OverrideDefaultValidateQueueSize_Call {
	_c.Call.Return(nodeBuilder)
	return _c
}

func (_c *NodeBuilder_OverrideDefaultValidateQueueSize_Call) RunAndReturn(run func(n int) p2p.NodeBuilder) *NodeBuilder_OverrideDefaultValidateQueueSize_Call {
	_c.Call.Return(run)
	return _c
}

// OverrideGossipSubFactory provides a mock function for the type NodeBuilder
func (_mock *NodeBuilder) OverrideGossipSubFactory(gossipSubFactoryFunc p2p.GossipSubFactoryFunc, gossipSubAdapterConfigFunc p2p.GossipSubAdapterConfigFunc) p2p.NodeBuilder {
	ret := _mock.Called(gossipSubFactoryFunc, gossipSubAdapterConfigFunc)

	if len(ret) == 0 {
		panic("no return value specified for OverrideGossipSubFactory")
	}

	var r0 p2p.NodeBuilder
	if returnFunc, ok := ret.Get(0).(func(p2p.GossipSubFactoryFunc, p2p.GossipSubAdapterConfigFunc) p2p.NodeBuilder); ok {
		r0 = returnFunc(gossipSubFactoryFunc, gossipSubAdapterConfigFunc)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(p2p.NodeBuilder)
		}
	}
	return r0
}

// NodeBuilder_OverrideGossipSubFactory_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OverrideGossipSubFactory'
type NodeBuilder_OverrideGossipSubFactory_Call struct {
	*mock.Call
}

// OverrideGossipSubFactory is a helper method to define mock.On call
//   - gossipSubFactoryFunc p2p.GossipSubFactoryFunc
//   - gossipSubAdapterConfigFunc p2p.GossipSubAdapterConfigFunc
func (_e *NodeBuilder_Expecter) OverrideGossipSubFactory(gossipSubFactoryFunc interface{}, gossipSubAdapterConfigFunc interface{}) *NodeBuilder_OverrideGossipSubFactory_Call {
	return &NodeBuilder_OverrideGossipSubFactory_Call{Call: _e.mock.On("OverrideGossipSubFactory", gossipSubFactoryFunc, gossipSubAdapterConfigFunc)}
}

func (_c *NodeBuilder_OverrideGossipSubFactory_Call) Run(run func(gossipSubFactoryFunc p2p.GossipSubFactoryFunc, gossipSubAdapterConfigFunc p2p.GossipSubAdapterConfigFunc)) *NodeBuilder_OverrideGossipSubFactory_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 p2p.GossipSubFactoryFunc
		if args[0] != nil {
			arg0 = args[0].(p2p.GossipSubFactoryFunc)
		}
		var arg1 p2p.GossipSubAdapterConfigFunc
		if args[1] != nil {
			arg1 = args[1].(p2p.GossipSubAdapterConfigFunc)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *NodeBuilder_OverrideGossipSubFactory_Call) Return(nodeBuilder p2p.NodeBuilder) *NodeBuilder_OverrideGossipSubFactory_Call {
	_c.Call.Return(nodeBuilder)
	return _c
}

func (_c *NodeBuilder_OverrideGossipSubFactory_Call) RunAndReturn(run func(gossipSubFactoryFunc p2p.GossipSubFactoryFunc, gossipSubAdapterConfigFunc p2p.GossipSubAdapterConfigFunc) p2p.NodeBuilder) *NodeBuilder_OverrideGossipSubFactory_Call {
	_c.Call.Return(run)
	return _c
}

// OverrideGossipSubScoringConfig provides a mock function for the type NodeBuilder
func (_mock *NodeBuilder) OverrideGossipSubScoringConfig(peerScoringConfigOverride *p2p.PeerScoringConfigOverride) p2p.NodeBuilder {
	ret := _mock.Called(peerScoringConfigOverride)

	if len(ret) == 0 {
		panic("no return value specified for OverrideGossipSubScoringConfig")
	}

	var r0 p2p.NodeBuilder
	if returnFunc, ok := ret.Get(0).(func(*p2p.PeerScoringConfigOverride) p2p.NodeBuilder); ok {
		r0 = returnFunc(peerScoringConfigOverride)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(p2p.NodeBuilder)
		}
	}
	return r0
}

// NodeBuilder_OverrideGossipSubScoringConfig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OverrideGossipSubScoringConfig'
type NodeBuilder_OverrideGossipSubScoringConfig_Call struct {
	*mock.Call
}

// OverrideGossipSubScoringConfig is a helper method to define mock.On call
//   - peerScoringConfigOverride *p2p.PeerScoringConfigOverride
func (_e *NodeBuilder_Expecter) OverrideGossipSubScoringConfig(peerScoringConfigOverride interface{}) *NodeBuilder_OverrideGossipSubScoringConfig_Call {
	return &NodeBuilder_OverrideGossipSubScoringConfig_Call{Call: _e.mock.On("OverrideGossipSubScoringConfig", peerScoringConfigOverride)}
}

func (_c *NodeBuilder_OverrideGossipSubScoringConfig_Call) Run(run func(peerScoringConfigOverride *p2p.PeerScoringConfigOverride)) *NodeBuilder_OverrideGossipSubScoringConfig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *p2p.PeerScoringConfigOverride
		if args[0] != nil {
			arg0 = args[0].(*p2p.PeerScoringConfigOverride)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *NodeBuilder_OverrideGossipSubScoringConfig_Call) Return(nodeBuilder p2p.NodeBuilder) *NodeBuilder_OverrideGossipSubScoringConfig_Call {
	_c.Call.Return(nodeBuilder)
	return _c
}

func (_c *NodeBuilder_OverrideGossipSubScoringConfig_Call) RunAndReturn(run func(peerScoringConfigOverride *p2p.PeerScoringConfigOverride) p2p.NodeBuilder) *NodeBuilder_OverrideGossipSubScoringConfig_Call {
	_c.Call.Return(run)
	return _c
}

// OverrideNodeConstructor provides a mock function for the type NodeBuilder
func (_mock *NodeBuilder) OverrideNodeConstructor(nodeConstructor p2p.NodeConstructor) p2p.NodeBuilder {
	ret := _mock.Called(nodeConstructor)

	if len(ret) == 0 {
		panic("no return value specified for OverrideNodeConstructor")
	}

	var r0 p2p.NodeBuilder
	if returnFunc, ok := ret.Get(0).(func(p2p.NodeConstructor) p2p.NodeBuilder); ok {
		r0 = returnFunc(nodeConstructor)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(p2p.NodeBuilder)
		}
	}
	return r0
}

// NodeBuilder_OverrideNodeConstructor_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OverrideNodeConstructor'
type NodeBuilder_OverrideNodeConstructor_Call struct {
	*mock.Call
}

// OverrideNodeConstructor is a helper method to define mock.On call
//   - nodeConstructor p2p.NodeConstructor
func (_e *NodeBuilder_Expecter) OverrideNodeConstructor(nodeConstructor interface{}) *NodeBuilder_OverrideNodeConstructor_Call {
	return &NodeBuilder_OverrideNodeConstructor_Call{Call: _e.mock.On("OverrideNodeConstructor", nodeConstructor)}
}

func (_c *NodeBuilder_OverrideNodeConstructor_Call) Run(run func(nodeConstructor p2p.NodeConstructor)) *NodeBuilder_OverrideNodeConstructor_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 p2p.NodeConstructor
		if args[0] != nil {
			arg0 = args[0].(p2p.NodeConstructor)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *NodeBuilder_OverrideNodeConstructor_Call) Return(nodeBuilder p2p.NodeBuilder) *NodeBuilder_OverrideNodeConstructor_Call {
	_c.Call.Return(nodeBuilder)
	return _c
}

func (_c *NodeBuilder_OverrideNodeConstructor_Call) RunAndReturn(run func(nodeConstructor p2p.NodeConstructor) p2p.NodeBuilder) *NodeBuilder_OverrideNodeConstructor_Call {
	_c.Call.Return(run)
	return _c
}

// SetBasicResolver provides a mock function for the type NodeBuilder
func (_mock *NodeBuilder) SetBasicResolver(basicResolver madns.BasicResolver) p2p.NodeBuilder {
	ret := _mock.Called(basicResolver)

	if len(ret) == 0 {
		panic("no return value specified for SetBasicResolver")
	}

	var r0 p2p.NodeBuilder
	if returnFunc, ok := ret.Get(0).(func(madns.BasicResolver) p2p.NodeBuilder); ok {
		r0 = returnFunc(basicResolver)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(p2p.NodeBuilder)
		}
	}
	return r0
}

// NodeBuilder_SetBasicResolver_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetBasicResolver'
type NodeBuilder_SetBasicResolver_Call struct {
	*mock.Call
}

// SetBasicResolver is a helper method to define mock.On call
//   - basicResolver madns.BasicResolver
func (_e *NodeBuilder_Expecter) SetBasicResolver(basicResolver interface{}) *NodeBuilder_SetBasicResolver_Call {
	return &NodeBuilder_SetBasicResolver_Call{Call: _e.mock.On("SetBasicResolver", basicResolver)}
}

func (_c *NodeBuilder_SetBasicResolver_Call) Run(run func(basicResolver madns.BasicResolver)) *NodeBuilder_SetBasicResolver_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 madns.BasicResolver
		if args[0] != nil {
			arg0 = args[0].(madns.BasicResolver)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *NodeBuilder_SetBasicResolver_Call) Return(nodeBuilder p2p.NodeBuilder) *NodeBuilder_SetBasicResolver_Call {
	_c.Call.Return(nodeBuilder)
	return _c
}

func (_c *NodeBuilder_SetBasicResolver_Call) RunAndReturn(run func(basicResolver madns.BasicResolver) p2p.NodeBuilder) *NodeBuilder_SetBasicResolver_Call {
	_c.Call.Return(run)
	return _c
}

// SetConnectionGater provides a mock function for the type NodeBuilder
func (_mock *NodeBuilder) SetConnectionGater(connectionGater p2p.ConnectionGater) p2p.NodeBuilder {
	ret := _mock.Called(connectionGater)

	if len(ret) == 0 {
		panic("no return value specified for SetConnectionGater")
	}

	var r0 p2p.NodeBuilder
	if returnFunc, ok := ret.Get(0).(func(p2p.ConnectionGater) p2p.NodeBuilder); ok {
		r0 = returnFunc(connectionGater)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(p2p.NodeBuilder)
		}
	}
	return r0
}

// NodeBuilder_SetConnectionGater_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetConnectionGater'
type NodeBuilder_SetConnectionGater_Call struct {
	*mock.Call
}

// SetConnectionGater is a helper method to define mock.On call
//   - connectionGater p2p.ConnectionGater
func (_e *NodeBuilder_Expecter) SetConnectionGater(connectionGater interface{}) *NodeBuilder_SetConnectionGater_Call {
	return &NodeBuilder_SetConnectionGater_Call{Call: _e.mock.On("SetConnectionGater", connectionGater)}
}

func (_c *NodeBuilder_SetConnectionGater_Call) Run(run func(connectionGater p2p.ConnectionGater)) *NodeBuilder_SetConnectionGater_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 p2p.ConnectionGater
		if args[0] != nil {
			arg0 = args[0].(p2p.ConnectionGater)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *NodeBuilder_SetConnectionGater_Call) Return(nodeBuilder p2p.NodeBuilder) *NodeBuilder_SetConnectionGater_Call {
	_c.Call.Return(nodeBuilder)
	return _c
}

func (_c *NodeBuilder_SetConnectionGater_Call) RunAndReturn(run func(connectionGater p2p.ConnectionGater) p2p.NodeBuilder) *NodeBuilder_SetConnectionGater_Call {
	_c.Call.Return(run)
	return _c
}

// SetConnectionManager provides a mock function for the type NodeBuilder
func (_mock *NodeBuilder) SetConnectionManager(connManager connmgr.ConnManager) p2p.NodeBuilder {
	ret := _mock.Called(connManager)

	if len(ret) == 0 {
		panic("no return value specified for SetConnectionManager")
	}

	var r0 p2p.NodeBuilder
	if returnFunc, ok := ret.Get(0).(func(connmgr.ConnManager) p2p.NodeBuilder); ok {
		r0 = returnFunc(connManager)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(p2p.NodeBuilder)
		}
	}
	return r0
}

// NodeBuilder_SetConnectionManager_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetConnectionManager'
type NodeBuilder_SetConnectionManager_Call struct {
	*mock.Call
}

// SetConnectionManager is a helper method to define mock.On call
//   - connManager connmgr.ConnManager
func (_e *NodeBuilder_Expecter) SetConnectionManager(connManager interface{}) *NodeBuilder_SetConnectionManager_Call {
	return &NodeBuilder_SetConnectionManager_Call{Call: _e.mock.On("SetConnectionManager", connManager)}
}

func (_c *NodeBuilder_SetConnectionManager_Call) Run(run func(connManager connmgr.ConnManager)) *NodeBuilder_SetConnectionManager_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 connmgr.ConnManager
		if args[0] != nil {
			arg0 = args[0].(connmgr.ConnManager)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *NodeBuilder_SetConnectionManager_Call) Return(nodeBuilder p2p.NodeBuilder) *NodeBuilder_SetConnectionManager_Call {
	_c.Call.Return(nodeBuilder)
	return _c
}

func (_c *NodeBuilder_SetConnectionManager_Call) RunAndReturn(run func(connManager connmgr.ConnManager) p2p.NodeBuilder) *NodeBuilder_SetConnectionManager_Call {
	_c.Call.Return(run)
	return _c
}

// SetResourceManager provides a mock function for the type NodeBuilder
func (_mock *NodeBuilder) SetResourceManager(resourceManager network.ResourceManager) p2p.NodeBuilder {
	ret := _mock.Called(resourceManager)

	if len(ret) == 0 {
		panic("no return value specified for SetResourceManager")
	}

	var r0 p2p.NodeBuilder
	if returnFunc, ok := ret.Get(0).(func(network.ResourceManager) p2p.NodeBuilder); ok {
		r0 = returnFunc(resourceManager)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(p2p.NodeBuilder)
		}
	}
	return r0
}

// NodeBuilder_SetResourceManager_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetResourceManager'
type NodeBuilder_SetResourceManager_Call struct {
	*mock.Call
}

// SetResourceManager is a helper method to define mock.On call
//   - resourceManager network.ResourceManager
func (_e *NodeBuilder_Expecter) SetResourceManager(resourceManager interface{}) *NodeBuilder_SetResourceManager_Call {
	return &NodeBuilder_SetResourceManager_Call{Call: _e.mock.On("SetResourceManager", resourceManager)}
}

func (_c *NodeBuilder_SetResourceManager_Call) Run(run func(resourceManager network.ResourceManager)) *NodeBuilder_SetResourceManager_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 network.ResourceManager
		if args[0] != nil {
			arg0 = args[0].(network.ResourceManager)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *NodeBuilder_SetResourceManager_Call) Return(nodeBuilder p2p.NodeBuilder) *NodeBuilder_SetResourceManager_Call {
	_c.Call.Return(nodeBuilder)
	return _c
}

func (_c *NodeBuilder_SetResourceManager_Call) RunAndReturn(run func(resourceManager network.ResourceManager) p2p.NodeBuilder) *NodeBuilder_SetResourceManager_Call {
	_c.Call.Return(run)
	return _c
}

// SetRoutingSystem provides a mock function for the type NodeBuilder
func (_mock *NodeBuilder) SetRoutingSystem(fn func(context.Context, host.Host) (routing.Routing, error)) p2p.NodeBuilder {
	ret := _mock.Called(fn)

	if len(ret) == 0 {
		panic("no return value specified for SetRoutingSystem")
	}

	var r0 p2p.NodeBuilder
	if returnFunc, ok := ret.Get(0).(func(func(context.Context, host.Host) (routing.Routing, error)) p2p.NodeBuilder); ok {
		r0 = returnFunc(fn)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(p2p.NodeBuilder)
		}
	}
	return r0
}

// NodeBuilder_SetRoutingSystem_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetRoutingSystem'
type NodeBuilder_SetRoutingSystem_Call struct {
	*mock.Call
}

// SetRoutingSystem is a helper method to define mock.On call
//   - fn func(context.Context, host.Host) (routing.Routing, error)
func (_e *NodeBuilder_Expecter) SetRoutingSystem(fn interface{}) *NodeBuilder_SetRoutingSystem_Call {
	return &NodeBuilder_SetRoutingSystem_Call{Call: _e.mock.On("SetRoutingSystem", fn)}
}

func (_c *NodeBuilder_SetRoutingSystem_Call) Run(run func(fn func(context.Context, host.Host) (routing.Routing, error))) *NodeBuilder_SetRoutingSystem_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 func(context.Context, host.Host) (routing.Routing, error)
		if args[0] != nil {
			arg0 = args[0].(func(context.Context, host.Host) (routing.Routing, error))
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *NodeBuilder_SetRoutingSystem_Call) Return(nodeBuilder p2p.NodeBuilder) *NodeBuilder_SetRoutingSystem_Call {
	_c.Call.Return(nodeBuilder)
	return _c
}

func (_c *NodeBuilder_SetRoutingSystem_Call) RunAndReturn(run func(fn func(context.Context, host.Host) (routing.Routing, error)) p2p.NodeBuilder) *NodeBuilder_SetRoutingSystem_Call {
	_c.Call.Return(run)
	return _c
}

// SetSubscriptionFilter provides a mock function for the type NodeBuilder
func (_mock *NodeBuilder) SetSubscriptionFilter(subscriptionFilter pubsub.SubscriptionFilter) p2p.NodeBuilder {
	ret := _mock.Called(subscriptionFilter)

	if len(ret) == 0 {
		panic("no return value specified for SetSubscriptionFilter")
	}

	var r0 p2p.NodeBuilder
	if returnFunc, ok := ret.Get(0).(func(pubsub.SubscriptionFilter) p2p.NodeBuilder); ok {
		r0 = returnFunc(subscriptionFilter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(p2p.NodeBuilder)
		}
	}
	return r0
}

// NodeBuilder_SetSubscriptionFilter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetSubscriptionFilter'
type NodeBuilder_SetSubscriptionFilter_Call struct {
	*mock.Call
}

// SetSubscriptionFilter is a helper method to define mock.On call
//   - subscriptionFilter pubsub.SubscriptionFilter
func (_e *NodeBuilder_Expecter) SetSubscriptionFilter(subscriptionFilter interface{}) *NodeBuilder_SetSubscriptionFilter_Call {
	return &NodeBuilder_SetSubscriptionFilter_Call{Call: _e.mock.On("SetSubscriptionFilter", subscriptionFilter)}
}

func (_c *NodeBuilder_SetSubscriptionFilter_Call) Run(run func(subscriptionFilter pubsub.SubscriptionFilter)) *NodeBuilder_SetSubscriptionFilter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 pubsub.SubscriptionFilter
		if args[0] != nil {
			arg0 = args[0].(pubsub.SubscriptionFilter)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *NodeBuilder_SetSubscriptionFilter_Call) Return(nodeBuilder p2p.NodeBuilder) *NodeBuilder_SetSubscriptionFilter_Call {
	_c.Call.Return(nodeBuilder)
	return _c
}

func (_c *NodeBuilder_SetSubscriptionFilter_Call) RunAndReturn(run func(subscriptionFilter pubsub.SubscriptionFilter) p2p.NodeBuilder) *NodeBuilder_SetSubscriptionFilter_Call {
	_c.Call.Return(run)
	return _c
}

// NewProtocolPeerCache creates a new instance of ProtocolPeerCache. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewProtocolPeerCache(t interface {
	mock.TestingT
	Cleanup(func())
}) *ProtocolPeerCache {
	mock := &ProtocolPeerCache{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// ProtocolPeerCache is an autogenerated mock type for the ProtocolPeerCache type
type ProtocolPeerCache struct {
	mock.Mock
}

type ProtocolPeerCache_Expecter struct {
	mock *mock.Mock
}

func (_m *ProtocolPeerCache) EXPECT() *ProtocolPeerCache_Expecter {
	return &ProtocolPeerCache_Expecter{mock: &_m.Mock}
}

// AddProtocols provides a mock function for the type ProtocolPeerCache
func (_mock *ProtocolPeerCache) AddProtocols(peerID peer.ID, protocols []protocol.ID) {
	_mock.Called(peerID, protocols)
	return
}

// ProtocolPeerCache_AddProtocols_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddProtocols'
type ProtocolPeerCache_AddProtocols_Call struct {
	*mock.Call
}

// AddProtocols is a helper method to define mock.On call
//   - peerID peer.ID
//   - protocols []protocol.ID
func (_e *ProtocolPeerCache_Expecter) AddProtocols(peerID interface{}, protocols interface{}) *ProtocolPeerCache_AddProtocols_Call {
	return &ProtocolPeerCache_AddProtocols_Call{Call: _e.mock.On("AddProtocols", peerID, protocols)}
}

func (_c *ProtocolPeerCache_AddProtocols_Call) Run(run func(peerID peer.ID, protocols []protocol.ID)) *ProtocolPeerCache_AddProtocols_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 peer.ID
		if args[0] != nil {
			arg0 = args[0].(peer.ID)
		}
		var arg1 []protocol.ID
		if args[1] != nil {
			arg1 = args[1].([]protocol.ID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ProtocolPeerCache_AddProtocols_Call) Return() *ProtocolPeerCache_AddProtocols_Call {
	_c.Call.Return()
	return _c
}

func (_c *ProtocolPeerCache_AddProtocols_Call) RunAndReturn(run func(peerID peer.ID, protocols []protocol.ID)) *ProtocolPeerCache_AddProtocols_Call {
	_c.Run(run)
	return _c
}

// GetPeers provides a mock function for the type ProtocolPeerCache
func (_mock *ProtocolPeerCache) GetPeers(pid protocol.ID) peer.IDSlice {
	ret := _mock.Called(pid)

	if len(ret) == 0 {
		panic("no return value specified for GetPeers")
	}

	var r0 peer.IDSlice
	if returnFunc, ok := ret.Get(0).(func(protocol.ID) peer.IDSlice); ok {
		r0 = returnFunc(pid)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(peer.IDSlice)
		}
	}
	return r0
}

// ProtocolPeerCache_GetPeers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPeers'
type ProtocolPeerCache_GetPeers_Call struct {
	*mock.Call
}

// GetPeers is a helper method to define mock.On call
//   - pid protocol.ID
func (_e *ProtocolPeerCache_Expecter) GetPeers(pid interface{}) *ProtocolPeerCache_GetPeers_Call {
	return &ProtocolPeerCache_GetPeers_Call{Call: _e.mock.On("GetPeers", pid)}
}

func (_c *ProtocolPeerCache_GetPeers_Call) Run(run func(pid protocol.ID)) *ProtocolPeerCache_GetPeers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 protocol.ID
		if args[0] != nil {
			arg0 = args[0].(protocol.ID)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ProtocolPeerCache_GetPeers_Call) Return(iDSlice peer.IDSlice) *ProtocolPeerCache_GetPeers_Call {
	_c.Call.Return(iDSlice)
	return _c
}

func (_c *ProtocolPeerCache_GetPeers_Call) RunAndReturn(run func(pid protocol.ID) peer.IDSlice) *ProtocolPeerCache_GetPeers_Call {
	_c.Call.Return(run)
	return _c
}

// RemovePeer provides a mock function for the type ProtocolPeerCache
func (_mock *ProtocolPeerCache) RemovePeer(peerID peer.ID) {
	_mock.Called(peerID)
	return
}

// ProtocolPeerCache_RemovePeer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemovePeer'
type ProtocolPeerCache_RemovePeer_Call struct {
	*mock.Call
}

// RemovePeer is a helper method to define mock.On call
//   - peerID peer.ID
func (_e *ProtocolPeerCache_Expecter) RemovePeer(peerID interface{}) *ProtocolPeerCache_RemovePeer_Call {
	return &ProtocolPeerCache_RemovePeer_Call{Call: _e.mock.On("RemovePeer", peerID)}
}

func (_c *ProtocolPeerCache_RemovePeer_Call) Run(run func(peerID peer.ID)) *ProtocolPeerCache_RemovePeer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 peer.ID
		if args[0] != nil {
			arg0 = args[0].(peer.ID)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ProtocolPeerCache_RemovePeer_Call) Return() *ProtocolPeerCache_RemovePeer_Call {
	_c.Call.Return()
	return _c
}

func (_c *ProtocolPeerCache_RemovePeer_Call) RunAndReturn(run func(peerID peer.ID)) *ProtocolPeerCache_RemovePeer_Call {
	_c.Run(run)
	return _c
}

// RemoveProtocols provides a mock function for the type ProtocolPeerCache
func (_mock *ProtocolPeerCache) RemoveProtocols(peerID peer.ID, protocols []protocol.ID) {
	_mock.Called(peerID, protocols)
	return
}

// ProtocolPeerCache_RemoveProtocols_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveProtocols'
type ProtocolPeerCache_RemoveProtocols_Call struct {
	*mock.Call
}

// RemoveProtocols is a helper method to define mock.On call
//   - peerID peer.ID
//   - protocols []protocol.ID
func (_e *ProtocolPeerCache_Expecter) RemoveProtocols(peerID interface{}, protocols interface{}) *ProtocolPeerCache_RemoveProtocols_Call {
	return &ProtocolPeerCache_RemoveProtocols_Call{Call: _e.mock.On("RemoveProtocols", peerID, protocols)}
}

func (_c *ProtocolPeerCache_RemoveProtocols_Call) Run(run func(peerID peer.ID, protocols []protocol.ID)) *ProtocolPeerCache_RemoveProtocols_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 peer.ID
		if args[0] != nil {
			arg0 = args[0].(peer.ID)
		}
		var arg1 []protocol.ID
		if args[1] != nil {
			arg1 = args[1].([]protocol.ID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ProtocolPeerCache_RemoveProtocols_Call) Return() *ProtocolPeerCache_RemoveProtocols_Call {
	_c.Call.Return()
	return _c
}

func (_c *ProtocolPeerCache_RemoveProtocols_Call) RunAndReturn(run func(peerID peer.ID, protocols []protocol.ID)) *ProtocolPeerCache_RemoveProtocols_Call {
	_c.Run(run)
	return _c
}

// NewGossipSubSpamRecordCache creates a new instance of GossipSubSpamRecordCache. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewGossipSubSpamRecordCache(t interface {
	mock.TestingT
	Cleanup(func())
}) *GossipSubSpamRecordCache {
	mock := &GossipSubSpamRecordCache{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// GossipSubSpamRecordCache is an autogenerated mock type for the GossipSubSpamRecordCache type
type GossipSubSpamRecordCache struct {
	mock.Mock
}

type GossipSubSpamRecordCache_Expecter struct {
	mock *mock.Mock
}

func (_m *GossipSubSpamRecordCache) EXPECT() *GossipSubSpamRecordCache_Expecter {
	return &GossipSubSpamRecordCache_Expecter{mock: &_m.Mock}
}

// Adjust provides a mock function for the type GossipSubSpamRecordCache
func (_mock *GossipSubSpamRecordCache) Adjust(peerID peer.ID, updateFunc p2p.UpdateFunction) (*p2p.GossipSubSpamRecord, error) {
	ret := _mock.Called(peerID, updateFunc)

	if len(ret) == 0 {
		panic("no return value specified for Adjust")
	}

	var r0 *p2p.GossipSubSpamRecord
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(peer.ID, p2p.UpdateFunction) (*p2p.GossipSubSpamRecord, error)); ok {
		return returnFunc(peerID, updateFunc)
	}
	if returnFunc, ok := ret.Get(0).(func(peer.ID, p2p.UpdateFunction) *p2p.GossipSubSpamRecord); ok {
		r0 = returnFunc(peerID, updateFunc)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*p2p.GossipSubSpamRecord)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(peer.ID, p2p.UpdateFunction) error); ok {
		r1 = returnFunc(peerID, updateFunc)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// GossipSubSpamRecordCache_Adjust_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Adjust'
type GossipSubSpamRecordCache_Adjust_Call struct {
	*mock.Call
}

// Adjust is a helper method to define mock.On call
//   - peerID peer.ID
//   - updateFunc p2p.UpdateFunction
func (_e *GossipSubSpamRecordCache_Expecter) Adjust(peerID interface{}, updateFunc interface{}) *GossipSubSpamRecordCache_Adjust_Call {
	return &GossipSubSpamRecordCache_Adjust_Call{Call: _e.mock.On("Adjust", peerID, updateFunc)}
}

func (_c *GossipSubSpamRecordCache_Adjust_Call) Run(run func(peerID peer.ID, updateFunc p2p.UpdateFunction)) *GossipSubSpamRecordCache_Adjust_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 peer.ID
		if args[0] != nil {
			arg0 = args[0].(peer.ID)
		}
		var arg1 p2p.UpdateFunction
		if args[1] != nil {
			arg1 = args[1].(p2p.UpdateFunction)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *GossipSubSpamRecordCache_Adjust_Call) Return(gossipSubSpamRecord *p2p.GossipSubSpamRecord, err error) *GossipSubSpamRecordCache_Adjust_Call {
	_c.Call.Return(gossipSubSpamRecord, err)
	return _c
}

func (_c *GossipSubSpamRecordCache_Adjust_Call) RunAndReturn(run func(peerID peer.ID, updateFunc p2p.UpdateFunction) (*p2p.GossipSubSpamRecord, error)) *GossipSubSpamRecordCache_Adjust_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function for the type GossipSubSpamRecordCache
func (_mock *GossipSubSpamRecordCache) Get(peerID peer.ID) (*p2p.GossipSubSpamRecord, error, bool) {
	ret := _mock.Called(peerID)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *p2p.GossipSubSpamRecord
	var r1 error
	var r2 bool
	if returnFunc, ok := ret.Get(0).(func(peer.ID) (*p2p.GossipSubSpamRecord, error, bool)); ok {
		return returnFunc(peerID)
	}
	if returnFunc, ok := ret.Get(0).(func(peer.ID) *p2p.GossipSubSpamRecord); ok {
		r0 = returnFunc(peerID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*p2p.GossipSubSpamRecord)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(peer.ID) error); ok {
		r1 = returnFunc(peerID)
	} else {
		r1 = ret.Error(1)
	}
	if returnFunc, ok := ret.Get(2).(func(peer.ID) bool); ok {
		r2 = returnFunc(peerID)
	} else {
		r2 = ret.Get(2).(bool)
	}
	return r0, r1, r2
}

// GossipSubSpamRecordCache_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type GossipSubSpamRecordCache_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - peerID peer.ID
func (_e *GossipSubSpamRecordCache_Expecter) Get(peerID interface{}) *GossipSubSpamRecordCache_Get_Call {
	return &GossipSubSpamRecordCache_Get_Call{Call: _e.mock.On("Get", peerID)}
}

func (_c *GossipSubSpamRecordCache_Get_Call) Run(run func(peerID peer.ID)) *GossipSubSpamRecordCache_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 peer.ID
		if args[0] != nil {
			arg0 = args[0].(peer.ID)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *GossipSubSpamRecordCache_Get_Call) Return(gossipSubSpamRecord *p2p.GossipSubSpamRecord, err error, b bool) *GossipSubSpamRecordCache_Get_Call {
	_c.Call.Return(gossipSubSpamRecord, err, b)
	return _c
}

func (_c *GossipSubSpamRecordCache_Get_Call) RunAndReturn(run func(peerID peer.ID) (*p2p.GossipSubSpamRecord, error, bool)) *GossipSubSpamRecordCache_Get_Call {
	_c.Call.Return(run)
	return _c
}

// Has provides a mock function for the type GossipSubSpamRecordCache
func (_mock *GossipSubSpamRecordCache) Has(peerID peer.ID) bool {
	ret := _mock.Called(peerID)

	if len(ret) == 0 {
		panic("no return value specified for Has")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(peer.ID) bool); ok {
		r0 = returnFunc(peerID)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// GossipSubSpamRecordCache_Has_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Has'
type GossipSubSpamRecordCache_Has_Call struct {
	*mock.Call
}

// Has is a helper method to define mock.On call
//   - peerID peer.ID
func (_e *GossipSubSpamRecordCache_Expecter) Has(peerID interface{}) *GossipSubSpamRecordCache_Has_Call {
	return &GossipSubSpamRecordCache_Has_Call{Call: _e.mock.On("Has", peerID)}
}

func (_c *GossipSubSpamRecordCache_Has_Call) Run(run func(peerID peer.ID)) *GossipSubSpamRecordCache_Has_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 peer.ID
		if args[0] != nil {
			arg0 = args[0].(peer.ID)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *GossipSubSpamRecordCache_Has_Call) Return(b bool) *GossipSubSpamRecordCache_Has_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *GossipSubSpamRecordCache_Has_Call) RunAndReturn(run func(peerID peer.ID) bool) *GossipSubSpamRecordCache_Has_Call {
	_c.Call.Return(run)
	return _c
}

// NewGossipSubApplicationSpecificScoreCache creates a new instance of GossipSubApplicationSpecificScoreCache. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewGossipSubApplicationSpecificScoreCache(t interface {
	mock.TestingT
	Cleanup(func())
}) *GossipSubApplicationSpecificScoreCache {
	mock := &GossipSubApplicationSpecificScoreCache{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// GossipSubApplicationSpecificScoreCache is an autogenerated mock type for the GossipSubApplicationSpecificScoreCache type
type GossipSubApplicationSpecificScoreCache struct {
	mock.Mock
}

type GossipSubApplicationSpecificScoreCache_Expecter struct {
	mock *mock.Mock
}

func (_m *GossipSubApplicationSpecificScoreCache) EXPECT() *GossipSubApplicationSpecificScoreCache_Expecter {
	return &GossipSubApplicationSpecificScoreCache_Expecter{mock: &_m.Mock}
}

// AdjustWithInit provides a mock function for the type GossipSubApplicationSpecificScoreCache
func (_mock *GossipSubApplicationSpecificScoreCache) AdjustWithInit(peerID peer.ID, score float64, time1 time.Time) error {
	ret := _mock.Called(peerID, score, time1)

	if len(ret) == 0 {
		panic("no return value specified for AdjustWithInit")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(peer.ID, float64, time.Time) error); ok {
		r0 = returnFunc(peerID, score, time1)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// GossipSubApplicationSpecificScoreCache_AdjustWithInit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AdjustWithInit'
type GossipSubApplicationSpecificScoreCache_AdjustWithInit_Call struct {
	*mock.Call
}

// AdjustWithInit is a helper method to define mock.On call
//   - peerID peer.ID
//   - score float64
//   - time1 time.Time
func (_e *GossipSubApplicationSpecificScoreCache_Expecter) AdjustWithInit(peerID interface{}, score interface{}, time1 interface{}) *GossipSubApplicationSpecificScoreCache_AdjustWithInit_Call {
	return &GossipSubApplicationSpecificScoreCache_AdjustWithInit_Call{Call: _e.mock.On("AdjustWithInit", peerID, score, time1)}
}

func (_c *GossipSubApplicationSpecificScoreCache_AdjustWithInit_Call) Run(run func(peerID peer.ID, score float64, time1 time.Time)) *GossipSubApplicationSpecificScoreCache_AdjustWithInit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 peer.ID
		if args[0] != nil {
			arg0 = args[0].(peer.ID)
		}
		var arg1 float64
		if args[1] != nil {
			arg1 = args[1].(float64)
		}
		var arg2 time.Time
		if args[2] != nil {
			arg2 = args[2].(time.Time)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *GossipSubApplicationSpecificScoreCache_AdjustWithInit_Call) Return(err error) *GossipSubApplicationSpecificScoreCache_AdjustWithInit_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *GossipSubApplicationSpecificScoreCache_AdjustWithInit_Call) RunAndReturn(run func(peerID peer.ID, score float64, time1 time.Time) error) *GossipSubApplicationSpecificScoreCache_AdjustWithInit_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function for the type GossipSubApplicationSpecificScoreCache
func (_mock *GossipSubApplicationSpecificScoreCache) Get(peerID peer.ID) (float64, time.Time, bool) {
	ret := _mock.Called(peerID)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 float64
	var r1 time.Time
	var r2 bool
	if returnFunc, ok := ret.Get(0).(func(peer.ID) (float64, time.Time, bool)); ok {
		return returnFunc(peerID)
	}
	if returnFunc, ok := ret.Get(0).(func(peer.ID) float64); ok {
		r0 = returnFunc(peerID)
	} else {
		r0 = ret.Get(0).(float64)
	}
	if returnFunc, ok := ret.Get(1).(func(peer.ID) time.Time); ok {
		r1 = returnFunc(peerID)
	} else {
		r1 = ret.Get(1).(time.Time)
	}
	if returnFunc, ok := ret.Get(2).(func(peer.ID) bool); ok {
		r2 = returnFunc(peerID)
	} else {
		r2 = ret.Get(2).(bool)
	}
	return r0, r1, r2
}

// GossipSubApplicationSpecificScoreCache_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type GossipSubApplicationSpecificScoreCache_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - peerID peer.ID
func (_e *GossipSubApplicationSpecificScoreCache_Expecter) Get(peerID interface{}) *GossipSubApplicationSpecificScoreCache_Get_Call {
	return &GossipSubApplicationSpecificScoreCache_Get_Call{Call: _e.mock.On("Get", peerID)}
}

func (_c *GossipSubApplicationSpecificScoreCache_Get_Call) Run(run func(peerID peer.ID)) *GossipSubApplicationSpecificScoreCache_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 peer.ID
		if args[0] != nil {
			arg0 = args[0].(peer.ID)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *GossipSubApplicationSpecificScoreCache_Get_Call) Return(f float64, time1 time.Time, b bool) *GossipSubApplicationSpecificScoreCache_Get_Call {
	_c.Call.Return(f, time1, b)
	return _c
}

func (_c *GossipSubApplicationSpecificScoreCache_Get_Call) RunAndReturn(run func(peerID peer.ID) (float64, time.Time, bool)) *GossipSubApplicationSpecificScoreCache_Get_Call {
	_c.Call.Return(run)
	return _c
}

// NewConnectionGater creates a new instance of ConnectionGater. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewConnectionGater(t interface {
	mock.TestingT
	Cleanup(func())
}) *ConnectionGater {
	mock := &ConnectionGater{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// ConnectionGater is an autogenerated mock type for the ConnectionGater type
type ConnectionGater struct {
	mock.Mock
}

type ConnectionGater_Expecter struct {
	mock *mock.Mock
}

func (_m *ConnectionGater) EXPECT() *ConnectionGater_Expecter {
	return &ConnectionGater_Expecter{mock: &_m.Mock}
}

// InterceptAccept provides a mock function for the type ConnectionGater
func (_mock *ConnectionGater) InterceptAccept(connMultiaddrs network.ConnMultiaddrs) bool {
	ret := _mock.Called(connMultiaddrs)

	if len(ret) == 0 {
		panic("no return value specified for InterceptAccept")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(network.ConnMultiaddrs) bool); ok {
		r0 = returnFunc(connMultiaddrs)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// ConnectionGater_InterceptAccept_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InterceptAccept'
type ConnectionGater_InterceptAccept_Call struct {
	*mock.Call
}

// InterceptAccept is a helper method to define mock.On call
//   - connMultiaddrs network.ConnMultiaddrs
func (_e *ConnectionGater_Expecter) InterceptAccept(connMultiaddrs interface{}) *ConnectionGater_InterceptAccept_Call {
	return &ConnectionGater_InterceptAccept_Call{Call: _e.mock.On("InterceptAccept", connMultiaddrs)}
}

func (_c *ConnectionGater_InterceptAccept_Call) Run(run func(connMultiaddrs network.ConnMultiaddrs)) *ConnectionGater_InterceptAccept_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 network.ConnMultiaddrs
		if args[0] != nil {
			arg0 = args[0].(network.ConnMultiaddrs)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ConnectionGater_InterceptAccept_Call) Return(allow bool) *ConnectionGater_InterceptAccept_Call {
	_c.Call.Return(allow)
	return _c
}

func (_c *ConnectionGater_InterceptAccept_Call) RunAndReturn(run func(connMultiaddrs network.ConnMultiaddrs) bool) *ConnectionGater_InterceptAccept_Call {
	_c.Call.Return(run)
	return _c
}

// InterceptAddrDial provides a mock function for the type ConnectionGater
func (_mock *ConnectionGater) InterceptAddrDial(iD peer.ID, multiaddr1 multiaddr.Multiaddr) bool {
	ret := _mock.Called(iD, multiaddr1)

	if len(ret) == 0 {
		panic("no return value specified for InterceptAddrDial")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(peer.ID, multiaddr.Multiaddr) bool); ok {
		r0 = returnFunc(iD, multiaddr1)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// ConnectionGater_InterceptAddrDial_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InterceptAddrDial'
type ConnectionGater_InterceptAddrDial_Call struct {
	*mock.Call
}

// InterceptAddrDial is a helper method to define mock.On call
//   - iD peer.ID
//   - multiaddr1 multiaddr.Multiaddr
func (_e *ConnectionGater_Expecter) InterceptAddrDial(iD interface{}, multiaddr1 interface{}) *ConnectionGater_InterceptAddrDial_Call {
	return &ConnectionGater_InterceptAddrDial_Call{Call: _e.mock.On("InterceptAddrDial", iD, multiaddr1)}
}

func (_c *ConnectionGater_InterceptAddrDial_Call) Run(run func(iD peer.ID, multiaddr1 multiaddr.Multiaddr)) *ConnectionGater_InterceptAddrDial_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 peer.ID
		if args[0] != nil {
			arg0 = args[0].(peer.ID)
		}
		var arg1 multiaddr.Multiaddr
		if args[1] != nil {
			arg1 = args[1].(multiaddr.Multiaddr)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ConnectionGater_InterceptAddrDial_Call) Return(allow bool) *ConnectionGater_InterceptAddrDial_Call {
	_c.Call.Return(allow)
	return _c
}

func (_c *ConnectionGater_InterceptAddrDial_Call) RunAndReturn(run func(iD peer.ID, multiaddr1 multiaddr.Multiaddr) bool) *ConnectionGater_InterceptAddrDial_Call {
	_c.Call.Return(run)
	return _c
}

// InterceptPeerDial provides a mock function for the type ConnectionGater
func (_mock *ConnectionGater) InterceptPeerDial(p peer.ID) bool {
	ret := _mock.Called(p)

	if len(ret) == 0 {
		panic("no return value specified for InterceptPeerDial")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(peer.ID) bool); ok {
		r0 = returnFunc(p)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// ConnectionGater_InterceptPeerDial_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InterceptPeerDial'
type ConnectionGater_InterceptPeerDial_Call struct {
	*mock.Call
}

// InterceptPeerDial is a helper method to define mock.On call
//   - p peer.ID
func (_e *ConnectionGater_Expecter) InterceptPeerDial(p interface{}) *ConnectionGater_InterceptPeerDial_Call {
	return &ConnectionGater_InterceptPeerDial_Call{Call: _e.mock.On("InterceptPeerDial", p)}
}

func (_c *ConnectionGater_InterceptPeerDial_Call) Run(run func(p peer.ID)) *ConnectionGater_InterceptPeerDial_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 peer.ID
		if args[0] != nil {
			arg0 = args[0].(peer.ID)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ConnectionGater_InterceptPeerDial_Call) Return(allow bool) *ConnectionGater_InterceptPeerDial_Call {
	_c.Call.Return(allow)
	return _c
}

func (_c *ConnectionGater_InterceptPeerDial_Call) RunAndReturn(run func(p peer.ID) bool) *ConnectionGater_InterceptPeerDial_Call {
	_c.Call.Return(run)
	return _c
}

// InterceptSecured provides a mock function for the type ConnectionGater
func (_mock *ConnectionGater) InterceptSecured(direction network.Direction, iD peer.ID, connMultiaddrs network.ConnMultiaddrs) bool {
	ret := _mock.Called(direction, iD, connMultiaddrs)

	if len(ret) == 0 {
		panic("no return value specified for InterceptSecured")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(network.Direction, peer.ID, network.ConnMultiaddrs) bool); ok {
		r0 = returnFunc(direction, iD, connMultiaddrs)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// ConnectionGater_InterceptSecured_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InterceptSecured'
type ConnectionGater_InterceptSecured_Call struct {
	*mock.Call
}

// InterceptSecured is a helper method to define mock.On call
//   - direction network.Direction
//   - iD peer.ID
//   - connMultiaddrs network.ConnMultiaddrs
func (_e *ConnectionGater_Expecter) InterceptSecured(direction interface{}, iD interface{}, connMultiaddrs interface{}) *ConnectionGater_InterceptSecured_Call {
	return &ConnectionGater_InterceptSecured_Call{Call: _e.mock.On("InterceptSecured", direction, iD, connMultiaddrs)}
}

func (_c *ConnectionGater_InterceptSecured_Call) Run(run func(direction network.Direction, iD peer.ID, connMultiaddrs network.ConnMultiaddrs)) *ConnectionGater_InterceptSecured_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 network.Direction
		if args[0] != nil {
			arg0 = args[0].(network.Direction)
		}
		var arg1 peer.ID
		if args[1] != nil {
			arg1 = args[1].(peer.ID)
		}
		var arg2 network.ConnMultiaddrs
		if args[2] != nil {
			arg2 = args[2].(network.ConnMultiaddrs)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *ConnectionGater_InterceptSecured_Call) Return(allow bool) *ConnectionGater_InterceptSecured_Call {
	_c.Call.Return(allow)
	return _c
}

func (_c *ConnectionGater_InterceptSecured_Call) RunAndReturn(run func(direction network.Direction, iD peer.ID, connMultiaddrs network.ConnMultiaddrs) bool) *ConnectionGater_InterceptSecured_Call {
	_c.Call.Return(run)
	return _c
}

// InterceptUpgraded provides a mock function for the type ConnectionGater
func (_mock *ConnectionGater) InterceptUpgraded(conn network.Conn) (bool, control.DisconnectReason) {
	ret := _mock.Called(conn)

	if len(ret) == 0 {
		panic("no return value specified for InterceptUpgraded")
	}

	var r0 bool
	var r1 control.DisconnectReason
	if returnFunc, ok := ret.Get(0).(func(network.Conn) (bool, control.DisconnectReason)); ok {
		return returnFunc(conn)
	}
	if returnFunc, ok := ret.Get(0).(func(network.Conn) bool); ok {
		r0 = returnFunc(conn)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(network.Conn) control.DisconnectReason); ok {
		r1 = returnFunc(conn)
	} else {
		r1 = ret.Get(1).(control.DisconnectReason)
	}
	return r0, r1
}

// ConnectionGater_InterceptUpgraded_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InterceptUpgraded'
type ConnectionGater_InterceptUpgraded_Call struct {
	*mock.Call
}

// InterceptUpgraded is a helper method to define mock.On call
//   - conn network.Conn
func (_e *ConnectionGater_Expecter) InterceptUpgraded(conn interface{}) *ConnectionGater_InterceptUpgraded_Call {
	return &ConnectionGater_InterceptUpgraded_Call{Call: _e.mock.On("InterceptUpgraded", conn)}
}

func (_c *ConnectionGater_InterceptUpgraded_Call) Run(run func(conn network.Conn)) *ConnectionGater_InterceptUpgraded_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 network.Conn
		if args[0] != nil {
			arg0 = args[0].(network.Conn)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ConnectionGater_InterceptUpgraded_Call) Return(allow bool, reason control.DisconnectReason) *ConnectionGater_InterceptUpgraded_Call {
	_c.Call.Return(allow, reason)
	return _c
}

func (_c *ConnectionGater_InterceptUpgraded_Call) RunAndReturn(run func(conn network.Conn) (bool, control.DisconnectReason)) *ConnectionGater_InterceptUpgraded_Call {
	_c.Call.Return(run)
	return _c
}

// SetDisallowListOracle provides a mock function for the type ConnectionGater
func (_mock *ConnectionGater) SetDisallowListOracle(oracle p2p.DisallowListOracle) {
	_mock.Called(oracle)
	return
}

// ConnectionGater_SetDisallowListOracle_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetDisallowListOracle'
type ConnectionGater_SetDisallowListOracle_Call struct {
	*mock.Call
}

// SetDisallowListOracle is a helper method to define mock.On call
//   - oracle p2p.DisallowListOracle
func (_e *ConnectionGater_Expecter) SetDisallowListOracle(oracle interface{}) *ConnectionGater_SetDisallowListOracle_Call {
	return &ConnectionGater_SetDisallowListOracle_Call{Call: _e.mock.On("SetDisallowListOracle", oracle)}
}

func (_c *ConnectionGater_SetDisallowListOracle_Call) Run(run func(oracle p2p.DisallowListOracle)) *ConnectionGater_SetDisallowListOracle_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 p2p.DisallowListOracle
		if args[0] != nil {
			arg0 = args[0].(p2p.DisallowListOracle)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ConnectionGater_SetDisallowListOracle_Call) Return() *ConnectionGater_SetDisallowListOracle_Call {
	_c.Call.Return()
	return _c
}

func (_c *ConnectionGater_SetDisallowListOracle_Call) RunAndReturn(run func(oracle p2p.DisallowListOracle)) *ConnectionGater_SetDisallowListOracle_Call {
	_c.Run(run)
	return _c
}

// NewPeerUpdater creates a new instance of PeerUpdater. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewPeerUpdater(t interface {
	mock.TestingT
	Cleanup(func())
}) *PeerUpdater {
	mock := &PeerUpdater{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// PeerUpdater is an autogenerated mock type for the PeerUpdater type
type PeerUpdater struct {
	mock.Mock
}

type PeerUpdater_Expecter struct {
	mock *mock.Mock
}

func (_m *PeerUpdater) EXPECT() *PeerUpdater_Expecter {
	return &PeerUpdater_Expecter{mock: &_m.Mock}
}

// UpdatePeers provides a mock function for the type PeerUpdater
func (_mock *PeerUpdater) UpdatePeers(ctx context.Context, peerIDs peer.IDSlice) {
	_mock.Called(ctx, peerIDs)
	return
}

// PeerUpdater_UpdatePeers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdatePeers'
type PeerUpdater_UpdatePeers_Call struct {
	*mock.Call
}

// UpdatePeers is a helper method to define mock.On call
//   - ctx context.Context
//   - peerIDs peer.IDSlice
func (_e *PeerUpdater_Expecter) UpdatePeers(ctx interface{}, peerIDs interface{}) *PeerUpdater_UpdatePeers_Call {
	return &PeerUpdater_UpdatePeers_Call{Call: _e.mock.On("UpdatePeers", ctx, peerIDs)}
}

func (_c *PeerUpdater_UpdatePeers_Call) Run(run func(ctx context.Context, peerIDs peer.IDSlice)) *PeerUpdater_UpdatePeers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 peer.IDSlice
		if args[1] != nil {
			arg1 = args[1].(peer.IDSlice)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *PeerUpdater_UpdatePeers_Call) Return() *PeerUpdater_UpdatePeers_Call {
	_c.Call.Return()
	return _c
}

func (_c *PeerUpdater_UpdatePeers_Call) RunAndReturn(run func(ctx context.Context, peerIDs peer.IDSlice)) *PeerUpdater_UpdatePeers_Call {
	_c.Run(run)
	return _c
}

// NewConnector creates a new instance of Connector. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewConnector(t interface {
	mock.TestingT
	Cleanup(func())
}) *Connector {
	mock := &Connector{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Connector is an autogenerated mock type for the Connector type
type Connector struct {
	mock.Mock
}

type Connector_Expecter struct {
	mock *mock.Mock
}

func (_m *Connector) EXPECT() *Connector_Expecter {
	return &Connector_Expecter{mock: &_m.Mock}
}

// Connect provides a mock function for the type Connector
func (_mock *Connector) Connect(ctx context.Context, peerChan <-chan peer.AddrInfo) {
	_mock.Called(ctx, peerChan)
	return
}

// Connector_Connect_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Connect'
type Connector_Connect_Call struct {
	*mock.Call
}

// Connect is a helper method to define mock.On call
//   - ctx context.Context
//   - peerChan <-chan peer.AddrInfo
func (_e *Connector_Expecter) Connect(ctx interface{}, peerChan interface{}) *Connector_Connect_Call {
	return &Connector_Connect_Call{Call: _e.mock.On("Connect", ctx, peerChan)}
}

func (_c *Connector_Connect_Call) Run(run func(ctx context.Context, peerChan <-chan peer.AddrInfo)) *Connector_Connect_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 <-chan peer.AddrInfo
		if args[1] != nil {
			arg1 = args[1].(<-chan peer.AddrInfo)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Connector_Connect_Call) Return() *Connector_Connect_Call {
	_c.Call.Return()
	return _c
}

func (_c *Connector_Connect_Call) RunAndReturn(run func(ctx context.Context, peerChan <-chan peer.AddrInfo)) *Connector_Connect_Call {
	_c.Run(run)
	return _c
}

// NewConnectorHost creates a new instance of ConnectorHost. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewConnectorHost(t interface {
	mock.TestingT
	Cleanup(func())
}) *ConnectorHost {
	mock := &ConnectorHost{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// ConnectorHost is an autogenerated mock type for the ConnectorHost type
type ConnectorHost struct {
	mock.Mock
}

type ConnectorHost_Expecter struct {
	mock *mock.Mock
}

func (_m *ConnectorHost) EXPECT() *ConnectorHost_Expecter {
	return &ConnectorHost_Expecter{mock: &_m.Mock}
}

// ClosePeer provides a mock function for the type ConnectorHost
func (_mock *ConnectorHost) ClosePeer(peerId peer.ID) error {
	ret := _mock.Called(peerId)

	if len(ret) == 0 {
		panic("no return value specified for ClosePeer")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(peer.ID) error); ok {
		r0 = returnFunc(peerId)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ConnectorHost_ClosePeer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClosePeer'
type ConnectorHost_ClosePeer_Call struct {
	*mock.Call
}

// ClosePeer is a helper method to define mock.On call
//   - peerId peer.ID
func (_e *ConnectorHost_Expecter) ClosePeer(peerId interface{}) *ConnectorHost_ClosePeer_Call {
	return &ConnectorHost_ClosePeer_Call{Call: _e.mock.On("ClosePeer", peerId)}
}

func (_c *ConnectorHost_ClosePeer_Call) Run(run func(peerId peer.ID)) *ConnectorHost_ClosePeer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 peer.ID
		if args[0] != nil {
			arg0 = args[0].(peer.ID)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ConnectorHost_ClosePeer_Call) Return(err error) *ConnectorHost_ClosePeer_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ConnectorHost_ClosePeer_Call) RunAndReturn(run func(peerId peer.ID) error) *ConnectorHost_ClosePeer_Call {
	_c.Call.Return(run)
	return _c
}

// Connections provides a mock function for the type ConnectorHost
func (_mock *ConnectorHost) Connections() []network.Conn {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Connections")
	}

	var r0 []network.Conn
	if returnFunc, ok := ret.Get(0).(func() []network.Conn); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]network.Conn)
		}
	}
	return r0
}

// ConnectorHost_Connections_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Connections'
type ConnectorHost_Connections_Call struct {
	*mock.Call
}

// Connections is a helper method to define mock.On call
func (_e *ConnectorHost_Expecter) Connections() *ConnectorHost_Connections_Call {
	return &ConnectorHost_Connections_Call{Call: _e.mock.On("Connections")}
}

func (_c *ConnectorHost_Connections_Call) Run(run func()) *ConnectorHost_Connections_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ConnectorHost_Connections_Call) Return(conns []network.Conn) *ConnectorHost_Connections_Call {
	_c.Call.Return(conns)
	return _c
}

func (_c *ConnectorHost_Connections_Call) RunAndReturn(run func() []network.Conn) *ConnectorHost_Connections_Call {
	_c.Call.Return(run)
	return _c
}

// ID provides a mock function for the type ConnectorHost
func (_mock *ConnectorHost) ID() peer.ID {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for ID")
	}

	var r0 peer.ID
	if returnFunc, ok := ret.Get(0).(func() peer.ID); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(peer.ID)
	}
	return r0
}

// ConnectorHost_ID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ID'
type ConnectorHost_ID_Call struct {
	*mock.Call
}

// ID is a helper method to define mock.On call
func (_e *ConnectorHost_Expecter) ID() *ConnectorHost_ID_Call {
	return &ConnectorHost_ID_Call{Call: _e.mock.On("ID")}
}

func (_c *ConnectorHost_ID_Call) Run(run func()) *ConnectorHost_ID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ConnectorHost_ID_Call) Return(iD peer.ID) *ConnectorHost_ID_Call {
	_c.Call.Return(iD)
	return _c
}

func (_c *ConnectorHost_ID_Call) RunAndReturn(run func() peer.ID) *ConnectorHost_ID_Call {
	_c.Call.Return(run)
	return _c
}

// IsConnectedTo provides a mock function for the type ConnectorHost
func (_mock *ConnectorHost) IsConnectedTo(peerId peer.ID) bool {
	ret := _mock.Called(peerId)

	if len(ret) == 0 {
		panic("no return value specified for IsConnectedTo")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(peer.ID) bool); ok {
		r0 = returnFunc(peerId)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// ConnectorHost_IsConnectedTo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsConnectedTo'
type ConnectorHost_IsConnectedTo_Call struct {
	*mock.Call
}

// IsConnectedTo is a helper method to define mock.On call
//   - peerId peer.ID
func (_e *ConnectorHost_Expecter) IsConnectedTo(peerId interface{}) *ConnectorHost_IsConnectedTo_Call {
	return &ConnectorHost_IsConnectedTo_Call{Call: _e.mock.On("IsConnectedTo", peerId)}
}

func (_c *ConnectorHost_IsConnectedTo_Call) Run(run func(peerId peer.ID)) *ConnectorHost_IsConnectedTo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 peer.ID
		if args[0] != nil {
			arg0 = args[0].(peer.ID)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ConnectorHost_IsConnectedTo_Call) Return(b bool) *ConnectorHost_IsConnectedTo_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *ConnectorHost_IsConnectedTo_Call) RunAndReturn(run func(peerId peer.ID) bool) *ConnectorHost_IsConnectedTo_Call {
	_c.Call.Return(run)
	return _c
}

// IsProtected provides a mock function for the type ConnectorHost
func (_mock *ConnectorHost) IsProtected(peerId peer.ID) bool {
	ret := _mock.Called(peerId)

	if len(ret) == 0 {
		panic("no return value specified for IsProtected")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(peer.ID) bool); ok {
		r0 = returnFunc(peerId)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// ConnectorHost_IsProtected_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsProtected'
type ConnectorHost_IsProtected_Call struct {
	*mock.Call
}

// IsProtected is a helper method to define mock.On call
//   - peerId peer.ID
func (_e *ConnectorHost_Expecter) IsProtected(peerId interface{}) *ConnectorHost_IsProtected_Call {
	return &ConnectorHost_IsProtected_Call{Call: _e.mock.On("IsProtected", peerId)}
}

func (_c *ConnectorHost_IsProtected_Call) Run(run func(peerId peer.ID)) *ConnectorHost_IsProtected_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 peer.ID
		if args[0] != nil {
			arg0 = args[0].(peer.ID)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ConnectorHost_IsProtected_Call) Return(b bool) *ConnectorHost_IsProtected_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *ConnectorHost_IsProtected_Call) RunAndReturn(run func(peerId peer.ID) bool) *ConnectorHost_IsProtected_Call {
	_c.Call.Return(run)
	return _c
}

// PeerInfo provides a mock function for the type ConnectorHost
func (_mock *ConnectorHost) PeerInfo(peerId peer.ID) peer.AddrInfo {
	ret := _mock.Called(peerId)

	if len(ret) == 0 {
		panic("no return value specified for PeerInfo")
	}

	var r0 peer.AddrInfo
	if returnFunc, ok := ret.Get(0).(func(peer.ID) peer.AddrInfo); ok {
		r0 = returnFunc(peerId)
	} else {
		r0 = ret.Get(0).(peer.AddrInfo)
	}
	return r0
}

// ConnectorHost_PeerInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PeerInfo'
type ConnectorHost_PeerInfo_Call struct {
	*mock.Call
}

// PeerInfo is a helper method to define mock.On call
//   - peerId peer.ID
func (_e *ConnectorHost_Expecter) PeerInfo(peerId interface{}) *ConnectorHost_PeerInfo_Call {
	return &ConnectorHost_PeerInfo_Call{Call: _e.mock.On("PeerInfo", peerId)}
}

func (_c *ConnectorHost_PeerInfo_Call) Run(run func(peerId peer.ID)) *ConnectorHost_PeerInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 peer.ID
		if args[0] != nil {
			arg0 = args[0].(peer.ID)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ConnectorHost_PeerInfo_Call) Return(addrInfo peer.AddrInfo) *ConnectorHost_PeerInfo_Call {
	_c.Call.Return(addrInfo)
	return _c
}

func (_c *ConnectorHost_PeerInfo_Call) RunAndReturn(run func(peerId peer.ID) peer.AddrInfo) *ConnectorHost_PeerInfo_Call {
	_c.Call.Return(run)
	return _c
}

// NewGossipSubInvCtrlMsgNotifConsumer creates a new instance of GossipSubInvCtrlMsgNotifConsumer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewGossipSubInvCtrlMsgNotifConsumer(t interface {
	mock.TestingT
	Cleanup(func())
}) *GossipSubInvCtrlMsgNotifConsumer {
	mock := &GossipSubInvCtrlMsgNotifConsumer{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// GossipSubInvCtrlMsgNotifConsumer is an autogenerated mock type for the GossipSubInvCtrlMsgNotifConsumer type
type GossipSubInvCtrlMsgNotifConsumer struct {
	mock.Mock
}

type GossipSubInvCtrlMsgNotifConsumer_Expecter struct {
	mock *mock.Mock
}

func (_m *GossipSubInvCtrlMsgNotifConsumer) EXPECT() *GossipSubInvCtrlMsgNotifConsumer_Expecter {
	return &GossipSubInvCtrlMsgNotifConsumer_Expecter{mock: &_m.Mock}
}

// OnInvalidControlMessageNotification provides a mock function for the type GossipSubInvCtrlMsgNotifConsumer
func (_mock *GossipSubInvCtrlMsgNotifConsumer) OnInvalidControlMessageNotification(invCtrlMsgNotif *p2p.InvCtrlMsgNotif) {
	_mock.Called(invCtrlMsgNotif)
	return
}

// GossipSubInvCtrlMsgNotifConsumer_OnInvalidControlMessageNotification_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnInvalidControlMessageNotification'
type GossipSubInvCtrlMsgNotifConsumer_OnInvalidControlMessageNotification_Call struct {
	*mock.Call
}

// OnInvalidControlMessageNotification is a helper method to define mock.On call
//   - invCtrlMsgNotif *p2p.InvCtrlMsgNotif
func (_e *GossipSubInvCtrlMsgNotifConsumer_Expecter) OnInvalidControlMessageNotification(invCtrlMsgNotif interface{}) *GossipSubInvCtrlMsgNotifConsumer_OnInvalidControlMessageNotification_Call {
	return &GossipSubInvCtrlMsgNotifConsumer_OnInvalidControlMessageNotification_Call{Call: _e.mock.On("OnInvalidControlMessageNotification", invCtrlMsgNotif)}
}

func (_c *GossipSubInvCtrlMsgNotifConsumer_OnInvalidControlMessageNotification_Call) Run(run func(invCtrlMsgNotif *p2p.InvCtrlMsgNotif)) *GossipSubInvCtrlMsgNotifConsumer_OnInvalidControlMessageNotification_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *p2p.InvCtrlMsgNotif
		if args[0] != nil {
			arg0 = args[0].(*p2p.InvCtrlMsgNotif)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *GossipSubInvCtrlMsgNotifConsumer_OnInvalidControlMessageNotification_Call) Return() *GossipSubInvCtrlMsgNotifConsumer_OnInvalidControlMessageNotification_Call {
	_c.Call.Return()
	return _c
}

func (_c *GossipSubInvCtrlMsgNotifConsumer_OnInvalidControlMessageNotification_Call) RunAndReturn(run func(invCtrlMsgNotif *p2p.InvCtrlMsgNotif)) *GossipSubInvCtrlMsgNotifConsumer_OnInvalidControlMessageNotification_Call {
	_c.Run(run)
	return _c
}

// NewDisallowListCache creates a new instance of DisallowListCache. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewDisallowListCache(t interface {
	mock.TestingT
	Cleanup(func())
}) *DisallowListCache {
	mock := &DisallowListCache{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// DisallowListCache is an autogenerated mock type for the DisallowListCache type
type DisallowListCache struct {
	mock.Mock
}

type DisallowListCache_Expecter struct {
	mock *mock.Mock
}

func (_m *DisallowListCache) EXPECT() *DisallowListCache_Expecter {
	return &DisallowListCache_Expecter{mock: &_m.Mock}
}

// AllowFor provides a mock function for the type DisallowListCache
func (_mock *DisallowListCache) AllowFor(peerID peer.ID, cause network0.DisallowListedCause) []network0.DisallowListedCause {
	ret := _mock.Called(peerID, cause)

	if len(ret) == 0 {
		panic("no return value specified for AllowFor")
	}

	var r0 []network0.DisallowListedCause
	if returnFunc, ok := ret.Get(0).(func(peer.ID, network0.DisallowListedCause) []network0.DisallowListedCause); ok {
		r0 = returnFunc(peerID, cause)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]network0.DisallowListedCause)
		}
	}
	return r0
}

// DisallowListCache_AllowFor_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AllowFor'
type DisallowListCache_AllowFor_Call struct {
	*mock.Call
}

// AllowFor is a helper method to define mock.On call
//   - peerID peer.ID
//   - cause network0.DisallowListedCause
func (_e *DisallowListCache_Expecter) AllowFor(peerID interface{}, cause interface{}) *DisallowListCache_AllowFor_Call {
	return &DisallowListCache_AllowFor_Call{Call: _e.mock.On("AllowFor", peerID, cause)}
}

func (_c *DisallowListCache_AllowFor_Call) Run(run func(peerID peer.ID, cause network0.DisallowListedCause)) *DisallowListCache_AllowFor_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 peer.ID
		if args[0] != nil {
			arg0 = args[0].(peer.ID)
		}
		var arg1 network0.DisallowListedCause
		if args[1] != nil {
			arg1 = args[1].(network0.DisallowListedCause)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *DisallowListCache_AllowFor_Call) Return(disallowListedCauses []network0.DisallowListedCause) *DisallowListCache_AllowFor_Call {
	_c.Call.Return(disallowListedCauses)
	return _c
}

func (_c *DisallowListCache_AllowFor_Call) RunAndReturn(run func(peerID peer.ID, cause network0.DisallowListedCause) []network0.DisallowListedCause) *DisallowListCache_AllowFor_Call {
	_c.Call.Return(run)
	return _c
}

// DisallowFor provides a mock function for the type DisallowListCache
func (_mock *DisallowListCache) DisallowFor(peerID peer.ID, cause network0.DisallowListedCause) ([]network0.DisallowListedCause, error) {
	ret := _mock.Called(peerID, cause)

	if len(ret) == 0 {
		panic("no return value specified for DisallowFor")
	}

	var r0 []network0.DisallowListedCause
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(peer.ID, network0.DisallowListedCause) ([]network0.DisallowListedCause, error)); ok {
		return returnFunc(peerID, cause)
	}
	if returnFunc, ok := ret.Get(0).(func(peer.ID, network0.DisallowListedCause) []network0.DisallowListedCause); ok {
		r0 = returnFunc(peerID, cause)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]network0.DisallowListedCause)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(peer.ID, network0.DisallowListedCause) error); ok {
		r1 = returnFunc(peerID, cause)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// DisallowListCache_DisallowFor_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DisallowFor'
type DisallowListCache_DisallowFor_Call struct {
	*mock.Call
}

// DisallowFor is a helper method to define mock.On call
//   - peerID peer.ID
//   - cause network0.DisallowListedCause
func (_e *DisallowListCache_Expecter) DisallowFor(peerID interface{}, cause interface{}) *DisallowListCache_DisallowFor_Call {
	return &DisallowListCache_DisallowFor_Call{Call: _e.mock.On("DisallowFor", peerID, cause)}
}

func (_c *DisallowListCache_DisallowFor_Call) Run(run func(peerID peer.ID, cause network0.DisallowListedCause)) *DisallowListCache_DisallowFor_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 peer.ID
		if args[0] != nil {
			arg0 = args[0].(peer.ID)
		}
		var arg1 network0.DisallowListedCause
		if args[1] != nil {
			arg1 = args[1].(network0.DisallowListedCause)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *DisallowListCache_DisallowFor_Call) Return(disallowListedCauses []network0.DisallowListedCause, err error) *DisallowListCache_DisallowFor_Call {
	_c.Call.Return(disallowListedCauses, err)
	return _c
}

func (_c *DisallowListCache_DisallowFor_Call) RunAndReturn(run func(peerID peer.ID, cause network0.DisallowListedCause) ([]network0.DisallowListedCause, error)) *DisallowListCache_DisallowFor_Call {
	_c.Call.Return(run)
	return _c
}

// IsDisallowListed provides a mock function for the type DisallowListCache
func (_mock *DisallowListCache) IsDisallowListed(peerID peer.ID) ([]network0.DisallowListedCause, bool) {
	ret := _mock.Called(peerID)

	if len(ret) == 0 {
		panic("no return value specified for IsDisallowListed")
	}

	var r0 []network0.DisallowListedCause
	var r1 bool
	if returnFunc, ok := ret.Get(0).(func(peer.ID) ([]network0.DisallowListedCause, bool)); ok {
		return returnFunc(peerID)
	}
	if returnFunc, ok := ret.Get(0).(func(peer.ID) []network0.DisallowListedCause); ok {
		r0 = returnFunc(peerID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]network0.DisallowListedCause)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(peer.ID) bool); ok {
		r1 = returnFunc(peerID)
	} else {
		r1 = ret.Get(1).(bool)
	}
	return r0, r1
}

// DisallowListCache_IsDisallowListed_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsDisallowListed'
type DisallowListCache_IsDisallowListed_Call struct {
	*mock.Call
}

// IsDisallowListed is a helper method to define mock.On call
//   - peerID peer.ID
func (_e *DisallowListCache_Expecter) IsDisallowListed(peerID interface{}) *DisallowListCache_IsDisallowListed_Call {
	return &DisallowListCache_IsDisallowListed_Call{Call: _e.mock.On("IsDisallowListed", peerID)}
}

func (_c *DisallowListCache_IsDisallowListed_Call) Run(run func(peerID peer.ID)) *DisallowListCache_IsDisallowListed_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 peer.ID
		if args[0] != nil {
			arg0 = args[0].(peer.ID)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *DisallowListCache_IsDisallowListed_Call) Return(disallowListedCauses []network0.DisallowListedCause, b bool) *DisallowListCache_IsDisallowListed_Call {
	_c.Call.Return(disallowListedCauses, b)
	return _c
}

func (_c *DisallowListCache_IsDisallowListed_Call) RunAndReturn(run func(peerID peer.ID) ([]network0.DisallowListedCause, bool)) *DisallowListCache_IsDisallowListed_Call {
	_c.Call.Return(run)
	return _c
}

// NewIDTranslator creates a new instance of IDTranslator. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIDTranslator(t interface {
	mock.TestingT
	Cleanup(func())
}) *IDTranslator {
	mock := &IDTranslator{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// IDTranslator is an autogenerated mock type for the IDTranslator type
type IDTranslator struct {
	mock.Mock
}

type IDTranslator_Expecter struct {
	mock *mock.Mock
}

func (_m *IDTranslator) EXPECT() *IDTranslator_Expecter {
	return &IDTranslator_Expecter{mock: &_m.Mock}
}

// GetFlowID provides a mock function for the type IDTranslator
func (_mock *IDTranslator) GetFlowID(iD peer.ID) (flow.Identifier, error) {
	ret := _mock.Called(iD)

	if len(ret) == 0 {
		panic("no return value specified for GetFlowID")
	}

	var r0 flow.Identifier
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(peer.ID) (flow.Identifier, error)); ok {
		return returnFunc(iD)
	}
	if returnFunc, ok := ret.Get(0).(func(peer.ID) flow.Identifier); ok {
		r0 = returnFunc(iD)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.Identifier)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(peer.ID) error); ok {
		r1 = returnFunc(iD)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// IDTranslator_GetFlowID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFlowID'
type IDTranslator_GetFlowID_Call struct {
	*mock.Call
}

// GetFlowID is a helper method to define mock.On call
//   - iD peer.ID
func (_e *IDTranslator_Expecter) GetFlowID(iD interface{}) *IDTranslator_GetFlowID_Call {
	return &IDTranslator_GetFlowID_Call{Call: _e.mock.On("GetFlowID", iD)}
}

func (_c *IDTranslator_GetFlowID_Call) Run(run func(iD peer.ID)) *IDTranslator_GetFlowID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 peer.ID
		if args[0] != nil {
			arg0 = args[0].(peer.ID)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *IDTranslator_GetFlowID_Call) Return(identifier flow.Identifier, err error) *IDTranslator_GetFlowID_Call {
	_c.Call.Return(identifier, err)
	return _c
}

func (_c *IDTranslator_GetFlowID_Call) RunAndReturn(run func(iD peer.ID) (flow.Identifier, error)) *IDTranslator_GetFlowID_Call {
	_c.Call.Return(run)
	return _c
}

// GetPeerID provides a mock function for the type IDTranslator
func (_mock *IDTranslator) GetPeerID(identifier flow.Identifier) (peer.ID, error) {
	ret := _mock.Called(identifier)

	if len(ret) == 0 {
		panic("no return value specified for GetPeerID")
	}

	var r0 peer.ID
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (peer.ID, error)); ok {
		return returnFunc(identifier)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) peer.ID); ok {
		r0 = returnFunc(identifier)
	} else {
		r0 = ret.Get(0).(peer.ID)
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(identifier)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// IDTranslator_GetPeerID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPeerID'
type IDTranslator_GetPeerID_Call struct {
	*mock.Call
}

// GetPeerID is a helper method to define mock.On call
//   - identifier flow.Identifier
func (_e *IDTranslator_Expecter) GetPeerID(identifier interface{}) *IDTranslator_GetPeerID_Call {
	return &IDTranslator_GetPeerID_Call{Call: _e.mock.On("GetPeerID", identifier)}
}

func (_c *IDTranslator_GetPeerID_Call) Run(run func(identifier flow.Identifier)) *IDTranslator_GetPeerID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *IDTranslator_GetPeerID_Call) Return(iD peer.ID, err error) *IDTranslator_GetPeerID_Call {
	_c.Call.Return(iD, err)
	return _c
}

func (_c *IDTranslator_GetPeerID_Call) RunAndReturn(run func(identifier flow.Identifier) (peer.ID, error)) *IDTranslator_GetPeerID_Call {
	_c.Call.Return(run)
	return _c
}

// NewCoreP2P creates a new instance of CoreP2P. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewCoreP2P(t interface {
	mock.TestingT
	Cleanup(func())
}) *CoreP2P {
	mock := &CoreP2P{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// CoreP2P is an autogenerated mock type for the CoreP2P type
type CoreP2P struct {
	mock.Mock
}

type CoreP2P_Expecter struct {
	mock *mock.Mock
}

func (_m *CoreP2P) EXPECT() *CoreP2P_Expecter {
	return &CoreP2P_Expecter{mock: &_m.Mock}
}

// GetIPPort provides a mock function for the type CoreP2P
func (_mock *CoreP2P) GetIPPort() (string, string, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetIPPort")
	}

	var r0 string
	var r1 string
	var r2 error
	if returnFunc, ok := ret.Get(0).(func() (string, string, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() string); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func() string); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Get(1).(string)
	}
	if returnFunc, ok := ret.Get(2).(func() error); ok {
		r2 = returnFunc()
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// CoreP2P_GetIPPort_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetIPPort'
type CoreP2P_GetIPPort_Call struct {
	*mock.Call
}

// GetIPPort is a helper method to define mock.On call
func (_e *CoreP2P_Expecter) GetIPPort() *CoreP2P_GetIPPort_Call {
	return &CoreP2P_GetIPPort_Call{Call: _e.mock.On("GetIPPort")}
}

func (_c *CoreP2P_GetIPPort_Call) Run(run func()) *CoreP2P_GetIPPort_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *CoreP2P_GetIPPort_Call) Return(s string, s1 string, err error) *CoreP2P_GetIPPort_Call {
	_c.Call.Return(s, s1, err)
	return _c
}

func (_c *CoreP2P_GetIPPort_Call) RunAndReturn(run func() (string, string, error)) *CoreP2P_GetIPPort_Call {
	_c.Call.Return(run)
	return _c
}

// Host provides a mock function for the type CoreP2P
func (_mock *CoreP2P) Host() host.Host {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Host")
	}

	var r0 host.Host
	if returnFunc, ok := ret.Get(0).(func() host.Host); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(host.Host)
		}
	}
	return r0
}

// CoreP2P_Host_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Host'
type CoreP2P_Host_Call struct {
	*mock.Call
}

// Host is a helper method to define mock.On call
func (_e *CoreP2P_Expecter) Host() *CoreP2P_Host_Call {
	return &CoreP2P_Host_Call{Call: _e.mock.On("Host")}
}

func (_c *CoreP2P_Host_Call) Run(run func()) *CoreP2P_Host_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *CoreP2P_Host_Call) Return(host1 host.Host) *CoreP2P_Host_Call {
	_c.Call.Return(host1)
	return _c
}

func (_c *CoreP2P_Host_Call) RunAndReturn(run func() host.Host) *CoreP2P_Host_Call {
	_c.Call.Return(run)
	return _c
}

// SetComponentManager provides a mock function for the type CoreP2P
func (_mock *CoreP2P) SetComponentManager(cm *component.ComponentManager) {
	_mock.Called(cm)
	return
}

// CoreP2P_SetComponentManager_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetComponentManager'
type CoreP2P_SetComponentManager_Call struct {
	*mock.Call
}

// SetComponentManager is a helper method to define mock.On call
//   - cm *component.ComponentManager
func (_e *CoreP2P_Expecter) SetComponentManager(cm interface{}) *CoreP2P_SetComponentManager_Call {
	return &CoreP2P_SetComponentManager_Call{Call: _e.mock.On("SetComponentManager", cm)}
}

func (_c *CoreP2P_SetComponentManager_Call) Run(run func(cm *component.ComponentManager)) *CoreP2P_SetComponentManager_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *component.ComponentManager
		if args[0] != nil {
			arg0 = args[0].(*component.ComponentManager)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *CoreP2P_SetComponentManager_Call) Return() *CoreP2P_SetComponentManager_Call {
	_c.Call.Return()
	return _c
}

func (_c *CoreP2P_SetComponentManager_Call) RunAndReturn(run func(cm *component.ComponentManager)) *CoreP2P_SetComponentManager_Call {
	_c.Run(run)
	return _c
}

// Start provides a mock function for the type CoreP2P
func (_mock *CoreP2P) Start(ctx irrecoverable.SignalerContext) {
	_mock.Called(ctx)
	return
}

// CoreP2P_Start_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Start'
type CoreP2P_Start_Call struct {
	*mock.Call
}

// Start is a helper method to define mock.On call
//   - ctx irrecoverable.SignalerContext
func (_e *CoreP2P_Expecter) Start(ctx interface{}) *CoreP2P_Start_Call {
	return &CoreP2P_Start_Call{Call: _e.mock.On("Start", ctx)}
}

func (_c *CoreP2P_Start_Call) Run(run func(ctx irrecoverable.SignalerContext)) *CoreP2P_Start_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 irrecoverable.SignalerContext
		if args[0] != nil {
			arg0 = args[0].(irrecoverable.SignalerContext)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *CoreP2P_Start_Call) Return() *CoreP2P_Start_Call {
	_c.Call.Return()
	return _c
}

func (_c *CoreP2P_Start_Call) RunAndReturn(run func(ctx irrecoverable.SignalerContext)) *CoreP2P_Start_Call {
	_c.Run(run)
	return _c
}

// Stop provides a mock function for the type CoreP2P
func (_mock *CoreP2P) Stop() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Stop")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// CoreP2P_Stop_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Stop'
type CoreP2P_Stop_Call struct {
	*mock.Call
}

// Stop is a helper method to define mock.On call
func (_e *CoreP2P_Expecter) Stop() *CoreP2P_Stop_Call {
	return &CoreP2P_Stop_Call{Call: _e.mock.On("Stop")}
}

func (_c *CoreP2P_Stop_Call) Run(run func()) *CoreP2P_Stop_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *CoreP2P_Stop_Call) Return(err error) *CoreP2P_Stop_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *CoreP2P_Stop_Call) RunAndReturn(run func() error) *CoreP2P_Stop_Call {
	_c.Call.Return(run)
	return _c
}

// NewPeerManagement creates a new instance of PeerManagement. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewPeerManagement(t interface {
	mock.TestingT
	Cleanup(func())
}) *PeerManagement {
	mock := &PeerManagement{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// PeerManagement is an autogenerated mock type for the PeerManagement type
type PeerManagement struct {
	mock.Mock
}

type PeerManagement_Expecter struct {
	mock *mock.Mock
}

func (_m *PeerManagement) EXPECT() *PeerManagement_Expecter {
	return &PeerManagement_Expecter{mock: &_m.Mock}
}

// ConnectToPeer provides a mock function for the type PeerManagement
func (_mock *PeerManagement) ConnectToPeer(ctx context.Context, peerInfo peer.AddrInfo) error {
	ret := _mock.Called(ctx, peerInfo)

	if len(ret) == 0 {
		panic("no return value specified for ConnectToPeer")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, peer.AddrInfo) error); ok {
		r0 = returnFunc(ctx, peerInfo)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// PeerManagement_ConnectToPeer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConnectToPeer'
type PeerManagement_ConnectToPeer_Call struct {
	*mock.Call
}

// ConnectToPeer is a helper method to define mock.On call
//   - ctx context.Context
//   - peerInfo peer.AddrInfo
func (_e *PeerManagement_Expecter) ConnectToPeer(ctx interface{}, peerInfo interface{}) *PeerManagement_ConnectToPeer_Call {
	return &PeerManagement_ConnectToPeer_Call{Call: _e.mock.On("ConnectToPeer", ctx, peerInfo)}
}

func (_c *PeerManagement_ConnectToPeer_Call) Run(run func(ctx context.Context, peerInfo peer.AddrInfo)) *PeerManagement_ConnectToPeer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 peer.AddrInfo
		if args[1] != nil {
			arg1 = args[1].(peer.AddrInfo)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *PeerManagement_ConnectToPeer_Call) Return(err error) *PeerManagement_ConnectToPeer_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *PeerManagement_ConnectToPeer_Call) RunAndReturn(run func(ctx context.Context, peerInfo peer.AddrInfo) error) *PeerManagement_ConnectToPeer_Call {
	_c.Call.Return(run)
	return _c
}

// GetIPPort provides a mock function for the type PeerManagement
func (_mock *PeerManagement) GetIPPort() (string, string, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetIPPort")
	}

	var r0 string
	var r1 string
	var r2 error
	if returnFunc, ok := ret.Get(0).(func() (string, string, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() string); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func() string); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Get(1).(string)
	}
	if returnFunc, ok := ret.Get(2).(func() error); ok {
		r2 = returnFunc()
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// PeerManagement_GetIPPort_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetIPPort'
type PeerManagement_GetIPPort_Call struct {
	*mock.Call
}

// GetIPPort is a helper method to define mock.On call
func (_e *PeerManagement_Expecter) GetIPPort() *PeerManagement_GetIPPort_Call {
	return &PeerManagement_GetIPPort_Call{Call: _e.mock.On("GetIPPort")}
}

func (_c *PeerManagement_GetIPPort_Call) Run(run func()) *PeerManagement_GetIPPort_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *PeerManagement_GetIPPort_Call) Return(s string, s1 string, err error) *PeerManagement_GetIPPort_Call {
	_c.Call.Return(s, s1, err)
	return _c
}

func (_c *PeerManagement_GetIPPort_Call) RunAndReturn(run func() (string, string, error)) *PeerManagement_GetIPPort_Call {
	_c.Call.Return(run)
	return _c
}

// GetPeersForProtocol provides a mock function for the type PeerManagement
func (_mock *PeerManagement) GetPeersForProtocol(pid protocol.ID) peer.IDSlice {
	ret := _mock.Called(pid)

	if len(ret) == 0 {
		panic("no return value specified for GetPeersForProtocol")
	}

	var r0 peer.IDSlice
	if returnFunc, ok := ret.Get(0).(func(protocol.ID) peer.IDSlice); ok {
		r0 = returnFunc(pid)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(peer.IDSlice)
		}
	}
	return r0
}

// PeerManagement_GetPeersForProtocol_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPeersForProtocol'
type PeerManagement_GetPeersForProtocol_Call struct {
	*mock.Call
}

// GetPeersForProtocol is a helper method to define mock.On call
//   - pid protocol.ID
func (_e *PeerManagement_Expecter) GetPeersForProtocol(pid interface{}) *PeerManagement_GetPeersForProtocol_Call {
	return &PeerManagement_GetPeersForProtocol_Call{Call: _e.mock.On("GetPeersForProtocol", pid)}
}

func (_c *PeerManagement_GetPeersForProtocol_Call) Run(run func(pid protocol.ID)) *PeerManagement_GetPeersForProtocol_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 protocol.ID
		if args[0] != nil {
			arg0 = args[0].(protocol.ID)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PeerManagement_GetPeersForProtocol_Call) Return(iDSlice peer.IDSlice) *PeerManagement_GetPeersForProtocol_Call {
	_c.Call.Return(iDSlice)
	return _c
}

func (_c *PeerManagement_GetPeersForProtocol_Call) RunAndReturn(run func(pid protocol.ID) peer.IDSlice) *PeerManagement_GetPeersForProtocol_Call {
	_c.Call.Return(run)
	return _c
}

// Host provides a mock function for the type PeerManagement
func (_mock *PeerManagement) Host() host.Host {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Host")
	}

	var r0 host.Host
	if returnFunc, ok := ret.Get(0).(func() host.Host); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(host.Host)
		}
	}
	return r0
}

// PeerManagement_Host_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Host'
type PeerManagement_Host_Call struct {
	*mock.Call
}

// Host is a helper method to define mock.On call
func (_e *PeerManagement_Expecter) Host() *PeerManagement_Host_Call {
	return &PeerManagement_Host_Call{Call: _e.mock.On("Host")}
}

func (_c *PeerManagement_Host_Call) Run(run func()) *PeerManagement_Host_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *PeerManagement_Host_Call) Return(host1 host.Host) *PeerManagement_Host_Call {
	_c.Call.Return(host1)
	return _c
}

func (_c *PeerManagement_Host_Call) RunAndReturn(run func() host.Host) *PeerManagement_Host_Call {
	_c.Call.Return(run)
	return _c
}

// ID provides a mock function for the type PeerManagement
func (_mock *PeerManagement) ID() peer.ID {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for ID")
	}

	var r0 peer.ID
	if returnFunc, ok := ret.Get(0).(func() peer.ID); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(peer.ID)
	}
	return r0
}

// PeerManagement_ID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ID'
type PeerManagement_ID_Call struct {
	*mock.Call
}

// ID is a helper method to define mock.On call
func (_e *PeerManagement_Expecter) ID() *PeerManagement_ID_Call {
	return &PeerManagement_ID_Call{Call: _e.mock.On("ID")}
}

func (_c *PeerManagement_ID_Call) Run(run func()) *PeerManagement_ID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *PeerManagement_ID_Call) Return(iD peer.ID) *PeerManagement_ID_Call {
	_c.Call.Return(iD)
	return _c
}

func (_c *PeerManagement_ID_Call) RunAndReturn(run func() peer.ID) *PeerManagement_ID_Call {
	_c.Call.Return(run)
	return _c
}

// ListPeers provides a mock function for the type PeerManagement
func (_mock *PeerManagement) ListPeers(topic string) []peer.ID {
	ret := _mock.Called(topic)

	if len(ret) == 0 {
		panic("no return value specified for ListPeers")
	}

	var r0 []peer.ID
	if returnFunc, ok := ret.Get(0).(func(string) []peer.ID); ok {
		r0 = returnFunc(topic)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]peer.ID)
		}
	}
	return r0
}

// PeerManagement_ListPeers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListPeers'
type PeerManagement_ListPeers_Call struct {
	*mock.Call
}

// ListPeers is a helper method to define mock.On call
//   - topic string
func (_e *PeerManagement_Expecter) ListPeers(topic interface{}) *PeerManagement_ListPeers_Call {
	return &PeerManagement_ListPeers_Call{Call: _e.mock.On("ListPeers", topic)}
}

func (_c *PeerManagement_ListPeers_Call) Run(run func(topic string)) *PeerManagement_ListPeers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PeerManagement_ListPeers_Call) Return(iDs []peer.ID) *PeerManagement_ListPeers_Call {
	_c.Call.Return(iDs)
	return _c
}

func (_c *PeerManagement_ListPeers_Call) RunAndReturn(run func(topic string) []peer.ID) *PeerManagement_ListPeers_Call {
	_c.Call.Return(run)
	return _c
}

// PeerManagerComponent provides a mock function for the type PeerManagement
func (_mock *PeerManagement) PeerManagerComponent() component.Component {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for PeerManagerComponent")
	}

	var r0 component.Component
	if returnFunc, ok := ret.Get(0).(func() component.Component); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(component.Component)
		}
	}
	return r0
}

// PeerManagement_PeerManagerComponent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PeerManagerComponent'
type PeerManagement_PeerManagerComponent_Call struct {
	*mock.Call
}

// PeerManagerComponent is a helper method to define mock.On call
func (_e *PeerManagement_Expecter) PeerManagerComponent() *PeerManagement_PeerManagerComponent_Call {
	return &PeerManagement_PeerManagerComponent_Call{Call: _e.mock.On("PeerManagerComponent")}
}

func (_c *PeerManagement_PeerManagerComponent_Call) Run(run func()) *PeerManagement_PeerManagerComponent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *PeerManagement_PeerManagerComponent_Call) Return(component1 component.Component) *PeerManagement_PeerManagerComponent_Call {
	_c.Call.Return(component1)
	return _c
}

func (_c *PeerManagement_PeerManagerComponent_Call) RunAndReturn(run func() component.Component) *PeerManagement_PeerManagerComponent_Call {
	_c.Call.Return(run)
	return _c
}

// Publish provides a mock function for the type PeerManagement
func (_mock *PeerManagement) Publish(ctx context.Context, messageScope network0.OutgoingMessageScope) error {
	ret := _mock.Called(ctx, messageScope)

	if len(ret) == 0 {
		panic("no return value specified for Publish")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, network0.OutgoingMessageScope) error); ok {
		r0 = returnFunc(ctx, messageScope)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// PeerManagement_Publish_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Publish'
type PeerManagement_Publish_Call struct {
	*mock.Call
}

// Publish is a helper method to define mock.On call
//   - ctx context.Context
//   - messageScope network0.OutgoingMessageScope
func (_e *PeerManagement_Expecter) Publish(ctx interface{}, messageScope interface{}) *PeerManagement_Publish_Call {
	return &PeerManagement_Publish_Call{Call: _e.mock.On("Publish", ctx, messageScope)}
}

func (_c *PeerManagement_Publish_Call) Run(run func(ctx context.Context, messageScope network0.OutgoingMessageScope)) *PeerManagement_Publish_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 network0.OutgoingMessageScope
		if args[1] != nil {
			arg1 = args[1].(network0.OutgoingMessageScope)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *PeerManagement_Publish_Call) Return(err error) *PeerManagement_Publish_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *PeerManagement_Publish_Call) RunAndReturn(run func(ctx context.Context, messageScope network0.OutgoingMessageScope) error) *PeerManagement_Publish_Call {
	_c.Call.Return(run)
	return _c
}

// RemovePeer provides a mock function for the type PeerManagement
func (_mock *PeerManagement) RemovePeer(peerID peer.ID) error {
	ret := _mock.Called(peerID)

	if len(ret) == 0 {
		panic("no return value specified for RemovePeer")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(peer.ID) error); ok {
		r0 = returnFunc(peerID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// PeerManagement_RemovePeer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemovePeer'
type PeerManagement_RemovePeer_Call struct {
	*mock.Call
}

// RemovePeer is a helper method to define mock.On call
//   - peerID peer.ID
func (_e *PeerManagement_Expecter) RemovePeer(peerID interface{}) *PeerManagement_RemovePeer_Call {
	return &PeerManagement_RemovePeer_Call{Call: _e.mock.On("RemovePeer", peerID)}
}

func (_c *PeerManagement_RemovePeer_Call) Run(run func(peerID peer.ID)) *PeerManagement_RemovePeer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 peer.ID
		if args[0] != nil {
			arg0 = args[0].(peer.ID)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PeerManagement_RemovePeer_Call) Return(err error) *PeerManagement_RemovePeer_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *PeerManagement_RemovePeer_Call) RunAndReturn(run func(peerID peer.ID) error) *PeerManagement_RemovePeer_Call {
	_c.Call.Return(run)
	return _c
}

// RequestPeerUpdate provides a mock function for the type PeerManagement
func (_mock *PeerManagement) RequestPeerUpdate() {
	_mock.Called()
	return
}

// PeerManagement_RequestPeerUpdate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RequestPeerUpdate'
type PeerManagement_RequestPeerUpdate_Call struct {
	*mock.Call
}

// RequestPeerUpdate is a helper method to define mock.On call
func (_e *PeerManagement_Expecter) RequestPeerUpdate() *PeerManagement_RequestPeerUpdate_Call {
	return &PeerManagement_RequestPeerUpdate_Call{Call: _e.mock.On("RequestPeerUpdate")}
}

func (_c *PeerManagement_RequestPeerUpdate_Call) Run(run func()) *PeerManagement_RequestPeerUpdate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *PeerManagement_RequestPeerUpdate_Call) Return() *PeerManagement_RequestPeerUpdate_Call {
	_c.Call.Return()
	return _c
}

func (_c *PeerManagement_RequestPeerUpdate_Call) RunAndReturn(run func()) *PeerManagement_RequestPeerUpdate_Call {
	_c.Run(run)
	return _c
}

// RoutingTable provides a mock function for the type PeerManagement
func (_mock *PeerManagement) RoutingTable() *kbucket.RoutingTable {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for RoutingTable")
	}

	var r0 *kbucket.RoutingTable
	if returnFunc, ok := ret.Get(0).(func() *kbucket.RoutingTable); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kbucket.RoutingTable)
		}
	}
	return r0
}

// PeerManagement_RoutingTable_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RoutingTable'
type PeerManagement_RoutingTable_Call struct {
	*mock.Call
}

// RoutingTable is a helper method to define mock.On call
func (_e *PeerManagement_Expecter) RoutingTable() *PeerManagement_RoutingTable_Call {
	return &PeerManagement_RoutingTable_Call{Call: _e.mock.On("RoutingTable")}
}

func (_c *PeerManagement_RoutingTable_Call) Run(run func()) *PeerManagement_RoutingTable_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *PeerManagement_RoutingTable_Call) Return(routingTable *kbucket.RoutingTable) *PeerManagement_RoutingTable_Call {
	_c.Call.Return(routingTable)
	return _c
}

func (_c *PeerManagement_RoutingTable_Call) RunAndReturn(run func() *kbucket.RoutingTable) *PeerManagement_RoutingTable_Call {
	_c.Call.Return(run)
	return _c
}

// Subscribe provides a mock function for the type PeerManagement
func (_mock *PeerManagement) Subscribe(topic channels.Topic, topicValidator p2p.TopicValidatorFunc) (p2p.Subscription, error) {
	ret := _mock.Called(topic, topicValidator)

	if len(ret) == 0 {
		panic("no return value specified for Subscribe")
	}

	var r0 p2p.Subscription
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(channels.Topic, p2p.TopicValidatorFunc) (p2p.Subscription, error)); ok {
		return returnFunc(topic, topicValidator)
	}
	if returnFunc, ok := ret.Get(0).(func(channels.Topic, p2p.TopicValidatorFunc) p2p.Subscription); ok {
		r0 = returnFunc(topic, topicValidator)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(p2p.Subscription)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(channels.Topic, p2p.TopicValidatorFunc) error); ok {
		r1 = returnFunc(topic, topicValidator)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// PeerManagement_Subscribe_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Subscribe'
type PeerManagement_Subscribe_Call struct {
	*mock.Call
}

// Subscribe is a helper method to define mock.On call
//   - topic channels.Topic
//   - topicValidator p2p.TopicValidatorFunc
func (_e *PeerManagement_Expecter) Subscribe(topic interface{}, topicValidator interface{}) *PeerManagement_Subscribe_Call {
	return &PeerManagement_Subscribe_Call{Call: _e.mock.On("Subscribe", topic, topicValidator)}
}

func (_c *PeerManagement_Subscribe_Call) Run(run func(topic channels.Topic, topicValidator p2p.TopicValidatorFunc)) *PeerManagement_Subscribe_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 channels.Topic
		if args[0] != nil {
			arg0 = args[0].(channels.Topic)
		}
		var arg1 p2p.TopicValidatorFunc
		if args[1] != nil {
			arg1 = args[1].(p2p.TopicValidatorFunc)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *PeerManagement_Subscribe_Call) Return(subscription p2p.Subscription, err error) *PeerManagement_Subscribe_Call {
	_c.Call.Return(subscription, err)
	return _c
}

func (_c *PeerManagement_Subscribe_Call) RunAndReturn(run func(topic channels.Topic, topicValidator p2p.TopicValidatorFunc) (p2p.Subscription, error)) *PeerManagement_Subscribe_Call {
	_c.Call.Return(run)
	return _c
}

// Unsubscribe provides a mock function for the type PeerManagement
func (_mock *PeerManagement) Unsubscribe(topic channels.Topic) error {
	ret := _mock.Called(topic)

	if len(ret) == 0 {
		panic("no return value specified for Unsubscribe")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(channels.Topic) error); ok {
		r0 = returnFunc(topic)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// PeerManagement_Unsubscribe_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Unsubscribe'
type PeerManagement_Unsubscribe_Call struct {
	*mock.Call
}

// Unsubscribe is a helper method to define mock.On call
//   - topic channels.Topic
func (_e *PeerManagement_Expecter) Unsubscribe(topic interface{}) *PeerManagement_Unsubscribe_Call {
	return &PeerManagement_Unsubscribe_Call{Call: _e.mock.On("Unsubscribe", topic)}
}

func (_c *PeerManagement_Unsubscribe_Call) Run(run func(topic channels.Topic)) *PeerManagement_Unsubscribe_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 channels.Topic
		if args[0] != nil {
			arg0 = args[0].(channels.Topic)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PeerManagement_Unsubscribe_Call) Return(err error) *PeerManagement_Unsubscribe_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *PeerManagement_Unsubscribe_Call) RunAndReturn(run func(topic channels.Topic) error) *PeerManagement_Unsubscribe_Call {
	_c.Call.Return(run)
	return _c
}

// WithDefaultUnicastProtocol provides a mock function for the type PeerManagement
func (_mock *PeerManagement) WithDefaultUnicastProtocol(defaultHandler network.StreamHandler, preferred []protocols.ProtocolName) error {
	ret := _mock.Called(defaultHandler, preferred)

	if len(ret) == 0 {
		panic("no return value specified for WithDefaultUnicastProtocol")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(network.StreamHandler, []protocols.ProtocolName) error); ok {
		r0 = returnFunc(defaultHandler, preferred)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// PeerManagement_WithDefaultUnicastProtocol_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithDefaultUnicastProtocol'
type PeerManagement_WithDefaultUnicastProtocol_Call struct {
	*mock.Call
}

// WithDefaultUnicastProtocol is a helper method to define mock.On call
//   - defaultHandler network.StreamHandler
//   - preferred []protocols.ProtocolName
func (_e *PeerManagement_Expecter) WithDefaultUnicastProtocol(defaultHandler interface{}, preferred interface{}) *PeerManagement_WithDefaultUnicastProtocol_Call {
	return &PeerManagement_WithDefaultUnicastProtocol_Call{Call: _e.mock.On("WithDefaultUnicastProtocol", defaultHandler, preferred)}
}

func (_c *PeerManagement_WithDefaultUnicastProtocol_Call) Run(run func(defaultHandler network.StreamHandler, preferred []protocols.ProtocolName)) *PeerManagement_WithDefaultUnicastProtocol_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 network.StreamHandler
		if args[0] != nil {
			arg0 = args[0].(network.StreamHandler)
		}
		var arg1 []protocols.ProtocolName
		if args[1] != nil {
			arg1 = args[1].([]protocols.ProtocolName)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *PeerManagement_WithDefaultUnicastProtocol_Call) Return(err error) *PeerManagement_WithDefaultUnicastProtocol_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *PeerManagement_WithDefaultUnicastProtocol_Call) RunAndReturn(run func(defaultHandler network.StreamHandler, preferred []protocols.ProtocolName) error) *PeerManagement_WithDefaultUnicastProtocol_Call {
	_c.Call.Return(run)
	return _c
}

// WithPeersProvider provides a mock function for the type PeerManagement
func (_mock *PeerManagement) WithPeersProvider(peersProvider p2p.PeersProvider) {
	_mock.Called(peersProvider)
	return
}

// PeerManagement_WithPeersProvider_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithPeersProvider'
type PeerManagement_WithPeersProvider_Call struct {
	*mock.Call
}

// WithPeersProvider is a helper method to define mock.On call
//   - peersProvider p2p.PeersProvider
func (_e *PeerManagement_Expecter) WithPeersProvider(peersProvider interface{}) *PeerManagement_WithPeersProvider_Call {
	return &PeerManagement_WithPeersProvider_Call{Call: _e.mock.On("WithPeersProvider", peersProvider)}
}

func (_c *PeerManagement_WithPeersProvider_Call) Run(run func(peersProvider p2p.PeersProvider)) *PeerManagement_WithPeersProvider_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 p2p.PeersProvider
		if args[0] != nil {
			arg0 = args[0].(p2p.PeersProvider)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PeerManagement_WithPeersProvider_Call) Return() *PeerManagement_WithPeersProvider_Call {
	_c.Call.Return()
	return _c
}

func (_c *PeerManagement_WithPeersProvider_Call) RunAndReturn(run func(peersProvider p2p.PeersProvider)) *PeerManagement_WithPeersProvider_Call {
	_c.Run(run)
	return _c
}

// NewRoutable creates a new instance of Routable. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewRoutable(t interface {
	mock.TestingT
	Cleanup(func())
}) *Routable {
	mock := &Routable{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Routable is an autogenerated mock type for the Routable type
type Routable struct {
	mock.Mock
}

type Routable_Expecter struct {
	mock *mock.Mock
}

func (_m *Routable) EXPECT() *Routable_Expecter {
	return &Routable_Expecter{mock: &_m.Mock}
}

// Routing provides a mock function for the type Routable
func (_mock *Routable) Routing() routing.Routing {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Routing")
	}

	var r0 routing.Routing
	if returnFunc, ok := ret.Get(0).(func() routing.Routing); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(routing.Routing)
		}
	}
	return r0
}

// Routable_Routing_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Routing'
type Routable_Routing_Call struct {
	*mock.Call
}

// Routing is a helper method to define mock.On call
func (_e *Routable_Expecter) Routing() *Routable_Routing_Call {
	return &Routable_Routing_Call{Call: _e.mock.On("Routing")}
}

func (_c *Routable_Routing_Call) Run(run func()) *Routable_Routing_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Routable_Routing_Call) Return(routing1 routing.Routing) *Routable_Routing_Call {
	_c.Call.Return(routing1)
	return _c
}

func (_c *Routable_Routing_Call) RunAndReturn(run func() routing.Routing) *Routable_Routing_Call {
	_c.Call.Return(run)
	return _c
}

// RoutingTable provides a mock function for the type Routable
func (_mock *Routable) RoutingTable() *kbucket.RoutingTable {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for RoutingTable")
	}

	var r0 *kbucket.RoutingTable
	if returnFunc, ok := ret.Get(0).(func() *kbucket.RoutingTable); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kbucket.RoutingTable)
		}
	}
	return r0
}

// Routable_RoutingTable_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RoutingTable'
type Routable_RoutingTable_Call struct {
	*mock.Call
}

// RoutingTable is a helper method to define mock.On call
func (_e *Routable_Expecter) RoutingTable() *Routable_RoutingTable_Call {
	return &Routable_RoutingTable_Call{Call: _e.mock.On("RoutingTable")}
}

func (_c *Routable_RoutingTable_Call) Run(run func()) *Routable_RoutingTable_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Routable_RoutingTable_Call) Return(routingTable *kbucket.RoutingTable) *Routable_RoutingTable_Call {
	_c.Call.Return(routingTable)
	return _c
}

func (_c *Routable_RoutingTable_Call) RunAndReturn(run func() *kbucket.RoutingTable) *Routable_RoutingTable_Call {
	_c.Call.Return(run)
	return _c
}

// SetRouting provides a mock function for the type Routable
func (_mock *Routable) SetRouting(r routing.Routing) error {
	ret := _mock.Called(r)

	if len(ret) == 0 {
		panic("no return value specified for SetRouting")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(routing.Routing) error); ok {
		r0 = returnFunc(r)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Routable_SetRouting_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetRouting'
type Routable_SetRouting_Call struct {
	*mock.Call
}

// SetRouting is a helper method to define mock.On call
//   - r routing.Routing
func (_e *Routable_Expecter) SetRouting(r interface{}) *Routable_SetRouting_Call {
	return &Routable_SetRouting_Call{Call: _e.mock.On("SetRouting", r)}
}

func (_c *Routable_SetRouting_Call) Run(run func(r routing.Routing)) *Routable_SetRouting_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 routing.Routing
		if args[0] != nil {
			arg0 = args[0].(routing.Routing)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Routable_SetRouting_Call) Return(err error) *Routable_SetRouting_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Routable_SetRouting_Call) RunAndReturn(run func(r routing.Routing) error) *Routable_SetRouting_Call {
	_c.Call.Return(run)
	return _c
}

// NewUnicastManagement creates a new instance of UnicastManagement. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewUnicastManagement(t interface {
	mock.TestingT
	Cleanup(func())
}) *UnicastManagement {
	mock := &UnicastManagement{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// UnicastManagement is an autogenerated mock type for the UnicastManagement type
type UnicastManagement struct {
	mock.Mock
}

type UnicastManagement_Expecter struct {
	mock *mock.Mock
}

func (_m *UnicastManagement) EXPECT() *UnicastManagement_Expecter {
	return &UnicastManagement_Expecter{mock: &_m.Mock}
}

// OpenAndWriteOnStream provides a mock function for the type UnicastManagement
func (_mock *UnicastManagement) OpenAndWriteOnStream(ctx context.Context, peerID peer.ID, protectionTag string, writingLogic func(stream network.Stream) error) error {
	ret := _mock.Called(ctx, peerID, protectionTag, writingLogic)

	if len(ret) == 0 {
		panic("no return value specified for OpenAndWriteOnStream")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, peer.ID, string, func(stream network.Stream) error) error); ok {
		r0 = returnFunc(ctx, peerID, protectionTag, writingLogic)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// UnicastManagement_OpenAndWriteOnStream_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OpenAndWriteOnStream'
type UnicastManagement_OpenAndWriteOnStream_Call struct {
	*mock.Call
}

// OpenAndWriteOnStream is a helper method to define mock.On call
//   - ctx context.Context
//   - peerID peer.ID
//   - protectionTag string
//   - writingLogic func(stream network.Stream) error
func (_e *UnicastManagement_Expecter) OpenAndWriteOnStream(ctx interface{}, peerID interface{}, protectionTag interface{}, writingLogic interface{}) *UnicastManagement_OpenAndWriteOnStream_Call {
	return &UnicastManagement_OpenAndWriteOnStream_Call{Call: _e.mock.On("OpenAndWriteOnStream", ctx, peerID, protectionTag, writingLogic)}
}

func (_c *UnicastManagement_OpenAndWriteOnStream_Call) Run(run func(ctx context.Context, peerID peer.ID, protectionTag string, writingLogic func(stream network.Stream) error)) *UnicastManagement_OpenAndWriteOnStream_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 peer.ID
		if args[1] != nil {
			arg1 = args[1].(peer.ID)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 func(stream network.Stream) error
		if args[3] != nil {
			arg3 = args[3].(func(stream network.Stream) error)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *UnicastManagement_OpenAndWriteOnStream_Call) Return(err error) *UnicastManagement_OpenAndWriteOnStream_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *UnicastManagement_OpenAndWriteOnStream_Call) RunAndReturn(run func(ctx context.Context, peerID peer.ID, protectionTag string, writingLogic func(stream network.Stream) error) error) *UnicastManagement_OpenAndWriteOnStream_Call {
	_c.Call.Return(run)
	return _c
}

// WithDefaultUnicastProtocol provides a mock function for the type UnicastManagement
func (_mock *UnicastManagement) WithDefaultUnicastProtocol(defaultHandler network.StreamHandler, preferred []protocols.ProtocolName) error {
	ret := _mock.Called(defaultHandler, preferred)

	if len(ret) == 0 {
		panic("no return value specified for WithDefaultUnicastProtocol")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(network.StreamHandler, []protocols.ProtocolName) error); ok {
		r0 = returnFunc(defaultHandler, preferred)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// UnicastManagement_WithDefaultUnicastProtocol_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithDefaultUnicastProtocol'
type UnicastManagement_WithDefaultUnicastProtocol_Call struct {
	*mock.Call
}

// WithDefaultUnicastProtocol is a helper method to define mock.On call
//   - defaultHandler network.StreamHandler
//   - preferred []protocols.ProtocolName
func (_e *UnicastManagement_Expecter) WithDefaultUnicastProtocol(defaultHandler interface{}, preferred interface{}) *UnicastManagement_WithDefaultUnicastProtocol_Call {
	return &UnicastManagement_WithDefaultUnicastProtocol_Call{Call: _e.mock.On("WithDefaultUnicastProtocol", defaultHandler, preferred)}
}

func (_c *UnicastManagement_WithDefaultUnicastProtocol_Call) Run(run func(defaultHandler network.StreamHandler, preferred []protocols.ProtocolName)) *UnicastManagement_WithDefaultUnicastProtocol_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 network.StreamHandler
		if args[0] != nil {
			arg0 = args[0].(network.StreamHandler)
		}
		var arg1 []protocols.ProtocolName
		if args[1] != nil {
			arg1 = args[1].([]protocols.ProtocolName)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *UnicastManagement_WithDefaultUnicastProtocol_Call) Return(err error) *UnicastManagement_WithDefaultUnicastProtocol_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *UnicastManagement_WithDefaultUnicastProtocol_Call) RunAndReturn(run func(defaultHandler network.StreamHandler, preferred []protocols.ProtocolName) error) *UnicastManagement_WithDefaultUnicastProtocol_Call {
	_c.Call.Return(run)
	return _c
}

// NewPubSub creates a new instance of PubSub. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewPubSub(t interface {
	mock.TestingT
	Cleanup(func())
}) *PubSub {
	mock := &PubSub{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// PubSub is an autogenerated mock type for the PubSub type
type PubSub struct {
	mock.Mock
}

type PubSub_Expecter struct {
	mock *mock.Mock
}

func (_m *PubSub) EXPECT() *PubSub_Expecter {
	return &PubSub_Expecter{mock: &_m.Mock}
}

// GetLocalMeshPeers provides a mock function for the type PubSub
func (_mock *PubSub) GetLocalMeshPeers(topic channels.Topic) []peer.ID {
	ret := _mock.Called(topic)

	if len(ret) == 0 {
		panic("no return value specified for GetLocalMeshPeers")
	}

	var r0 []peer.ID
	if returnFunc, ok := ret.Get(0).(func(channels.Topic) []peer.ID); ok {
		r0 = returnFunc(topic)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]peer.ID)
		}
	}
	return r0
}

// PubSub_GetLocalMeshPeers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLocalMeshPeers'
type PubSub_GetLocalMeshPeers_Call struct {
	*mock.Call
}

// GetLocalMeshPeers is a helper method to define mock.On call
//   - topic channels.Topic
func (_e *PubSub_Expecter) GetLocalMeshPeers(topic interface{}) *PubSub_GetLocalMeshPeers_Call {
	return &PubSub_GetLocalMeshPeers_Call{Call: _e.mock.On("GetLocalMeshPeers", topic)}
}

func (_c *PubSub_GetLocalMeshPeers_Call) Run(run func(topic channels.Topic)) *PubSub_GetLocalMeshPeers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 channels.Topic
		if args[0] != nil {
			arg0 = args[0].(channels.Topic)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PubSub_GetLocalMeshPeers_Call) Return(iDs []peer.ID) *PubSub_GetLocalMeshPeers_Call {
	_c.Call.Return(iDs)
	return _c
}

func (_c *PubSub_GetLocalMeshPeers_Call) RunAndReturn(run func(topic channels.Topic) []peer.ID) *PubSub_GetLocalMeshPeers_Call {
	_c.Call.Return(run)
	return _c
}

// Publish provides a mock function for the type PubSub
func (_mock *PubSub) Publish(ctx context.Context, messageScope network0.OutgoingMessageScope) error {
	ret := _mock.Called(ctx, messageScope)

	if len(ret) == 0 {
		panic("no return value specified for Publish")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, network0.OutgoingMessageScope) error); ok {
		r0 = returnFunc(ctx, messageScope)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// PubSub_Publish_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Publish'
type PubSub_Publish_Call struct {
	*mock.Call
}

// Publish is a helper method to define mock.On call
//   - ctx context.Context
//   - messageScope network0.OutgoingMessageScope
func (_e *PubSub_Expecter) Publish(ctx interface{}, messageScope interface{}) *PubSub_Publish_Call {
	return &PubSub_Publish_Call{Call: _e.mock.On("Publish", ctx, messageScope)}
}

func (_c *PubSub_Publish_Call) Run(run func(ctx context.Context, messageScope network0.OutgoingMessageScope)) *PubSub_Publish_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 network0.OutgoingMessageScope
		if args[1] != nil {
			arg1 = args[1].(network0.OutgoingMessageScope)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *PubSub_Publish_Call) Return(err error) *PubSub_Publish_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *PubSub_Publish_Call) RunAndReturn(run func(ctx context.Context, messageScope network0.OutgoingMessageScope) error) *PubSub_Publish_Call {
	_c.Call.Return(run)
	return _c
}

// SetPubSub provides a mock function for the type PubSub
func (_mock *PubSub) SetPubSub(ps p2p.PubSubAdapter) {
	_mock.Called(ps)
	return
}

// PubSub_SetPubSub_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetPubSub'
type PubSub_SetPubSub_Call struct {
	*mock.Call
}

// SetPubSub is a helper method to define mock.On call
//   - ps p2p.PubSubAdapter
func (_e *PubSub_Expecter) SetPubSub(ps interface{}) *PubSub_SetPubSub_Call {
	return &PubSub_SetPubSub_Call{Call: _e.mock.On("SetPubSub", ps)}
}

func (_c *PubSub_SetPubSub_Call) Run(run func(ps p2p.PubSubAdapter)) *PubSub_SetPubSub_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 p2p.PubSubAdapter
		if args[0] != nil {
			arg0 = args[0].(p2p.PubSubAdapter)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PubSub_SetPubSub_Call) Return() *PubSub_SetPubSub_Call {
	_c.Call.Return()
	return _c
}

func (_c *PubSub_SetPubSub_Call) RunAndReturn(run func(ps p2p.PubSubAdapter)) *PubSub_SetPubSub_Call {
	_c.Run(run)
	return _c
}

// Subscribe provides a mock function for the type PubSub
func (_mock *PubSub) Subscribe(topic channels.Topic, topicValidator p2p.TopicValidatorFunc) (p2p.Subscription, error) {
	ret := _mock.Called(topic, topicValidator)

	if len(ret) == 0 {
		panic("no return value specified for Subscribe")
	}

	var r0 p2p.Subscription
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(channels.Topic, p2p.TopicValidatorFunc) (p2p.Subscription, error)); ok {
		return returnFunc(topic, topicValidator)
	}
	if returnFunc, ok := ret.Get(0).(func(channels.Topic, p2p.TopicValidatorFunc) p2p.Subscription); ok {
		r0 = returnFunc(topic, topicValidator)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(p2p.Subscription)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(channels.Topic, p2p.TopicValidatorFunc) error); ok {
		r1 = returnFunc(topic, topicValidator)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// PubSub_Subscribe_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Subscribe'
type PubSub_Subscribe_Call struct {
	*mock.Call
}

// Subscribe is a helper method to define mock.On call
//   - topic channels.Topic
//   - topicValidator p2p.TopicValidatorFunc
func (_e *PubSub_Expecter) Subscribe(topic interface{}, topicValidator interface{}) *PubSub_Subscribe_Call {
	return &PubSub_Subscribe_Call{Call: _e.mock.On("Subscribe", topic, topicValidator)}
}

func (_c *PubSub_Subscribe_Call) Run(run func(topic channels.Topic, topicValidator p2p.TopicValidatorFunc)) *PubSub_Subscribe_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 channels.Topic
		if args[0] != nil {
			arg0 = args[0].(channels.Topic)
		}
		var arg1 p2p.TopicValidatorFunc
		if args[1] != nil {
			arg1 = args[1].(p2p.TopicValidatorFunc)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *PubSub_Subscribe_Call) Return(subscription p2p.Subscription, err error) *PubSub_Subscribe_Call {
	_c.Call.Return(subscription, err)
	return _c
}

func (_c *PubSub_Subscribe_Call) RunAndReturn(run func(topic channels.Topic, topicValidator p2p.TopicValidatorFunc) (p2p.Subscription, error)) *PubSub_Subscribe_Call {
	_c.Call.Return(run)
	return _c
}

// Unsubscribe provides a mock function for the type PubSub
func (_mock *PubSub) Unsubscribe(topic channels.Topic) error {
	ret := _mock.Called(topic)

	if len(ret) == 0 {
		panic("no return value specified for Unsubscribe")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(channels.Topic) error); ok {
		r0 = returnFunc(topic)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// PubSub_Unsubscribe_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Unsubscribe'
type PubSub_Unsubscribe_Call struct {
	*mock.Call
}

// Unsubscribe is a helper method to define mock.On call
//   - topic channels.Topic
func (_e *PubSub_Expecter) Unsubscribe(topic interface{}) *PubSub_Unsubscribe_Call {
	return &PubSub_Unsubscribe_Call{Call: _e.mock.On("Unsubscribe", topic)}
}

func (_c *PubSub_Unsubscribe_Call) Run(run func(topic channels.Topic)) *PubSub_Unsubscribe_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 channels.Topic
		if args[0] != nil {
			arg0 = args[0].(channels.Topic)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PubSub_Unsubscribe_Call) Return(err error) *PubSub_Unsubscribe_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *PubSub_Unsubscribe_Call) RunAndReturn(run func(topic channels.Topic) error) *PubSub_Unsubscribe_Call {
	_c.Call.Return(run)
	return _c
}

// NewLibP2PNode creates a new instance of LibP2PNode. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewLibP2PNode(t interface {
	mock.TestingT
	Cleanup(func())
}) *LibP2PNode {
	mock := &LibP2PNode{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// LibP2PNode is an autogenerated mock type for the LibP2PNode type
type LibP2PNode struct {
	mock.Mock
}

type LibP2PNode_Expecter struct {
	mock *mock.Mock
}

func (_m *LibP2PNode) EXPECT() *LibP2PNode_Expecter {
	return &LibP2PNode_Expecter{mock: &_m.Mock}
}

// ActiveClustersChanged provides a mock function for the type LibP2PNode
func (_mock *LibP2PNode) ActiveClustersChanged(chainIDList flow.ChainIDList) {
	_mock.Called(chainIDList)
	return
}

// LibP2PNode_ActiveClustersChanged_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ActiveClustersChanged'
type LibP2PNode_ActiveClustersChanged_Call struct {
	*mock.Call
}

// ActiveClustersChanged is a helper method to define mock.On call
//   - chainIDList flow.ChainIDList
func (_e *LibP2PNode_Expecter) ActiveClustersChanged(chainIDList interface{}) *LibP2PNode_ActiveClustersChanged_Call {
	return &LibP2PNode_ActiveClustersChanged_Call{Call: _e.mock.On("ActiveClustersChanged", chainIDList)}
}

func (_c *LibP2PNode_ActiveClustersChanged_Call) Run(run func(chainIDList flow.ChainIDList)) *LibP2PNode_ActiveClustersChanged_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.ChainIDList
		if args[0] != nil {
			arg0 = args[0].(flow.ChainIDList)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *LibP2PNode_ActiveClustersChanged_Call) Return() *LibP2PNode_ActiveClustersChanged_Call {
	_c.Call.Return()
	return _c
}

func (_c *LibP2PNode_ActiveClustersChanged_Call) RunAndReturn(run func(chainIDList flow.ChainIDList)) *LibP2PNode_ActiveClustersChanged_Call {
	_c.Run(run)
	return _c
}

// ConnectToPeer provides a mock function for the type LibP2PNode
func (_mock *LibP2PNode) ConnectToPeer(ctx context.Context, peerInfo peer.AddrInfo) error {
	ret := _mock.Called(ctx, peerInfo)

	if len(ret) == 0 {
		panic("no return value specified for ConnectToPeer")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, peer.AddrInfo) error); ok {
		r0 = returnFunc(ctx, peerInfo)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// LibP2PNode_ConnectToPeer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConnectToPeer'
type LibP2PNode_ConnectToPeer_Call struct {
	*mock.Call
}

// ConnectToPeer is a helper method to define mock.On call
//   - ctx context.Context
//   - peerInfo peer.AddrInfo
func (_e *LibP2PNode_Expecter) ConnectToPeer(ctx interface{}, peerInfo interface{}) *LibP2PNode_ConnectToPeer_Call {
	return &LibP2PNode_ConnectToPeer_Call{Call: _e.mock.On("ConnectToPeer", ctx, peerInfo)}
}

func (_c *LibP2PNode_ConnectToPeer_Call) Run(run func(ctx context.Context, peerInfo peer.AddrInfo)) *LibP2PNode_ConnectToPeer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 peer.AddrInfo
		if args[1] != nil {
			arg1 = args[1].(peer.AddrInfo)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *LibP2PNode_ConnectToPeer_Call) Return(err error) *LibP2PNode_ConnectToPeer_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *LibP2PNode_ConnectToPeer_Call) RunAndReturn(run func(ctx context.Context, peerInfo peer.AddrInfo) error) *LibP2PNode_ConnectToPeer_Call {
	_c.Call.Return(run)
	return _c
}

// Done provides a mock function for the type LibP2PNode
func (_mock *LibP2PNode) Done() <-chan struct{} {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Done")
	}

	var r0 <-chan struct{}
	if returnFunc, ok := ret.Get(0).(func() <-chan struct{}); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan struct{})
		}
	}
	return r0
}

// LibP2PNode_Done_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Done'
type LibP2PNode_Done_Call struct {
	*mock.Call
}

// Done is a helper method to define mock.On call
func (_e *LibP2PNode_Expecter) Done() *LibP2PNode_Done_Call {
	return &LibP2PNode_Done_Call{Call: _e.mock.On("Done")}
}

func (_c *LibP2PNode_Done_Call) Run(run func()) *LibP2PNode_Done_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *LibP2PNode_Done_Call) Return(valCh <-chan struct{}) *LibP2PNode_Done_Call {
	_c.Call.Return(valCh)
	return _c
}

func (_c *LibP2PNode_Done_Call) RunAndReturn(run func() <-chan struct{}) *LibP2PNode_Done_Call {
	_c.Call.Return(run)
	return _c
}

// GetIPPort provides a mock function for the type LibP2PNode
func (_mock *LibP2PNode) GetIPPort() (string, string, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetIPPort")
	}

	var r0 string
	var r1 string
	var r2 error
	if returnFunc, ok := ret.Get(0).(func() (string, string, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() string); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func() string); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Get(1).(string)
	}
	if returnFunc, ok := ret.Get(2).(func() error); ok {
		r2 = returnFunc()
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// LibP2PNode_GetIPPort_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetIPPort'
type LibP2PNode_GetIPPort_Call struct {
	*mock.Call
}

// GetIPPort is a helper method to define mock.On call
func (_e *LibP2PNode_Expecter) GetIPPort() *LibP2PNode_GetIPPort_Call {
	return &LibP2PNode_GetIPPort_Call{Call: _e.mock.On("GetIPPort")}
}

func (_c *LibP2PNode_GetIPPort_Call) Run(run func()) *LibP2PNode_GetIPPort_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *LibP2PNode_GetIPPort_Call) Return(s string, s1 string, err error) *LibP2PNode_GetIPPort_Call {
	_c.Call.Return(s, s1, err)
	return _c
}

func (_c *LibP2PNode_GetIPPort_Call) RunAndReturn(run func() (string, string, error)) *LibP2PNode_GetIPPort_Call {
	_c.Call.Return(run)
	return _c
}

// GetLocalMeshPeers provides a mock function for the type LibP2PNode
func (_mock *LibP2PNode) GetLocalMeshPeers(topic channels.Topic) []peer.ID {
	ret := _mock.Called(topic)

	if len(ret) == 0 {
		panic("no return value specified for GetLocalMeshPeers")
	}

	var r0 []peer.ID
	if returnFunc, ok := ret.Get(0).(func(channels.Topic) []peer.ID); ok {
		r0 = returnFunc(topic)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]peer.ID)
		}
	}
	return r0
}

// LibP2PNode_GetLocalMeshPeers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLocalMeshPeers'
type LibP2PNode_GetLocalMeshPeers_Call struct {
	*mock.Call
}

// GetLocalMeshPeers is a helper method to define mock.On call
//   - topic channels.Topic
func (_e *LibP2PNode_Expecter) GetLocalMeshPeers(topic interface{}) *LibP2PNode_GetLocalMeshPeers_Call {
	return &LibP2PNode_GetLocalMeshPeers_Call{Call: _e.mock.On("GetLocalMeshPeers", topic)}
}

func (_c *LibP2PNode_GetLocalMeshPeers_Call) Run(run func(topic channels.Topic)) *LibP2PNode_GetLocalMeshPeers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 channels.Topic
		if args[0] != nil {
			arg0 = args[0].(channels.Topic)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *LibP2PNode_GetLocalMeshPeers_Call) Return(iDs []peer.ID) *LibP2PNode_GetLocalMeshPeers_Call {
	_c.Call.Return(iDs)
	return _c
}

func (_c *LibP2PNode_GetLocalMeshPeers_Call) RunAndReturn(run func(topic channels.Topic) []peer.ID) *LibP2PNode_GetLocalMeshPeers_Call {
	_c.Call.Return(run)
	return _c
}

// GetPeersForProtocol provides a mock function for the type LibP2PNode
func (_mock *LibP2PNode) GetPeersForProtocol(pid protocol.ID) peer.IDSlice {
	ret := _mock.Called(pid)

	if len(ret) == 0 {
		panic("no return value specified for GetPeersForProtocol")
	}

	var r0 peer.IDSlice
	if returnFunc, ok := ret.Get(0).(func(protocol.ID) peer.IDSlice); ok {
		r0 = returnFunc(pid)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(peer.IDSlice)
		}
	}
	return r0
}

// LibP2PNode_GetPeersForProtocol_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPeersForProtocol'
type LibP2PNode_GetPeersForProtocol_Call struct {
	*mock.Call
}

// GetPeersForProtocol is a helper method to define mock.On call
//   - pid protocol.ID
func (_e *LibP2PNode_Expecter) GetPeersForProtocol(pid interface{}) *LibP2PNode_GetPeersForProtocol_Call {
	return &LibP2PNode_GetPeersForProtocol_Call{Call: _e.mock.On("GetPeersForProtocol", pid)}
}

func (_c *LibP2PNode_GetPeersForProtocol_Call) Run(run func(pid protocol.ID)) *LibP2PNode_GetPeersForProtocol_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 protocol.ID
		if args[0] != nil {
			arg0 = args[0].(protocol.ID)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *LibP2PNode_GetPeersForProtocol_Call) Return(iDSlice peer.IDSlice) *LibP2PNode_GetPeersForProtocol_Call {
	_c.Call.Return(iDSlice)
	return _c
}

func (_c *LibP2PNode_GetPeersForProtocol_Call) RunAndReturn(run func(pid protocol.ID) peer.IDSlice) *LibP2PNode_GetPeersForProtocol_Call {
	_c.Call.Return(run)
	return _c
}

// HasSubscription provides a mock function for the type LibP2PNode
func (_mock *LibP2PNode) HasSubscription(topic channels.Topic) bool {
	ret := _mock.Called(topic)

	if len(ret) == 0 {
		panic("no return value specified for HasSubscription")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(channels.Topic) bool); ok {
		r0 = returnFunc(topic)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// LibP2PNode_HasSubscription_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HasSubscription'
type LibP2PNode_HasSubscription_Call struct {
	*mock.Call
}

// HasSubscription is a helper method to define mock.On call
//   - topic channels.Topic
func (_e *LibP2PNode_Expecter) HasSubscription(topic interface{}) *LibP2PNode_HasSubscription_Call {
	return &LibP2PNode_HasSubscription_Call{Call: _e.mock.On("HasSubscription", topic)}
}

func (_c *LibP2PNode_HasSubscription_Call) Run(run func(topic channels.Topic)) *LibP2PNode_HasSubscription_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 channels.Topic
		if args[0] != nil {
			arg0 = args[0].(channels.Topic)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *LibP2PNode_HasSubscription_Call) Return(b bool) *LibP2PNode_HasSubscription_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *LibP2PNode_HasSubscription_Call) RunAndReturn(run func(topic channels.Topic) bool) *LibP2PNode_HasSubscription_Call {
	_c.Call.Return(run)
	return _c
}

// Host provides a mock function for the type LibP2PNode
func (_mock *LibP2PNode) Host() host.Host {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Host")
	}

	var r0 host.Host
	if returnFunc, ok := ret.Get(0).(func() host.Host); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(host.Host)
		}
	}
	return r0
}

// LibP2PNode_Host_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Host'
type LibP2PNode_Host_Call struct {
	*mock.Call
}

// Host is a helper method to define mock.On call
func (_e *LibP2PNode_Expecter) Host() *LibP2PNode_Host_Call {
	return &LibP2PNode_Host_Call{Call: _e.mock.On("Host")}
}

func (_c *LibP2PNode_Host_Call) Run(run func()) *LibP2PNode_Host_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *LibP2PNode_Host_Call) Return(host1 host.Host) *LibP2PNode_Host_Call {
	_c.Call.Return(host1)
	return _c
}

func (_c *LibP2PNode_Host_Call) RunAndReturn(run func() host.Host) *LibP2PNode_Host_Call {
	_c.Call.Return(run)
	return _c
}

// ID provides a mock function for the type LibP2PNode
func (_mock *LibP2PNode) ID() peer.ID {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for ID")
	}

	var r0 peer.ID
	if returnFunc, ok := ret.Get(0).(func() peer.ID); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(peer.ID)
	}
	return r0
}

// LibP2PNode_ID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ID'
type LibP2PNode_ID_Call struct {
	*mock.Call
}

// ID is a helper method to define mock.On call
func (_e *LibP2PNode_Expecter) ID() *LibP2PNode_ID_Call {
	return &LibP2PNode_ID_Call{Call: _e.mock.On("ID")}
}

func (_c *LibP2PNode_ID_Call) Run(run func()) *LibP2PNode_ID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *LibP2PNode_ID_Call) Return(iD peer.ID) *LibP2PNode_ID_Call {
	_c.Call.Return(iD)
	return _c
}

func (_c *LibP2PNode_ID_Call) RunAndReturn(run func() peer.ID) *LibP2PNode_ID_Call {
	_c.Call.Return(run)
	return _c
}

// IsConnected provides a mock function for the type LibP2PNode
func (_mock *LibP2PNode) IsConnected(peerID peer.ID) (bool, error) {
	ret := _mock.Called(peerID)

	if len(ret) == 0 {
		panic("no return value specified for IsConnected")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(peer.ID) (bool, error)); ok {
		return returnFunc(peerID)
	}
	if returnFunc, ok := ret.Get(0).(func(peer.ID) bool); ok {
		r0 = returnFunc(peerID)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(peer.ID) error); ok {
		r1 = returnFunc(peerID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// LibP2PNode_IsConnected_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsConnected'
type LibP2PNode_IsConnected_Call struct {
	*mock.Call
}

// IsConnected is a helper method to define mock.On call
//   - peerID peer.ID
func (_e *LibP2PNode_Expecter) IsConnected(peerID interface{}) *LibP2PNode_IsConnected_Call {
	return &LibP2PNode_IsConnected_Call{Call: _e.mock.On("IsConnected", peerID)}
}

func (_c *LibP2PNode_IsConnected_Call) Run(run func(peerID peer.ID)) *LibP2PNode_IsConnected_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 peer.ID
		if args[0] != nil {
			arg0 = args[0].(peer.ID)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *LibP2PNode_IsConnected_Call) Return(b bool, err error) *LibP2PNode_IsConnected_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *LibP2PNode_IsConnected_Call) RunAndReturn(run func(peerID peer.ID) (bool, error)) *LibP2PNode_IsConnected_Call {
	_c.Call.Return(run)
	return _c
}

// IsDisallowListed provides a mock function for the type LibP2PNode
func (_mock *LibP2PNode) IsDisallowListed(peerId peer.ID) ([]network0.DisallowListedCause, bool) {
	ret := _mock.Called(peerId)

	if len(ret) == 0 {
		panic("no return value specified for IsDisallowListed")
	}

	var r0 []network0.DisallowListedCause
	var r1 bool
	if returnFunc, ok := ret.Get(0).(func(peer.ID) ([]network0.DisallowListedCause, bool)); ok {
		return returnFunc(peerId)
	}
	if returnFunc, ok := ret.Get(0).(func(peer.ID) []network0.DisallowListedCause); ok {
		r0 = returnFunc(peerId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]network0.DisallowListedCause)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(peer.ID) bool); ok {
		r1 = returnFunc(peerId)
	} else {
		r1 = ret.Get(1).(bool)
	}
	return r0, r1
}

// LibP2PNode_IsDisallowListed_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsDisallowListed'
type LibP2PNode_IsDisallowListed_Call struct {
	*mock.Call
}

// IsDisallowListed is a helper method to define mock.On call
//   - peerId peer.ID
func (_e *LibP2PNode_Expecter) IsDisallowListed(peerId interface{}) *LibP2PNode_IsDisallowListed_Call {
	return &LibP2PNode_IsDisallowListed_Call{Call: _e.mock.On("IsDisallowListed", peerId)}
}

func (_c *LibP2PNode_IsDisallowListed_Call) Run(run func(peerId peer.ID)) *LibP2PNode_IsDisallowListed_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 peer.ID
		if args[0] != nil {
			arg0 = args[0].(peer.ID)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *LibP2PNode_IsDisallowListed_Call) Return(disallowListedCauses []network0.DisallowListedCause, b bool) *LibP2PNode_IsDisallowListed_Call {
	_c.Call.Return(disallowListedCauses, b)
	return _c
}

func (_c *LibP2PNode_IsDisallowListed_Call) RunAndReturn(run func(peerId peer.ID) ([]network0.DisallowListedCause, bool)) *LibP2PNode_IsDisallowListed_Call {
	_c.Call.Return(run)
	return _c
}

// ListPeers provides a mock function for the type LibP2PNode
func (_mock *LibP2PNode) ListPeers(topic string) []peer.ID {
	ret := _mock.Called(topic)

	if len(ret) == 0 {
		panic("no return value specified for ListPeers")
	}

	var r0 []peer.ID
	if returnFunc, ok := ret.Get(0).(func(string) []peer.ID); ok {
		r0 = returnFunc(topic)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]peer.ID)
		}
	}
	return r0
}

// LibP2PNode_ListPeers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListPeers'
type LibP2PNode_ListPeers_Call struct {
	*mock.Call
}

// ListPeers is a helper method to define mock.On call
//   - topic string
func (_e *LibP2PNode_Expecter) ListPeers(topic interface{}) *LibP2PNode_ListPeers_Call {
	return &LibP2PNode_ListPeers_Call{Call: _e.mock.On("ListPeers", topic)}
}

func (_c *LibP2PNode_ListPeers_Call) Run(run func(topic string)) *LibP2PNode_ListPeers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *LibP2PNode_ListPeers_Call) Return(iDs []peer.ID) *LibP2PNode_ListPeers_Call {
	_c.Call.Return(iDs)
	return _c
}

func (_c *LibP2PNode_ListPeers_Call) RunAndReturn(run func(topic string) []peer.ID) *LibP2PNode_ListPeers_Call {
	_c.Call.Return(run)
	return _c
}

// OnAllowListNotification provides a mock function for the type LibP2PNode
func (_mock *LibP2PNode) OnAllowListNotification(id peer.ID, cause network0.DisallowListedCause) {
	_mock.Called(id, cause)
	return
}

// LibP2PNode_OnAllowListNotification_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnAllowListNotification'
type LibP2PNode_OnAllowListNotification_Call struct {
	*mock.Call
}

// OnAllowListNotification is a helper method to define mock.On call
//   - id peer.ID
//   - cause network0.DisallowListedCause
func (_e *LibP2PNode_Expecter) OnAllowListNotification(id interface{}, cause interface{}) *LibP2PNode_OnAllowListNotification_Call {
	return &LibP2PNode_OnAllowListNotification_Call{Call: _e.mock.On("OnAllowListNotification", id, cause)}
}

func (_c *LibP2PNode_OnAllowListNotification_Call) Run(run func(id peer.ID, cause network0.DisallowListedCause)) *LibP2PNode_OnAllowListNotification_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 peer.ID
		if args[0] != nil {
			arg0 = args[0].(peer.ID)
		}
		var arg1 network0.DisallowListedCause
		if args[1] != nil {
			arg1 = args[1].(network0.DisallowListedCause)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *LibP2PNode_OnAllowListNotification_Call) Return() *LibP2PNode_OnAllowListNotification_Call {
	_c.Call.Return()
	return _c
}

func (_c *LibP2PNode_OnAllowListNotification_Call) RunAndReturn(run func(id peer.ID, cause network0.DisallowListedCause)) *LibP2PNode_OnAllowListNotification_Call {
	_c.Run(run)
	return _c
}

// OnDisallowListNotification provides a mock function for the type LibP2PNode
func (_mock *LibP2PNode) OnDisallowListNotification(id peer.ID, cause network0.DisallowListedCause) {
	_mock.Called(id, cause)
	return
}

// LibP2PNode_OnDisallowListNotification_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnDisallowListNotification'
type LibP2PNode_OnDisallowListNotification_Call struct {
	*mock.Call
}

// OnDisallowListNotification is a helper method to define mock.On call
//   - id peer.ID
//   - cause network0.DisallowListedCause
func (_e *LibP2PNode_Expecter) OnDisallowListNotification(id interface{}, cause interface{}) *LibP2PNode_OnDisallowListNotification_Call {
	return &LibP2PNode_OnDisallowListNotification_Call{Call: _e.mock.On("OnDisallowListNotification", id, cause)}
}

func (_c *LibP2PNode_OnDisallowListNotification_Call) Run(run func(id peer.ID, cause network0.DisallowListedCause)) *LibP2PNode_OnDisallowListNotification_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 peer.ID
		if args[0] != nil {
			arg0 = args[0].(peer.ID)
		}
		var arg1 network0.DisallowListedCause
		if args[1] != nil {
			arg1 = args[1].(network0.DisallowListedCause)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *LibP2PNode_OnDisallowListNotification_Call) Return() *LibP2PNode_OnDisallowListNotification_Call {
	_c.Call.Return()
	return _c
}

func (_c *LibP2PNode_OnDisallowListNotification_Call) RunAndReturn(run func(id peer.ID, cause network0.DisallowListedCause)) *LibP2PNode_OnDisallowListNotification_Call {
	_c.Run(run)
	return _c
}

// OpenAndWriteOnStream provides a mock function for the type LibP2PNode
func (_mock *LibP2PNode) OpenAndWriteOnStream(ctx context.Context, peerID peer.ID, protectionTag string, writingLogic func(stream network.Stream) error) error {
	ret := _mock.Called(ctx, peerID, protectionTag, writingLogic)

	if len(ret) == 0 {
		panic("no return value specified for OpenAndWriteOnStream")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, peer.ID, string, func(stream network.Stream) error) error); ok {
		r0 = returnFunc(ctx, peerID, protectionTag, writingLogic)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// LibP2PNode_OpenAndWriteOnStream_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OpenAndWriteOnStream'
type LibP2PNode_OpenAndWriteOnStream_Call struct {
	*mock.Call
}

// OpenAndWriteOnStream is a helper method to define mock.On call
//   - ctx context.Context
//   - peerID peer.ID
//   - protectionTag string
//   - writingLogic func(stream network.Stream) error
func (_e *LibP2PNode_Expecter) OpenAndWriteOnStream(ctx interface{}, peerID interface{}, protectionTag interface{}, writingLogic interface{}) *LibP2PNode_OpenAndWriteOnStream_Call {
	return &LibP2PNode_OpenAndWriteOnStream_Call{Call: _e.mock.On("OpenAndWriteOnStream", ctx, peerID, protectionTag, writingLogic)}
}

func (_c *LibP2PNode_OpenAndWriteOnStream_Call) Run(run func(ctx context.Context, peerID peer.ID, protectionTag string, writingLogic func(stream network.Stream) error)) *LibP2PNode_OpenAndWriteOnStream_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 peer.ID
		if args[1] != nil {
			arg1 = args[1].(peer.ID)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 func(stream network.Stream) error
		if args[3] != nil {
			arg3 = args[3].(func(stream network.Stream) error)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *LibP2PNode_OpenAndWriteOnStream_Call) Return(err error) *LibP2PNode_OpenAndWriteOnStream_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *LibP2PNode_OpenAndWriteOnStream_Call) RunAndReturn(run func(ctx context.Context, peerID peer.ID, protectionTag string, writingLogic func(stream network.Stream) error) error) *LibP2PNode_OpenAndWriteOnStream_Call {
	_c.Call.Return(run)
	return _c
}

// PeerManagerComponent provides a mock function for the type LibP2PNode
func (_mock *LibP2PNode) PeerManagerComponent() component.Component {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for PeerManagerComponent")
	}

	var r0 component.Component
	if returnFunc, ok := ret.Get(0).(func() component.Component); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(component.Component)
		}
	}
	return r0
}

// LibP2PNode_PeerManagerComponent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PeerManagerComponent'
type LibP2PNode_PeerManagerComponent_Call struct {
	*mock.Call
}

// PeerManagerComponent is a helper method to define mock.On call
func (_e *LibP2PNode_Expecter) PeerManagerComponent() *LibP2PNode_PeerManagerComponent_Call {
	return &LibP2PNode_PeerManagerComponent_Call{Call: _e.mock.On("PeerManagerComponent")}
}

func (_c *LibP2PNode_PeerManagerComponent_Call) Run(run func()) *LibP2PNode_PeerManagerComponent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *LibP2PNode_PeerManagerComponent_Call) Return(component1 component.Component) *LibP2PNode_PeerManagerComponent_Call {
	_c.Call.Return(component1)
	return _c
}

func (_c *LibP2PNode_PeerManagerComponent_Call) RunAndReturn(run func() component.Component) *LibP2PNode_PeerManagerComponent_Call {
	_c.Call.Return(run)
	return _c
}

// PeerScoreExposer provides a mock function for the type LibP2PNode
func (_mock *LibP2PNode) PeerScoreExposer() p2p.PeerScoreExposer {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for PeerScoreExposer")
	}

	var r0 p2p.PeerScoreExposer
	if returnFunc, ok := ret.Get(0).(func() p2p.PeerScoreExposer); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(p2p.PeerScoreExposer)
		}
	}
	return r0
}

// LibP2PNode_PeerScoreExposer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PeerScoreExposer'
type LibP2PNode_PeerScoreExposer_Call struct {
	*mock.Call
}

// PeerScoreExposer is a helper method to define mock.On call
func (_e *LibP2PNode_Expecter) PeerScoreExposer() *LibP2PNode_PeerScoreExposer_Call {
	return &LibP2PNode_PeerScoreExposer_Call{Call: _e.mock.On("PeerScoreExposer")}
}

func (_c *LibP2PNode_PeerScoreExposer_Call) Run(run func()) *LibP2PNode_PeerScoreExposer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *LibP2PNode_PeerScoreExposer_Call) Return(peerScoreExposer p2p.PeerScoreExposer) *LibP2PNode_PeerScoreExposer_Call {
	_c.Call.Return(peerScoreExposer)
	return _c
}

func (_c *LibP2PNode_PeerScoreExposer_Call) RunAndReturn(run func() p2p.PeerScoreExposer) *LibP2PNode_PeerScoreExposer_Call {
	_c.Call.Return(run)
	return _c
}

// Publish provides a mock function for the type LibP2PNode
func (_mock *LibP2PNode) Publish(ctx context.Context, messageScope network0.OutgoingMessageScope) error {
	ret := _mock.Called(ctx, messageScope)

	if len(ret) == 0 {
		panic("no return value specified for Publish")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, network0.OutgoingMessageScope) error); ok {
		r0 = returnFunc(ctx, messageScope)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// LibP2PNode_Publish_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Publish'
type LibP2PNode_Publish_Call struct {
	*mock.Call
}

// Publish is a helper method to define mock.On call
//   - ctx context.Context
//   - messageScope network0.OutgoingMessageScope
func (_e *LibP2PNode_Expecter) Publish(ctx interface{}, messageScope interface{}) *LibP2PNode_Publish_Call {
	return &LibP2PNode_Publish_Call{Call: _e.mock.On("Publish", ctx, messageScope)}
}

func (_c *LibP2PNode_Publish_Call) Run(run func(ctx context.Context, messageScope network0.OutgoingMessageScope)) *LibP2PNode_Publish_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 network0.OutgoingMessageScope
		if args[1] != nil {
			arg1 = args[1].(network0.OutgoingMessageScope)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *LibP2PNode_Publish_Call) Return(err error) *LibP2PNode_Publish_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *LibP2PNode_Publish_Call) RunAndReturn(run func(ctx context.Context, messageScope network0.OutgoingMessageScope) error) *LibP2PNode_Publish_Call {
	_c.Call.Return(run)
	return _c
}

// Ready provides a mock function for the type LibP2PNode
func (_mock *LibP2PNode) Ready() <-chan struct{} {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Ready")
	}

	var r0 <-chan struct{}
	if returnFunc, ok := ret.Get(0).(func() <-chan struct{}); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan struct{})
		}
	}
	return r0
}

// LibP2PNode_Ready_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Ready'
type LibP2PNode_Ready_Call struct {
	*mock.Call
}

// Ready is a helper method to define mock.On call
func (_e *LibP2PNode_Expecter) Ready() *LibP2PNode_Ready_Call {
	return &LibP2PNode_Ready_Call{Call: _e.mock.On("Ready")}
}

func (_c *LibP2PNode_Ready_Call) Run(run func()) *LibP2PNode_Ready_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *LibP2PNode_Ready_Call) Return(valCh <-chan struct{}) *LibP2PNode_Ready_Call {
	_c.Call.Return(valCh)
	return _c
}

func (_c *LibP2PNode_Ready_Call) RunAndReturn(run func() <-chan struct{}) *LibP2PNode_Ready_Call {
	_c.Call.Return(run)
	return _c
}

// RemovePeer provides a mock function for the type LibP2PNode
func (_mock *LibP2PNode) RemovePeer(peerID peer.ID) error {
	ret := _mock.Called(peerID)

	if len(ret) == 0 {
		panic("no return value specified for RemovePeer")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(peer.ID) error); ok {
		r0 = returnFunc(peerID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// LibP2PNode_RemovePeer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemovePeer'
type LibP2PNode_RemovePeer_Call struct {
	*mock.Call
}

// RemovePeer is a helper method to define mock.On call
//   - peerID peer.ID
func (_e *LibP2PNode_Expecter) RemovePeer(peerID interface{}) *LibP2PNode_RemovePeer_Call {
	return &LibP2PNode_RemovePeer_Call{Call: _e.mock.On("RemovePeer", peerID)}
}

func (_c *LibP2PNode_RemovePeer_Call) Run(run func(peerID peer.ID)) *LibP2PNode_RemovePeer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 peer.ID
		if args[0] != nil {
			arg0 = args[0].(peer.ID)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *LibP2PNode_RemovePeer_Call) Return(err error) *LibP2PNode_RemovePeer_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *LibP2PNode_RemovePeer_Call) RunAndReturn(run func(peerID peer.ID) error) *LibP2PNode_RemovePeer_Call {
	_c.Call.Return(run)
	return _c
}

// RequestPeerUpdate provides a mock function for the type LibP2PNode
func (_mock *LibP2PNode) RequestPeerUpdate() {
	_mock.Called()
	return
}

// LibP2PNode_RequestPeerUpdate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RequestPeerUpdate'
type LibP2PNode_RequestPeerUpdate_Call struct {
	*mock.Call
}

// RequestPeerUpdate is a helper method to define mock.On call
func (_e *LibP2PNode_Expecter) RequestPeerUpdate() *LibP2PNode_RequestPeerUpdate_Call {
	return &LibP2PNode_RequestPeerUpdate_Call{Call: _e.mock.On("RequestPeerUpdate")}
}

func (_c *LibP2PNode_RequestPeerUpdate_Call) Run(run func()) *LibP2PNode_RequestPeerUpdate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *LibP2PNode_RequestPeerUpdate_Call) Return() *LibP2PNode_RequestPeerUpdate_Call {
	_c.Call.Return()
	return _c
}

func (_c *LibP2PNode_RequestPeerUpdate_Call) RunAndReturn(run func()) *LibP2PNode_RequestPeerUpdate_Call {
	_c.Run(run)
	return _c
}

// Routing provides a mock function for the type LibP2PNode
func (_mock *LibP2PNode) Routing() routing.Routing {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Routing")
	}

	var r0 routing.Routing
	if returnFunc, ok := ret.Get(0).(func() routing.Routing); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(routing.Routing)
		}
	}
	return r0
}

// LibP2PNode_Routing_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Routing'
type LibP2PNode_Routing_Call struct {
	*mock.Call
}

// Routing is a helper method to define mock.On call
func (_e *LibP2PNode_Expecter) Routing() *LibP2PNode_Routing_Call {
	return &LibP2PNode_Routing_Call{Call: _e.mock.On("Routing")}
}

func (_c *LibP2PNode_Routing_Call) Run(run func()) *LibP2PNode_Routing_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *LibP2PNode_Routing_Call) Return(routing1 routing.Routing) *LibP2PNode_Routing_Call {
	_c.Call.Return(routing1)
	return _c
}

func (_c *LibP2PNode_Routing_Call) RunAndReturn(run func() routing.Routing) *LibP2PNode_Routing_Call {
	_c.Call.Return(run)
	return _c
}

// RoutingTable provides a mock function for the type LibP2PNode
func (_mock *LibP2PNode) RoutingTable() *kbucket.RoutingTable {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for RoutingTable")
	}

	var r0 *kbucket.RoutingTable
	if returnFunc, ok := ret.Get(0).(func() *kbucket.RoutingTable); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kbucket.RoutingTable)
		}
	}
	return r0
}

// LibP2PNode_RoutingTable_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RoutingTable'
type LibP2PNode_RoutingTable_Call struct {
	*mock.Call
}

// RoutingTable is a helper method to define mock.On call
func (_e *LibP2PNode_Expecter) RoutingTable() *LibP2PNode_RoutingTable_Call {
	return &LibP2PNode_RoutingTable_Call{Call: _e.mock.On("RoutingTable")}
}

func (_c *LibP2PNode_RoutingTable_Call) Run(run func()) *LibP2PNode_RoutingTable_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *LibP2PNode_RoutingTable_Call) Return(routingTable *kbucket.RoutingTable) *LibP2PNode_RoutingTable_Call {
	_c.Call.Return(routingTable)
	return _c
}

func (_c *LibP2PNode_RoutingTable_Call) RunAndReturn(run func() *kbucket.RoutingTable) *LibP2PNode_RoutingTable_Call {
	_c.Call.Return(run)
	return _c
}

// SetComponentManager provides a mock function for the type LibP2PNode
func (_mock *LibP2PNode) SetComponentManager(cm *component.ComponentManager) {
	_mock.Called(cm)
	return
}

// LibP2PNode_SetComponentManager_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetComponentManager'
type LibP2PNode_SetComponentManager_Call struct {
	*mock.Call
}

// SetComponentManager is a helper method to define mock.On call
//   - cm *component.ComponentManager
func (_e *LibP2PNode_Expecter) SetComponentManager(cm interface{}) *LibP2PNode_SetComponentManager_Call {
	return &LibP2PNode_SetComponentManager_Call{Call: _e.mock.On("SetComponentManager", cm)}
}

func (_c *LibP2PNode_SetComponentManager_Call) Run(run func(cm *component.ComponentManager)) *LibP2PNode_SetComponentManager_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *component.ComponentManager
		if args[0] != nil {
			arg0 = args[0].(*component.ComponentManager)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *LibP2PNode_SetComponentManager_Call) Return() *LibP2PNode_SetComponentManager_Call {
	_c.Call.Return()
	return _c
}

func (_c *LibP2PNode_SetComponentManager_Call) RunAndReturn(run func(cm *component.ComponentManager)) *LibP2PNode_SetComponentManager_Call {
	_c.Run(run)
	return _c
}

// SetPubSub provides a mock function for the type LibP2PNode
func (_mock *LibP2PNode) SetPubSub(ps p2p.PubSubAdapter) {
	_mock.Called(ps)
	return
}

// LibP2PNode_SetPubSub_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetPubSub'
type LibP2PNode_SetPubSub_Call struct {
	*mock.Call
}

// SetPubSub is a helper method to define mock.On call
//   - ps p2p.PubSubAdapter
func (_e *LibP2PNode_Expecter) SetPubSub(ps interface{}) *LibP2PNode_SetPubSub_Call {
	return &LibP2PNode_SetPubSub_Call{Call: _e.mock.On("SetPubSub", ps)}
}

func (_c *LibP2PNode_SetPubSub_Call) Run(run func(ps p2p.PubSubAdapter)) *LibP2PNode_SetPubSub_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 p2p.PubSubAdapter
		if args[0] != nil {
			arg0 = args[0].(p2p.PubSubAdapter)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *LibP2PNode_SetPubSub_Call) Return() *LibP2PNode_SetPubSub_Call {
	_c.Call.Return()
	return _c
}

func (_c *LibP2PNode_SetPubSub_Call) RunAndReturn(run func(ps p2p.PubSubAdapter)) *LibP2PNode_SetPubSub_Call {
	_c.Run(run)
	return _c
}

// SetRouting provides a mock function for the type LibP2PNode
func (_mock *LibP2PNode) SetRouting(r routing.Routing) error {
	ret := _mock.Called(r)

	if len(ret) == 0 {
		panic("no return value specified for SetRouting")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(routing.Routing) error); ok {
		r0 = returnFunc(r)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// LibP2PNode_SetRouting_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetRouting'
type LibP2PNode_SetRouting_Call struct {
	*mock.Call
}

// SetRouting is a helper method to define mock.On call
//   - r routing.Routing
func (_e *LibP2PNode_Expecter) SetRouting(r interface{}) *LibP2PNode_SetRouting_Call {
	return &LibP2PNode_SetRouting_Call{Call: _e.mock.On("SetRouting", r)}
}

func (_c *LibP2PNode_SetRouting_Call) Run(run func(r routing.Routing)) *LibP2PNode_SetRouting_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 routing.Routing
		if args[0] != nil {
			arg0 = args[0].(routing.Routing)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *LibP2PNode_SetRouting_Call) Return(err error) *LibP2PNode_SetRouting_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *LibP2PNode_SetRouting_Call) RunAndReturn(run func(r routing.Routing) error) *LibP2PNode_SetRouting_Call {
	_c.Call.Return(run)
	return _c
}

// SetUnicastManager provides a mock function for the type LibP2PNode
func (_mock *LibP2PNode) SetUnicastManager(uniMgr p2p.UnicastManager) {
	_mock.Called(uniMgr)
	return
}

// LibP2PNode_SetUnicastManager_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetUnicastManager'
type LibP2PNode_SetUnicastManager_Call struct {
	*mock.Call
}

// SetUnicastManager is a helper method to define mock.On call
//   - uniMgr p2p.UnicastManager
func (_e *LibP2PNode_Expecter) SetUnicastManager(uniMgr interface{}) *LibP2PNode_SetUnicastManager_Call {
	return &LibP2PNode_SetUnicastManager_Call{Call: _e.mock.On("SetUnicastManager", uniMgr)}
}

func (_c *LibP2PNode_SetUnicastManager_Call) Run(run func(uniMgr p2p.UnicastManager)) *LibP2PNode_SetUnicastManager_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 p2p.UnicastManager
		if args[0] != nil {
			arg0 = args[0].(p2p.UnicastManager)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *LibP2PNode_SetUnicastManager_Call) Return() *LibP2PNode_SetUnicastManager_Call {
	_c.Call.Return()
	return _c
}

func (_c *LibP2PNode_SetUnicastManager_Call) RunAndReturn(run func(uniMgr p2p.UnicastManager)) *LibP2PNode_SetUnicastManager_Call {
	_c.Run(run)
	return _c
}

// Start provides a mock function for the type LibP2PNode
func (_mock *LibP2PNode) Start(ctx irrecoverable.SignalerContext) {
	_mock.Called(ctx)
	return
}

// LibP2PNode_Start_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Start'
type LibP2PNode_Start_Call struct {
	*mock.Call
}

// Start is a helper method to define mock.On call
//   - ctx irrecoverable.SignalerContext
func (_e *LibP2PNode_Expecter) Start(ctx interface{}) *LibP2PNode_Start_Call {
	return &LibP2PNode_Start_Call{Call: _e.mock.On("Start", ctx)}
}

func (_c *LibP2PNode_Start_Call) Run(run func(ctx irrecoverable.SignalerContext)) *LibP2PNode_Start_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 irrecoverable.SignalerContext
		if args[0] != nil {
			arg0 = args[0].(irrecoverable.SignalerContext)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *LibP2PNode_Start_Call) Return() *LibP2PNode_Start_Call {
	_c.Call.Return()
	return _c
}

func (_c *LibP2PNode_Start_Call) RunAndReturn(run func(ctx irrecoverable.SignalerContext)) *LibP2PNode_Start_Call {
	_c.Run(run)
	return _c
}

// Stop provides a mock function for the type LibP2PNode
func (_mock *LibP2PNode) Stop() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Stop")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// LibP2PNode_Stop_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Stop'
type LibP2PNode_Stop_Call struct {
	*mock.Call
}

// Stop is a helper method to define mock.On call
func (_e *LibP2PNode_Expecter) Stop() *LibP2PNode_Stop_Call {
	return &LibP2PNode_Stop_Call{Call: _e.mock.On("Stop")}
}

func (_c *LibP2PNode_Stop_Call) Run(run func()) *LibP2PNode_Stop_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *LibP2PNode_Stop_Call) Return(err error) *LibP2PNode_Stop_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *LibP2PNode_Stop_Call) RunAndReturn(run func() error) *LibP2PNode_Stop_Call {
	_c.Call.Return(run)
	return _c
}

// Subscribe provides a mock function for the type LibP2PNode
func (_mock *LibP2PNode) Subscribe(topic channels.Topic, topicValidator p2p.TopicValidatorFunc) (p2p.Subscription, error) {
	ret := _mock.Called(topic, topicValidator)

	if len(ret) == 0 {
		panic("no return value specified for Subscribe")
	}

	var r0 p2p.Subscription
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(channels.Topic, p2p.TopicValidatorFunc) (p2p.Subscription, error)); ok {
		return returnFunc(topic, topicValidator)
	}
	if returnFunc, ok := ret.Get(0).(func(channels.Topic, p2p.TopicValidatorFunc) p2p.Subscription); ok {
		r0 = returnFunc(topic, topicValidator)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(p2p.Subscription)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(channels.Topic, p2p.TopicValidatorFunc) error); ok {
		r1 = returnFunc(topic, topicValidator)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// LibP2PNode_Subscribe_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Subscribe'
type LibP2PNode_Subscribe_Call struct {
	*mock.Call
}

// Subscribe is a helper method to define mock.On call
//   - topic channels.Topic
//   - topicValidator p2p.TopicValidatorFunc
func (_e *LibP2PNode_Expecter) Subscribe(topic interface{}, topicValidator interface{}) *LibP2PNode_Subscribe_Call {
	return &LibP2PNode_Subscribe_Call{Call: _e.mock.On("Subscribe", topic, topicValidator)}
}

func (_c *LibP2PNode_Subscribe_Call) Run(run func(topic channels.Topic, topicValidator p2p.TopicValidatorFunc)) *LibP2PNode_Subscribe_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 channels.Topic
		if args[0] != nil {
			arg0 = args[0].(channels.Topic)
		}
		var arg1 p2p.TopicValidatorFunc
		if args[1] != nil {
			arg1 = args[1].(p2p.TopicValidatorFunc)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *LibP2PNode_Subscribe_Call) Return(subscription p2p.Subscription, err error) *LibP2PNode_Subscribe_Call {
	_c.Call.Return(subscription, err)
	return _c
}

func (_c *LibP2PNode_Subscribe_Call) RunAndReturn(run func(topic channels.Topic, topicValidator p2p.TopicValidatorFunc) (p2p.Subscription, error)) *LibP2PNode_Subscribe_Call {
	_c.Call.Return(run)
	return _c
}

// Unsubscribe provides a mock function for the type LibP2PNode
func (_mock *LibP2PNode) Unsubscribe(topic channels.Topic) error {
	ret := _mock.Called(topic)

	if len(ret) == 0 {
		panic("no return value specified for Unsubscribe")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(channels.Topic) error); ok {
		r0 = returnFunc(topic)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// LibP2PNode_Unsubscribe_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Unsubscribe'
type LibP2PNode_Unsubscribe_Call struct {
	*mock.Call
}

// Unsubscribe is a helper method to define mock.On call
//   - topic channels.Topic
func (_e *LibP2PNode_Expecter) Unsubscribe(topic interface{}) *LibP2PNode_Unsubscribe_Call {
	return &LibP2PNode_Unsubscribe_Call{Call: _e.mock.On("Unsubscribe", topic)}
}

func (_c *LibP2PNode_Unsubscribe_Call) Run(run func(topic channels.Topic)) *LibP2PNode_Unsubscribe_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 channels.Topic
		if args[0] != nil {
			arg0 = args[0].(channels.Topic)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *LibP2PNode_Unsubscribe_Call) Return(err error) *LibP2PNode_Unsubscribe_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *LibP2PNode_Unsubscribe_Call) RunAndReturn(run func(topic channels.Topic) error) *LibP2PNode_Unsubscribe_Call {
	_c.Call.Return(run)
	return _c
}

// WithDefaultUnicastProtocol provides a mock function for the type LibP2PNode
func (_mock *LibP2PNode) WithDefaultUnicastProtocol(defaultHandler network.StreamHandler, preferred []protocols.ProtocolName) error {
	ret := _mock.Called(defaultHandler, preferred)

	if len(ret) == 0 {
		panic("no return value specified for WithDefaultUnicastProtocol")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(network.StreamHandler, []protocols.ProtocolName) error); ok {
		r0 = returnFunc(defaultHandler, preferred)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// LibP2PNode_WithDefaultUnicastProtocol_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithDefaultUnicastProtocol'
type LibP2PNode_WithDefaultUnicastProtocol_Call struct {
	*mock.Call
}

// WithDefaultUnicastProtocol is a helper method to define mock.On call
//   - defaultHandler network.StreamHandler
//   - preferred []protocols.ProtocolName
func (_e *LibP2PNode_Expecter) WithDefaultUnicastProtocol(defaultHandler interface{}, preferred interface{}) *LibP2PNode_WithDefaultUnicastProtocol_Call {
	return &LibP2PNode_WithDefaultUnicastProtocol_Call{Call: _e.mock.On("WithDefaultUnicastProtocol", defaultHandler, preferred)}
}

func (_c *LibP2PNode_WithDefaultUnicastProtocol_Call) Run(run func(defaultHandler network.StreamHandler, preferred []protocols.ProtocolName)) *LibP2PNode_WithDefaultUnicastProtocol_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 network.StreamHandler
		if args[0] != nil {
			arg0 = args[0].(network.StreamHandler)
		}
		var arg1 []protocols.ProtocolName
		if args[1] != nil {
			arg1 = args[1].([]protocols.ProtocolName)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *LibP2PNode_WithDefaultUnicastProtocol_Call) Return(err error) *LibP2PNode_WithDefaultUnicastProtocol_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *LibP2PNode_WithDefaultUnicastProtocol_Call) RunAndReturn(run func(defaultHandler network.StreamHandler, preferred []protocols.ProtocolName) error) *LibP2PNode_WithDefaultUnicastProtocol_Call {
	_c.Call.Return(run)
	return _c
}

// WithPeersProvider provides a mock function for the type LibP2PNode
func (_mock *LibP2PNode) WithPeersProvider(peersProvider p2p.PeersProvider) {
	_mock.Called(peersProvider)
	return
}

// LibP2PNode_WithPeersProvider_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithPeersProvider'
type LibP2PNode_WithPeersProvider_Call struct {
	*mock.Call
}

// WithPeersProvider is a helper method to define mock.On call
//   - peersProvider p2p.PeersProvider
func (_e *LibP2PNode_Expecter) WithPeersProvider(peersProvider interface{}) *LibP2PNode_WithPeersProvider_Call {
	return &LibP2PNode_WithPeersProvider_Call{Call: _e.mock.On("WithPeersProvider", peersProvider)}
}

func (_c *LibP2PNode_WithPeersProvider_Call) Run(run func(peersProvider p2p.PeersProvider)) *LibP2PNode_WithPeersProvider_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 p2p.PeersProvider
		if args[0] != nil {
			arg0 = args[0].(p2p.PeersProvider)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *LibP2PNode_WithPeersProvider_Call) Return() *LibP2PNode_WithPeersProvider_Call {
	_c.Call.Return()
	return _c
}

func (_c *LibP2PNode_WithPeersProvider_Call) RunAndReturn(run func(peersProvider p2p.PeersProvider)) *LibP2PNode_WithPeersProvider_Call {
	_c.Run(run)
	return _c
}

// NewSubscriptions creates a new instance of Subscriptions. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewSubscriptions(t interface {
	mock.TestingT
	Cleanup(func())
}) *Subscriptions {
	mock := &Subscriptions{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Subscriptions is an autogenerated mock type for the Subscriptions type
type Subscriptions struct {
	mock.Mock
}

type Subscriptions_Expecter struct {
	mock *mock.Mock
}

func (_m *Subscriptions) EXPECT() *Subscriptions_Expecter {
	return &Subscriptions_Expecter{mock: &_m.Mock}
}

// HasSubscription provides a mock function for the type Subscriptions
func (_mock *Subscriptions) HasSubscription(topic channels.Topic) bool {
	ret := _mock.Called(topic)

	if len(ret) == 0 {
		panic("no return value specified for HasSubscription")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(channels.Topic) bool); ok {
		r0 = returnFunc(topic)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// Subscriptions_HasSubscription_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HasSubscription'
type Subscriptions_HasSubscription_Call struct {
	*mock.Call
}

// HasSubscription is a helper method to define mock.On call
//   - topic channels.Topic
func (_e *Subscriptions_Expecter) HasSubscription(topic interface{}) *Subscriptions_HasSubscription_Call {
	return &Subscriptions_HasSubscription_Call{Call: _e.mock.On("HasSubscription", topic)}
}

func (_c *Subscriptions_HasSubscription_Call) Run(run func(topic channels.Topic)) *Subscriptions_HasSubscription_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 channels.Topic
		if args[0] != nil {
			arg0 = args[0].(channels.Topic)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Subscriptions_HasSubscription_Call) Return(b bool) *Subscriptions_HasSubscription_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *Subscriptions_HasSubscription_Call) RunAndReturn(run func(topic channels.Topic) bool) *Subscriptions_HasSubscription_Call {
	_c.Call.Return(run)
	return _c
}

// SetUnicastManager provides a mock function for the type Subscriptions
func (_mock *Subscriptions) SetUnicastManager(uniMgr p2p.UnicastManager) {
	_mock.Called(uniMgr)
	return
}

// Subscriptions_SetUnicastManager_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetUnicastManager'
type Subscriptions_SetUnicastManager_Call struct {
	*mock.Call
}

// SetUnicastManager is a helper method to define mock.On call
//   - uniMgr p2p.UnicastManager
func (_e *Subscriptions_Expecter) SetUnicastManager(uniMgr interface{}) *Subscriptions_SetUnicastManager_Call {
	return &Subscriptions_SetUnicastManager_Call{Call: _e.mock.On("SetUnicastManager", uniMgr)}
}

func (_c *Subscriptions_SetUnicastManager_Call) Run(run func(uniMgr p2p.UnicastManager)) *Subscriptions_SetUnicastManager_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 p2p.UnicastManager
		if args[0] != nil {
			arg0 = args[0].(p2p.UnicastManager)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Subscriptions_SetUnicastManager_Call) Return() *Subscriptions_SetUnicastManager_Call {
	_c.Call.Return()
	return _c
}

func (_c *Subscriptions_SetUnicastManager_Call) RunAndReturn(run func(uniMgr p2p.UnicastManager)) *Subscriptions_SetUnicastManager_Call {
	_c.Run(run)
	return _c
}

// NewCollectionClusterChangesConsumer creates a new instance of CollectionClusterChangesConsumer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewCollectionClusterChangesConsumer(t interface {
	mock.TestingT
	Cleanup(func())
}) *CollectionClusterChangesConsumer {
	mock := &CollectionClusterChangesConsumer{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// CollectionClusterChangesConsumer is an autogenerated mock type for the CollectionClusterChangesConsumer type
type CollectionClusterChangesConsumer struct {
	mock.Mock
}

type CollectionClusterChangesConsumer_Expecter struct {
	mock *mock.Mock
}

func (_m *CollectionClusterChangesConsumer) EXPECT() *CollectionClusterChangesConsumer_Expecter {
	return &CollectionClusterChangesConsumer_Expecter{mock: &_m.Mock}
}

// ActiveClustersChanged provides a mock function for the type CollectionClusterChangesConsumer
func (_mock *CollectionClusterChangesConsumer) ActiveClustersChanged(chainIDList flow.ChainIDList) {
	_mock.Called(chainIDList)
	return
}

// CollectionClusterChangesConsumer_ActiveClustersChanged_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ActiveClustersChanged'
type CollectionClusterChangesConsumer_ActiveClustersChanged_Call struct {
	*mock.Call
}

// ActiveClustersChanged is a helper method to define mock.On call
//   - chainIDList flow.ChainIDList
func (_e *CollectionClusterChangesConsumer_Expecter) ActiveClustersChanged(chainIDList interface{}) *CollectionClusterChangesConsumer_ActiveClustersChanged_Call {
	return &CollectionClusterChangesConsumer_ActiveClustersChanged_Call{Call: _e.mock.On("ActiveClustersChanged", chainIDList)}
}

func (_c *CollectionClusterChangesConsumer_ActiveClustersChanged_Call) Run(run func(chainIDList flow.ChainIDList)) *CollectionClusterChangesConsumer_ActiveClustersChanged_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.ChainIDList
		if args[0] != nil {
			arg0 = args[0].(flow.ChainIDList)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *CollectionClusterChangesConsumer_ActiveClustersChanged_Call) Return() *CollectionClusterChangesConsumer_ActiveClustersChanged_Call {
	_c.Call.Return()
	return _c
}

func (_c *CollectionClusterChangesConsumer_ActiveClustersChanged_Call) RunAndReturn(run func(chainIDList flow.ChainIDList)) *CollectionClusterChangesConsumer_ActiveClustersChanged_Call {
	_c.Run(run)
	return _c
}

// NewPeerScore creates a new instance of PeerScore. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewPeerScore(t interface {
	mock.TestingT
	Cleanup(func())
}) *PeerScore {
	mock := &PeerScore{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// PeerScore is an autogenerated mock type for the PeerScore type
type PeerScore struct {
	mock.Mock
}

type PeerScore_Expecter struct {
	mock *mock.Mock
}

func (_m *PeerScore) EXPECT() *PeerScore_Expecter {
	return &PeerScore_Expecter{mock: &_m.Mock}
}

// PeerScoreExposer provides a mock function for the type PeerScore
func (_mock *PeerScore) PeerScoreExposer() p2p.PeerScoreExposer {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for PeerScoreExposer")
	}

	var r0 p2p.PeerScoreExposer
	if returnFunc, ok := ret.Get(0).(func() p2p.PeerScoreExposer); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(p2p.PeerScoreExposer)
		}
	}
	return r0
}

// PeerScore_PeerScoreExposer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PeerScoreExposer'
type PeerScore_PeerScoreExposer_Call struct {
	*mock.Call
}

// PeerScoreExposer is a helper method to define mock.On call
func (_e *PeerScore_Expecter) PeerScoreExposer() *PeerScore_PeerScoreExposer_Call {
	return &PeerScore_PeerScoreExposer_Call{Call: _e.mock.On("PeerScoreExposer")}
}

func (_c *PeerScore_PeerScoreExposer_Call) Run(run func()) *PeerScore_PeerScoreExposer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *PeerScore_PeerScoreExposer_Call) Return(peerScoreExposer p2p.PeerScoreExposer) *PeerScore_PeerScoreExposer_Call {
	_c.Call.Return(peerScoreExposer)
	return _c
}

func (_c *PeerScore_PeerScoreExposer_Call) RunAndReturn(run func() p2p.PeerScoreExposer) *PeerScore_PeerScoreExposer_Call {
	_c.Call.Return(run)
	return _c
}

// NewPeerConnections creates a new instance of PeerConnections. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewPeerConnections(t interface {
	mock.TestingT
	Cleanup(func())
}) *PeerConnections {
	mock := &PeerConnections{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// PeerConnections is an autogenerated mock type for the PeerConnections type
type PeerConnections struct {
	mock.Mock
}

type PeerConnections_Expecter struct {
	mock *mock.Mock
}

func (_m *PeerConnections) EXPECT() *PeerConnections_Expecter {
	return &PeerConnections_Expecter{mock: &_m.Mock}
}

// IsConnected provides a mock function for the type PeerConnections
func (_mock *PeerConnections) IsConnected(peerID peer.ID) (bool, error) {
	ret := _mock.Called(peerID)

	if len(ret) == 0 {
		panic("no return value specified for IsConnected")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(peer.ID) (bool, error)); ok {
		return returnFunc(peerID)
	}
	if returnFunc, ok := ret.Get(0).(func(peer.ID) bool); ok {
		r0 = returnFunc(peerID)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(peer.ID) error); ok {
		r1 = returnFunc(peerID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// PeerConnections_IsConnected_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsConnected'
type PeerConnections_IsConnected_Call struct {
	*mock.Call
}

// IsConnected is a helper method to define mock.On call
//   - peerID peer.ID
func (_e *PeerConnections_Expecter) IsConnected(peerID interface{}) *PeerConnections_IsConnected_Call {
	return &PeerConnections_IsConnected_Call{Call: _e.mock.On("IsConnected", peerID)}
}

func (_c *PeerConnections_IsConnected_Call) Run(run func(peerID peer.ID)) *PeerConnections_IsConnected_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 peer.ID
		if args[0] != nil {
			arg0 = args[0].(peer.ID)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PeerConnections_IsConnected_Call) Return(b bool, err error) *PeerConnections_IsConnected_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *PeerConnections_IsConnected_Call) RunAndReturn(run func(peerID peer.ID) (bool, error)) *PeerConnections_IsConnected_Call {
	_c.Call.Return(run)
	return _c
}

// NewDisallowListNotificationConsumer creates a new instance of DisallowListNotificationConsumer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewDisallowListNotificationConsumer(t interface {
	mock.TestingT
	Cleanup(func())
}) *DisallowListNotificationConsumer {
	mock := &DisallowListNotificationConsumer{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// DisallowListNotificationConsumer is an autogenerated mock type for the DisallowListNotificationConsumer type
type DisallowListNotificationConsumer struct {
	mock.Mock
}

type DisallowListNotificationConsumer_Expecter struct {
	mock *mock.Mock
}

func (_m *DisallowListNotificationConsumer) EXPECT() *DisallowListNotificationConsumer_Expecter {
	return &DisallowListNotificationConsumer_Expecter{mock: &_m.Mock}
}

// OnAllowListNotification provides a mock function for the type DisallowListNotificationConsumer
func (_mock *DisallowListNotificationConsumer) OnAllowListNotification(id peer.ID, cause network0.DisallowListedCause) {
	_mock.Called(id, cause)
	return
}

// DisallowListNotificationConsumer_OnAllowListNotification_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnAllowListNotification'
type DisallowListNotificationConsumer_OnAllowListNotification_Call struct {
	*mock.Call
}

// OnAllowListNotification is a helper method to define mock.On call
//   - id peer.ID
//   - cause network0.DisallowListedCause
func (_e *DisallowListNotificationConsumer_Expecter) OnAllowListNotification(id interface{}, cause interface{}) *DisallowListNotificationConsumer_OnAllowListNotification_Call {
	return &DisallowListNotificationConsumer_OnAllowListNotification_Call{Call: _e.mock.On("OnAllowListNotification", id, cause)}
}

func (_c *DisallowListNotificationConsumer_OnAllowListNotification_Call) Run(run func(id peer.ID, cause network0.DisallowListedCause)) *DisallowListNotificationConsumer_OnAllowListNotification_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 peer.ID
		if args[0] != nil {
			arg0 = args[0].(peer.ID)
		}
		var arg1 network0.DisallowListedCause
		if args[1] != nil {
			arg1 = args[1].(network0.DisallowListedCause)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *DisallowListNotificationConsumer_OnAllowListNotification_Call) Return() *DisallowListNotificationConsumer_OnAllowListNotification_Call {
	_c.Call.Return()
	return _c
}

func (_c *DisallowListNotificationConsumer_OnAllowListNotification_Call) RunAndReturn(run func(id peer.ID, cause network0.DisallowListedCause)) *DisallowListNotificationConsumer_OnAllowListNotification_Call {
	_c.Run(run)
	return _c
}

// OnDisallowListNotification provides a mock function for the type DisallowListNotificationConsumer
func (_mock *DisallowListNotificationConsumer) OnDisallowListNotification(id peer.ID, cause network0.DisallowListedCause) {
	_mock.Called(id, cause)
	return
}

// DisallowListNotificationConsumer_OnDisallowListNotification_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnDisallowListNotification'
type DisallowListNotificationConsumer_OnDisallowListNotification_Call struct {
	*mock.Call
}

// OnDisallowListNotification is a helper method to define mock.On call
//   - id peer.ID
//   - cause network0.DisallowListedCause
func (_e *DisallowListNotificationConsumer_Expecter) OnDisallowListNotification(id interface{}, cause interface{}) *DisallowListNotificationConsumer_OnDisallowListNotification_Call {
	return &DisallowListNotificationConsumer_OnDisallowListNotification_Call{Call: _e.mock.On("OnDisallowListNotification", id, cause)}
}

func (_c *DisallowListNotificationConsumer_OnDisallowListNotification_Call) Run(run func(id peer.ID, cause network0.DisallowListedCause)) *DisallowListNotificationConsumer_OnDisallowListNotification_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 peer.ID
		if args[0] != nil {
			arg0 = args[0].(peer.ID)
		}
		var arg1 network0.DisallowListedCause
		if args[1] != nil {
			arg1 = args[1].(network0.DisallowListedCause)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *DisallowListNotificationConsumer_OnDisallowListNotification_Call) Return() *DisallowListNotificationConsumer_OnDisallowListNotification_Call {
	_c.Call.Return()
	return _c
}

func (_c *DisallowListNotificationConsumer_OnDisallowListNotification_Call) RunAndReturn(run func(id peer.ID, cause network0.DisallowListedCause)) *DisallowListNotificationConsumer_OnDisallowListNotification_Call {
	_c.Run(run)
	return _c
}

// NewDisallowListOracle creates a new instance of DisallowListOracle. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewDisallowListOracle(t interface {
	mock.TestingT
	Cleanup(func())
}) *DisallowListOracle {
	mock := &DisallowListOracle{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// DisallowListOracle is an autogenerated mock type for the DisallowListOracle type
type DisallowListOracle struct {
	mock.Mock
}

type DisallowListOracle_Expecter struct {
	mock *mock.Mock
}

func (_m *DisallowListOracle) EXPECT() *DisallowListOracle_Expecter {
	return &DisallowListOracle_Expecter{mock: &_m.Mock}
}

// IsDisallowListed provides a mock function for the type DisallowListOracle
func (_mock *DisallowListOracle) IsDisallowListed(peerId peer.ID) ([]network0.DisallowListedCause, bool) {
	ret := _mock.Called(peerId)

	if len(ret) == 0 {
		panic("no return value specified for IsDisallowListed")
	}

	var r0 []network0.DisallowListedCause
	var r1 bool
	if returnFunc, ok := ret.Get(0).(func(peer.ID) ([]network0.DisallowListedCause, bool)); ok {
		return returnFunc(peerId)
	}
	if returnFunc, ok := ret.Get(0).(func(peer.ID) []network0.DisallowListedCause); ok {
		r0 = returnFunc(peerId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]network0.DisallowListedCause)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(peer.ID) bool); ok {
		r1 = returnFunc(peerId)
	} else {
		r1 = ret.Get(1).(bool)
	}
	return r0, r1
}

// DisallowListOracle_IsDisallowListed_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsDisallowListed'
type DisallowListOracle_IsDisallowListed_Call struct {
	*mock.Call
}

// IsDisallowListed is a helper method to define mock.On call
//   - peerId peer.ID
func (_e *DisallowListOracle_Expecter) IsDisallowListed(peerId interface{}) *DisallowListOracle_IsDisallowListed_Call {
	return &DisallowListOracle_IsDisallowListed_Call{Call: _e.mock.On("IsDisallowListed", peerId)}
}

func (_c *DisallowListOracle_IsDisallowListed_Call) Run(run func(peerId peer.ID)) *DisallowListOracle_IsDisallowListed_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 peer.ID
		if args[0] != nil {
			arg0 = args[0].(peer.ID)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *DisallowListOracle_IsDisallowListed_Call) Return(disallowListedCauses []network0.DisallowListedCause, b bool) *DisallowListOracle_IsDisallowListed_Call {
	_c.Call.Return(disallowListedCauses, b)
	return _c
}

func (_c *DisallowListOracle_IsDisallowListed_Call) RunAndReturn(run func(peerId peer.ID) ([]network0.DisallowListedCause, bool)) *DisallowListOracle_IsDisallowListed_Call {
	_c.Call.Return(run)
	return _c
}

// NewPeerManager creates a new instance of PeerManager. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewPeerManager(t interface {
	mock.TestingT
	Cleanup(func())
}) *PeerManager {
	mock := &PeerManager{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// PeerManager is an autogenerated mock type for the PeerManager type
type PeerManager struct {
	mock.Mock
}

type PeerManager_Expecter struct {
	mock *mock.Mock
}

func (_m *PeerManager) EXPECT() *PeerManager_Expecter {
	return &PeerManager_Expecter{mock: &_m.Mock}
}

// Done provides a mock function for the type PeerManager
func (_mock *PeerManager) Done() <-chan struct{} {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Done")
	}

	var r0 <-chan struct{}
	if returnFunc, ok := ret.Get(0).(func() <-chan struct{}); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan struct{})
		}
	}
	return r0
}

// PeerManager_Done_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Done'
type PeerManager_Done_Call struct {
	*mock.Call
}

// Done is a helper method to define mock.On call
func (_e *PeerManager_Expecter) Done() *PeerManager_Done_Call {
	return &PeerManager_Done_Call{Call: _e.mock.On("Done")}
}

func (_c *PeerManager_Done_Call) Run(run func()) *PeerManager_Done_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *PeerManager_Done_Call) Return(valCh <-chan struct{}) *PeerManager_Done_Call {
	_c.Call.Return(valCh)
	return _c
}

func (_c *PeerManager_Done_Call) RunAndReturn(run func() <-chan struct{}) *PeerManager_Done_Call {
	_c.Call.Return(run)
	return _c
}

// ForceUpdatePeers provides a mock function for the type PeerManager
func (_mock *PeerManager) ForceUpdatePeers(context1 context.Context) {
	_mock.Called(context1)
	return
}

// PeerManager_ForceUpdatePeers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ForceUpdatePeers'
type PeerManager_ForceUpdatePeers_Call struct {
	*mock.Call
}

// ForceUpdatePeers is a helper method to define mock.On call
//   - context1 context.Context
func (_e *PeerManager_Expecter) ForceUpdatePeers(context1 interface{}) *PeerManager_ForceUpdatePeers_Call {
	return &PeerManager_ForceUpdatePeers_Call{Call: _e.mock.On("ForceUpdatePeers", context1)}
}

func (_c *PeerManager_ForceUpdatePeers_Call) Run(run func(context1 context.Context)) *PeerManager_ForceUpdatePeers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PeerManager_ForceUpdatePeers_Call) Return() *PeerManager_ForceUpdatePeers_Call {
	_c.Call.Return()
	return _c
}

func (_c *PeerManager_ForceUpdatePeers_Call) RunAndReturn(run func(context1 context.Context)) *PeerManager_ForceUpdatePeers_Call {
	_c.Run(run)
	return _c
}

// OnRateLimitedPeer provides a mock function for the type PeerManager
func (_mock *PeerManager) OnRateLimitedPeer(pid peer.ID, role string, msgType string, topic string, reason string) {
	_mock.Called(pid, role, msgType, topic, reason)
	return
}

// PeerManager_OnRateLimitedPeer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnRateLimitedPeer'
type PeerManager_OnRateLimitedPeer_Call struct {
	*mock.Call
}

// OnRateLimitedPeer is a helper method to define mock.On call
//   - pid peer.ID
//   - role string
//   - msgType string
//   - topic string
//   - reason string
func (_e *PeerManager_Expecter) OnRateLimitedPeer(pid interface{}, role interface{}, msgType interface{}, topic interface{}, reason interface{}) *PeerManager_OnRateLimitedPeer_Call {
	return &PeerManager_OnRateLimitedPeer_Call{Call: _e.mock.On("OnRateLimitedPeer", pid, role, msgType, topic, reason)}
}

func (_c *PeerManager_OnRateLimitedPeer_Call) Run(run func(pid peer.ID, role string, msgType string, topic string, reason string)) *PeerManager_OnRateLimitedPeer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 peer.ID
		if args[0] != nil {
			arg0 = args[0].(peer.ID)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		var arg4 string
		if args[4] != nil {
			arg4 = args[4].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *PeerManager_OnRateLimitedPeer_Call) Return() *PeerManager_OnRateLimitedPeer_Call {
	_c.Call.Return()
	return _c
}

func (_c *PeerManager_OnRateLimitedPeer_Call) RunAndReturn(run func(pid peer.ID, role string, msgType string, topic string, reason string)) *PeerManager_OnRateLimitedPeer_Call {
	_c.Run(run)
	return _c
}

// Ready provides a mock function for the type PeerManager
func (_mock *PeerManager) Ready() <-chan struct{} {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Ready")
	}

	var r0 <-chan struct{}
	if returnFunc, ok := ret.Get(0).(func() <-chan struct{}); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan struct{})
		}
	}
	return r0
}

// PeerManager_Ready_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Ready'
type PeerManager_Ready_Call struct {
	*mock.Call
}

// Ready is a helper method to define mock.On call
func (_e *PeerManager_Expecter) Ready() *PeerManager_Ready_Call {
	return &PeerManager_Ready_Call{Call: _e.mock.On("Ready")}
}

func (_c *PeerManager_Ready_Call) Run(run func()) *PeerManager_Ready_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *PeerManager_Ready_Call) Return(valCh <-chan struct{}) *PeerManager_Ready_Call {
	_c.Call.Return(valCh)
	return _c
}

func (_c *PeerManager_Ready_Call) RunAndReturn(run func() <-chan struct{}) *PeerManager_Ready_Call {
	_c.Call.Return(run)
	return _c
}

// RequestPeerUpdate provides a mock function for the type PeerManager
func (_mock *PeerManager) RequestPeerUpdate() {
	_mock.Called()
	return
}

// PeerManager_RequestPeerUpdate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RequestPeerUpdate'
type PeerManager_RequestPeerUpdate_Call struct {
	*mock.Call
}

// RequestPeerUpdate is a helper method to define mock.On call
func (_e *PeerManager_Expecter) RequestPeerUpdate() *PeerManager_RequestPeerUpdate_Call {
	return &PeerManager_RequestPeerUpdate_Call{Call: _e.mock.On("RequestPeerUpdate")}
}

func (_c *PeerManager_RequestPeerUpdate_Call) Run(run func()) *PeerManager_RequestPeerUpdate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *PeerManager_RequestPeerUpdate_Call) Return() *PeerManager_RequestPeerUpdate_Call {
	_c.Call.Return()
	return _c
}

func (_c *PeerManager_RequestPeerUpdate_Call) RunAndReturn(run func()) *PeerManager_RequestPeerUpdate_Call {
	_c.Run(run)
	return _c
}

// SetPeersProvider provides a mock function for the type PeerManager
func (_mock *PeerManager) SetPeersProvider(peersProvider p2p.PeersProvider) {
	_mock.Called(peersProvider)
	return
}

// PeerManager_SetPeersProvider_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetPeersProvider'
type PeerManager_SetPeersProvider_Call struct {
	*mock.Call
}

// SetPeersProvider is a helper method to define mock.On call
//   - peersProvider p2p.PeersProvider
func (_e *PeerManager_Expecter) SetPeersProvider(peersProvider interface{}) *PeerManager_SetPeersProvider_Call {
	return &PeerManager_SetPeersProvider_Call{Call: _e.mock.On("SetPeersProvider", peersProvider)}
}

func (_c *PeerManager_SetPeersProvider_Call) Run(run func(peersProvider p2p.PeersProvider)) *PeerManager_SetPeersProvider_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 p2p.PeersProvider
		if args[0] != nil {
			arg0 = args[0].(p2p.PeersProvider)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PeerManager_SetPeersProvider_Call) Return() *PeerManager_SetPeersProvider_Call {
	_c.Call.Return()
	return _c
}

func (_c *PeerManager_SetPeersProvider_Call) RunAndReturn(run func(peersProvider p2p.PeersProvider)) *PeerManager_SetPeersProvider_Call {
	_c.Run(run)
	return _c
}

// Start provides a mock function for the type PeerManager
func (_mock *PeerManager) Start(signalerContext irrecoverable.SignalerContext) {
	_mock.Called(signalerContext)
	return
}

// PeerManager_Start_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Start'
type PeerManager_Start_Call struct {
	*mock.Call
}

// Start is a helper method to define mock.On call
//   - signalerContext irrecoverable.SignalerContext
func (_e *PeerManager_Expecter) Start(signalerContext interface{}) *PeerManager_Start_Call {
	return &PeerManager_Start_Call{Call: _e.mock.On("Start", signalerContext)}
}

func (_c *PeerManager_Start_Call) Run(run func(signalerContext irrecoverable.SignalerContext)) *PeerManager_Start_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 irrecoverable.SignalerContext
		if args[0] != nil {
			arg0 = args[0].(irrecoverable.SignalerContext)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PeerManager_Start_Call) Return() *PeerManager_Start_Call {
	_c.Call.Return()
	return _c
}

func (_c *PeerManager_Start_Call) RunAndReturn(run func(signalerContext irrecoverable.SignalerContext)) *PeerManager_Start_Call {
	_c.Run(run)
	return _c
}

// NewPubSubAdapter creates a new instance of PubSubAdapter. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewPubSubAdapter(t interface {
	mock.TestingT
	Cleanup(func())
}) *PubSubAdapter {
	mock := &PubSubAdapter{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// PubSubAdapter is an autogenerated mock type for the PubSubAdapter type
type PubSubAdapter struct {
	mock.Mock
}

type PubSubAdapter_Expecter struct {
	mock *mock.Mock
}

func (_m *PubSubAdapter) EXPECT() *PubSubAdapter_Expecter {
	return &PubSubAdapter_Expecter{mock: &_m.Mock}
}

// ActiveClustersChanged provides a mock function for the type PubSubAdapter
func (_mock *PubSubAdapter) ActiveClustersChanged(chainIDList flow.ChainIDList) {
	_mock.Called(chainIDList)
	return
}

// PubSubAdapter_ActiveClustersChanged_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ActiveClustersChanged'
type PubSubAdapter_ActiveClustersChanged_Call struct {
	*mock.Call
}

// ActiveClustersChanged is a helper method to define mock.On call
//   - chainIDList flow.ChainIDList
func (_e *PubSubAdapter_Expecter) ActiveClustersChanged(chainIDList interface{}) *PubSubAdapter_ActiveClustersChanged_Call {
	return &PubSubAdapter_ActiveClustersChanged_Call{Call: _e.mock.On("ActiveClustersChanged", chainIDList)}
}

func (_c *PubSubAdapter_ActiveClustersChanged_Call) Run(run func(chainIDList flow.ChainIDList)) *PubSubAdapter_ActiveClustersChanged_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.ChainIDList
		if args[0] != nil {
			arg0 = args[0].(flow.ChainIDList)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PubSubAdapter_ActiveClustersChanged_Call) Return() *PubSubAdapter_ActiveClustersChanged_Call {
	_c.Call.Return()
	return _c
}

func (_c *PubSubAdapter_ActiveClustersChanged_Call) RunAndReturn(run func(chainIDList flow.ChainIDList)) *PubSubAdapter_ActiveClustersChanged_Call {
	_c.Run(run)
	return _c
}

// Done provides a mock function for the type PubSubAdapter
func (_mock *PubSubAdapter) Done() <-chan struct{} {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Done")
	}

	var r0 <-chan struct{}
	if returnFunc, ok := ret.Get(0).(func() <-chan struct{}); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan struct{})
		}
	}
	return r0
}

// PubSubAdapter_Done_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Done'
type PubSubAdapter_Done_Call struct {
	*mock.Call
}

// Done is a helper method to define mock.On call
func (_e *PubSubAdapter_Expecter) Done() *PubSubAdapter_Done_Call {
	return &PubSubAdapter_Done_Call{Call: _e.mock.On("Done")}
}

func (_c *PubSubAdapter_Done_Call) Run(run func()) *PubSubAdapter_Done_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *PubSubAdapter_Done_Call) Return(valCh <-chan struct{}) *PubSubAdapter_Done_Call {
	_c.Call.Return(valCh)
	return _c
}

func (_c *PubSubAdapter_Done_Call) RunAndReturn(run func() <-chan struct{}) *PubSubAdapter_Done_Call {
	_c.Call.Return(run)
	return _c
}

// GetLocalMeshPeers provides a mock function for the type PubSubAdapter
func (_mock *PubSubAdapter) GetLocalMeshPeers(topic channels.Topic) []peer.ID {
	ret := _mock.Called(topic)

	if len(ret) == 0 {
		panic("no return value specified for GetLocalMeshPeers")
	}

	var r0 []peer.ID
	if returnFunc, ok := ret.Get(0).(func(channels.Topic) []peer.ID); ok {
		r0 = returnFunc(topic)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]peer.ID)
		}
	}
	return r0
}

// PubSubAdapter_GetLocalMeshPeers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLocalMeshPeers'
type PubSubAdapter_GetLocalMeshPeers_Call struct {
	*mock.Call
}

// GetLocalMeshPeers is a helper method to define mock.On call
//   - topic channels.Topic
func (_e *PubSubAdapter_Expecter) GetLocalMeshPeers(topic interface{}) *PubSubAdapter_GetLocalMeshPeers_Call {
	return &PubSubAdapter_GetLocalMeshPeers_Call{Call: _e.mock.On("GetLocalMeshPeers", topic)}
}

func (_c *PubSubAdapter_GetLocalMeshPeers_Call) Run(run func(topic channels.Topic)) *PubSubAdapter_GetLocalMeshPeers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 channels.Topic
		if args[0] != nil {
			arg0 = args[0].(channels.Topic)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PubSubAdapter_GetLocalMeshPeers_Call) Return(iDs []peer.ID) *PubSubAdapter_GetLocalMeshPeers_Call {
	_c.Call.Return(iDs)
	return _c
}

func (_c *PubSubAdapter_GetLocalMeshPeers_Call) RunAndReturn(run func(topic channels.Topic) []peer.ID) *PubSubAdapter_GetLocalMeshPeers_Call {
	_c.Call.Return(run)
	return _c
}

// GetTopics provides a mock function for the type PubSubAdapter
func (_mock *PubSubAdapter) GetTopics() []string {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetTopics")
	}

	var r0 []string
	if returnFunc, ok := ret.Get(0).(func() []string); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}
	return r0
}

// PubSubAdapter_GetTopics_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTopics'
type PubSubAdapter_GetTopics_Call struct {
	*mock.Call
}

// GetTopics is a helper method to define mock.On call
func (_e *PubSubAdapter_Expecter) GetTopics() *PubSubAdapter_GetTopics_Call {
	return &PubSubAdapter_GetTopics_Call{Call: _e.mock.On("GetTopics")}
}

func (_c *PubSubAdapter_GetTopics_Call) Run(run func()) *PubSubAdapter_GetTopics_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *PubSubAdapter_GetTopics_Call) Return(strings []string) *PubSubAdapter_GetTopics_Call {
	_c.Call.Return(strings)
	return _c
}

func (_c *PubSubAdapter_GetTopics_Call) RunAndReturn(run func() []string) *PubSubAdapter_GetTopics_Call {
	_c.Call.Return(run)
	return _c
}

// Join provides a mock function for the type PubSubAdapter
func (_mock *PubSubAdapter) Join(topic string) (p2p.Topic, error) {
	ret := _mock.Called(topic)

	if len(ret) == 0 {
		panic("no return value specified for Join")
	}

	var r0 p2p.Topic
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string) (p2p.Topic, error)); ok {
		return returnFunc(topic)
	}
	if returnFunc, ok := ret.Get(0).(func(string) p2p.Topic); ok {
		r0 = returnFunc(topic)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(p2p.Topic)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string) error); ok {
		r1 = returnFunc(topic)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// PubSubAdapter_Join_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Join'
type PubSubAdapter_Join_Call struct {
	*mock.Call
}

// Join is a helper method to define mock.On call
//   - topic string
func (_e *PubSubAdapter_Expecter) Join(topic interface{}) *PubSubAdapter_Join_Call {
	return &PubSubAdapter_Join_Call{Call: _e.mock.On("Join", topic)}
}

func (_c *PubSubAdapter_Join_Call) Run(run func(topic string)) *PubSubAdapter_Join_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PubSubAdapter_Join_Call) Return(topic1 p2p.Topic, err error) *PubSubAdapter_Join_Call {
	_c.Call.Return(topic1, err)
	return _c
}

func (_c *PubSubAdapter_Join_Call) RunAndReturn(run func(topic string) (p2p.Topic, error)) *PubSubAdapter_Join_Call {
	_c.Call.Return(run)
	return _c
}

// ListPeers provides a mock function for the type PubSubAdapter
func (_mock *PubSubAdapter) ListPeers(topic string) []peer.ID {
	ret := _mock.Called(topic)

	if len(ret) == 0 {
		panic("no return value specified for ListPeers")
	}

	var r0 []peer.ID
	if returnFunc, ok := ret.Get(0).(func(string) []peer.ID); ok {
		r0 = returnFunc(topic)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]peer.ID)
		}
	}
	return r0
}

// PubSubAdapter_ListPeers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListPeers'
type PubSubAdapter_ListPeers_Call struct {
	*mock.Call
}

// ListPeers is a helper method to define mock.On call
//   - topic string
func (_e *PubSubAdapter_Expecter) ListPeers(topic interface{}) *PubSubAdapter_ListPeers_Call {
	return &PubSubAdapter_ListPeers_Call{Call: _e.mock.On("ListPeers", topic)}
}

func (_c *PubSubAdapter_ListPeers_Call) Run(run func(topic string)) *PubSubAdapter_ListPeers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PubSubAdapter_ListPeers_Call) Return(iDs []peer.ID) *PubSubAdapter_ListPeers_Call {
	_c.Call.Return(iDs)
	return _c
}

func (_c *PubSubAdapter_ListPeers_Call) RunAndReturn(run func(topic string) []peer.ID) *PubSubAdapter_ListPeers_Call {
	_c.Call.Return(run)
	return _c
}

// PeerScoreExposer provides a mock function for the type PubSubAdapter
func (_mock *PubSubAdapter) PeerScoreExposer() p2p.PeerScoreExposer {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for PeerScoreExposer")
	}

	var r0 p2p.PeerScoreExposer
	if returnFunc, ok := ret.Get(0).(func() p2p.PeerScoreExposer); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(p2p.PeerScoreExposer)
		}
	}
	return r0
}

// PubSubAdapter_PeerScoreExposer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PeerScoreExposer'
type PubSubAdapter_PeerScoreExposer_Call struct {
	*mock.Call
}

// PeerScoreExposer is a helper method to define mock.On call
func (_e *PubSubAdapter_Expecter) PeerScoreExposer() *PubSubAdapter_PeerScoreExposer_Call {
	return &PubSubAdapter_PeerScoreExposer_Call{Call: _e.mock.On("PeerScoreExposer")}
}

func (_c *PubSubAdapter_PeerScoreExposer_Call) Run(run func()) *PubSubAdapter_PeerScoreExposer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *PubSubAdapter_PeerScoreExposer_Call) Return(peerScoreExposer p2p.PeerScoreExposer) *PubSubAdapter_PeerScoreExposer_Call {
	_c.Call.Return(peerScoreExposer)
	return _c
}

func (_c *PubSubAdapter_PeerScoreExposer_Call) RunAndReturn(run func() p2p.PeerScoreExposer) *PubSubAdapter_PeerScoreExposer_Call {
	_c.Call.Return(run)
	return _c
}

// Ready provides a mock function for the type PubSubAdapter
func (_mock *PubSubAdapter) Ready() <-chan struct{} {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Ready")
	}

	var r0 <-chan struct{}
	if returnFunc, ok := ret.Get(0).(func() <-chan struct{}); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan struct{})
		}
	}
	return r0
}

// PubSubAdapter_Ready_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Ready'
type PubSubAdapter_Ready_Call struct {
	*mock.Call
}

// Ready is a helper method to define mock.On call
func (_e *PubSubAdapter_Expecter) Ready() *PubSubAdapter_Ready_Call {
	return &PubSubAdapter_Ready_Call{Call: _e.mock.On("Ready")}
}

func (_c *PubSubAdapter_Ready_Call) Run(run func()) *PubSubAdapter_Ready_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *PubSubAdapter_Ready_Call) Return(valCh <-chan struct{}) *PubSubAdapter_Ready_Call {
	_c.Call.Return(valCh)
	return _c
}

func (_c *PubSubAdapter_Ready_Call) RunAndReturn(run func() <-chan struct{}) *PubSubAdapter_Ready_Call {
	_c.Call.Return(run)
	return _c
}

// RegisterTopicValidator provides a mock function for the type PubSubAdapter
func (_mock *PubSubAdapter) RegisterTopicValidator(topic string, topicValidator p2p.TopicValidatorFunc) error {
	ret := _mock.Called(topic, topicValidator)

	if len(ret) == 0 {
		panic("no return value specified for RegisterTopicValidator")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string, p2p.TopicValidatorFunc) error); ok {
		r0 = returnFunc(topic, topicValidator)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// PubSubAdapter_RegisterTopicValidator_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RegisterTopicValidator'
type PubSubAdapter_RegisterTopicValidator_Call struct {
	*mock.Call
}

// RegisterTopicValidator is a helper method to define mock.On call
//   - topic string
//   - topicValidator p2p.TopicValidatorFunc
func (_e *PubSubAdapter_Expecter) RegisterTopicValidator(topic interface{}, topicValidator interface{}) *PubSubAdapter_RegisterTopicValidator_Call {
	return &PubSubAdapter_RegisterTopicValidator_Call{Call: _e.mock.On("RegisterTopicValidator", topic, topicValidator)}
}

func (_c *PubSubAdapter_RegisterTopicValidator_Call) Run(run func(topic string, topicValidator p2p.TopicValidatorFunc)) *PubSubAdapter_RegisterTopicValidator_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 p2p.TopicValidatorFunc
		if args[1] != nil {
			arg1 = args[1].(p2p.TopicValidatorFunc)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *PubSubAdapter_RegisterTopicValidator_Call) Return(err error) *PubSubAdapter_RegisterTopicValidator_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *PubSubAdapter_RegisterTopicValidator_Call) RunAndReturn(run func(topic string, topicValidator p2p.TopicValidatorFunc) error) *PubSubAdapter_RegisterTopicValidator_Call {
	_c.Call.Return(run)
	return _c
}

// Start provides a mock function for the type PubSubAdapter
func (_mock *PubSubAdapter) Start(signalerContext irrecoverable.SignalerContext) {
	_mock.Called(signalerContext)
	return
}

// PubSubAdapter_Start_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Start'
type PubSubAdapter_Start_Call struct {
	*mock.Call
}

// Start is a helper method to define mock.On call
//   - signalerContext irrecoverable.SignalerContext
func (_e *PubSubAdapter_Expecter) Start(signalerContext interface{}) *PubSubAdapter_Start_Call {
	return &PubSubAdapter_Start_Call{Call: _e.mock.On("Start", signalerContext)}
}

func (_c *PubSubAdapter_Start_Call) Run(run func(signalerContext irrecoverable.SignalerContext)) *PubSubAdapter_Start_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 irrecoverable.SignalerContext
		if args[0] != nil {
			arg0 = args[0].(irrecoverable.SignalerContext)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PubSubAdapter_Start_Call) Return() *PubSubAdapter_Start_Call {
	_c.Call.Return()
	return _c
}

func (_c *PubSubAdapter_Start_Call) RunAndReturn(run func(signalerContext irrecoverable.SignalerContext)) *PubSubAdapter_Start_Call {
	_c.Run(run)
	return _c
}

// UnregisterTopicValidator provides a mock function for the type PubSubAdapter
func (_mock *PubSubAdapter) UnregisterTopicValidator(topic string) error {
	ret := _mock.Called(topic)

	if len(ret) == 0 {
		panic("no return value specified for UnregisterTopicValidator")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string) error); ok {
		r0 = returnFunc(topic)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// PubSubAdapter_UnregisterTopicValidator_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnregisterTopicValidator'
type PubSubAdapter_UnregisterTopicValidator_Call struct {
	*mock.Call
}

// UnregisterTopicValidator is a helper method to define mock.On call
//   - topic string
func (_e *PubSubAdapter_Expecter) UnregisterTopicValidator(topic interface{}) *PubSubAdapter_UnregisterTopicValidator_Call {
	return &PubSubAdapter_UnregisterTopicValidator_Call{Call: _e.mock.On("UnregisterTopicValidator", topic)}
}

func (_c *PubSubAdapter_UnregisterTopicValidator_Call) Run(run func(topic string)) *PubSubAdapter_UnregisterTopicValidator_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PubSubAdapter_UnregisterTopicValidator_Call) Return(err error) *PubSubAdapter_UnregisterTopicValidator_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *PubSubAdapter_UnregisterTopicValidator_Call) RunAndReturn(run func(topic string) error) *PubSubAdapter_UnregisterTopicValidator_Call {
	_c.Call.Return(run)
	return _c
}

// NewPubSubAdapterConfig creates a new instance of PubSubAdapterConfig. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewPubSubAdapterConfig(t interface {
	mock.TestingT
	Cleanup(func())
}) *PubSubAdapterConfig {
	mock := &PubSubAdapterConfig{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// PubSubAdapterConfig is an autogenerated mock type for the PubSubAdapterConfig type
type PubSubAdapterConfig struct {
	mock.Mock
}

type PubSubAdapterConfig_Expecter struct {
	mock *mock.Mock
}

func (_m *PubSubAdapterConfig) EXPECT() *PubSubAdapterConfig_Expecter {
	return &PubSubAdapterConfig_Expecter{mock: &_m.Mock}
}

// WithMessageIdFunction provides a mock function for the type PubSubAdapterConfig
func (_mock *PubSubAdapterConfig) WithMessageIdFunction(f func([]byte) string) {
	_mock.Called(f)
	return
}

// PubSubAdapterConfig_WithMessageIdFunction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithMessageIdFunction'
type PubSubAdapterConfig_WithMessageIdFunction_Call struct {
	*mock.Call
}

// WithMessageIdFunction is a helper method to define mock.On call
//   - f func([]byte) string
func (_e *PubSubAdapterConfig_Expecter) WithMessageIdFunction(f interface{}) *PubSubAdapterConfig_WithMessageIdFunction_Call {
	return &PubSubAdapterConfig_WithMessageIdFunction_Call{Call: _e.mock.On("WithMessageIdFunction", f)}
}

func (_c *PubSubAdapterConfig_WithMessageIdFunction_Call) Run(run func(f func([]byte) string)) *PubSubAdapterConfig_WithMessageIdFunction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 func([]byte) string
		if args[0] != nil {
			arg0 = args[0].(func([]byte) string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PubSubAdapterConfig_WithMessageIdFunction_Call) Return() *PubSubAdapterConfig_WithMessageIdFunction_Call {
	_c.Call.Return()
	return _c
}

func (_c *PubSubAdapterConfig_WithMessageIdFunction_Call) RunAndReturn(run func(f func([]byte) string)) *PubSubAdapterConfig_WithMessageIdFunction_Call {
	_c.Run(run)
	return _c
}

// WithPeerGater provides a mock function for the type PubSubAdapterConfig
func (_mock *PubSubAdapterConfig) WithPeerGater(topicDeliveryWeights map[string]float64, sourceDecay time.Duration) {
	_mock.Called(topicDeliveryWeights, sourceDecay)
	return
}

// PubSubAdapterConfig_WithPeerGater_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithPeerGater'
type PubSubAdapterConfig_WithPeerGater_Call struct {
	*mock.Call
}

// WithPeerGater is a helper method to define mock.On call
//   - topicDeliveryWeights map[string]float64
//   - sourceDecay time.Duration
func (_e *PubSubAdapterConfig_Expecter) WithPeerGater(topicDeliveryWeights interface{}, sourceDecay interface{}) *PubSubAdapterConfig_WithPeerGater_Call {
	return &PubSubAdapterConfig_WithPeerGater_Call{Call: _e.mock.On("WithPeerGater", topicDeliveryWeights, sourceDecay)}
}

func (_c *PubSubAdapterConfig_WithPeerGater_Call) Run(run func(topicDeliveryWeights map[string]float64, sourceDecay time.Duration)) *PubSubAdapterConfig_WithPeerGater_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 map[string]float64
		if args[0] != nil {
			arg0 = args[0].(map[string]float64)
		}
		var arg1 time.Duration
		if args[1] != nil {
			arg1 = args[1].(time.Duration)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *PubSubAdapterConfig_WithPeerGater_Call) Return() *PubSubAdapterConfig_WithPeerGater_Call {
	_c.Call.Return()
	return _c
}

func (_c *PubSubAdapterConfig_WithPeerGater_Call) RunAndReturn(run func(topicDeliveryWeights map[string]float64, sourceDecay time.Duration)) *PubSubAdapterConfig_WithPeerGater_Call {
	_c.Run(run)
	return _c
}

// WithRoutingDiscovery provides a mock function for the type PubSubAdapterConfig
func (_mock *PubSubAdapterConfig) WithRoutingDiscovery(contentRouting routing.ContentRouting) {
	_mock.Called(contentRouting)
	return
}

// PubSubAdapterConfig_WithRoutingDiscovery_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithRoutingDiscovery'
type PubSubAdapterConfig_WithRoutingDiscovery_Call struct {
	*mock.Call
}

// WithRoutingDiscovery is a helper method to define mock.On call
//   - contentRouting routing.ContentRouting
func (_e *PubSubAdapterConfig_Expecter) WithRoutingDiscovery(contentRouting interface{}) *PubSubAdapterConfig_WithRoutingDiscovery_Call {
	return &PubSubAdapterConfig_WithRoutingDiscovery_Call{Call: _e.mock.On("WithRoutingDiscovery", contentRouting)}
}

func (_c *PubSubAdapterConfig_WithRoutingDiscovery_Call) Run(run func(contentRouting routing.ContentRouting)) *PubSubAdapterConfig_WithRoutingDiscovery_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 routing.ContentRouting
		if args[0] != nil {
			arg0 = args[0].(routing.ContentRouting)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PubSubAdapterConfig_WithRoutingDiscovery_Call) Return() *PubSubAdapterConfig_WithRoutingDiscovery_Call {
	_c.Call.Return()
	return _c
}

func (_c *PubSubAdapterConfig_WithRoutingDiscovery_Call) RunAndReturn(run func(contentRouting routing.ContentRouting)) *PubSubAdapterConfig_WithRoutingDiscovery_Call {
	_c.Run(run)
	return _c
}

// WithRpcInspector provides a mock function for the type PubSubAdapterConfig
func (_mock *PubSubAdapterConfig) WithRpcInspector(gossipSubRPCInspector p2p.GossipSubRPCInspector) {
	_mock.Called(gossipSubRPCInspector)
	return
}

// PubSubAdapterConfig_WithRpcInspector_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithRpcInspector'
type PubSubAdapterConfig_WithRpcInspector_Call struct {
	*mock.Call
}

// WithRpcInspector is a helper method to define mock.On call
//   - gossipSubRPCInspector p2p.GossipSubRPCInspector
func (_e *PubSubAdapterConfig_Expecter) WithRpcInspector(gossipSubRPCInspector interface{}) *PubSubAdapterConfig_WithRpcInspector_Call {
	return &PubSubAdapterConfig_WithRpcInspector_Call{Call: _e.mock.On("WithRpcInspector", gossipSubRPCInspector)}
}

func (_c *PubSubAdapterConfig_WithRpcInspector_Call) Run(run func(gossipSubRPCInspector p2p.GossipSubRPCInspector)) *PubSubAdapterConfig_WithRpcInspector_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 p2p.GossipSubRPCInspector
		if args[0] != nil {
			arg0 = args[0].(p2p.GossipSubRPCInspector)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PubSubAdapterConfig_WithRpcInspector_Call) Return() *PubSubAdapterConfig_WithRpcInspector_Call {
	_c.Call.Return()
	return _c
}

func (_c *PubSubAdapterConfig_WithRpcInspector_Call) RunAndReturn(run func(gossipSubRPCInspector p2p.GossipSubRPCInspector)) *PubSubAdapterConfig_WithRpcInspector_Call {
	_c.Run(run)
	return _c
}

// WithScoreOption provides a mock function for the type PubSubAdapterConfig
func (_mock *PubSubAdapterConfig) WithScoreOption(scoreOptionBuilder p2p.ScoreOptionBuilder) {
	_mock.Called(scoreOptionBuilder)
	return
}

// PubSubAdapterConfig_WithScoreOption_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithScoreOption'
type PubSubAdapterConfig_WithScoreOption_Call struct {
	*mock.Call
}

// WithScoreOption is a helper method to define mock.On call
//   - scoreOptionBuilder p2p.ScoreOptionBuilder
func (_e *PubSubAdapterConfig_Expecter) WithScoreOption(scoreOptionBuilder interface{}) *PubSubAdapterConfig_WithScoreOption_Call {
	return &PubSubAdapterConfig_WithScoreOption_Call{Call: _e.mock.On("WithScoreOption", scoreOptionBuilder)}
}

func (_c *PubSubAdapterConfig_WithScoreOption_Call) Run(run func(scoreOptionBuilder p2p.ScoreOptionBuilder)) *PubSubAdapterConfig_WithScoreOption_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 p2p.ScoreOptionBuilder
		if args[0] != nil {
			arg0 = args[0].(p2p.ScoreOptionBuilder)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PubSubAdapterConfig_WithScoreOption_Call) Return() *PubSubAdapterConfig_WithScoreOption_Call {
	_c.Call.Return()
	return _c
}

func (_c *PubSubAdapterConfig_WithScoreOption_Call) RunAndReturn(run func(scoreOptionBuilder p2p.ScoreOptionBuilder)) *PubSubAdapterConfig_WithScoreOption_Call {
	_c.Run(run)
	return _c
}

// WithScoreTracer provides a mock function for the type PubSubAdapterConfig
func (_mock *PubSubAdapterConfig) WithScoreTracer(tracer p2p.PeerScoreTracer) {
	_mock.Called(tracer)
	return
}

// PubSubAdapterConfig_WithScoreTracer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithScoreTracer'
type PubSubAdapterConfig_WithScoreTracer_Call struct {
	*mock.Call
}

// WithScoreTracer is a helper method to define mock.On call
//   - tracer p2p.PeerScoreTracer
func (_e *PubSubAdapterConfig_Expecter) WithScoreTracer(tracer interface{}) *PubSubAdapterConfig_WithScoreTracer_Call {
	return &PubSubAdapterConfig_WithScoreTracer_Call{Call: _e.mock.On("WithScoreTracer", tracer)}
}

func (_c *PubSubAdapterConfig_WithScoreTracer_Call) Run(run func(tracer p2p.PeerScoreTracer)) *PubSubAdapterConfig_WithScoreTracer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 p2p.PeerScoreTracer
		if args[0] != nil {
			arg0 = args[0].(p2p.PeerScoreTracer)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PubSubAdapterConfig_WithScoreTracer_Call) Return() *PubSubAdapterConfig_WithScoreTracer_Call {
	_c.Call.Return()
	return _c
}

func (_c *PubSubAdapterConfig_WithScoreTracer_Call) RunAndReturn(run func(tracer p2p.PeerScoreTracer)) *PubSubAdapterConfig_WithScoreTracer_Call {
	_c.Run(run)
	return _c
}

// WithSubscriptionFilter provides a mock function for the type PubSubAdapterConfig
func (_mock *PubSubAdapterConfig) WithSubscriptionFilter(subscriptionFilter p2p.SubscriptionFilter) {
	_mock.Called(subscriptionFilter)
	return
}

// PubSubAdapterConfig_WithSubscriptionFilter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithSubscriptionFilter'
type PubSubAdapterConfig_WithSubscriptionFilter_Call struct {
	*mock.Call
}

// WithSubscriptionFilter is a helper method to define mock.On call
//   - subscriptionFilter p2p.SubscriptionFilter
func (_e *PubSubAdapterConfig_Expecter) WithSubscriptionFilter(subscriptionFilter interface{}) *PubSubAdapterConfig_WithSubscriptionFilter_Call {
	return &PubSubAdapterConfig_WithSubscriptionFilter_Call{Call: _e.mock.On("WithSubscriptionFilter", subscriptionFilter)}
}

func (_c *PubSubAdapterConfig_WithSubscriptionFilter_Call) Run(run func(subscriptionFilter p2p.SubscriptionFilter)) *PubSubAdapterConfig_WithSubscriptionFilter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 p2p.SubscriptionFilter
		if args[0] != nil {
			arg0 = args[0].(p2p.SubscriptionFilter)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PubSubAdapterConfig_WithSubscriptionFilter_Call) Return() *PubSubAdapterConfig_WithSubscriptionFilter_Call {
	_c.Call.Return()
	return _c
}

func (_c *PubSubAdapterConfig_WithSubscriptionFilter_Call) RunAndReturn(run func(subscriptionFilter p2p.SubscriptionFilter)) *PubSubAdapterConfig_WithSubscriptionFilter_Call {
	_c.Run(run)
	return _c
}

// WithTracer provides a mock function for the type PubSubAdapterConfig
func (_mock *PubSubAdapterConfig) WithTracer(t p2p.PubSubTracer) {
	_mock.Called(t)
	return
}

// PubSubAdapterConfig_WithTracer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithTracer'
type PubSubAdapterConfig_WithTracer_Call struct {
	*mock.Call
}

// WithTracer is a helper method to define mock.On call
//   - t p2p.PubSubTracer
func (_e *PubSubAdapterConfig_Expecter) WithTracer(t interface{}) *PubSubAdapterConfig_WithTracer_Call {
	return &PubSubAdapterConfig_WithTracer_Call{Call: _e.mock.On("WithTracer", t)}
}

func (_c *PubSubAdapterConfig_WithTracer_Call) Run(run func(t p2p.PubSubTracer)) *PubSubAdapterConfig_WithTracer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 p2p.PubSubTracer
		if args[0] != nil {
			arg0 = args[0].(p2p.PubSubTracer)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PubSubAdapterConfig_WithTracer_Call) Return() *PubSubAdapterConfig_WithTracer_Call {
	_c.Call.Return()
	return _c
}

func (_c *PubSubAdapterConfig_WithTracer_Call) RunAndReturn(run func(t p2p.PubSubTracer)) *PubSubAdapterConfig_WithTracer_Call {
	_c.Run(run)
	return _c
}

// WithValidateQueueSize provides a mock function for the type PubSubAdapterConfig
func (_mock *PubSubAdapterConfig) WithValidateQueueSize(n int) {
	_mock.Called(n)
	return
}

// PubSubAdapterConfig_WithValidateQueueSize_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithValidateQueueSize'
type PubSubAdapterConfig_WithValidateQueueSize_Call struct {
	*mock.Call
}

// WithValidateQueueSize is a helper method to define mock.On call
//   - n int
func (_e *PubSubAdapterConfig_Expecter) WithValidateQueueSize(n interface{}) *PubSubAdapterConfig_WithValidateQueueSize_Call {
	return &PubSubAdapterConfig_WithValidateQueueSize_Call{Call: _e.mock.On("WithValidateQueueSize", n)}
}

func (_c *PubSubAdapterConfig_WithValidateQueueSize_Call) Run(run func(n int)) *PubSubAdapterConfig_WithValidateQueueSize_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 int
		if args[0] != nil {
			arg0 = args[0].(int)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PubSubAdapterConfig_WithValidateQueueSize_Call) Return() *PubSubAdapterConfig_WithValidateQueueSize_Call {
	_c.Call.Return()
	return _c
}

func (_c *PubSubAdapterConfig_WithValidateQueueSize_Call) RunAndReturn(run func(n int)) *PubSubAdapterConfig_WithValidateQueueSize_Call {
	_c.Run(run)
	return _c
}

// NewGossipSubRPCInspector creates a new instance of GossipSubRPCInspector. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewGossipSubRPCInspector(t interface {
	mock.TestingT
	Cleanup(func())
}) *GossipSubRPCInspector {
	mock := &GossipSubRPCInspector{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// GossipSubRPCInspector is an autogenerated mock type for the GossipSubRPCInspector type
type GossipSubRPCInspector struct {
	mock.Mock
}

type GossipSubRPCInspector_Expecter struct {
	mock *mock.Mock
}

func (_m *GossipSubRPCInspector) EXPECT() *GossipSubRPCInspector_Expecter {
	return &GossipSubRPCInspector_Expecter{mock: &_m.Mock}
}

// ActiveClustersChanged provides a mock function for the type GossipSubRPCInspector
func (_mock *GossipSubRPCInspector) ActiveClustersChanged(chainIDList flow.ChainIDList) {
	_mock.Called(chainIDList)
	return
}

// GossipSubRPCInspector_ActiveClustersChanged_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ActiveClustersChanged'
type GossipSubRPCInspector_ActiveClustersChanged_Call struct {
	*mock.Call
}

// ActiveClustersChanged is a helper method to define mock.On call
//   - chainIDList flow.ChainIDList
func (_e *GossipSubRPCInspector_Expecter) ActiveClustersChanged(chainIDList interface{}) *GossipSubRPCInspector_ActiveClustersChanged_Call {
	return &GossipSubRPCInspector_ActiveClustersChanged_Call{Call: _e.mock.On("ActiveClustersChanged", chainIDList)}
}

func (_c *GossipSubRPCInspector_ActiveClustersChanged_Call) Run(run func(chainIDList flow.ChainIDList)) *GossipSubRPCInspector_ActiveClustersChanged_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.ChainIDList
		if args[0] != nil {
			arg0 = args[0].(flow.ChainIDList)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *GossipSubRPCInspector_ActiveClustersChanged_Call) Return() *GossipSubRPCInspector_ActiveClustersChanged_Call {
	_c.Call.Return()
	return _c
}

func (_c *GossipSubRPCInspector_ActiveClustersChanged_Call) RunAndReturn(run func(chainIDList flow.ChainIDList)) *GossipSubRPCInspector_ActiveClustersChanged_Call {
	_c.Run(run)
	return _c
}

// Done provides a mock function for the type GossipSubRPCInspector
func (_mock *GossipSubRPCInspector) Done() <-chan struct{} {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Done")
	}

	var r0 <-chan struct{}
	if returnFunc, ok := ret.Get(0).(func() <-chan struct{}); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan struct{})
		}
	}
	return r0
}

// GossipSubRPCInspector_Done_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Done'
type GossipSubRPCInspector_Done_Call struct {
	*mock.Call
}

// Done is a helper method to define mock.On call
func (_e *GossipSubRPCInspector_Expecter) Done() *GossipSubRPCInspector_Done_Call {
	return &GossipSubRPCInspector_Done_Call{Call: _e.mock.On("Done")}
}

func (_c *GossipSubRPCInspector_Done_Call) Run(run func()) *GossipSubRPCInspector_Done_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *GossipSubRPCInspector_Done_Call) Return(valCh <-chan struct{}) *GossipSubRPCInspector_Done_Call {
	_c.Call.Return(valCh)
	return _c
}

func (_c *GossipSubRPCInspector_Done_Call) RunAndReturn(run func() <-chan struct{}) *GossipSubRPCInspector_Done_Call {
	_c.Call.Return(run)
	return _c
}

// Inspect provides a mock function for the type GossipSubRPCInspector
func (_mock *GossipSubRPCInspector) Inspect(iD peer.ID, rPC *pubsub.RPC) error {
	ret := _mock.Called(iD, rPC)

	if len(ret) == 0 {
		panic("no return value specified for Inspect")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(peer.ID, *pubsub.RPC) error); ok {
		r0 = returnFunc(iD, rPC)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// GossipSubRPCInspector_Inspect_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Inspect'
type GossipSubRPCInspector_Inspect_Call struct {
	*mock.Call
}

// Inspect is a helper method to define mock.On call
//   - iD peer.ID
//   - rPC *pubsub.RPC
func (_e *GossipSubRPCInspector_Expecter) Inspect(iD interface{}, rPC interface{}) *GossipSubRPCInspector_Inspect_Call {
	return &GossipSubRPCInspector_Inspect_Call{Call: _e.mock.On("Inspect", iD, rPC)}
}

func (_c *GossipSubRPCInspector_Inspect_Call) Run(run func(iD peer.ID, rPC *pubsub.RPC)) *GossipSubRPCInspector_Inspect_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 peer.ID
		if args[0] != nil {
			arg0 = args[0].(peer.ID)
		}
		var arg1 *pubsub.RPC
		if args[1] != nil {
			arg1 = args[1].(*pubsub.RPC)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *GossipSubRPCInspector_Inspect_Call) Return(err error) *GossipSubRPCInspector_Inspect_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *GossipSubRPCInspector_Inspect_Call) RunAndReturn(run func(iD peer.ID, rPC *pubsub.RPC) error) *GossipSubRPCInspector_Inspect_Call {
	_c.Call.Return(run)
	return _c
}

// Name provides a mock function for the type GossipSubRPCInspector
func (_mock *GossipSubRPCInspector) Name() string {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Name")
	}

	var r0 string
	if returnFunc, ok := ret.Get(0).(func() string); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(string)
	}
	return r0
}

// GossipSubRPCInspector_Name_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Name'
type GossipSubRPCInspector_Name_Call struct {
	*mock.Call
}

// Name is a helper method to define mock.On call
func (_e *GossipSubRPCInspector_Expecter) Name() *GossipSubRPCInspector_Name_Call {
	return &GossipSubRPCInspector_Name_Call{Call: _e.mock.On("Name")}
}

func (_c *GossipSubRPCInspector_Name_Call) Run(run func()) *GossipSubRPCInspector_Name_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *GossipSubRPCInspector_Name_Call) Return(s string) *GossipSubRPCInspector_Name_Call {
	_c.Call.Return(s)
	return _c
}

func (_c *GossipSubRPCInspector_Name_Call) RunAndReturn(run func() string) *GossipSubRPCInspector_Name_Call {
	_c.Call.Return(run)
	return _c
}

// Ready provides a mock function for the type GossipSubRPCInspector
func (_mock *GossipSubRPCInspector) Ready() <-chan struct{} {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Ready")
	}

	var r0 <-chan struct{}
	if returnFunc, ok := ret.Get(0).(func() <-chan struct{}); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan struct{})
		}
	}
	return r0
}

// GossipSubRPCInspector_Ready_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Ready'
type GossipSubRPCInspector_Ready_Call struct {
	*mock.Call
}

// Ready is a helper method to define mock.On call
func (_e *GossipSubRPCInspector_Expecter) Ready() *GossipSubRPCInspector_Ready_Call {
	return &GossipSubRPCInspector_Ready_Call{Call: _e.mock.On("Ready")}
}

func (_c *GossipSubRPCInspector_Ready_Call) Run(run func()) *GossipSubRPCInspector_Ready_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *GossipSubRPCInspector_Ready_Call) Return(valCh <-chan struct{}) *GossipSubRPCInspector_Ready_Call {
	_c.Call.Return(valCh)
	return _c
}

func (_c *GossipSubRPCInspector_Ready_Call) RunAndReturn(run func() <-chan struct{}) *GossipSubRPCInspector_Ready_Call {
	_c.Call.Return(run)
	return _c
}

// Start provides a mock function for the type GossipSubRPCInspector
func (_mock *GossipSubRPCInspector) Start(signalerContext irrecoverable.SignalerContext) {
	_mock.Called(signalerContext)
	return
}

// GossipSubRPCInspector_Start_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Start'
type GossipSubRPCInspector_Start_Call struct {
	*mock.Call
}

// Start is a helper method to define mock.On call
//   - signalerContext irrecoverable.SignalerContext
func (_e *GossipSubRPCInspector_Expecter) Start(signalerContext interface{}) *GossipSubRPCInspector_Start_Call {
	return &GossipSubRPCInspector_Start_Call{Call: _e.mock.On("Start", signalerContext)}
}

func (_c *GossipSubRPCInspector_Start_Call) Run(run func(signalerContext irrecoverable.SignalerContext)) *GossipSubRPCInspector_Start_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 irrecoverable.SignalerContext
		if args[0] != nil {
			arg0 = args[0].(irrecoverable.SignalerContext)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *GossipSubRPCInspector_Start_Call) Return() *GossipSubRPCInspector_Start_Call {
	_c.Call.Return()
	return _c
}

func (_c *GossipSubRPCInspector_Start_Call) RunAndReturn(run func(signalerContext irrecoverable.SignalerContext)) *GossipSubRPCInspector_Start_Call {
	_c.Run(run)
	return _c
}

// NewTopic creates a new instance of Topic. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewTopic(t interface {
	mock.TestingT
	Cleanup(func())
}) *Topic {
	mock := &Topic{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Topic is an autogenerated mock type for the Topic type
type Topic struct {
	mock.Mock
}

type Topic_Expecter struct {
	mock *mock.Mock
}

func (_m *Topic) EXPECT() *Topic_Expecter {
	return &Topic_Expecter{mock: &_m.Mock}
}

// Close provides a mock function for the type Topic
func (_mock *Topic) Close() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Close")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Topic_Close_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Close'
type Topic_Close_Call struct {
	*mock.Call
}

// Close is a helper method to define mock.On call
func (_e *Topic_Expecter) Close() *Topic_Close_Call {
	return &Topic_Close_Call{Call: _e.mock.On("Close")}
}

func (_c *Topic_Close_Call) Run(run func()) *Topic_Close_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Topic_Close_Call) Return(err error) *Topic_Close_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Topic_Close_Call) RunAndReturn(run func() error) *Topic_Close_Call {
	_c.Call.Return(run)
	return _c
}

// Publish provides a mock function for the type Topic
func (_mock *Topic) Publish(context1 context.Context, bytes []byte) error {
	ret := _mock.Called(context1, bytes)

	if len(ret) == 0 {
		panic("no return value specified for Publish")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, []byte) error); ok {
		r0 = returnFunc(context1, bytes)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Topic_Publish_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Publish'
type Topic_Publish_Call struct {
	*mock.Call
}

// Publish is a helper method to define mock.On call
//   - context1 context.Context
//   - bytes []byte
func (_e *Topic_Expecter) Publish(context1 interface{}, bytes interface{}) *Topic_Publish_Call {
	return &Topic_Publish_Call{Call: _e.mock.On("Publish", context1, bytes)}
}

func (_c *Topic_Publish_Call) Run(run func(context1 context.Context, bytes []byte)) *Topic_Publish_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 []byte
		if args[1] != nil {
			arg1 = args[1].([]byte)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Topic_Publish_Call) Return(err error) *Topic_Publish_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Topic_Publish_Call) RunAndReturn(run func(context1 context.Context, bytes []byte) error) *Topic_Publish_Call {
	_c.Call.Return(run)
	return _c
}

// String provides a mock function for the type Topic
func (_mock *Topic) String() string {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for String")
	}

	var r0 string
	if returnFunc, ok := ret.Get(0).(func() string); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(string)
	}
	return r0
}

// Topic_String_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'String'
type Topic_String_Call struct {
	*mock.Call
}

// String is a helper method to define mock.On call
func (_e *Topic_Expecter) String() *Topic_String_Call {
	return &Topic_String_Call{Call: _e.mock.On("String")}
}

func (_c *Topic_String_Call) Run(run func()) *Topic_String_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Topic_String_Call) Return(s string) *Topic_String_Call {
	_c.Call.Return(s)
	return _c
}

func (_c *Topic_String_Call) RunAndReturn(run func() string) *Topic_String_Call {
	_c.Call.Return(run)
	return _c
}

// Subscribe provides a mock function for the type Topic
func (_mock *Topic) Subscribe() (p2p.Subscription, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Subscribe")
	}

	var r0 p2p.Subscription
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (p2p.Subscription, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() p2p.Subscription); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(p2p.Subscription)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Topic_Subscribe_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Subscribe'
type Topic_Subscribe_Call struct {
	*mock.Call
}

// Subscribe is a helper method to define mock.On call
func (_e *Topic_Expecter) Subscribe() *Topic_Subscribe_Call {
	return &Topic_Subscribe_Call{Call: _e.mock.On("Subscribe")}
}

func (_c *Topic_Subscribe_Call) Run(run func()) *Topic_Subscribe_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Topic_Subscribe_Call) Return(subscription p2p.Subscription, err error) *Topic_Subscribe_Call {
	_c.Call.Return(subscription, err)
	return _c
}

func (_c *Topic_Subscribe_Call) RunAndReturn(run func() (p2p.Subscription, error)) *Topic_Subscribe_Call {
	_c.Call.Return(run)
	return _c
}

// NewScoreOptionBuilder creates a new instance of ScoreOptionBuilder. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewScoreOptionBuilder(t interface {
	mock.TestingT
	Cleanup(func())
}) *ScoreOptionBuilder {
	mock := &ScoreOptionBuilder{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// ScoreOptionBuilder is an autogenerated mock type for the ScoreOptionBuilder type
type ScoreOptionBuilder struct {
	mock.Mock
}

type ScoreOptionBuilder_Expecter struct {
	mock *mock.Mock
}

func (_m *ScoreOptionBuilder) EXPECT() *ScoreOptionBuilder_Expecter {
	return &ScoreOptionBuilder_Expecter{mock: &_m.Mock}
}

// BuildFlowPubSubScoreOption provides a mock function for the type ScoreOptionBuilder
func (_mock *ScoreOptionBuilder) BuildFlowPubSubScoreOption() (*pubsub.PeerScoreParams, *pubsub.PeerScoreThresholds) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for BuildFlowPubSubScoreOption")
	}

	var r0 *pubsub.PeerScoreParams
	var r1 *pubsub.PeerScoreThresholds
	if returnFunc, ok := ret.Get(0).(func() (*pubsub.PeerScoreParams, *pubsub.PeerScoreThresholds)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() *pubsub.PeerScoreParams); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pubsub.PeerScoreParams)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() *pubsub.PeerScoreThresholds); ok {
		r1 = returnFunc()
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*pubsub.PeerScoreThresholds)
		}
	}
	return r0, r1
}

// ScoreOptionBuilder_BuildFlowPubSubScoreOption_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BuildFlowPubSubScoreOption'
type ScoreOptionBuilder_BuildFlowPubSubScoreOption_Call struct {
	*mock.Call
}

// BuildFlowPubSubScoreOption is a helper method to define mock.On call
func (_e *ScoreOptionBuilder_Expecter) BuildFlowPubSubScoreOption() *ScoreOptionBuilder_BuildFlowPubSubScoreOption_Call {
	return &ScoreOptionBuilder_BuildFlowPubSubScoreOption_Call{Call: _e.mock.On("BuildFlowPubSubScoreOption")}
}

func (_c *ScoreOptionBuilder_BuildFlowPubSubScoreOption_Call) Run(run func()) *ScoreOptionBuilder_BuildFlowPubSubScoreOption_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ScoreOptionBuilder_BuildFlowPubSubScoreOption_Call) Return(peerScoreParams *pubsub.PeerScoreParams, peerScoreThresholds *pubsub.PeerScoreThresholds) *ScoreOptionBuilder_BuildFlowPubSubScoreOption_Call {
	_c.Call.Return(peerScoreParams, peerScoreThresholds)
	return _c
}

func (_c *ScoreOptionBuilder_BuildFlowPubSubScoreOption_Call) RunAndReturn(run func() (*pubsub.PeerScoreParams, *pubsub.PeerScoreThresholds)) *ScoreOptionBuilder_BuildFlowPubSubScoreOption_Call {
	_c.Call.Return(run)
	return _c
}

// Done provides a mock function for the type ScoreOptionBuilder
func (_mock *ScoreOptionBuilder) Done() <-chan struct{} {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Done")
	}

	var r0 <-chan struct{}
	if returnFunc, ok := ret.Get(0).(func() <-chan struct{}); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan struct{})
		}
	}
	return r0
}

// ScoreOptionBuilder_Done_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Done'
type ScoreOptionBuilder_Done_Call struct {
	*mock.Call
}

// Done is a helper method to define mock.On call
func (_e *ScoreOptionBuilder_Expecter) Done() *ScoreOptionBuilder_Done_Call {
	return &ScoreOptionBuilder_Done_Call{Call: _e.mock.On("Done")}
}

func (_c *ScoreOptionBuilder_Done_Call) Run(run func()) *ScoreOptionBuilder_Done_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ScoreOptionBuilder_Done_Call) Return(valCh <-chan struct{}) *ScoreOptionBuilder_Done_Call {
	_c.Call.Return(valCh)
	return _c
}

func (_c *ScoreOptionBuilder_Done_Call) RunAndReturn(run func() <-chan struct{}) *ScoreOptionBuilder_Done_Call {
	_c.Call.Return(run)
	return _c
}

// Ready provides a mock function for the type ScoreOptionBuilder
func (_mock *ScoreOptionBuilder) Ready() <-chan struct{} {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Ready")
	}

	var r0 <-chan struct{}
	if returnFunc, ok := ret.Get(0).(func() <-chan struct{}); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan struct{})
		}
	}
	return r0
}

// ScoreOptionBuilder_Ready_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Ready'
type ScoreOptionBuilder_Ready_Call struct {
	*mock.Call
}

// Ready is a helper method to define mock.On call
func (_e *ScoreOptionBuilder_Expecter) Ready() *ScoreOptionBuilder_Ready_Call {
	return &ScoreOptionBuilder_Ready_Call{Call: _e.mock.On("Ready")}
}

func (_c *ScoreOptionBuilder_Ready_Call) Run(run func()) *ScoreOptionBuilder_Ready_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ScoreOptionBuilder_Ready_Call) Return(valCh <-chan struct{}) *ScoreOptionBuilder_Ready_Call {
	_c.Call.Return(valCh)
	return _c
}

func (_c *ScoreOptionBuilder_Ready_Call) RunAndReturn(run func() <-chan struct{}) *ScoreOptionBuilder_Ready_Call {
	_c.Call.Return(run)
	return _c
}

// Start provides a mock function for the type ScoreOptionBuilder
func (_mock *ScoreOptionBuilder) Start(signalerContext irrecoverable.SignalerContext) {
	_mock.Called(signalerContext)
	return
}

// ScoreOptionBuilder_Start_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Start'
type ScoreOptionBuilder_Start_Call struct {
	*mock.Call
}

// Start is a helper method to define mock.On call
//   - signalerContext irrecoverable.SignalerContext
func (_e *ScoreOptionBuilder_Expecter) Start(signalerContext interface{}) *ScoreOptionBuilder_Start_Call {
	return &ScoreOptionBuilder_Start_Call{Call: _e.mock.On("Start", signalerContext)}
}

func (_c *ScoreOptionBuilder_Start_Call) Run(run func(signalerContext irrecoverable.SignalerContext)) *ScoreOptionBuilder_Start_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 irrecoverable.SignalerContext
		if args[0] != nil {
			arg0 = args[0].(irrecoverable.SignalerContext)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ScoreOptionBuilder_Start_Call) Return() *ScoreOptionBuilder_Start_Call {
	_c.Call.Return()
	return _c
}

func (_c *ScoreOptionBuilder_Start_Call) RunAndReturn(run func(signalerContext irrecoverable.SignalerContext)) *ScoreOptionBuilder_Start_Call {
	_c.Run(run)
	return _c
}

// TopicScoreParams provides a mock function for the type ScoreOptionBuilder
func (_mock *ScoreOptionBuilder) TopicScoreParams(topic *pubsub.Topic) *pubsub.TopicScoreParams {
	ret := _mock.Called(topic)

	if len(ret) == 0 {
		panic("no return value specified for TopicScoreParams")
	}

	var r0 *pubsub.TopicScoreParams
	if returnFunc, ok := ret.Get(0).(func(*pubsub.Topic) *pubsub.TopicScoreParams); ok {
		r0 = returnFunc(topic)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pubsub.TopicScoreParams)
		}
	}
	return r0
}

// ScoreOptionBuilder_TopicScoreParams_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TopicScoreParams'
type ScoreOptionBuilder_TopicScoreParams_Call struct {
	*mock.Call
}

// TopicScoreParams is a helper method to define mock.On call
//   - topic *pubsub.Topic
func (_e *ScoreOptionBuilder_Expecter) TopicScoreParams(topic interface{}) *ScoreOptionBuilder_TopicScoreParams_Call {
	return &ScoreOptionBuilder_TopicScoreParams_Call{Call: _e.mock.On("TopicScoreParams", topic)}
}

func (_c *ScoreOptionBuilder_TopicScoreParams_Call) Run(run func(topic *pubsub.Topic)) *ScoreOptionBuilder_TopicScoreParams_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *pubsub.Topic
		if args[0] != nil {
			arg0 = args[0].(*pubsub.Topic)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ScoreOptionBuilder_TopicScoreParams_Call) Return(topicScoreParams *pubsub.TopicScoreParams) *ScoreOptionBuilder_TopicScoreParams_Call {
	_c.Call.Return(topicScoreParams)
	return _c
}

func (_c *ScoreOptionBuilder_TopicScoreParams_Call) RunAndReturn(run func(topic *pubsub.Topic) *pubsub.TopicScoreParams) *ScoreOptionBuilder_TopicScoreParams_Call {
	_c.Call.Return(run)
	return _c
}

// NewSubscription creates a new instance of Subscription. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewSubscription(t interface {
	mock.TestingT
	Cleanup(func())
}) *Subscription {
	mock := &Subscription{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Subscription is an autogenerated mock type for the Subscription type
type Subscription struct {
	mock.Mock
}

type Subscription_Expecter struct {
	mock *mock.Mock
}

func (_m *Subscription) EXPECT() *Subscription_Expecter {
	return &Subscription_Expecter{mock: &_m.Mock}
}

// Cancel provides a mock function for the type Subscription
func (_mock *Subscription) Cancel() {
	_mock.Called()
	return
}

// Subscription_Cancel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Cancel'
type Subscription_Cancel_Call struct {
	*mock.Call
}

// Cancel is a helper method to define mock.On call
func (_e *Subscription_Expecter) Cancel() *Subscription_Cancel_Call {
	return &Subscription_Cancel_Call{Call: _e.mock.On("Cancel")}
}

func (_c *Subscription_Cancel_Call) Run(run func()) *Subscription_Cancel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Subscription_Cancel_Call) Return() *Subscription_Cancel_Call {
	_c.Call.Return()
	return _c
}

func (_c *Subscription_Cancel_Call) RunAndReturn(run func()) *Subscription_Cancel_Call {
	_c.Run(run)
	return _c
}

// Next provides a mock function for the type Subscription
func (_mock *Subscription) Next(context1 context.Context) (*pubsub.Message, error) {
	ret := _mock.Called(context1)

	if len(ret) == 0 {
		panic("no return value specified for Next")
	}

	var r0 *pubsub.Message
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (*pubsub.Message, error)); ok {
		return returnFunc(context1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) *pubsub.Message); ok {
		r0 = returnFunc(context1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pubsub.Message)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(context1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Subscription_Next_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Next'
type Subscription_Next_Call struct {
	*mock.Call
}

// Next is a helper method to define mock.On call
//   - context1 context.Context
func (_e *Subscription_Expecter) Next(context1 interface{}) *Subscription_Next_Call {
	return &Subscription_Next_Call{Call: _e.mock.On("Next", context1)}
}

func (_c *Subscription_Next_Call) Run(run func(context1 context.Context)) *Subscription_Next_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Subscription_Next_Call) Return(message *pubsub.Message, err error) *Subscription_Next_Call {
	_c.Call.Return(message, err)
	return _c
}

func (_c *Subscription_Next_Call) RunAndReturn(run func(context1 context.Context) (*pubsub.Message, error)) *Subscription_Next_Call {
	_c.Call.Return(run)
	return _c
}

// Topic provides a mock function for the type Subscription
func (_mock *Subscription) Topic() string {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Topic")
	}

	var r0 string
	if returnFunc, ok := ret.Get(0).(func() string); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(string)
	}
	return r0
}

// Subscription_Topic_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Topic'
type Subscription_Topic_Call struct {
	*mock.Call
}

// Topic is a helper method to define mock.On call
func (_e *Subscription_Expecter) Topic() *Subscription_Topic_Call {
	return &Subscription_Topic_Call{Call: _e.mock.On("Topic")}
}

func (_c *Subscription_Topic_Call) Run(run func()) *Subscription_Topic_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Subscription_Topic_Call) Return(s string) *Subscription_Topic_Call {
	_c.Call.Return(s)
	return _c
}

func (_c *Subscription_Topic_Call) RunAndReturn(run func() string) *Subscription_Topic_Call {
	_c.Call.Return(run)
	return _c
}

// NewSubscriptionFilter creates a new instance of SubscriptionFilter. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewSubscriptionFilter(t interface {
	mock.TestingT
	Cleanup(func())
}) *SubscriptionFilter {
	mock := &SubscriptionFilter{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// SubscriptionFilter is an autogenerated mock type for the SubscriptionFilter type
type SubscriptionFilter struct {
	mock.Mock
}

type SubscriptionFilter_Expecter struct {
	mock *mock.Mock
}

func (_m *SubscriptionFilter) EXPECT() *SubscriptionFilter_Expecter {
	return &SubscriptionFilter_Expecter{mock: &_m.Mock}
}

// CanSubscribe provides a mock function for the type SubscriptionFilter
func (_mock *SubscriptionFilter) CanSubscribe(s string) bool {
	ret := _mock.Called(s)

	if len(ret) == 0 {
		panic("no return value specified for CanSubscribe")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(string) bool); ok {
		r0 = returnFunc(s)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// SubscriptionFilter_CanSubscribe_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CanSubscribe'
type SubscriptionFilter_CanSubscribe_Call struct {
	*mock.Call
}

// CanSubscribe is a helper method to define mock.On call
//   - s string
func (_e *SubscriptionFilter_Expecter) CanSubscribe(s interface{}) *SubscriptionFilter_CanSubscribe_Call {
	return &SubscriptionFilter_CanSubscribe_Call{Call: _e.mock.On("CanSubscribe", s)}
}

func (_c *SubscriptionFilter_CanSubscribe_Call) Run(run func(s string)) *SubscriptionFilter_CanSubscribe_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *SubscriptionFilter_CanSubscribe_Call) Return(b bool) *SubscriptionFilter_CanSubscribe_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *SubscriptionFilter_CanSubscribe_Call) RunAndReturn(run func(s string) bool) *SubscriptionFilter_CanSubscribe_Call {
	_c.Call.Return(run)
	return _c
}

// FilterIncomingSubscriptions provides a mock function for the type SubscriptionFilter
func (_mock *SubscriptionFilter) FilterIncomingSubscriptions(iD peer.ID, rPC_SubOptss []*pubsub_pb.RPC_SubOpts) ([]*pubsub_pb.RPC_SubOpts, error) {
	ret := _mock.Called(iD, rPC_SubOptss)

	if len(ret) == 0 {
		panic("no return value specified for FilterIncomingSubscriptions")
	}

	var r0 []*pubsub_pb.RPC_SubOpts
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(peer.ID, []*pubsub_pb.RPC_SubOpts) ([]*pubsub_pb.RPC_SubOpts, error)); ok {
		return returnFunc(iD, rPC_SubOptss)
	}
	if returnFunc, ok := ret.Get(0).(func(peer.ID, []*pubsub_pb.RPC_SubOpts) []*pubsub_pb.RPC_SubOpts); ok {
		r0 = returnFunc(iD, rPC_SubOptss)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*pubsub_pb.RPC_SubOpts)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(peer.ID, []*pubsub_pb.RPC_SubOpts) error); ok {
		r1 = returnFunc(iD, rPC_SubOptss)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// SubscriptionFilter_FilterIncomingSubscriptions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FilterIncomingSubscriptions'
type SubscriptionFilter_FilterIncomingSubscriptions_Call struct {
	*mock.Call
}

// FilterIncomingSubscriptions is a helper method to define mock.On call
//   - iD peer.ID
//   - rPC_SubOptss []*pubsub_pb.RPC_SubOpts
func (_e *SubscriptionFilter_Expecter) FilterIncomingSubscriptions(iD interface{}, rPC_SubOptss interface{}) *SubscriptionFilter_FilterIncomingSubscriptions_Call {
	return &SubscriptionFilter_FilterIncomingSubscriptions_Call{Call: _e.mock.On("FilterIncomingSubscriptions", iD, rPC_SubOptss)}
}

func (_c *SubscriptionFilter_FilterIncomingSubscriptions_Call) Run(run func(iD peer.ID, rPC_SubOptss []*pubsub_pb.RPC_SubOpts)) *SubscriptionFilter_FilterIncomingSubscriptions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 peer.ID
		if args[0] != nil {
			arg0 = args[0].(peer.ID)
		}
		var arg1 []*pubsub_pb.RPC_SubOpts
		if args[1] != nil {
			arg1 = args[1].([]*pubsub_pb.RPC_SubOpts)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *SubscriptionFilter_FilterIncomingSubscriptions_Call) Return(rPC_SubOptss1 []*pubsub_pb.RPC_SubOpts, err error) *SubscriptionFilter_FilterIncomingSubscriptions_Call {
	_c.Call.Return(rPC_SubOptss1, err)
	return _c
}

func (_c *SubscriptionFilter_FilterIncomingSubscriptions_Call) RunAndReturn(run func(iD peer.ID, rPC_SubOptss []*pubsub_pb.RPC_SubOpts) ([]*pubsub_pb.RPC_SubOpts, error)) *SubscriptionFilter_FilterIncomingSubscriptions_Call {
	_c.Call.Return(run)
	return _c
}

// NewPubSubTracer creates a new instance of PubSubTracer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewPubSubTracer(t interface {
	mock.TestingT
	Cleanup(func())
}) *PubSubTracer {
	mock := &PubSubTracer{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// PubSubTracer is an autogenerated mock type for the PubSubTracer type
type PubSubTracer struct {
	mock.Mock
}

type PubSubTracer_Expecter struct {
	mock *mock.Mock
}

func (_m *PubSubTracer) EXPECT() *PubSubTracer_Expecter {
	return &PubSubTracer_Expecter{mock: &_m.Mock}
}

// AddPeer provides a mock function for the type PubSubTracer
func (_mock *PubSubTracer) AddPeer(p peer.ID, proto protocol.ID) {
	_mock.Called(p, proto)
	return
}

// PubSubTracer_AddPeer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddPeer'
type PubSubTracer_AddPeer_Call struct {
	*mock.Call
}

// AddPeer is a helper method to define mock.On call
//   - p peer.ID
//   - proto protocol.ID
func (_e *PubSubTracer_Expecter) AddPeer(p interface{}, proto interface{}) *PubSubTracer_AddPeer_Call {
	return &PubSubTracer_AddPeer_Call{Call: _e.mock.On("AddPeer", p, proto)}
}

func (_c *PubSubTracer_AddPeer_Call) Run(run func(p peer.ID, proto protocol.ID)) *PubSubTracer_AddPeer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 peer.ID
		if args[0] != nil {
			arg0 = args[0].(peer.ID)
		}
		var arg1 protocol.ID
		if args[1] != nil {
			arg1 = args[1].(protocol.ID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *PubSubTracer_AddPeer_Call) Return() *PubSubTracer_AddPeer_Call {
	_c.Call.Return()
	return _c
}

func (_c *PubSubTracer_AddPeer_Call) RunAndReturn(run func(p peer.ID, proto protocol.ID)) *PubSubTracer_AddPeer_Call {
	_c.Run(run)
	return _c
}

// DeliverMessage provides a mock function for the type PubSubTracer
func (_mock *PubSubTracer) DeliverMessage(msg *pubsub.Message) {
	_mock.Called(msg)
	return
}

// PubSubTracer_DeliverMessage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeliverMessage'
type PubSubTracer_DeliverMessage_Call struct {
	*mock.Call
}

// DeliverMessage is a helper method to define mock.On call
//   - msg *pubsub.Message
func (_e *PubSubTracer_Expecter) DeliverMessage(msg interface{}) *PubSubTracer_DeliverMessage_Call {
	return &PubSubTracer_DeliverMessage_Call{Call: _e.mock.On("DeliverMessage", msg)}
}

func (_c *PubSubTracer_DeliverMessage_Call) Run(run func(msg *pubsub.Message)) *PubSubTracer_DeliverMessage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *pubsub.Message
		if args[0] != nil {
			arg0 = args[0].(*pubsub.Message)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PubSubTracer_DeliverMessage_Call) Return() *PubSubTracer_DeliverMessage_Call {
	_c.Call.Return()
	return _c
}

func (_c *PubSubTracer_DeliverMessage_Call) RunAndReturn(run func(msg *pubsub.Message)) *PubSubTracer_DeliverMessage_Call {
	_c.Run(run)
	return _c
}

// Done provides a mock function for the type PubSubTracer
func (_mock *PubSubTracer) Done() <-chan struct{} {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Done")
	}

	var r0 <-chan struct{}
	if returnFunc, ok := ret.Get(0).(func() <-chan struct{}); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan struct{})
		}
	}
	return r0
}

// PubSubTracer_Done_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Done'
type PubSubTracer_Done_Call struct {
	*mock.Call
}

// Done is a helper method to define mock.On call
func (_e *PubSubTracer_Expecter) Done() *PubSubTracer_Done_Call {
	return &PubSubTracer_Done_Call{Call: _e.mock.On("Done")}
}

func (_c *PubSubTracer_Done_Call) Run(run func()) *PubSubTracer_Done_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *PubSubTracer_Done_Call) Return(valCh <-chan struct{}) *PubSubTracer_Done_Call {
	_c.Call.Return(valCh)
	return _c
}

func (_c *PubSubTracer_Done_Call) RunAndReturn(run func() <-chan struct{}) *PubSubTracer_Done_Call {
	_c.Call.Return(run)
	return _c
}

// DropRPC provides a mock function for the type PubSubTracer
func (_mock *PubSubTracer) DropRPC(rpc *pubsub.RPC, p peer.ID) {
	_mock.Called(rpc, p)
	return
}

// PubSubTracer_DropRPC_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DropRPC'
type PubSubTracer_DropRPC_Call struct {
	*mock.Call
}

// DropRPC is a helper method to define mock.On call
//   - rpc *pubsub.RPC
//   - p peer.ID
func (_e *PubSubTracer_Expecter) DropRPC(rpc interface{}, p interface{}) *PubSubTracer_DropRPC_Call {
	return &PubSubTracer_DropRPC_Call{Call: _e.mock.On("DropRPC", rpc, p)}
}

func (_c *PubSubTracer_DropRPC_Call) Run(run func(rpc *pubsub.RPC, p peer.ID)) *PubSubTracer_DropRPC_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *pubsub.RPC
		if args[0] != nil {
			arg0 = args[0].(*pubsub.RPC)
		}
		var arg1 peer.ID
		if args[1] != nil {
			arg1 = args[1].(peer.ID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *PubSubTracer_DropRPC_Call) Return() *PubSubTracer_DropRPC_Call {
	_c.Call.Return()
	return _c
}

func (_c *PubSubTracer_DropRPC_Call) RunAndReturn(run func(rpc *pubsub.RPC, p peer.ID)) *PubSubTracer_DropRPC_Call {
	_c.Run(run)
	return _c
}

// DuplicateMessage provides a mock function for the type PubSubTracer
func (_mock *PubSubTracer) DuplicateMessage(msg *pubsub.Message) {
	_mock.Called(msg)
	return
}

// PubSubTracer_DuplicateMessage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DuplicateMessage'
type PubSubTracer_DuplicateMessage_Call struct {
	*mock.Call
}

// DuplicateMessage is a helper method to define mock.On call
//   - msg *pubsub.Message
func (_e *PubSubTracer_Expecter) DuplicateMessage(msg interface{}) *PubSubTracer_DuplicateMessage_Call {
	return &PubSubTracer_DuplicateMessage_Call{Call: _e.mock.On("DuplicateMessage", msg)}
}

func (_c *PubSubTracer_DuplicateMessage_Call) Run(run func(msg *pubsub.Message)) *PubSubTracer_DuplicateMessage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *pubsub.Message
		if args[0] != nil {
			arg0 = args[0].(*pubsub.Message)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PubSubTracer_DuplicateMessage_Call) Return() *PubSubTracer_DuplicateMessage_Call {
	_c.Call.Return()
	return _c
}

func (_c *PubSubTracer_DuplicateMessage_Call) RunAndReturn(run func(msg *pubsub.Message)) *PubSubTracer_DuplicateMessage_Call {
	_c.Run(run)
	return _c
}

// DuplicateMessageCount provides a mock function for the type PubSubTracer
func (_mock *PubSubTracer) DuplicateMessageCount(iD peer.ID) float64 {
	ret := _mock.Called(iD)

	if len(ret) == 0 {
		panic("no return value specified for DuplicateMessageCount")
	}

	var r0 float64
	if returnFunc, ok := ret.Get(0).(func(peer.ID) float64); ok {
		r0 = returnFunc(iD)
	} else {
		r0 = ret.Get(0).(float64)
	}
	return r0
}

// PubSubTracer_DuplicateMessageCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DuplicateMessageCount'
type PubSubTracer_DuplicateMessageCount_Call struct {
	*mock.Call
}

// DuplicateMessageCount is a helper method to define mock.On call
//   - iD peer.ID
func (_e *PubSubTracer_Expecter) DuplicateMessageCount(iD interface{}) *PubSubTracer_DuplicateMessageCount_Call {
	return &PubSubTracer_DuplicateMessageCount_Call{Call: _e.mock.On("DuplicateMessageCount", iD)}
}

func (_c *PubSubTracer_DuplicateMessageCount_Call) Run(run func(iD peer.ID)) *PubSubTracer_DuplicateMessageCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 peer.ID
		if args[0] != nil {
			arg0 = args[0].(peer.ID)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PubSubTracer_DuplicateMessageCount_Call) Return(f float64) *PubSubTracer_DuplicateMessageCount_Call {
	_c.Call.Return(f)
	return _c
}

func (_c *PubSubTracer_DuplicateMessageCount_Call) RunAndReturn(run func(iD peer.ID) float64) *PubSubTracer_DuplicateMessageCount_Call {
	_c.Call.Return(run)
	return _c
}

// GetLocalMeshPeers provides a mock function for the type PubSubTracer
func (_mock *PubSubTracer) GetLocalMeshPeers(topic channels.Topic) []peer.ID {
	ret := _mock.Called(topic)

	if len(ret) == 0 {
		panic("no return value specified for GetLocalMeshPeers")
	}

	var r0 []peer.ID
	if returnFunc, ok := ret.Get(0).(func(channels.Topic) []peer.ID); ok {
		r0 = returnFunc(topic)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]peer.ID)
		}
	}
	return r0
}

// PubSubTracer_GetLocalMeshPeers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLocalMeshPeers'
type PubSubTracer_GetLocalMeshPeers_Call struct {
	*mock.Call
}

// GetLocalMeshPeers is a helper method to define mock.On call
//   - topic channels.Topic
func (_e *PubSubTracer_Expecter) GetLocalMeshPeers(topic interface{}) *PubSubTracer_GetLocalMeshPeers_Call {
	return &PubSubTracer_GetLocalMeshPeers_Call{Call: _e.mock.On("GetLocalMeshPeers", topic)}
}

func (_c *PubSubTracer_GetLocalMeshPeers_Call) Run(run func(topic channels.Topic)) *PubSubTracer_GetLocalMeshPeers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 channels.Topic
		if args[0] != nil {
			arg0 = args[0].(channels.Topic)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PubSubTracer_GetLocalMeshPeers_Call) Return(iDs []peer.ID) *PubSubTracer_GetLocalMeshPeers_Call {
	_c.Call.Return(iDs)
	return _c
}

func (_c *PubSubTracer_GetLocalMeshPeers_Call) RunAndReturn(run func(topic channels.Topic) []peer.ID) *PubSubTracer_GetLocalMeshPeers_Call {
	_c.Call.Return(run)
	return _c
}

// Graft provides a mock function for the type PubSubTracer
func (_mock *PubSubTracer) Graft(p peer.ID, topic string) {
	_mock.Called(p, topic)
	return
}

// PubSubTracer_Graft_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Graft'
type PubSubTracer_Graft_Call struct {
	*mock.Call
}

// Graft is a helper method to define mock.On call
//   - p peer.ID
//   - topic string
func (_e *PubSubTracer_Expecter) Graft(p interface{}, topic interface{}) *PubSubTracer_Graft_Call {
	return &PubSubTracer_Graft_Call{Call: _e.mock.On("Graft", p, topic)}
}

func (_c *PubSubTracer_Graft_Call) Run(run func(p peer.ID, topic string)) *PubSubTracer_Graft_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 peer.ID
		if args[0] != nil {
			arg0 = args[0].(peer.ID)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *PubSubTracer_Graft_Call) Return() *PubSubTracer_Graft_Call {
	_c.Call.Return()
	return _c
}

func (_c *PubSubTracer_Graft_Call) RunAndReturn(run func(p peer.ID, topic string)) *PubSubTracer_Graft_Call {
	_c.Run(run)
	return _c
}

// Join provides a mock function for the type PubSubTracer
func (_mock *PubSubTracer) Join(topic string) {
	_mock.Called(topic)
	return
}

// PubSubTracer_Join_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Join'
type PubSubTracer_Join_Call struct {
	*mock.Call
}

// Join is a helper method to define mock.On call
//   - topic string
func (_e *PubSubTracer_Expecter) Join(topic interface{}) *PubSubTracer_Join_Call {
	return &PubSubTracer_Join_Call{Call: _e.mock.On("Join", topic)}
}

func (_c *PubSubTracer_Join_Call) Run(run func(topic string)) *PubSubTracer_Join_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PubSubTracer_Join_Call) Return() *PubSubTracer_Join_Call {
	_c.Call.Return()
	return _c
}

func (_c *PubSubTracer_Join_Call) RunAndReturn(run func(topic string)) *PubSubTracer_Join_Call {
	_c.Run(run)
	return _c
}

// LastHighestIHaveRPCSize provides a mock function for the type PubSubTracer
func (_mock *PubSubTracer) LastHighestIHaveRPCSize() int64 {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for LastHighestIHaveRPCSize")
	}

	var r0 int64
	if returnFunc, ok := ret.Get(0).(func() int64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(int64)
	}
	return r0
}

// PubSubTracer_LastHighestIHaveRPCSize_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LastHighestIHaveRPCSize'
type PubSubTracer_LastHighestIHaveRPCSize_Call struct {
	*mock.Call
}

// LastHighestIHaveRPCSize is a helper method to define mock.On call
func (_e *PubSubTracer_Expecter) LastHighestIHaveRPCSize() *PubSubTracer_LastHighestIHaveRPCSize_Call {
	return &PubSubTracer_LastHighestIHaveRPCSize_Call{Call: _e.mock.On("LastHighestIHaveRPCSize")}
}

func (_c *PubSubTracer_LastHighestIHaveRPCSize_Call) Run(run func()) *PubSubTracer_LastHighestIHaveRPCSize_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *PubSubTracer_LastHighestIHaveRPCSize_Call) Return(n int64) *PubSubTracer_LastHighestIHaveRPCSize_Call {
	_c.Call.Return(n)
	return _c
}

func (_c *PubSubTracer_LastHighestIHaveRPCSize_Call) RunAndReturn(run func() int64) *PubSubTracer_LastHighestIHaveRPCSize_Call {
	_c.Call.Return(run)
	return _c
}

// Leave provides a mock function for the type PubSubTracer
func (_mock *PubSubTracer) Leave(topic string) {
	_mock.Called(topic)
	return
}

// PubSubTracer_Leave_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Leave'
type PubSubTracer_Leave_Call struct {
	*mock.Call
}

// Leave is a helper method to define mock.On call
//   - topic string
func (_e *PubSubTracer_Expecter) Leave(topic interface{}) *PubSubTracer_Leave_Call {
	return &PubSubTracer_Leave_Call{Call: _e.mock.On("Leave", topic)}
}

func (_c *PubSubTracer_Leave_Call) Run(run func(topic string)) *PubSubTracer_Leave_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PubSubTracer_Leave_Call) Return() *PubSubTracer_Leave_Call {
	_c.Call.Return()
	return _c
}

func (_c *PubSubTracer_Leave_Call) RunAndReturn(run func(topic string)) *PubSubTracer_Leave_Call {
	_c.Run(run)
	return _c
}

// Prune provides a mock function for the type PubSubTracer
func (_mock *PubSubTracer) Prune(p peer.ID, topic string) {
	_mock.Called(p, topic)
	return
}

// PubSubTracer_Prune_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Prune'
type PubSubTracer_Prune_Call struct {
	*mock.Call
}

// Prune is a helper method to define mock.On call
//   - p peer.ID
//   - topic string
func (_e *PubSubTracer_Expecter) Prune(p interface{}, topic interface{}) *PubSubTracer_Prune_Call {
	return &PubSubTracer_Prune_Call{Call: _e.mock.On("Prune", p, topic)}
}

func (_c *PubSubTracer_Prune_Call) Run(run func(p peer.ID, topic string)) *PubSubTracer_Prune_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 peer.ID
		if args[0] != nil {
			arg0 = args[0].(peer.ID)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *PubSubTracer_Prune_Call) Return() *PubSubTracer_Prune_Call {
	_c.Call.Return()
	return _c
}

func (_c *PubSubTracer_Prune_Call) RunAndReturn(run func(p peer.ID, topic string)) *PubSubTracer_Prune_Call {
	_c.Run(run)
	return _c
}

// Ready provides a mock function for the type PubSubTracer
func (_mock *PubSubTracer) Ready() <-chan struct{} {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Ready")
	}

	var r0 <-chan struct{}
	if returnFunc, ok := ret.Get(0).(func() <-chan struct{}); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan struct{})
		}
	}
	return r0
}

// PubSubTracer_Ready_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Ready'
type PubSubTracer_Ready_Call struct {
	*mock.Call
}

// Ready is a helper method to define mock.On call
func (_e *PubSubTracer_Expecter) Ready() *PubSubTracer_Ready_Call {
	return &PubSubTracer_Ready_Call{Call: _e.mock.On("Ready")}
}

func (_c *PubSubTracer_Ready_Call) Run(run func()) *PubSubTracer_Ready_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *PubSubTracer_Ready_Call) Return(valCh <-chan struct{}) *PubSubTracer_Ready_Call {
	_c.Call.Return(valCh)
	return _c
}

func (_c *PubSubTracer_Ready_Call) RunAndReturn(run func() <-chan struct{}) *PubSubTracer_Ready_Call {
	_c.Call.Return(run)
	return _c
}

// RecvRPC provides a mock function for the type PubSubTracer
func (_mock *PubSubTracer) RecvRPC(rpc *pubsub.RPC) {
	_mock.Called(rpc)
	return
}

// PubSubTracer_RecvRPC_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RecvRPC'
type PubSubTracer_RecvRPC_Call struct {
	*mock.Call
}

// RecvRPC is a helper method to define mock.On call
//   - rpc *pubsub.RPC
func (_e *PubSubTracer_Expecter) RecvRPC(rpc interface{}) *PubSubTracer_RecvRPC_Call {
	return &PubSubTracer_RecvRPC_Call{Call: _e.mock.On("RecvRPC", rpc)}
}

func (_c *PubSubTracer_RecvRPC_Call) Run(run func(rpc *pubsub.RPC)) *PubSubTracer_RecvRPC_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *pubsub.RPC
		if args[0] != nil {
			arg0 = args[0].(*pubsub.RPC)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PubSubTracer_RecvRPC_Call) Return() *PubSubTracer_RecvRPC_Call {
	_c.Call.Return()
	return _c
}

func (_c *PubSubTracer_RecvRPC_Call) RunAndReturn(run func(rpc *pubsub.RPC)) *PubSubTracer_RecvRPC_Call {
	_c.Run(run)
	return _c
}

// RejectMessage provides a mock function for the type PubSubTracer
func (_mock *PubSubTracer) RejectMessage(msg *pubsub.Message, reason string) {
	_mock.Called(msg, reason)
	return
}

// PubSubTracer_RejectMessage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RejectMessage'
type PubSubTracer_RejectMessage_Call struct {
	*mock.Call
}

// RejectMessage is a helper method to define mock.On call
//   - msg *pubsub.Message
//   - reason string
func (_e *PubSubTracer_Expecter) RejectMessage(msg interface{}, reason interface{}) *PubSubTracer_RejectMessage_Call {
	return &PubSubTracer_RejectMessage_Call{Call: _e.mock.On("RejectMessage", msg, reason)}
}

func (_c *PubSubTracer_RejectMessage_Call) Run(run func(msg *pubsub.Message, reason string)) *PubSubTracer_RejectMessage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *pubsub.Message
		if args[0] != nil {
			arg0 = args[0].(*pubsub.Message)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *PubSubTracer_RejectMessage_Call) Return() *PubSubTracer_RejectMessage_Call {
	_c.Call.Return()
	return _c
}

func (_c *PubSubTracer_RejectMessage_Call) RunAndReturn(run func(msg *pubsub.Message, reason string)) *PubSubTracer_RejectMessage_Call {
	_c.Run(run)
	return _c
}

// RemovePeer provides a mock function for the type PubSubTracer
func (_mock *PubSubTracer) RemovePeer(p peer.ID) {
	_mock.Called(p)
	return
}

// PubSubTracer_RemovePeer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemovePeer'
type PubSubTracer_RemovePeer_Call struct {
	*mock.Call
}

// RemovePeer is a helper method to define mock.On call
//   - p peer.ID
func (_e *PubSubTracer_Expecter) RemovePeer(p interface{}) *PubSubTracer_RemovePeer_Call {
	return &PubSubTracer_RemovePeer_Call{Call: _e.mock.On("RemovePeer", p)}
}

func (_c *PubSubTracer_RemovePeer_Call) Run(run func(p peer.ID)) *PubSubTracer_RemovePeer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 peer.ID
		if args[0] != nil {
			arg0 = args[0].(peer.ID)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PubSubTracer_RemovePeer_Call) Return() *PubSubTracer_RemovePeer_Call {
	_c.Call.Return()
	return _c
}

func (_c *PubSubTracer_RemovePeer_Call) RunAndReturn(run func(p peer.ID)) *PubSubTracer_RemovePeer_Call {
	_c.Run(run)
	return _c
}

// SendRPC provides a mock function for the type PubSubTracer
func (_mock *PubSubTracer) SendRPC(rpc *pubsub.RPC, p peer.ID) {
	_mock.Called(rpc, p)
	return
}

// PubSubTracer_SendRPC_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SendRPC'
type PubSubTracer_SendRPC_Call struct {
	*mock.Call
}

// SendRPC is a helper method to define mock.On call
//   - rpc *pubsub.RPC
//   - p peer.ID
func (_e *PubSubTracer_Expecter) SendRPC(rpc interface{}, p interface{}) *PubSubTracer_SendRPC_Call {
	return &PubSubTracer_SendRPC_Call{Call: _e.mock.On("SendRPC", rpc, p)}
}

func (_c *PubSubTracer_SendRPC_Call) Run(run func(rpc *pubsub.RPC, p peer.ID)) *PubSubTracer_SendRPC_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *pubsub.RPC
		if args[0] != nil {
			arg0 = args[0].(*pubsub.RPC)
		}
		var arg1 peer.ID
		if args[1] != nil {
			arg1 = args[1].(peer.ID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *PubSubTracer_SendRPC_Call) Return() *PubSubTracer_SendRPC_Call {
	_c.Call.Return()
	return _c
}

func (_c *PubSubTracer_SendRPC_Call) RunAndReturn(run func(rpc *pubsub.RPC, p peer.ID)) *PubSubTracer_SendRPC_Call {
	_c.Run(run)
	return _c
}

// Start provides a mock function for the type PubSubTracer
func (_mock *PubSubTracer) Start(signalerContext irrecoverable.SignalerContext) {
	_mock.Called(signalerContext)
	return
}

// PubSubTracer_Start_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Start'
type PubSubTracer_Start_Call struct {
	*mock.Call
}

// Start is a helper method to define mock.On call
//   - signalerContext irrecoverable.SignalerContext
func (_e *PubSubTracer_Expecter) Start(signalerContext interface{}) *PubSubTracer_Start_Call {
	return &PubSubTracer_Start_Call{Call: _e.mock.On("Start", signalerContext)}
}

func (_c *PubSubTracer_Start_Call) Run(run func(signalerContext irrecoverable.SignalerContext)) *PubSubTracer_Start_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 irrecoverable.SignalerContext
		if args[0] != nil {
			arg0 = args[0].(irrecoverable.SignalerContext)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PubSubTracer_Start_Call) Return() *PubSubTracer_Start_Call {
	_c.Call.Return()
	return _c
}

func (_c *PubSubTracer_Start_Call) RunAndReturn(run func(signalerContext irrecoverable.SignalerContext)) *PubSubTracer_Start_Call {
	_c.Run(run)
	return _c
}

// ThrottlePeer provides a mock function for the type PubSubTracer
func (_mock *PubSubTracer) ThrottlePeer(p peer.ID) {
	_mock.Called(p)
	return
}

// PubSubTracer_ThrottlePeer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ThrottlePeer'
type PubSubTracer_ThrottlePeer_Call struct {
	*mock.Call
}

// ThrottlePeer is a helper method to define mock.On call
//   - p peer.ID
func (_e *PubSubTracer_Expecter) ThrottlePeer(p interface{}) *PubSubTracer_ThrottlePeer_Call {
	return &PubSubTracer_ThrottlePeer_Call{Call: _e.mock.On("ThrottlePeer", p)}
}

func (_c *PubSubTracer_ThrottlePeer_Call) Run(run func(p peer.ID)) *PubSubTracer_ThrottlePeer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 peer.ID
		if args[0] != nil {
			arg0 = args[0].(peer.ID)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PubSubTracer_ThrottlePeer_Call) Return() *PubSubTracer_ThrottlePeer_Call {
	_c.Call.Return()
	return _c
}

func (_c *PubSubTracer_ThrottlePeer_Call) RunAndReturn(run func(p peer.ID)) *PubSubTracer_ThrottlePeer_Call {
	_c.Run(run)
	return _c
}

// UndeliverableMessage provides a mock function for the type PubSubTracer
func (_mock *PubSubTracer) UndeliverableMessage(msg *pubsub.Message) {
	_mock.Called(msg)
	return
}

// PubSubTracer_UndeliverableMessage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UndeliverableMessage'
type PubSubTracer_UndeliverableMessage_Call struct {
	*mock.Call
}

// UndeliverableMessage is a helper method to define mock.On call
//   - msg *pubsub.Message
func (_e *PubSubTracer_Expecter) UndeliverableMessage(msg interface{}) *PubSubTracer_UndeliverableMessage_Call {
	return &PubSubTracer_UndeliverableMessage_Call{Call: _e.mock.On("UndeliverableMessage", msg)}
}

func (_c *PubSubTracer_UndeliverableMessage_Call) Run(run func(msg *pubsub.Message)) *PubSubTracer_UndeliverableMessage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *pubsub.Message
		if args[0] != nil {
			arg0 = args[0].(*pubsub.Message)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PubSubTracer_UndeliverableMessage_Call) Return() *PubSubTracer_UndeliverableMessage_Call {
	_c.Call.Return()
	return _c
}

func (_c *PubSubTracer_UndeliverableMessage_Call) RunAndReturn(run func(msg *pubsub.Message)) *PubSubTracer_UndeliverableMessage_Call {
	_c.Run(run)
	return _c
}

// ValidateMessage provides a mock function for the type PubSubTracer
func (_mock *PubSubTracer) ValidateMessage(msg *pubsub.Message) {
	_mock.Called(msg)
	return
}

// PubSubTracer_ValidateMessage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ValidateMessage'
type PubSubTracer_ValidateMessage_Call struct {
	*mock.Call
}

// ValidateMessage is a helper method to define mock.On call
//   - msg *pubsub.Message
func (_e *PubSubTracer_Expecter) ValidateMessage(msg interface{}) *PubSubTracer_ValidateMessage_Call {
	return &PubSubTracer_ValidateMessage_Call{Call: _e.mock.On("ValidateMessage", msg)}
}

func (_c *PubSubTracer_ValidateMessage_Call) Run(run func(msg *pubsub.Message)) *PubSubTracer_ValidateMessage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *pubsub.Message
		if args[0] != nil {
			arg0 = args[0].(*pubsub.Message)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PubSubTracer_ValidateMessage_Call) Return() *PubSubTracer_ValidateMessage_Call {
	_c.Call.Return()
	return _c
}

func (_c *PubSubTracer_ValidateMessage_Call) RunAndReturn(run func(msg *pubsub.Message)) *PubSubTracer_ValidateMessage_Call {
	_c.Run(run)
	return _c
}

// WasIHaveRPCSent provides a mock function for the type PubSubTracer
func (_mock *PubSubTracer) WasIHaveRPCSent(messageID string) bool {
	ret := _mock.Called(messageID)

	if len(ret) == 0 {
		panic("no return value specified for WasIHaveRPCSent")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(string) bool); ok {
		r0 = returnFunc(messageID)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// PubSubTracer_WasIHaveRPCSent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WasIHaveRPCSent'
type PubSubTracer_WasIHaveRPCSent_Call struct {
	*mock.Call
}

// WasIHaveRPCSent is a helper method to define mock.On call
//   - messageID string
func (_e *PubSubTracer_Expecter) WasIHaveRPCSent(messageID interface{}) *PubSubTracer_WasIHaveRPCSent_Call {
	return &PubSubTracer_WasIHaveRPCSent_Call{Call: _e.mock.On("WasIHaveRPCSent", messageID)}
}

func (_c *PubSubTracer_WasIHaveRPCSent_Call) Run(run func(messageID string)) *PubSubTracer_WasIHaveRPCSent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PubSubTracer_WasIHaveRPCSent_Call) Return(b bool) *PubSubTracer_WasIHaveRPCSent_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *PubSubTracer_WasIHaveRPCSent_Call) RunAndReturn(run func(messageID string) bool) *PubSubTracer_WasIHaveRPCSent_Call {
	_c.Call.Return(run)
	return _c
}

// NewRpcControlTracking creates a new instance of RpcControlTracking. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewRpcControlTracking(t interface {
	mock.TestingT
	Cleanup(func())
}) *RpcControlTracking {
	mock := &RpcControlTracking{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// RpcControlTracking is an autogenerated mock type for the RpcControlTracking type
type RpcControlTracking struct {
	mock.Mock
}

type RpcControlTracking_Expecter struct {
	mock *mock.Mock
}

func (_m *RpcControlTracking) EXPECT() *RpcControlTracking_Expecter {
	return &RpcControlTracking_Expecter{mock: &_m.Mock}
}

// LastHighestIHaveRPCSize provides a mock function for the type RpcControlTracking
func (_mock *RpcControlTracking) LastHighestIHaveRPCSize() int64 {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for LastHighestIHaveRPCSize")
	}

	var r0 int64
	if returnFunc, ok := ret.Get(0).(func() int64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(int64)
	}
	return r0
}

// RpcControlTracking_LastHighestIHaveRPCSize_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LastHighestIHaveRPCSize'
type RpcControlTracking_LastHighestIHaveRPCSize_Call struct {
	*mock.Call
}

// LastHighestIHaveRPCSize is a helper method to define mock.On call
func (_e *RpcControlTracking_Expecter) LastHighestIHaveRPCSize() *RpcControlTracking_LastHighestIHaveRPCSize_Call {
	return &RpcControlTracking_LastHighestIHaveRPCSize_Call{Call: _e.mock.On("LastHighestIHaveRPCSize")}
}

func (_c *RpcControlTracking_LastHighestIHaveRPCSize_Call) Run(run func()) *RpcControlTracking_LastHighestIHaveRPCSize_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *RpcControlTracking_LastHighestIHaveRPCSize_Call) Return(n int64) *RpcControlTracking_LastHighestIHaveRPCSize_Call {
	_c.Call.Return(n)
	return _c
}

func (_c *RpcControlTracking_LastHighestIHaveRPCSize_Call) RunAndReturn(run func() int64) *RpcControlTracking_LastHighestIHaveRPCSize_Call {
	_c.Call.Return(run)
	return _c
}

// WasIHaveRPCSent provides a mock function for the type RpcControlTracking
func (_mock *RpcControlTracking) WasIHaveRPCSent(messageID string) bool {
	ret := _mock.Called(messageID)

	if len(ret) == 0 {
		panic("no return value specified for WasIHaveRPCSent")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(string) bool); ok {
		r0 = returnFunc(messageID)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// RpcControlTracking_WasIHaveRPCSent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WasIHaveRPCSent'
type RpcControlTracking_WasIHaveRPCSent_Call struct {
	*mock.Call
}

// WasIHaveRPCSent is a helper method to define mock.On call
//   - messageID string
func (_e *RpcControlTracking_Expecter) WasIHaveRPCSent(messageID interface{}) *RpcControlTracking_WasIHaveRPCSent_Call {
	return &RpcControlTracking_WasIHaveRPCSent_Call{Call: _e.mock.On("WasIHaveRPCSent", messageID)}
}

func (_c *RpcControlTracking_WasIHaveRPCSent_Call) Run(run func(messageID string)) *RpcControlTracking_WasIHaveRPCSent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *RpcControlTracking_WasIHaveRPCSent_Call) Return(b bool) *RpcControlTracking_WasIHaveRPCSent_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *RpcControlTracking_WasIHaveRPCSent_Call) RunAndReturn(run func(messageID string) bool) *RpcControlTracking_WasIHaveRPCSent_Call {
	_c.Call.Return(run)
	return _c
}

// NewPeerScoreTracer creates a new instance of PeerScoreTracer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewPeerScoreTracer(t interface {
	mock.TestingT
	Cleanup(func())
}) *PeerScoreTracer {
	mock := &PeerScoreTracer{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// PeerScoreTracer is an autogenerated mock type for the PeerScoreTracer type
type PeerScoreTracer struct {
	mock.Mock
}

type PeerScoreTracer_Expecter struct {
	mock *mock.Mock
}

func (_m *PeerScoreTracer) EXPECT() *PeerScoreTracer_Expecter {
	return &PeerScoreTracer_Expecter{mock: &_m.Mock}
}

// Done provides a mock function for the type PeerScoreTracer
func (_mock *PeerScoreTracer) Done() <-chan struct{} {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Done")
	}

	var r0 <-chan struct{}
	if returnFunc, ok := ret.Get(0).(func() <-chan struct{}); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan struct{})
		}
	}
	return r0
}

// PeerScoreTracer_Done_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Done'
type PeerScoreTracer_Done_Call struct {
	*mock.Call
}

// Done is a helper method to define mock.On call
func (_e *PeerScoreTracer_Expecter) Done() *PeerScoreTracer_Done_Call {
	return &PeerScoreTracer_Done_Call{Call: _e.mock.On("Done")}
}

func (_c *PeerScoreTracer_Done_Call) Run(run func()) *PeerScoreTracer_Done_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *PeerScoreTracer_Done_Call) Return(valCh <-chan struct{}) *PeerScoreTracer_Done_Call {
	_c.Call.Return(valCh)
	return _c
}

func (_c *PeerScoreTracer_Done_Call) RunAndReturn(run func() <-chan struct{}) *PeerScoreTracer_Done_Call {
	_c.Call.Return(run)
	return _c
}

// GetAppScore provides a mock function for the type PeerScoreTracer
func (_mock *PeerScoreTracer) GetAppScore(peerID peer.ID) (float64, bool) {
	ret := _mock.Called(peerID)

	if len(ret) == 0 {
		panic("no return value specified for GetAppScore")
	}

	var r0 float64
	var r1 bool
	if returnFunc, ok := ret.Get(0).(func(peer.ID) (float64, bool)); ok {
		return returnFunc(peerID)
	}
	if returnFunc, ok := ret.Get(0).(func(peer.ID) float64); ok {
		r0 = returnFunc(peerID)
	} else {
		r0 = ret.Get(0).(float64)
	}
	if returnFunc, ok := ret.Get(1).(func(peer.ID) bool); ok {
		r1 = returnFunc(peerID)
	} else {
		r1 = ret.Get(1).(bool)
	}
	return r0, r1
}

// PeerScoreTracer_GetAppScore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAppScore'
type PeerScoreTracer_GetAppScore_Call struct {
	*mock.Call
}

// GetAppScore is a helper method to define mock.On call
//   - peerID peer.ID
func (_e *PeerScoreTracer_Expecter) GetAppScore(peerID interface{}) *PeerScoreTracer_GetAppScore_Call {
	return &PeerScoreTracer_GetAppScore_Call{Call: _e.mock.On("GetAppScore", peerID)}
}

func (_c *PeerScoreTracer_GetAppScore_Call) Run(run func(peerID peer.ID)) *PeerScoreTracer_GetAppScore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 peer.ID
		if args[0] != nil {
			arg0 = args[0].(peer.ID)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PeerScoreTracer_GetAppScore_Call) Return(f float64, b bool) *PeerScoreTracer_GetAppScore_Call {
	_c.Call.Return(f, b)
	return _c
}

func (_c *PeerScoreTracer_GetAppScore_Call) RunAndReturn(run func(peerID peer.ID) (float64, bool)) *PeerScoreTracer_GetAppScore_Call {
	_c.Call.Return(run)
	return _c
}

// GetBehaviourPenalty provides a mock function for the type PeerScoreTracer
func (_mock *PeerScoreTracer) GetBehaviourPenalty(peerID peer.ID) (float64, bool) {
	ret := _mock.Called(peerID)

	if len(ret) == 0 {
		panic("no return value specified for GetBehaviourPenalty")
	}

	var r0 float64
	var r1 bool
	if returnFunc, ok := ret.Get(0).(func(peer.ID) (float64, bool)); ok {
		return returnFunc(peerID)
	}
	if returnFunc, ok := ret.Get(0).(func(peer.ID) float64); ok {
		r0 = returnFunc(peerID)
	} else {
		r0 = ret.Get(0).(float64)
	}
	if returnFunc, ok := ret.Get(1).(func(peer.ID) bool); ok {
		r1 = returnFunc(peerID)
	} else {
		r1 = ret.Get(1).(bool)
	}
	return r0, r1
}

// PeerScoreTracer_GetBehaviourPenalty_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBehaviourPenalty'
type PeerScoreTracer_GetBehaviourPenalty_Call struct {
	*mock.Call
}

// GetBehaviourPenalty is a helper method to define mock.On call
//   - peerID peer.ID
func (_e *PeerScoreTracer_Expecter) GetBehaviourPenalty(peerID interface{}) *PeerScoreTracer_GetBehaviourPenalty_Call {
	return &PeerScoreTracer_GetBehaviourPenalty_Call{Call: _e.mock.On("GetBehaviourPenalty", peerID)}
}

func (_c *PeerScoreTracer_GetBehaviourPenalty_Call) Run(run func(peerID peer.ID)) *PeerScoreTracer_GetBehaviourPenalty_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 peer.ID
		if args[0] != nil {
			arg0 = args[0].(peer.ID)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PeerScoreTracer_GetBehaviourPenalty_Call) Return(f float64, b bool) *PeerScoreTracer_GetBehaviourPenalty_Call {
	_c.Call.Return(f, b)
	return _c
}

func (_c *PeerScoreTracer_GetBehaviourPenalty_Call) RunAndReturn(run func(peerID peer.ID) (float64, bool)) *PeerScoreTracer_GetBehaviourPenalty_Call {
	_c.Call.Return(run)
	return _c
}

// GetIPColocationFactor provides a mock function for the type PeerScoreTracer
func (_mock *PeerScoreTracer) GetIPColocationFactor(peerID peer.ID) (float64, bool) {
	ret := _mock.Called(peerID)

	if len(ret) == 0 {
		panic("no return value specified for GetIPColocationFactor")
	}

	var r0 float64
	var r1 bool
	if returnFunc, ok := ret.Get(0).(func(peer.ID) (float64, bool)); ok {
		return returnFunc(peerID)
	}
	if returnFunc, ok := ret.Get(0).(func(peer.ID) float64); ok {
		r0 = returnFunc(peerID)
	} else {
		r0 = ret.Get(0).(float64)
	}
	if returnFunc, ok := ret.Get(1).(func(peer.ID) bool); ok {
		r1 = returnFunc(peerID)
	} else {
		r1 = ret.Get(1).(bool)
	}
	return r0, r1
}

// PeerScoreTracer_GetIPColocationFactor_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetIPColocationFactor'
type PeerScoreTracer_GetIPColocationFactor_Call struct {
	*mock.Call
}

// GetIPColocationFactor is a helper method to define mock.On call
//   - peerID peer.ID
func (_e *PeerScoreTracer_Expecter) GetIPColocationFactor(peerID interface{}) *PeerScoreTracer_GetIPColocationFactor_Call {
	return &PeerScoreTracer_GetIPColocationFactor_Call{Call: _e.mock.On("GetIPColocationFactor", peerID)}
}

func (_c *PeerScoreTracer_GetIPColocationFactor_Call) Run(run func(peerID peer.ID)) *PeerScoreTracer_GetIPColocationFactor_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 peer.ID
		if args[0] != nil {
			arg0 = args[0].(peer.ID)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PeerScoreTracer_GetIPColocationFactor_Call) Return(f float64, b bool) *PeerScoreTracer_GetIPColocationFactor_Call {
	_c.Call.Return(f, b)
	return _c
}

func (_c *PeerScoreTracer_GetIPColocationFactor_Call) RunAndReturn(run func(peerID peer.ID) (float64, bool)) *PeerScoreTracer_GetIPColocationFactor_Call {
	_c.Call.Return(run)
	return _c
}

// GetScore provides a mock function for the type PeerScoreTracer
func (_mock *PeerScoreTracer) GetScore(peerID peer.ID) (float64, bool) {
	ret := _mock.Called(peerID)

	if len(ret) == 0 {
		panic("no return value specified for GetScore")
	}

	var r0 float64
	var r1 bool
	if returnFunc, ok := ret.Get(0).(func(peer.ID) (float64, bool)); ok {
		return returnFunc(peerID)
	}
	if returnFunc, ok := ret.Get(0).(func(peer.ID) float64); ok {
		r0 = returnFunc(peerID)
	} else {
		r0 = ret.Get(0).(float64)
	}
	if returnFunc, ok := ret.Get(1).(func(peer.ID) bool); ok {
		r1 = returnFunc(peerID)
	} else {
		r1 = ret.Get(1).(bool)
	}
	return r0, r1
}

// PeerScoreTracer_GetScore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetScore'
type PeerScoreTracer_GetScore_Call struct {
	*mock.Call
}

// GetScore is a helper method to define mock.On call
//   - peerID peer.ID
func (_e *PeerScoreTracer_Expecter) GetScore(peerID interface{}) *PeerScoreTracer_GetScore_Call {
	return &PeerScoreTracer_GetScore_Call{Call: _e.mock.On("GetScore", peerID)}
}

func (_c *PeerScoreTracer_GetScore_Call) Run(run func(peerID peer.ID)) *PeerScoreTracer_GetScore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 peer.ID
		if args[0] != nil {
			arg0 = args[0].(peer.ID)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PeerScoreTracer_GetScore_Call) Return(f float64, b bool) *PeerScoreTracer_GetScore_Call {
	_c.Call.Return(f, b)
	return _c
}

func (_c *PeerScoreTracer_GetScore_Call) RunAndReturn(run func(peerID peer.ID) (float64, bool)) *PeerScoreTracer_GetScore_Call {
	_c.Call.Return(run)
	return _c
}

// GetTopicScores provides a mock function for the type PeerScoreTracer
func (_mock *PeerScoreTracer) GetTopicScores(peerID peer.ID) (map[string]p2p.TopicScoreSnapshot, bool) {
	ret := _mock.Called(peerID)

	if len(ret) == 0 {
		panic("no return value specified for GetTopicScores")
	}

	var r0 map[string]p2p.TopicScoreSnapshot
	var r1 bool
	if returnFunc, ok := ret.Get(0).(func(peer.ID) (map[string]p2p.TopicScoreSnapshot, bool)); ok {
		return returnFunc(peerID)
	}
	if returnFunc, ok := ret.Get(0).(func(peer.ID) map[string]p2p.TopicScoreSnapshot); ok {
		r0 = returnFunc(peerID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]p2p.TopicScoreSnapshot)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(peer.ID) bool); ok {
		r1 = returnFunc(peerID)
	} else {
		r1 = ret.Get(1).(bool)
	}
	return r0, r1
}

// PeerScoreTracer_GetTopicScores_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTopicScores'
type PeerScoreTracer_GetTopicScores_Call struct {
	*mock.Call
}

// GetTopicScores is a helper method to define mock.On call
//   - peerID peer.ID
func (_e *PeerScoreTracer_Expecter) GetTopicScores(peerID interface{}) *PeerScoreTracer_GetTopicScores_Call {
	return &PeerScoreTracer_GetTopicScores_Call{Call: _e.mock.On("GetTopicScores", peerID)}
}

func (_c *PeerScoreTracer_GetTopicScores_Call) Run(run func(peerID peer.ID)) *PeerScoreTracer_GetTopicScores_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 peer.ID
		if args[0] != nil {
			arg0 = args[0].(peer.ID)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PeerScoreTracer_GetTopicScores_Call) Return(stringToTopicScoreSnapshot map[string]p2p.TopicScoreSnapshot, b bool) *PeerScoreTracer_GetTopicScores_Call {
	_c.Call.Return(stringToTopicScoreSnapshot, b)
	return _c
}

func (_c *PeerScoreTracer_GetTopicScores_Call) RunAndReturn(run func(peerID peer.ID) (map[string]p2p.TopicScoreSnapshot, bool)) *PeerScoreTracer_GetTopicScores_Call {
	_c.Call.Return(run)
	return _c
}

// Ready provides a mock function for the type PeerScoreTracer
func (_mock *PeerScoreTracer) Ready() <-chan struct{} {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Ready")
	}

	var r0 <-chan struct{}
	if returnFunc, ok := ret.Get(0).(func() <-chan struct{}); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan struct{})
		}
	}
	return r0
}

// PeerScoreTracer_Ready_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Ready'
type PeerScoreTracer_Ready_Call struct {
	*mock.Call
}

// Ready is a helper method to define mock.On call
func (_e *PeerScoreTracer_Expecter) Ready() *PeerScoreTracer_Ready_Call {
	return &PeerScoreTracer_Ready_Call{Call: _e.mock.On("Ready")}
}

func (_c *PeerScoreTracer_Ready_Call) Run(run func()) *PeerScoreTracer_Ready_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *PeerScoreTracer_Ready_Call) Return(valCh <-chan struct{}) *PeerScoreTracer_Ready_Call {
	_c.Call.Return(valCh)
	return _c
}

func (_c *PeerScoreTracer_Ready_Call) RunAndReturn(run func() <-chan struct{}) *PeerScoreTracer_Ready_Call {
	_c.Call.Return(run)
	return _c
}

// Start provides a mock function for the type PeerScoreTracer
func (_mock *PeerScoreTracer) Start(signalerContext irrecoverable.SignalerContext) {
	_mock.Called(signalerContext)
	return
}

// PeerScoreTracer_Start_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Start'
type PeerScoreTracer_Start_Call struct {
	*mock.Call
}

// Start is a helper method to define mock.On call
//   - signalerContext irrecoverable.SignalerContext
func (_e *PeerScoreTracer_Expecter) Start(signalerContext interface{}) *PeerScoreTracer_Start_Call {
	return &PeerScoreTracer_Start_Call{Call: _e.mock.On("Start", signalerContext)}
}

func (_c *PeerScoreTracer_Start_Call) Run(run func(signalerContext irrecoverable.SignalerContext)) *PeerScoreTracer_Start_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 irrecoverable.SignalerContext
		if args[0] != nil {
			arg0 = args[0].(irrecoverable.SignalerContext)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PeerScoreTracer_Start_Call) Return() *PeerScoreTracer_Start_Call {
	_c.Call.Return()
	return _c
}

func (_c *PeerScoreTracer_Start_Call) RunAndReturn(run func(signalerContext irrecoverable.SignalerContext)) *PeerScoreTracer_Start_Call {
	_c.Run(run)
	return _c
}

// UpdateInterval provides a mock function for the type PeerScoreTracer
func (_mock *PeerScoreTracer) UpdateInterval() time.Duration {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for UpdateInterval")
	}

	var r0 time.Duration
	if returnFunc, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}
	return r0
}

// PeerScoreTracer_UpdateInterval_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateInterval'
type PeerScoreTracer_UpdateInterval_Call struct {
	*mock.Call
}

// UpdateInterval is a helper method to define mock.On call
func (_e *PeerScoreTracer_Expecter) UpdateInterval() *PeerScoreTracer_UpdateInterval_Call {
	return &PeerScoreTracer_UpdateInterval_Call{Call: _e.mock.On("UpdateInterval")}
}

func (_c *PeerScoreTracer_UpdateInterval_Call) Run(run func()) *PeerScoreTracer_UpdateInterval_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *PeerScoreTracer_UpdateInterval_Call) Return(duration time.Duration) *PeerScoreTracer_UpdateInterval_Call {
	_c.Call.Return(duration)
	return _c
}

func (_c *PeerScoreTracer_UpdateInterval_Call) RunAndReturn(run func() time.Duration) *PeerScoreTracer_UpdateInterval_Call {
	_c.Call.Return(run)
	return _c
}

// UpdatePeerScoreSnapshots provides a mock function for the type PeerScoreTracer
func (_mock *PeerScoreTracer) UpdatePeerScoreSnapshots(iDToPeerScoreSnapshot map[peer.ID]*p2p.PeerScoreSnapshot) {
	_mock.Called(iDToPeerScoreSnapshot)
	return
}

// PeerScoreTracer_UpdatePeerScoreSnapshots_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdatePeerScoreSnapshots'
type PeerScoreTracer_UpdatePeerScoreSnapshots_Call struct {
	*mock.Call
}

// UpdatePeerScoreSnapshots is a helper method to define mock.On call
//   - iDToPeerScoreSnapshot map[peer.ID]*p2p.PeerScoreSnapshot
func (_e *PeerScoreTracer_Expecter) UpdatePeerScoreSnapshots(iDToPeerScoreSnapshot interface{}) *PeerScoreTracer_UpdatePeerScoreSnapshots_Call {
	return &PeerScoreTracer_UpdatePeerScoreSnapshots_Call{Call: _e.mock.On("UpdatePeerScoreSnapshots", iDToPeerScoreSnapshot)}
}

func (_c *PeerScoreTracer_UpdatePeerScoreSnapshots_Call) Run(run func(iDToPeerScoreSnapshot map[peer.ID]*p2p.PeerScoreSnapshot)) *PeerScoreTracer_UpdatePeerScoreSnapshots_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 map[peer.ID]*p2p.PeerScoreSnapshot
		if args[0] != nil {
			arg0 = args[0].(map[peer.ID]*p2p.PeerScoreSnapshot)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PeerScoreTracer_UpdatePeerScoreSnapshots_Call) Return() *PeerScoreTracer_UpdatePeerScoreSnapshots_Call {
	_c.Call.Return()
	return _c
}

func (_c *PeerScoreTracer_UpdatePeerScoreSnapshots_Call) RunAndReturn(run func(iDToPeerScoreSnapshot map[peer.ID]*p2p.PeerScoreSnapshot)) *PeerScoreTracer_UpdatePeerScoreSnapshots_Call {
	_c.Run(run)
	return _c
}

// NewPeerScoreExposer creates a new instance of PeerScoreExposer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewPeerScoreExposer(t interface {
	mock.TestingT
	Cleanup(func())
}) *PeerScoreExposer {
	mock := &PeerScoreExposer{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// PeerScoreExposer is an autogenerated mock type for the PeerScoreExposer type
type PeerScoreExposer struct {
	mock.Mock
}

type PeerScoreExposer_Expecter struct {
	mock *mock.Mock
}

func (_m *PeerScoreExposer) EXPECT() *PeerScoreExposer_Expecter {
	return &PeerScoreExposer_Expecter{mock: &_m.Mock}
}

// GetAppScore provides a mock function for the type PeerScoreExposer
func (_mock *PeerScoreExposer) GetAppScore(peerID peer.ID) (float64, bool) {
	ret := _mock.Called(peerID)

	if len(ret) == 0 {
		panic("no return value specified for GetAppScore")
	}

	var r0 float64
	var r1 bool
	if returnFunc, ok := ret.Get(0).(func(peer.ID) (float64, bool)); ok {
		return returnFunc(peerID)
	}
	if returnFunc, ok := ret.Get(0).(func(peer.ID) float64); ok {
		r0 = returnFunc(peerID)
	} else {
		r0 = ret.Get(0).(float64)
	}
	if returnFunc, ok := ret.Get(1).(func(peer.ID) bool); ok {
		r1 = returnFunc(peerID)
	} else {
		r1 = ret.Get(1).(bool)
	}
	return r0, r1
}

// PeerScoreExposer_GetAppScore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAppScore'
type PeerScoreExposer_GetAppScore_Call struct {
	*mock.Call
}

// GetAppScore is a helper method to define mock.On call
//   - peerID peer.ID
func (_e *PeerScoreExposer_Expecter) GetAppScore(peerID interface{}) *PeerScoreExposer_GetAppScore_Call {
	return &PeerScoreExposer_GetAppScore_Call{Call: _e.mock.On("GetAppScore", peerID)}
}

func (_c *PeerScoreExposer_GetAppScore_Call) Run(run func(peerID peer.ID)) *PeerScoreExposer_GetAppScore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 peer.ID
		if args[0] != nil {
			arg0 = args[0].(peer.ID)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PeerScoreExposer_GetAppScore_Call) Return(f float64, b bool) *PeerScoreExposer_GetAppScore_Call {
	_c.Call.Return(f, b)
	return _c
}

func (_c *PeerScoreExposer_GetAppScore_Call) RunAndReturn(run func(peerID peer.ID) (float64, bool)) *PeerScoreExposer_GetAppScore_Call {
	_c.Call.Return(run)
	return _c
}

// GetBehaviourPenalty provides a mock function for the type PeerScoreExposer
func (_mock *PeerScoreExposer) GetBehaviourPenalty(peerID peer.ID) (float64, bool) {
	ret := _mock.Called(peerID)

	if len(ret) == 0 {
		panic("no return value specified for GetBehaviourPenalty")
	}

	var r0 float64
	var r1 bool
	if returnFunc, ok := ret.Get(0).(func(peer.ID) (float64, bool)); ok {
		return returnFunc(peerID)
	}
	if returnFunc, ok := ret.Get(0).(func(peer.ID) float64); ok {
		r0 = returnFunc(peerID)
	} else {
		r0 = ret.Get(0).(float64)
	}
	if returnFunc, ok := ret.Get(1).(func(peer.ID) bool); ok {
		r1 = returnFunc(peerID)
	} else {
		r1 = ret.Get(1).(bool)
	}
	return r0, r1
}

// PeerScoreExposer_GetBehaviourPenalty_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBehaviourPenalty'
type PeerScoreExposer_GetBehaviourPenalty_Call struct {
	*mock.Call
}

// GetBehaviourPenalty is a helper method to define mock.On call
//   - peerID peer.ID
func (_e *PeerScoreExposer_Expecter) GetBehaviourPenalty(peerID interface{}) *PeerScoreExposer_GetBehaviourPenalty_Call {
	return &PeerScoreExposer_GetBehaviourPenalty_Call{Call: _e.mock.On("GetBehaviourPenalty", peerID)}
}

func (_c *PeerScoreExposer_GetBehaviourPenalty_Call) Run(run func(peerID peer.ID)) *PeerScoreExposer_GetBehaviourPenalty_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 peer.ID
		if args[0] != nil {
			arg0 = args[0].(peer.ID)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PeerScoreExposer_GetBehaviourPenalty_Call) Return(f float64, b bool) *PeerScoreExposer_GetBehaviourPenalty_Call {
	_c.Call.Return(f, b)
	return _c
}

func (_c *PeerScoreExposer_GetBehaviourPenalty_Call) RunAndReturn(run func(peerID peer.ID) (float64, bool)) *PeerScoreExposer_GetBehaviourPenalty_Call {
	_c.Call.Return(run)
	return _c
}

// GetIPColocationFactor provides a mock function for the type PeerScoreExposer
func (_mock *PeerScoreExposer) GetIPColocationFactor(peerID peer.ID) (float64, bool) {
	ret := _mock.Called(peerID)

	if len(ret) == 0 {
		panic("no return value specified for GetIPColocationFactor")
	}

	var r0 float64
	var r1 bool
	if returnFunc, ok := ret.Get(0).(func(peer.ID) (float64, bool)); ok {
		return returnFunc(peerID)
	}
	if returnFunc, ok := ret.Get(0).(func(peer.ID) float64); ok {
		r0 = returnFunc(peerID)
	} else {
		r0 = ret.Get(0).(float64)
	}
	if returnFunc, ok := ret.Get(1).(func(peer.ID) bool); ok {
		r1 = returnFunc(peerID)
	} else {
		r1 = ret.Get(1).(bool)
	}
	return r0, r1
}

// PeerScoreExposer_GetIPColocationFactor_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetIPColocationFactor'
type PeerScoreExposer_GetIPColocationFactor_Call struct {
	*mock.Call
}

// GetIPColocationFactor is a helper method to define mock.On call
//   - peerID peer.ID
func (_e *PeerScoreExposer_Expecter) GetIPColocationFactor(peerID interface{}) *PeerScoreExposer_GetIPColocationFactor_Call {
	return &PeerScoreExposer_GetIPColocationFactor_Call{Call: _e.mock.On("GetIPColocationFactor", peerID)}
}

func (_c *PeerScoreExposer_GetIPColocationFactor_Call) Run(run func(peerID peer.ID)) *PeerScoreExposer_GetIPColocationFactor_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 peer.ID
		if args[0] != nil {
			arg0 = args[0].(peer.ID)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PeerScoreExposer_GetIPColocationFactor_Call) Return(f float64, b bool) *PeerScoreExposer_GetIPColocationFactor_Call {
	_c.Call.Return(f, b)
	return _c
}

func (_c *PeerScoreExposer_GetIPColocationFactor_Call) RunAndReturn(run func(peerID peer.ID) (float64, bool)) *PeerScoreExposer_GetIPColocationFactor_Call {
	_c.Call.Return(run)
	return _c
}

// GetScore provides a mock function for the type PeerScoreExposer
func (_mock *PeerScoreExposer) GetScore(peerID peer.ID) (float64, bool) {
	ret := _mock.Called(peerID)

	if len(ret) == 0 {
		panic("no return value specified for GetScore")
	}

	var r0 float64
	var r1 bool
	if returnFunc, ok := ret.Get(0).(func(peer.ID) (float64, bool)); ok {
		return returnFunc(peerID)
	}
	if returnFunc, ok := ret.Get(0).(func(peer.ID) float64); ok {
		r0 = returnFunc(peerID)
	} else {
		r0 = ret.Get(0).(float64)
	}
	if returnFunc, ok := ret.Get(1).(func(peer.ID) bool); ok {
		r1 = returnFunc(peerID)
	} else {
		r1 = ret.Get(1).(bool)
	}
	return r0, r1
}

// PeerScoreExposer_GetScore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetScore'
type PeerScoreExposer_GetScore_Call struct {
	*mock.Call
}

// GetScore is a helper method to define mock.On call
//   - peerID peer.ID
func (_e *PeerScoreExposer_Expecter) GetScore(peerID interface{}) *PeerScoreExposer_GetScore_Call {
	return &PeerScoreExposer_GetScore_Call{Call: _e.mock.On("GetScore", peerID)}
}

func (_c *PeerScoreExposer_GetScore_Call) Run(run func(peerID peer.ID)) *PeerScoreExposer_GetScore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 peer.ID
		if args[0] != nil {
			arg0 = args[0].(peer.ID)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PeerScoreExposer_GetScore_Call) Return(f float64, b bool) *PeerScoreExposer_GetScore_Call {
	_c.Call.Return(f, b)
	return _c
}

func (_c *PeerScoreExposer_GetScore_Call) RunAndReturn(run func(peerID peer.ID) (float64, bool)) *PeerScoreExposer_GetScore_Call {
	_c.Call.Return(run)
	return _c
}

// GetTopicScores provides a mock function for the type PeerScoreExposer
func (_mock *PeerScoreExposer) GetTopicScores(peerID peer.ID) (map[string]p2p.TopicScoreSnapshot, bool) {
	ret := _mock.Called(peerID)

	if len(ret) == 0 {
		panic("no return value specified for GetTopicScores")
	}

	var r0 map[string]p2p.TopicScoreSnapshot
	var r1 bool
	if returnFunc, ok := ret.Get(0).(func(peer.ID) (map[string]p2p.TopicScoreSnapshot, bool)); ok {
		return returnFunc(peerID)
	}
	if returnFunc, ok := ret.Get(0).(func(peer.ID) map[string]p2p.TopicScoreSnapshot); ok {
		r0 = returnFunc(peerID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]p2p.TopicScoreSnapshot)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(peer.ID) bool); ok {
		r1 = returnFunc(peerID)
	} else {
		r1 = ret.Get(1).(bool)
	}
	return r0, r1
}

// PeerScoreExposer_GetTopicScores_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTopicScores'
type PeerScoreExposer_GetTopicScores_Call struct {
	*mock.Call
}

// GetTopicScores is a helper method to define mock.On call
//   - peerID peer.ID
func (_e *PeerScoreExposer_Expecter) GetTopicScores(peerID interface{}) *PeerScoreExposer_GetTopicScores_Call {
	return &PeerScoreExposer_GetTopicScores_Call{Call: _e.mock.On("GetTopicScores", peerID)}
}

func (_c *PeerScoreExposer_GetTopicScores_Call) Run(run func(peerID peer.ID)) *PeerScoreExposer_GetTopicScores_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 peer.ID
		if args[0] != nil {
			arg0 = args[0].(peer.ID)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PeerScoreExposer_GetTopicScores_Call) Return(stringToTopicScoreSnapshot map[string]p2p.TopicScoreSnapshot, b bool) *PeerScoreExposer_GetTopicScores_Call {
	_c.Call.Return(stringToTopicScoreSnapshot, b)
	return _c
}

func (_c *PeerScoreExposer_GetTopicScores_Call) RunAndReturn(run func(peerID peer.ID) (map[string]p2p.TopicScoreSnapshot, bool)) *PeerScoreExposer_GetTopicScores_Call {
	_c.Call.Return(run)
	return _c
}

// NewRateLimiter creates a new instance of RateLimiter. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewRateLimiter(t interface {
	mock.TestingT
	Cleanup(func())
}) *RateLimiter {
	mock := &RateLimiter{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// RateLimiter is an autogenerated mock type for the RateLimiter type
type RateLimiter struct {
	mock.Mock
}

type RateLimiter_Expecter struct {
	mock *mock.Mock
}

func (_m *RateLimiter) EXPECT() *RateLimiter_Expecter {
	return &RateLimiter_Expecter{mock: &_m.Mock}
}

// Allow provides a mock function for the type RateLimiter
func (_mock *RateLimiter) Allow(peerID peer.ID, msgSize int) bool {
	ret := _mock.Called(peerID, msgSize)

	if len(ret) == 0 {
		panic("no return value specified for Allow")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(peer.ID, int) bool); ok {
		r0 = returnFunc(peerID, msgSize)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// RateLimiter_Allow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Allow'
type RateLimiter_Allow_Call struct {
	*mock.Call
}

// Allow is a helper method to define mock.On call
//   - peerID peer.ID
//   - msgSize int
func (_e *RateLimiter_Expecter) Allow(peerID interface{}, msgSize interface{}) *RateLimiter_Allow_Call {
	return &RateLimiter_Allow_Call{Call: _e.mock.On("Allow", peerID, msgSize)}
}

func (_c *RateLimiter_Allow_Call) Run(run func(peerID peer.ID, msgSize int)) *RateLimiter_Allow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 peer.ID
		if args[0] != nil {
			arg0 = args[0].(peer.ID)
		}
		var arg1 int
		if args[1] != nil {
			arg1 = args[1].(int)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *RateLimiter_Allow_Call) Return(b bool) *RateLimiter_Allow_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *RateLimiter_Allow_Call) RunAndReturn(run func(peerID peer.ID, msgSize int) bool) *RateLimiter_Allow_Call {
	_c.Call.Return(run)
	return _c
}

// Done provides a mock function for the type RateLimiter
func (_mock *RateLimiter) Done() <-chan struct{} {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Done")
	}

	var r0 <-chan struct{}
	if returnFunc, ok := ret.Get(0).(func() <-chan struct{}); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan struct{})
		}
	}
	return r0
}

// RateLimiter_Done_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Done'
type RateLimiter_Done_Call struct {
	*mock.Call
}

// Done is a helper method to define mock.On call
func (_e *RateLimiter_Expecter) Done() *RateLimiter_Done_Call {
	return &RateLimiter_Done_Call{Call: _e.mock.On("Done")}
}

func (_c *RateLimiter_Done_Call) Run(run func()) *RateLimiter_Done_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *RateLimiter_Done_Call) Return(valCh <-chan struct{}) *RateLimiter_Done_Call {
	_c.Call.Return(valCh)
	return _c
}

func (_c *RateLimiter_Done_Call) RunAndReturn(run func() <-chan struct{}) *RateLimiter_Done_Call {
	_c.Call.Return(run)
	return _c
}

// IsRateLimited provides a mock function for the type RateLimiter
func (_mock *RateLimiter) IsRateLimited(peerID peer.ID) bool {
	ret := _mock.Called(peerID)

	if len(ret) == 0 {
		panic("no return value specified for IsRateLimited")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(peer.ID) bool); ok {
		r0 = returnFunc(peerID)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// RateLimiter_IsRateLimited_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsRateLimited'
type RateLimiter_IsRateLimited_Call struct {
	*mock.Call
}

// IsRateLimited is a helper method to define mock.On call
//   - peerID peer.ID
func (_e *RateLimiter_Expecter) IsRateLimited(peerID interface{}) *RateLimiter_IsRateLimited_Call {
	return &RateLimiter_IsRateLimited_Call{Call: _e.mock.On("IsRateLimited", peerID)}
}

func (_c *RateLimiter_IsRateLimited_Call) Run(run func(peerID peer.ID)) *RateLimiter_IsRateLimited_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 peer.ID
		if args[0] != nil {
			arg0 = args[0].(peer.ID)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *RateLimiter_IsRateLimited_Call) Return(b bool) *RateLimiter_IsRateLimited_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *RateLimiter_IsRateLimited_Call) RunAndReturn(run func(peerID peer.ID) bool) *RateLimiter_IsRateLimited_Call {
	_c.Call.Return(run)
	return _c
}

// Ready provides a mock function for the type RateLimiter
func (_mock *RateLimiter) Ready() <-chan struct{} {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Ready")
	}

	var r0 <-chan struct{}
	if returnFunc, ok := ret.Get(0).(func() <-chan struct{}); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan struct{})
		}
	}
	return r0
}

// RateLimiter_Ready_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Ready'
type RateLimiter_Ready_Call struct {
	*mock.Call
}

// Ready is a helper method to define mock.On call
func (_e *RateLimiter_Expecter) Ready() *RateLimiter_Ready_Call {
	return &RateLimiter_Ready_Call{Call: _e.mock.On("Ready")}
}

func (_c *RateLimiter_Ready_Call) Run(run func()) *RateLimiter_Ready_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *RateLimiter_Ready_Call) Return(valCh <-chan struct{}) *RateLimiter_Ready_Call {
	_c.Call.Return(valCh)
	return _c
}

func (_c *RateLimiter_Ready_Call) RunAndReturn(run func() <-chan struct{}) *RateLimiter_Ready_Call {
	_c.Call.Return(run)
	return _c
}

// Start provides a mock function for the type RateLimiter
func (_mock *RateLimiter) Start(signalerContext irrecoverable.SignalerContext) {
	_mock.Called(signalerContext)
	return
}

// RateLimiter_Start_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Start'
type RateLimiter_Start_Call struct {
	*mock.Call
}

// Start is a helper method to define mock.On call
//   - signalerContext irrecoverable.SignalerContext
func (_e *RateLimiter_Expecter) Start(signalerContext interface{}) *RateLimiter_Start_Call {
	return &RateLimiter_Start_Call{Call: _e.mock.On("Start", signalerContext)}
}

func (_c *RateLimiter_Start_Call) Run(run func(signalerContext irrecoverable.SignalerContext)) *RateLimiter_Start_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 irrecoverable.SignalerContext
		if args[0] != nil {
			arg0 = args[0].(irrecoverable.SignalerContext)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *RateLimiter_Start_Call) Return() *RateLimiter_Start_Call {
	_c.Call.Return()
	return _c
}

func (_c *RateLimiter_Start_Call) RunAndReturn(run func(signalerContext irrecoverable.SignalerContext)) *RateLimiter_Start_Call {
	_c.Run(run)
	return _c
}

// NewBasicRateLimiter creates a new instance of BasicRateLimiter. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewBasicRateLimiter(t interface {
	mock.TestingT
	Cleanup(func())
}) *BasicRateLimiter {
	mock := &BasicRateLimiter{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// BasicRateLimiter is an autogenerated mock type for the BasicRateLimiter type
type BasicRateLimiter struct {
	mock.Mock
}

type BasicRateLimiter_Expecter struct {
	mock *mock.Mock
}

func (_m *BasicRateLimiter) EXPECT() *BasicRateLimiter_Expecter {
	return &BasicRateLimiter_Expecter{mock: &_m.Mock}
}

// Allow provides a mock function for the type BasicRateLimiter
func (_mock *BasicRateLimiter) Allow(peerID peer.ID, msgSize int) bool {
	ret := _mock.Called(peerID, msgSize)

	if len(ret) == 0 {
		panic("no return value specified for Allow")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(peer.ID, int) bool); ok {
		r0 = returnFunc(peerID, msgSize)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// BasicRateLimiter_Allow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Allow'
type BasicRateLimiter_Allow_Call struct {
	*mock.Call
}

// Allow is a helper method to define mock.On call
//   - peerID peer.ID
//   - msgSize int
func (_e *BasicRateLimiter_Expecter) Allow(peerID interface{}, msgSize interface{}) *BasicRateLimiter_Allow_Call {
	return &BasicRateLimiter_Allow_Call{Call: _e.mock.On("Allow", peerID, msgSize)}
}

func (_c *BasicRateLimiter_Allow_Call) Run(run func(peerID peer.ID, msgSize int)) *BasicRateLimiter_Allow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 peer.ID
		if args[0] != nil {
			arg0 = args[0].(peer.ID)
		}
		var arg1 int
		if args[1] != nil {
			arg1 = args[1].(int)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *BasicRateLimiter_Allow_Call) Return(b bool) *BasicRateLimiter_Allow_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *BasicRateLimiter_Allow_Call) RunAndReturn(run func(peerID peer.ID, msgSize int) bool) *BasicRateLimiter_Allow_Call {
	_c.Call.Return(run)
	return _c
}

// Done provides a mock function for the type BasicRateLimiter
func (_mock *BasicRateLimiter) Done() <-chan struct{} {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Done")
	}

	var r0 <-chan struct{}
	if returnFunc, ok := ret.Get(0).(func() <-chan struct{}); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan struct{})
		}
	}
	return r0
}

// BasicRateLimiter_Done_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Done'
type BasicRateLimiter_Done_Call struct {
	*mock.Call
}

// Done is a helper method to define mock.On call
func (_e *BasicRateLimiter_Expecter) Done() *BasicRateLimiter_Done_Call {
	return &BasicRateLimiter_Done_Call{Call: _e.mock.On("Done")}
}

func (_c *BasicRateLimiter_Done_Call) Run(run func()) *BasicRateLimiter_Done_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *BasicRateLimiter_Done_Call) Return(valCh <-chan struct{}) *BasicRateLimiter_Done_Call {
	_c.Call.Return(valCh)
	return _c
}

func (_c *BasicRateLimiter_Done_Call) RunAndReturn(run func() <-chan struct{}) *BasicRateLimiter_Done_Call {
	_c.Call.Return(run)
	return _c
}

// Ready provides a mock function for the type BasicRateLimiter
func (_mock *BasicRateLimiter) Ready() <-chan struct{} {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Ready")
	}

	var r0 <-chan struct{}
	if returnFunc, ok := ret.Get(0).(func() <-chan struct{}); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan struct{})
		}
	}
	return r0
}

// BasicRateLimiter_Ready_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Ready'
type BasicRateLimiter_Ready_Call struct {
	*mock.Call
}

// Ready is a helper method to define mock.On call
func (_e *BasicRateLimiter_Expecter) Ready() *BasicRateLimiter_Ready_Call {
	return &BasicRateLimiter_Ready_Call{Call: _e.mock.On("Ready")}
}

func (_c *BasicRateLimiter_Ready_Call) Run(run func()) *BasicRateLimiter_Ready_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *BasicRateLimiter_Ready_Call) Return(valCh <-chan struct{}) *BasicRateLimiter_Ready_Call {
	_c.Call.Return(valCh)
	return _c
}

func (_c *BasicRateLimiter_Ready_Call) RunAndReturn(run func() <-chan struct{}) *BasicRateLimiter_Ready_Call {
	_c.Call.Return(run)
	return _c
}

// Start provides a mock function for the type BasicRateLimiter
func (_mock *BasicRateLimiter) Start(signalerContext irrecoverable.SignalerContext) {
	_mock.Called(signalerContext)
	return
}

// BasicRateLimiter_Start_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Start'
type BasicRateLimiter_Start_Call struct {
	*mock.Call
}

// Start is a helper method to define mock.On call
//   - signalerContext irrecoverable.SignalerContext
func (_e *BasicRateLimiter_Expecter) Start(signalerContext interface{}) *BasicRateLimiter_Start_Call {
	return &BasicRateLimiter_Start_Call{Call: _e.mock.On("Start", signalerContext)}
}

func (_c *BasicRateLimiter_Start_Call) Run(run func(signalerContext irrecoverable.SignalerContext)) *BasicRateLimiter_Start_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 irrecoverable.SignalerContext
		if args[0] != nil {
			arg0 = args[0].(irrecoverable.SignalerContext)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *BasicRateLimiter_Start_Call) Return() *BasicRateLimiter_Start_Call {
	_c.Call.Return()
	return _c
}

func (_c *BasicRateLimiter_Start_Call) RunAndReturn(run func(signalerContext irrecoverable.SignalerContext)) *BasicRateLimiter_Start_Call {
	_c.Run(run)
	return _c
}

// NewUnicastRateLimiterDistributor creates a new instance of UnicastRateLimiterDistributor. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewUnicastRateLimiterDistributor(t interface {
	mock.TestingT
	Cleanup(func())
}) *UnicastRateLimiterDistributor {
	mock := &UnicastRateLimiterDistributor{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// UnicastRateLimiterDistributor is an autogenerated mock type for the UnicastRateLimiterDistributor type
type UnicastRateLimiterDistributor struct {
	mock.Mock
}

type UnicastRateLimiterDistributor_Expecter struct {
	mock *mock.Mock
}

func (_m *UnicastRateLimiterDistributor) EXPECT() *UnicastRateLimiterDistributor_Expecter {
	return &UnicastRateLimiterDistributor_Expecter{mock: &_m.Mock}
}

// AddConsumer provides a mock function for the type UnicastRateLimiterDistributor
func (_mock *UnicastRateLimiterDistributor) AddConsumer(consumer p2p.RateLimiterConsumer) {
	_mock.Called(consumer)
	return
}

// UnicastRateLimiterDistributor_AddConsumer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddConsumer'
type UnicastRateLimiterDistributor_AddConsumer_Call struct {
	*mock.Call
}

// AddConsumer is a helper method to define mock.On call
//   - consumer p2p.RateLimiterConsumer
func (_e *UnicastRateLimiterDistributor_Expecter) AddConsumer(consumer interface{}) *UnicastRateLimiterDistributor_AddConsumer_Call {
	return &UnicastRateLimiterDistributor_AddConsumer_Call{Call: _e.mock.On("AddConsumer", consumer)}
}

func (_c *UnicastRateLimiterDistributor_AddConsumer_Call) Run(run func(consumer p2p.RateLimiterConsumer)) *UnicastRateLimiterDistributor_AddConsumer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 p2p.RateLimiterConsumer
		if args[0] != nil {
			arg0 = args[0].(p2p.RateLimiterConsumer)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *UnicastRateLimiterDistributor_AddConsumer_Call) Return() *UnicastRateLimiterDistributor_AddConsumer_Call {
	_c.Call.Return()
	return _c
}

func (_c *UnicastRateLimiterDistributor_AddConsumer_Call) RunAndReturn(run func(consumer p2p.RateLimiterConsumer)) *UnicastRateLimiterDistributor_AddConsumer_Call {
	_c.Run(run)
	return _c
}

// OnRateLimitedPeer provides a mock function for the type UnicastRateLimiterDistributor
func (_mock *UnicastRateLimiterDistributor) OnRateLimitedPeer(pid peer.ID, role string, msgType string, topic string, reason string) {
	_mock.Called(pid, role, msgType, topic, reason)
	return
}

// UnicastRateLimiterDistributor_OnRateLimitedPeer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnRateLimitedPeer'
type UnicastRateLimiterDistributor_OnRateLimitedPeer_Call struct {
	*mock.Call
}

// OnRateLimitedPeer is a helper method to define mock.On call
//   - pid peer.ID
//   - role string
//   - msgType string
//   - topic string
//   - reason string
func (_e *UnicastRateLimiterDistributor_Expecter) OnRateLimitedPeer(pid interface{}, role interface{}, msgType interface{}, topic interface{}, reason interface{}) *UnicastRateLimiterDistributor_OnRateLimitedPeer_Call {
	return &UnicastRateLimiterDistributor_OnRateLimitedPeer_Call{Call: _e.mock.On("OnRateLimitedPeer", pid, role, msgType, topic, reason)}
}

func (_c *UnicastRateLimiterDistributor_OnRateLimitedPeer_Call) Run(run func(pid peer.ID, role string, msgType string, topic string, reason string)) *UnicastRateLimiterDistributor_OnRateLimitedPeer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 peer.ID
		if args[0] != nil {
			arg0 = args[0].(peer.ID)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		var arg4 string
		if args[4] != nil {
			arg4 = args[4].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *UnicastRateLimiterDistributor_OnRateLimitedPeer_Call) Return() *UnicastRateLimiterDistributor_OnRateLimitedPeer_Call {
	_c.Call.Return()
	return _c
}

func (_c *UnicastRateLimiterDistributor_OnRateLimitedPeer_Call) RunAndReturn(run func(pid peer.ID, role string, msgType string, topic string, reason string)) *UnicastRateLimiterDistributor_OnRateLimitedPeer_Call {
	_c.Run(run)
	return _c
}

// NewRateLimiterConsumer creates a new instance of RateLimiterConsumer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewRateLimiterConsumer(t interface {
	mock.TestingT
	Cleanup(func())
}) *RateLimiterConsumer {
	mock := &RateLimiterConsumer{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// RateLimiterConsumer is an autogenerated mock type for the RateLimiterConsumer type
type RateLimiterConsumer struct {
	mock.Mock
}

type RateLimiterConsumer_Expecter struct {
	mock *mock.Mock
}

func (_m *RateLimiterConsumer) EXPECT() *RateLimiterConsumer_Expecter {
	return &RateLimiterConsumer_Expecter{mock: &_m.Mock}
}

// OnRateLimitedPeer provides a mock function for the type RateLimiterConsumer
func (_mock *RateLimiterConsumer) OnRateLimitedPeer(pid peer.ID, role string, msgType string, topic string, reason string) {
	_mock.Called(pid, role, msgType, topic, reason)
	return
}

// RateLimiterConsumer_OnRateLimitedPeer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnRateLimitedPeer'
type RateLimiterConsumer_OnRateLimitedPeer_Call struct {
	*mock.Call
}

// OnRateLimitedPeer is a helper method to define mock.On call
//   - pid peer.ID
//   - role string
//   - msgType string
//   - topic string
//   - reason string
func (_e *RateLimiterConsumer_Expecter) OnRateLimitedPeer(pid interface{}, role interface{}, msgType interface{}, topic interface{}, reason interface{}) *RateLimiterConsumer_OnRateLimitedPeer_Call {
	return &RateLimiterConsumer_OnRateLimitedPeer_Call{Call: _e.mock.On("OnRateLimitedPeer", pid, role, msgType, topic, reason)}
}

func (_c *RateLimiterConsumer_OnRateLimitedPeer_Call) Run(run func(pid peer.ID, role string, msgType string, topic string, reason string)) *RateLimiterConsumer_OnRateLimitedPeer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 peer.ID
		if args[0] != nil {
			arg0 = args[0].(peer.ID)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		var arg4 string
		if args[4] != nil {
			arg4 = args[4].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *RateLimiterConsumer_OnRateLimitedPeer_Call) Return() *RateLimiterConsumer_OnRateLimitedPeer_Call {
	_c.Call.Return()
	return _c
}

func (_c *RateLimiterConsumer_OnRateLimitedPeer_Call) RunAndReturn(run func(pid peer.ID, role string, msgType string, topic string, reason string)) *RateLimiterConsumer_OnRateLimitedPeer_Call {
	_c.Run(run)
	return _c
}

// NewStreamFactory creates a new instance of StreamFactory. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewStreamFactory(t interface {
	mock.TestingT
	Cleanup(func())
}) *StreamFactory {
	mock := &StreamFactory{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// StreamFactory is an autogenerated mock type for the StreamFactory type
type StreamFactory struct {
	mock.Mock
}

type StreamFactory_Expecter struct {
	mock *mock.Mock
}

func (_m *StreamFactory) EXPECT() *StreamFactory_Expecter {
	return &StreamFactory_Expecter{mock: &_m.Mock}
}

// NewStream provides a mock function for the type StreamFactory
func (_mock *StreamFactory) NewStream(context1 context.Context, iD peer.ID, iD1 protocol.ID) (network.Stream, error) {
	ret := _mock.Called(context1, iD, iD1)

	if len(ret) == 0 {
		panic("no return value specified for NewStream")
	}

	var r0 network.Stream
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, peer.ID, protocol.ID) (network.Stream, error)); ok {
		return returnFunc(context1, iD, iD1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, peer.ID, protocol.ID) network.Stream); ok {
		r0 = returnFunc(context1, iD, iD1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(network.Stream)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, peer.ID, protocol.ID) error); ok {
		r1 = returnFunc(context1, iD, iD1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// StreamFactory_NewStream_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NewStream'
type StreamFactory_NewStream_Call struct {
	*mock.Call
}

// NewStream is a helper method to define mock.On call
//   - context1 context.Context
//   - iD peer.ID
//   - iD1 protocol.ID
func (_e *StreamFactory_Expecter) NewStream(context1 interface{}, iD interface{}, iD1 interface{}) *StreamFactory_NewStream_Call {
	return &StreamFactory_NewStream_Call{Call: _e.mock.On("NewStream", context1, iD, iD1)}
}

func (_c *StreamFactory_NewStream_Call) Run(run func(context1 context.Context, iD peer.ID, iD1 protocol.ID)) *StreamFactory_NewStream_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 peer.ID
		if args[1] != nil {
			arg1 = args[1].(peer.ID)
		}
		var arg2 protocol.ID
		if args[2] != nil {
			arg2 = args[2].(protocol.ID)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *StreamFactory_NewStream_Call) Return(stream network.Stream, err error) *StreamFactory_NewStream_Call {
	_c.Call.Return(stream, err)
	return _c
}

func (_c *StreamFactory_NewStream_Call) RunAndReturn(run func(context1 context.Context, iD peer.ID, iD1 protocol.ID) (network.Stream, error)) *StreamFactory_NewStream_Call {
	_c.Call.Return(run)
	return _c
}

// SetStreamHandler provides a mock function for the type StreamFactory
func (_mock *StreamFactory) SetStreamHandler(iD protocol.ID, streamHandler network.StreamHandler) {
	_mock.Called(iD, streamHandler)
	return
}

// StreamFactory_SetStreamHandler_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetStreamHandler'
type StreamFactory_SetStreamHandler_Call struct {
	*mock.Call
}

// SetStreamHandler is a helper method to define mock.On call
//   - iD protocol.ID
//   - streamHandler network.StreamHandler
func (_e *StreamFactory_Expecter) SetStreamHandler(iD interface{}, streamHandler interface{}) *StreamFactory_SetStreamHandler_Call {
	return &StreamFactory_SetStreamHandler_Call{Call: _e.mock.On("SetStreamHandler", iD, streamHandler)}
}

func (_c *StreamFactory_SetStreamHandler_Call) Run(run func(iD protocol.ID, streamHandler network.StreamHandler)) *StreamFactory_SetStreamHandler_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 protocol.ID
		if args[0] != nil {
			arg0 = args[0].(protocol.ID)
		}
		var arg1 network.StreamHandler
		if args[1] != nil {
			arg1 = args[1].(network.StreamHandler)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *StreamFactory_SetStreamHandler_Call) Return() *StreamFactory_SetStreamHandler_Call {
	_c.Call.Return()
	return _c
}

func (_c *StreamFactory_SetStreamHandler_Call) RunAndReturn(run func(iD protocol.ID, streamHandler network.StreamHandler)) *StreamFactory_SetStreamHandler_Call {
	_c.Run(run)
	return _c
}

// NewSubscriptionProvider creates a new instance of SubscriptionProvider. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewSubscriptionProvider(t interface {
	mock.TestingT
	Cleanup(func())
}) *SubscriptionProvider {
	mock := &SubscriptionProvider{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// SubscriptionProvider is an autogenerated mock type for the SubscriptionProvider type
type SubscriptionProvider struct {
	mock.Mock
}

type SubscriptionProvider_Expecter struct {
	mock *mock.Mock
}

func (_m *SubscriptionProvider) EXPECT() *SubscriptionProvider_Expecter {
	return &SubscriptionProvider_Expecter{mock: &_m.Mock}
}

// Done provides a mock function for the type SubscriptionProvider
func (_mock *SubscriptionProvider) Done() <-chan struct{} {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Done")
	}

	var r0 <-chan struct{}
	if returnFunc, ok := ret.Get(0).(func() <-chan struct{}); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan struct{})
		}
	}
	return r0
}

// SubscriptionProvider_Done_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Done'
type SubscriptionProvider_Done_Call struct {
	*mock.Call
}

// Done is a helper method to define mock.On call
func (_e *SubscriptionProvider_Expecter) Done() *SubscriptionProvider_Done_Call {
	return &SubscriptionProvider_Done_Call{Call: _e.mock.On("Done")}
}

func (_c *SubscriptionProvider_Done_Call) Run(run func()) *SubscriptionProvider_Done_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *SubscriptionProvider_Done_Call) Return(valCh <-chan struct{}) *SubscriptionProvider_Done_Call {
	_c.Call.Return(valCh)
	return _c
}

func (_c *SubscriptionProvider_Done_Call) RunAndReturn(run func() <-chan struct{}) *SubscriptionProvider_Done_Call {
	_c.Call.Return(run)
	return _c
}

// GetSubscribedTopics provides a mock function for the type SubscriptionProvider
func (_mock *SubscriptionProvider) GetSubscribedTopics(pid peer.ID) []string {
	ret := _mock.Called(pid)

	if len(ret) == 0 {
		panic("no return value specified for GetSubscribedTopics")
	}

	var r0 []string
	if returnFunc, ok := ret.Get(0).(func(peer.ID) []string); ok {
		r0 = returnFunc(pid)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}
	return r0
}

// SubscriptionProvider_GetSubscribedTopics_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSubscribedTopics'
type SubscriptionProvider_GetSubscribedTopics_Call struct {
	*mock.Call
}

// GetSubscribedTopics is a helper method to define mock.On call
//   - pid peer.ID
func (_e *SubscriptionProvider_Expecter) GetSubscribedTopics(pid interface{}) *SubscriptionProvider_GetSubscribedTopics_Call {
	return &SubscriptionProvider_GetSubscribedTopics_Call{Call: _e.mock.On("GetSubscribedTopics", pid)}
}

func (_c *SubscriptionProvider_GetSubscribedTopics_Call) Run(run func(pid peer.ID)) *SubscriptionProvider_GetSubscribedTopics_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 peer.ID
		if args[0] != nil {
			arg0 = args[0].(peer.ID)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *SubscriptionProvider_GetSubscribedTopics_Call) Return(strings []string) *SubscriptionProvider_GetSubscribedTopics_Call {
	_c.Call.Return(strings)
	return _c
}

func (_c *SubscriptionProvider_GetSubscribedTopics_Call) RunAndReturn(run func(pid peer.ID) []string) *SubscriptionProvider_GetSubscribedTopics_Call {
	_c.Call.Return(run)
	return _c
}

// Ready provides a mock function for the type SubscriptionProvider
func (_mock *SubscriptionProvider) Ready() <-chan struct{} {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Ready")
	}

	var r0 <-chan struct{}
	if returnFunc, ok := ret.Get(0).(func() <-chan struct{}); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan struct{})
		}
	}
	return r0
}

// SubscriptionProvider_Ready_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Ready'
type SubscriptionProvider_Ready_Call struct {
	*mock.Call
}

// Ready is a helper method to define mock.On call
func (_e *SubscriptionProvider_Expecter) Ready() *SubscriptionProvider_Ready_Call {
	return &SubscriptionProvider_Ready_Call{Call: _e.mock.On("Ready")}
}

func (_c *SubscriptionProvider_Ready_Call) Run(run func()) *SubscriptionProvider_Ready_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *SubscriptionProvider_Ready_Call) Return(valCh <-chan struct{}) *SubscriptionProvider_Ready_Call {
	_c.Call.Return(valCh)
	return _c
}

func (_c *SubscriptionProvider_Ready_Call) RunAndReturn(run func() <-chan struct{}) *SubscriptionProvider_Ready_Call {
	_c.Call.Return(run)
	return _c
}

// Start provides a mock function for the type SubscriptionProvider
func (_mock *SubscriptionProvider) Start(signalerContext irrecoverable.SignalerContext) {
	_mock.Called(signalerContext)
	return
}

// SubscriptionProvider_Start_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Start'
type SubscriptionProvider_Start_Call struct {
	*mock.Call
}

// Start is a helper method to define mock.On call
//   - signalerContext irrecoverable.SignalerContext
func (_e *SubscriptionProvider_Expecter) Start(signalerContext interface{}) *SubscriptionProvider_Start_Call {
	return &SubscriptionProvider_Start_Call{Call: _e.mock.On("Start", signalerContext)}
}

func (_c *SubscriptionProvider_Start_Call) Run(run func(signalerContext irrecoverable.SignalerContext)) *SubscriptionProvider_Start_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 irrecoverable.SignalerContext
		if args[0] != nil {
			arg0 = args[0].(irrecoverable.SignalerContext)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *SubscriptionProvider_Start_Call) Return() *SubscriptionProvider_Start_Call {
	_c.Call.Return()
	return _c
}

func (_c *SubscriptionProvider_Start_Call) RunAndReturn(run func(signalerContext irrecoverable.SignalerContext)) *SubscriptionProvider_Start_Call {
	_c.Run(run)
	return _c
}

// NewSubscriptionValidator creates a new instance of SubscriptionValidator. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewSubscriptionValidator(t interface {
	mock.TestingT
	Cleanup(func())
}) *SubscriptionValidator {
	mock := &SubscriptionValidator{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// SubscriptionValidator is an autogenerated mock type for the SubscriptionValidator type
type SubscriptionValidator struct {
	mock.Mock
}

type SubscriptionValidator_Expecter struct {
	mock *mock.Mock
}

func (_m *SubscriptionValidator) EXPECT() *SubscriptionValidator_Expecter {
	return &SubscriptionValidator_Expecter{mock: &_m.Mock}
}

// CheckSubscribedToAllowedTopics provides a mock function for the type SubscriptionValidator
func (_mock *SubscriptionValidator) CheckSubscribedToAllowedTopics(pid peer.ID, role flow.Role) error {
	ret := _mock.Called(pid, role)

	if len(ret) == 0 {
		panic("no return value specified for CheckSubscribedToAllowedTopics")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(peer.ID, flow.Role) error); ok {
		r0 = returnFunc(pid, role)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// SubscriptionValidator_CheckSubscribedToAllowedTopics_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckSubscribedToAllowedTopics'
type SubscriptionValidator_CheckSubscribedToAllowedTopics_Call struct {
	*mock.Call
}

// CheckSubscribedToAllowedTopics is a helper method to define mock.On call
//   - pid peer.ID
//   - role flow.Role
func (_e *SubscriptionValidator_Expecter) CheckSubscribedToAllowedTopics(pid interface{}, role interface{}) *SubscriptionValidator_CheckSubscribedToAllowedTopics_Call {
	return &SubscriptionValidator_CheckSubscribedToAllowedTopics_Call{Call: _e.mock.On("CheckSubscribedToAllowedTopics", pid, role)}
}

func (_c *SubscriptionValidator_CheckSubscribedToAllowedTopics_Call) Run(run func(pid peer.ID, role flow.Role)) *SubscriptionValidator_CheckSubscribedToAllowedTopics_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 peer.ID
		if args[0] != nil {
			arg0 = args[0].(peer.ID)
		}
		var arg1 flow.Role
		if args[1] != nil {
			arg1 = args[1].(flow.Role)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *SubscriptionValidator_CheckSubscribedToAllowedTopics_Call) Return(err error) *SubscriptionValidator_CheckSubscribedToAllowedTopics_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *SubscriptionValidator_CheckSubscribedToAllowedTopics_Call) RunAndReturn(run func(pid peer.ID, role flow.Role) error) *SubscriptionValidator_CheckSubscribedToAllowedTopics_Call {
	_c.Call.Return(run)
	return _c
}

// Done provides a mock function for the type SubscriptionValidator
func (_mock *SubscriptionValidator) Done() <-chan struct{} {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Done")
	}

	var r0 <-chan struct{}
	if returnFunc, ok := ret.Get(0).(func() <-chan struct{}); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan struct{})
		}
	}
	return r0
}

// SubscriptionValidator_Done_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Done'
type SubscriptionValidator_Done_Call struct {
	*mock.Call
}

// Done is a helper method to define mock.On call
func (_e *SubscriptionValidator_Expecter) Done() *SubscriptionValidator_Done_Call {
	return &SubscriptionValidator_Done_Call{Call: _e.mock.On("Done")}
}

func (_c *SubscriptionValidator_Done_Call) Run(run func()) *SubscriptionValidator_Done_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *SubscriptionValidator_Done_Call) Return(valCh <-chan struct{}) *SubscriptionValidator_Done_Call {
	_c.Call.Return(valCh)
	return _c
}

func (_c *SubscriptionValidator_Done_Call) RunAndReturn(run func() <-chan struct{}) *SubscriptionValidator_Done_Call {
	_c.Call.Return(run)
	return _c
}

// Ready provides a mock function for the type SubscriptionValidator
func (_mock *SubscriptionValidator) Ready() <-chan struct{} {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Ready")
	}

	var r0 <-chan struct{}
	if returnFunc, ok := ret.Get(0).(func() <-chan struct{}); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan struct{})
		}
	}
	return r0
}

// SubscriptionValidator_Ready_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Ready'
type SubscriptionValidator_Ready_Call struct {
	*mock.Call
}

// Ready is a helper method to define mock.On call
func (_e *SubscriptionValidator_Expecter) Ready() *SubscriptionValidator_Ready_Call {
	return &SubscriptionValidator_Ready_Call{Call: _e.mock.On("Ready")}
}

func (_c *SubscriptionValidator_Ready_Call) Run(run func()) *SubscriptionValidator_Ready_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *SubscriptionValidator_Ready_Call) Return(valCh <-chan struct{}) *SubscriptionValidator_Ready_Call {
	_c.Call.Return(valCh)
	return _c
}

func (_c *SubscriptionValidator_Ready_Call) RunAndReturn(run func() <-chan struct{}) *SubscriptionValidator_Ready_Call {
	_c.Call.Return(run)
	return _c
}

// Start provides a mock function for the type SubscriptionValidator
func (_mock *SubscriptionValidator) Start(signalerContext irrecoverable.SignalerContext) {
	_mock.Called(signalerContext)
	return
}

// SubscriptionValidator_Start_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Start'
type SubscriptionValidator_Start_Call struct {
	*mock.Call
}

// Start is a helper method to define mock.On call
//   - signalerContext irrecoverable.SignalerContext
func (_e *SubscriptionValidator_Expecter) Start(signalerContext interface{}) *SubscriptionValidator_Start_Call {
	return &SubscriptionValidator_Start_Call{Call: _e.mock.On("Start", signalerContext)}
}

func (_c *SubscriptionValidator_Start_Call) Run(run func(signalerContext irrecoverable.SignalerContext)) *SubscriptionValidator_Start_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 irrecoverable.SignalerContext
		if args[0] != nil {
			arg0 = args[0].(irrecoverable.SignalerContext)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *SubscriptionValidator_Start_Call) Return() *SubscriptionValidator_Start_Call {
	_c.Call.Return()
	return _c
}

func (_c *SubscriptionValidator_Start_Call) RunAndReturn(run func(signalerContext irrecoverable.SignalerContext)) *SubscriptionValidator_Start_Call {
	_c.Run(run)
	return _c
}

// NewTopicProvider creates a new instance of TopicProvider. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewTopicProvider(t interface {
	mock.TestingT
	Cleanup(func())
}) *TopicProvider {
	mock := &TopicProvider{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// TopicProvider is an autogenerated mock type for the TopicProvider type
type TopicProvider struct {
	mock.Mock
}

type TopicProvider_Expecter struct {
	mock *mock.Mock
}

func (_m *TopicProvider) EXPECT() *TopicProvider_Expecter {
	return &TopicProvider_Expecter{mock: &_m.Mock}
}

// GetTopics provides a mock function for the type TopicProvider
func (_mock *TopicProvider) GetTopics() []string {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetTopics")
	}

	var r0 []string
	if returnFunc, ok := ret.Get(0).(func() []string); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}
	return r0
}

// TopicProvider_GetTopics_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTopics'
type TopicProvider_GetTopics_Call struct {
	*mock.Call
}

// GetTopics is a helper method to define mock.On call
func (_e *TopicProvider_Expecter) GetTopics() *TopicProvider_GetTopics_Call {
	return &TopicProvider_GetTopics_Call{Call: _e.mock.On("GetTopics")}
}

func (_c *TopicProvider_GetTopics_Call) Run(run func()) *TopicProvider_GetTopics_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *TopicProvider_GetTopics_Call) Return(strings []string) *TopicProvider_GetTopics_Call {
	_c.Call.Return(strings)
	return _c
}

func (_c *TopicProvider_GetTopics_Call) RunAndReturn(run func() []string) *TopicProvider_GetTopics_Call {
	_c.Call.Return(run)
	return _c
}

// ListPeers provides a mock function for the type TopicProvider
func (_mock *TopicProvider) ListPeers(topic string) []peer.ID {
	ret := _mock.Called(topic)

	if len(ret) == 0 {
		panic("no return value specified for ListPeers")
	}

	var r0 []peer.ID
	if returnFunc, ok := ret.Get(0).(func(string) []peer.ID); ok {
		r0 = returnFunc(topic)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]peer.ID)
		}
	}
	return r0
}

// TopicProvider_ListPeers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListPeers'
type TopicProvider_ListPeers_Call struct {
	*mock.Call
}

// ListPeers is a helper method to define mock.On call
//   - topic string
func (_e *TopicProvider_Expecter) ListPeers(topic interface{}) *TopicProvider_ListPeers_Call {
	return &TopicProvider_ListPeers_Call{Call: _e.mock.On("ListPeers", topic)}
}

func (_c *TopicProvider_ListPeers_Call) Run(run func(topic string)) *TopicProvider_ListPeers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *TopicProvider_ListPeers_Call) Return(iDs []peer.ID) *TopicProvider_ListPeers_Call {
	_c.Call.Return(iDs)
	return _c
}

func (_c *TopicProvider_ListPeers_Call) RunAndReturn(run func(topic string) []peer.ID) *TopicProvider_ListPeers_Call {
	_c.Call.Return(run)
	return _c
}

// NewUnicastManager creates a new instance of UnicastManager. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewUnicastManager(t interface {
	mock.TestingT
	Cleanup(func())
}) *UnicastManager {
	mock := &UnicastManager{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// UnicastManager is an autogenerated mock type for the UnicastManager type
type UnicastManager struct {
	mock.Mock
}

type UnicastManager_Expecter struct {
	mock *mock.Mock
}

func (_m *UnicastManager) EXPECT() *UnicastManager_Expecter {
	return &UnicastManager_Expecter{mock: &_m.Mock}
}

// CreateStream provides a mock function for the type UnicastManager
func (_mock *UnicastManager) CreateStream(ctx context.Context, peerID peer.ID) (network.Stream, error) {
	ret := _mock.Called(ctx, peerID)

	if len(ret) == 0 {
		panic("no return value specified for CreateStream")
	}

	var r0 network.Stream
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, peer.ID) (network.Stream, error)); ok {
		return returnFunc(ctx, peerID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, peer.ID) network.Stream); ok {
		r0 = returnFunc(ctx, peerID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(network.Stream)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, peer.ID) error); ok {
		r1 = returnFunc(ctx, peerID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// UnicastManager_CreateStream_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateStream'
type UnicastManager_CreateStream_Call struct {
	*mock.Call
}

// CreateStream is a helper method to define mock.On call
//   - ctx context.Context
//   - peerID peer.ID
func (_e *UnicastManager_Expecter) CreateStream(ctx interface{}, peerID interface{}) *UnicastManager_CreateStream_Call {
	return &UnicastManager_CreateStream_Call{Call: _e.mock.On("CreateStream", ctx, peerID)}
}

func (_c *UnicastManager_CreateStream_Call) Run(run func(ctx context.Context, peerID peer.ID)) *UnicastManager_CreateStream_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 peer.ID
		if args[1] != nil {
			arg1 = args[1].(peer.ID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *UnicastManager_CreateStream_Call) Return(stream network.Stream, err error) *UnicastManager_CreateStream_Call {
	_c.Call.Return(stream, err)
	return _c
}

func (_c *UnicastManager_CreateStream_Call) RunAndReturn(run func(ctx context.Context, peerID peer.ID) (network.Stream, error)) *UnicastManager_CreateStream_Call {
	_c.Call.Return(run)
	return _c
}

// Register provides a mock function for the type UnicastManager
func (_mock *UnicastManager) Register(unicast protocols.ProtocolName) error {
	ret := _mock.Called(unicast)

	if len(ret) == 0 {
		panic("no return value specified for Register")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(protocols.ProtocolName) error); ok {
		r0 = returnFunc(unicast)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// UnicastManager_Register_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Register'
type UnicastManager_Register_Call struct {
	*mock.Call
}

// Register is a helper method to define mock.On call
//   - unicast protocols.ProtocolName
func (_e *UnicastManager_Expecter) Register(unicast interface{}) *UnicastManager_Register_Call {
	return &UnicastManager_Register_Call{Call: _e.mock.On("Register", unicast)}
}

func (_c *UnicastManager_Register_Call) Run(run func(unicast protocols.ProtocolName)) *UnicastManager_Register_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 protocols.ProtocolName
		if args[0] != nil {
			arg0 = args[0].(protocols.ProtocolName)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *UnicastManager_Register_Call) Return(err error) *UnicastManager_Register_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *UnicastManager_Register_Call) RunAndReturn(run func(unicast protocols.ProtocolName) error) *UnicastManager_Register_Call {
	_c.Call.Return(run)
	return _c
}

// SetDefaultHandler provides a mock function for the type UnicastManager
func (_mock *UnicastManager) SetDefaultHandler(defaultHandler network.StreamHandler) {
	_mock.Called(defaultHandler)
	return
}

// UnicastManager_SetDefaultHandler_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetDefaultHandler'
type UnicastManager_SetDefaultHandler_Call struct {
	*mock.Call
}

// SetDefaultHandler is a helper method to define mock.On call
//   - defaultHandler network.StreamHandler
func (_e *UnicastManager_Expecter) SetDefaultHandler(defaultHandler interface{}) *UnicastManager_SetDefaultHandler_Call {
	return &UnicastManager_SetDefaultHandler_Call{Call: _e.mock.On("SetDefaultHandler", defaultHandler)}
}

func (_c *UnicastManager_SetDefaultHandler_Call) Run(run func(defaultHandler network.StreamHandler)) *UnicastManager_SetDefaultHandler_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 network.StreamHandler
		if args[0] != nil {
			arg0 = args[0].(network.StreamHandler)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *UnicastManager_SetDefaultHandler_Call) Return() *UnicastManager_SetDefaultHandler_Call {
	_c.Call.Return()
	return _c
}

func (_c *UnicastManager_SetDefaultHandler_Call) RunAndReturn(run func(defaultHandler network.StreamHandler)) *UnicastManager_SetDefaultHandler_Call {
	_c.Run(run)
	return _c
}
