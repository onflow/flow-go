// Code generated by mockery v2.21.4. DO NOT EDIT.

package mockp2p

import (
	component "github.com/onflow/flow-go/module/component"
	channels "github.com/onflow/flow-go/network/channels"

	context "context"

	corenetwork "github.com/libp2p/go-libp2p/core/network"

	host "github.com/libp2p/go-libp2p/core/host"

	kbucket "github.com/libp2p/go-libp2p-kbucket"

	mock "github.com/stretchr/testify/mock"

	network "github.com/onflow/flow-go/network"

	p2p "github.com/onflow/flow-go/network/p2p"

	peer "github.com/libp2p/go-libp2p/core/peer"

	protocol "github.com/libp2p/go-libp2p/core/protocol"

	protocols "github.com/onflow/flow-go/network/p2p/unicast/protocols"
)

// PeerManagement is an autogenerated mock type for the PeerManagement type
type PeerManagement struct {
	mock.Mock
}

// ConnectToPeer provides a mock function with given fields: ctx, peerInfo
func (_m *PeerManagement) ConnectToPeer(ctx context.Context, peerInfo peer.AddrInfo) error {
	ret := _m.Called(ctx, peerInfo)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, peer.AddrInfo) error); ok {
		r0 = rf(ctx, peerInfo)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetIPPort provides a mock function with given fields:
func (_m *PeerManagement) GetIPPort() (string, string, error) {
	ret := _m.Called()

	var r0 string
	var r1 string
	var r2 error
	if rf, ok := ret.Get(0).(func() (string, string, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func() string); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func() error); ok {
		r2 = rf()
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetPeersForProtocol provides a mock function with given fields: pid
func (_m *PeerManagement) GetPeersForProtocol(pid protocol.ID) peer.IDSlice {
	ret := _m.Called(pid)

	var r0 peer.IDSlice
	if rf, ok := ret.Get(0).(func(protocol.ID) peer.IDSlice); ok {
		r0 = rf(pid)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(peer.IDSlice)
		}
	}

	return r0
}

// Host provides a mock function with given fields:
func (_m *PeerManagement) Host() host.Host {
	ret := _m.Called()

	var r0 host.Host
	if rf, ok := ret.Get(0).(func() host.Host); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(host.Host)
		}
	}

	return r0
}

// ID provides a mock function with given fields:
func (_m *PeerManagement) ID() peer.ID {
	ret := _m.Called()

	var r0 peer.ID
	if rf, ok := ret.Get(0).(func() peer.ID); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(peer.ID)
	}

	return r0
}

// ListPeers provides a mock function with given fields: topic
func (_m *PeerManagement) ListPeers(topic string) []peer.ID {
	ret := _m.Called(topic)

	var r0 []peer.ID
	if rf, ok := ret.Get(0).(func(string) []peer.ID); ok {
		r0 = rf(topic)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]peer.ID)
		}
	}

	return r0
}

// PeerManagerComponent provides a mock function with given fields:
func (_m *PeerManagement) PeerManagerComponent() component.Component {
	ret := _m.Called()

	var r0 component.Component
	if rf, ok := ret.Get(0).(func() component.Component); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(component.Component)
		}
	}

	return r0
}

// Publish provides a mock function with given fields: ctx, messageScope
func (_m *PeerManagement) Publish(ctx context.Context, messageScope network.OutgoingMessageScope) error {
	ret := _m.Called(ctx, messageScope)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, network.OutgoingMessageScope) error); ok {
		r0 = rf(ctx, messageScope)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RemovePeer provides a mock function with given fields: peerID
func (_m *PeerManagement) RemovePeer(peerID peer.ID) error {
	ret := _m.Called(peerID)

	var r0 error
	if rf, ok := ret.Get(0).(func(peer.ID) error); ok {
		r0 = rf(peerID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RequestPeerUpdate provides a mock function with given fields:
func (_m *PeerManagement) RequestPeerUpdate() {
	_m.Called()
}

// RoutingTable provides a mock function with given fields:
func (_m *PeerManagement) RoutingTable() *kbucket.RoutingTable {
	ret := _m.Called()

	var r0 *kbucket.RoutingTable
	if rf, ok := ret.Get(0).(func() *kbucket.RoutingTable); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kbucket.RoutingTable)
		}
	}

	return r0
}

// Subscribe provides a mock function with given fields: topic, topicValidator
func (_m *PeerManagement) Subscribe(topic channels.Topic, topicValidator p2p.TopicValidatorFunc) (p2p.Subscription, error) {
	ret := _m.Called(topic, topicValidator)

	var r0 p2p.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(channels.Topic, p2p.TopicValidatorFunc) (p2p.Subscription, error)); ok {
		return rf(topic, topicValidator)
	}
	if rf, ok := ret.Get(0).(func(channels.Topic, p2p.TopicValidatorFunc) p2p.Subscription); ok {
		r0 = rf(topic, topicValidator)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(p2p.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(channels.Topic, p2p.TopicValidatorFunc) error); ok {
		r1 = rf(topic, topicValidator)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Unsubscribe provides a mock function with given fields: topic
func (_m *PeerManagement) Unsubscribe(topic channels.Topic) error {
	ret := _m.Called(topic)

	var r0 error
	if rf, ok := ret.Get(0).(func(channels.Topic) error); ok {
		r0 = rf(topic)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WithDefaultUnicastProtocol provides a mock function with given fields: defaultHandler, preferred
func (_m *PeerManagement) WithDefaultUnicastProtocol(defaultHandler corenetwork.StreamHandler, preferred []protocols.ProtocolName) error {
	ret := _m.Called(defaultHandler, preferred)

	var r0 error
	if rf, ok := ret.Get(0).(func(corenetwork.StreamHandler, []protocols.ProtocolName) error); ok {
		r0 = rf(defaultHandler, preferred)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WithPeersProvider provides a mock function with given fields: peersProvider
func (_m *PeerManagement) WithPeersProvider(peersProvider p2p.PeersProvider) {
	_m.Called(peersProvider)
}

type mockConstructorTestingTNewPeerManagement interface {
	mock.TestingT
	Cleanup(func())
}

// NewPeerManagement creates a new instance of PeerManagement. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewPeerManagement(t mockConstructorTestingTNewPeerManagement) *PeerManagement {
	mock := &PeerManagement{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
