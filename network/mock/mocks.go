// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mock

import (
	"context"
	"io"
	"net"
	"time"

	"github.com/ipfs/go-cid"
	"github.com/ipfs/go-datastore"
	"github.com/libp2p/go-libp2p/core/peer"
	"github.com/libp2p/go-libp2p/core/protocol"
	"github.com/onflow/flow-go/model/flow"
	"github.com/onflow/flow-go/model/messages"
	"github.com/onflow/flow-go/module/blobs"
	"github.com/onflow/flow-go/module/irrecoverable"
	"github.com/onflow/flow-go/network"
	"github.com/onflow/flow-go/network/channels"
	"github.com/onflow/flow-go/network/message"
	mock "github.com/stretchr/testify/mock"
)

// NewMisbehaviorReporter creates a new instance of MisbehaviorReporter. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMisbehaviorReporter(t interface {
	mock.TestingT
	Cleanup(func())
}) *MisbehaviorReporter {
	mock := &MisbehaviorReporter{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MisbehaviorReporter is an autogenerated mock type for the MisbehaviorReporter type
type MisbehaviorReporter struct {
	mock.Mock
}

type MisbehaviorReporter_Expecter struct {
	mock *mock.Mock
}

func (_m *MisbehaviorReporter) EXPECT() *MisbehaviorReporter_Expecter {
	return &MisbehaviorReporter_Expecter{mock: &_m.Mock}
}

// ReportMisbehavior provides a mock function for the type MisbehaviorReporter
func (_mock *MisbehaviorReporter) ReportMisbehavior(misbehaviorReport network.MisbehaviorReport) {
	_mock.Called(misbehaviorReport)
	return
}

// MisbehaviorReporter_ReportMisbehavior_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReportMisbehavior'
type MisbehaviorReporter_ReportMisbehavior_Call struct {
	*mock.Call
}

// ReportMisbehavior is a helper method to define mock.On call
//   - misbehaviorReport network.MisbehaviorReport
func (_e *MisbehaviorReporter_Expecter) ReportMisbehavior(misbehaviorReport interface{}) *MisbehaviorReporter_ReportMisbehavior_Call {
	return &MisbehaviorReporter_ReportMisbehavior_Call{Call: _e.mock.On("ReportMisbehavior", misbehaviorReport)}
}

func (_c *MisbehaviorReporter_ReportMisbehavior_Call) Run(run func(misbehaviorReport network.MisbehaviorReport)) *MisbehaviorReporter_ReportMisbehavior_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 network.MisbehaviorReport
		if args[0] != nil {
			arg0 = args[0].(network.MisbehaviorReport)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MisbehaviorReporter_ReportMisbehavior_Call) Return() *MisbehaviorReporter_ReportMisbehavior_Call {
	_c.Call.Return()
	return _c
}

func (_c *MisbehaviorReporter_ReportMisbehavior_Call) RunAndReturn(run func(misbehaviorReport network.MisbehaviorReport)) *MisbehaviorReporter_ReportMisbehavior_Call {
	_c.Run(run)
	return _c
}

// NewMisbehaviorReport creates a new instance of MisbehaviorReport. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMisbehaviorReport(t interface {
	mock.TestingT
	Cleanup(func())
}) *MisbehaviorReport {
	mock := &MisbehaviorReport{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MisbehaviorReport is an autogenerated mock type for the MisbehaviorReport type
type MisbehaviorReport struct {
	mock.Mock
}

type MisbehaviorReport_Expecter struct {
	mock *mock.Mock
}

func (_m *MisbehaviorReport) EXPECT() *MisbehaviorReport_Expecter {
	return &MisbehaviorReport_Expecter{mock: &_m.Mock}
}

// OriginId provides a mock function for the type MisbehaviorReport
func (_mock *MisbehaviorReport) OriginId() flow.Identifier {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for OriginId")
	}

	var r0 flow.Identifier
	if returnFunc, ok := ret.Get(0).(func() flow.Identifier); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.Identifier)
		}
	}
	return r0
}

// MisbehaviorReport_OriginId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OriginId'
type MisbehaviorReport_OriginId_Call struct {
	*mock.Call
}

// OriginId is a helper method to define mock.On call
func (_e *MisbehaviorReport_Expecter) OriginId() *MisbehaviorReport_OriginId_Call {
	return &MisbehaviorReport_OriginId_Call{Call: _e.mock.On("OriginId")}
}

func (_c *MisbehaviorReport_OriginId_Call) Run(run func()) *MisbehaviorReport_OriginId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MisbehaviorReport_OriginId_Call) Return(identifier flow.Identifier) *MisbehaviorReport_OriginId_Call {
	_c.Call.Return(identifier)
	return _c
}

func (_c *MisbehaviorReport_OriginId_Call) RunAndReturn(run func() flow.Identifier) *MisbehaviorReport_OriginId_Call {
	_c.Call.Return(run)
	return _c
}

// Penalty provides a mock function for the type MisbehaviorReport
func (_mock *MisbehaviorReport) Penalty() float64 {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Penalty")
	}

	var r0 float64
	if returnFunc, ok := ret.Get(0).(func() float64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(float64)
	}
	return r0
}

// MisbehaviorReport_Penalty_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Penalty'
type MisbehaviorReport_Penalty_Call struct {
	*mock.Call
}

// Penalty is a helper method to define mock.On call
func (_e *MisbehaviorReport_Expecter) Penalty() *MisbehaviorReport_Penalty_Call {
	return &MisbehaviorReport_Penalty_Call{Call: _e.mock.On("Penalty")}
}

func (_c *MisbehaviorReport_Penalty_Call) Run(run func()) *MisbehaviorReport_Penalty_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MisbehaviorReport_Penalty_Call) Return(f float64) *MisbehaviorReport_Penalty_Call {
	_c.Call.Return(f)
	return _c
}

func (_c *MisbehaviorReport_Penalty_Call) RunAndReturn(run func() float64) *MisbehaviorReport_Penalty_Call {
	_c.Call.Return(run)
	return _c
}

// Reason provides a mock function for the type MisbehaviorReport
func (_mock *MisbehaviorReport) Reason() network.Misbehavior {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Reason")
	}

	var r0 network.Misbehavior
	if returnFunc, ok := ret.Get(0).(func() network.Misbehavior); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(network.Misbehavior)
	}
	return r0
}

// MisbehaviorReport_Reason_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Reason'
type MisbehaviorReport_Reason_Call struct {
	*mock.Call
}

// Reason is a helper method to define mock.On call
func (_e *MisbehaviorReport_Expecter) Reason() *MisbehaviorReport_Reason_Call {
	return &MisbehaviorReport_Reason_Call{Call: _e.mock.On("Reason")}
}

func (_c *MisbehaviorReport_Reason_Call) Run(run func()) *MisbehaviorReport_Reason_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MisbehaviorReport_Reason_Call) Return(misbehavior network.Misbehavior) *MisbehaviorReport_Reason_Call {
	_c.Call.Return(misbehavior)
	return _c
}

func (_c *MisbehaviorReport_Reason_Call) RunAndReturn(run func() network.Misbehavior) *MisbehaviorReport_Reason_Call {
	_c.Call.Return(run)
	return _c
}

// NewMisbehaviorReportManager creates a new instance of MisbehaviorReportManager. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMisbehaviorReportManager(t interface {
	mock.TestingT
	Cleanup(func())
}) *MisbehaviorReportManager {
	mock := &MisbehaviorReportManager{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MisbehaviorReportManager is an autogenerated mock type for the MisbehaviorReportManager type
type MisbehaviorReportManager struct {
	mock.Mock
}

type MisbehaviorReportManager_Expecter struct {
	mock *mock.Mock
}

func (_m *MisbehaviorReportManager) EXPECT() *MisbehaviorReportManager_Expecter {
	return &MisbehaviorReportManager_Expecter{mock: &_m.Mock}
}

// Done provides a mock function for the type MisbehaviorReportManager
func (_mock *MisbehaviorReportManager) Done() <-chan struct{} {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Done")
	}

	var r0 <-chan struct{}
	if returnFunc, ok := ret.Get(0).(func() <-chan struct{}); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan struct{})
		}
	}
	return r0
}

// MisbehaviorReportManager_Done_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Done'
type MisbehaviorReportManager_Done_Call struct {
	*mock.Call
}

// Done is a helper method to define mock.On call
func (_e *MisbehaviorReportManager_Expecter) Done() *MisbehaviorReportManager_Done_Call {
	return &MisbehaviorReportManager_Done_Call{Call: _e.mock.On("Done")}
}

func (_c *MisbehaviorReportManager_Done_Call) Run(run func()) *MisbehaviorReportManager_Done_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MisbehaviorReportManager_Done_Call) Return(valCh <-chan struct{}) *MisbehaviorReportManager_Done_Call {
	_c.Call.Return(valCh)
	return _c
}

func (_c *MisbehaviorReportManager_Done_Call) RunAndReturn(run func() <-chan struct{}) *MisbehaviorReportManager_Done_Call {
	_c.Call.Return(run)
	return _c
}

// HandleMisbehaviorReport provides a mock function for the type MisbehaviorReportManager
func (_mock *MisbehaviorReportManager) HandleMisbehaviorReport(channel channels.Channel, misbehaviorReport network.MisbehaviorReport) {
	_mock.Called(channel, misbehaviorReport)
	return
}

// MisbehaviorReportManager_HandleMisbehaviorReport_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HandleMisbehaviorReport'
type MisbehaviorReportManager_HandleMisbehaviorReport_Call struct {
	*mock.Call
}

// HandleMisbehaviorReport is a helper method to define mock.On call
//   - channel channels.Channel
//   - misbehaviorReport network.MisbehaviorReport
func (_e *MisbehaviorReportManager_Expecter) HandleMisbehaviorReport(channel interface{}, misbehaviorReport interface{}) *MisbehaviorReportManager_HandleMisbehaviorReport_Call {
	return &MisbehaviorReportManager_HandleMisbehaviorReport_Call{Call: _e.mock.On("HandleMisbehaviorReport", channel, misbehaviorReport)}
}

func (_c *MisbehaviorReportManager_HandleMisbehaviorReport_Call) Run(run func(channel channels.Channel, misbehaviorReport network.MisbehaviorReport)) *MisbehaviorReportManager_HandleMisbehaviorReport_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 channels.Channel
		if args[0] != nil {
			arg0 = args[0].(channels.Channel)
		}
		var arg1 network.MisbehaviorReport
		if args[1] != nil {
			arg1 = args[1].(network.MisbehaviorReport)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MisbehaviorReportManager_HandleMisbehaviorReport_Call) Return() *MisbehaviorReportManager_HandleMisbehaviorReport_Call {
	_c.Call.Return()
	return _c
}

func (_c *MisbehaviorReportManager_HandleMisbehaviorReport_Call) RunAndReturn(run func(channel channels.Channel, misbehaviorReport network.MisbehaviorReport)) *MisbehaviorReportManager_HandleMisbehaviorReport_Call {
	_c.Run(run)
	return _c
}

// Ready provides a mock function for the type MisbehaviorReportManager
func (_mock *MisbehaviorReportManager) Ready() <-chan struct{} {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Ready")
	}

	var r0 <-chan struct{}
	if returnFunc, ok := ret.Get(0).(func() <-chan struct{}); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan struct{})
		}
	}
	return r0
}

// MisbehaviorReportManager_Ready_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Ready'
type MisbehaviorReportManager_Ready_Call struct {
	*mock.Call
}

// Ready is a helper method to define mock.On call
func (_e *MisbehaviorReportManager_Expecter) Ready() *MisbehaviorReportManager_Ready_Call {
	return &MisbehaviorReportManager_Ready_Call{Call: _e.mock.On("Ready")}
}

func (_c *MisbehaviorReportManager_Ready_Call) Run(run func()) *MisbehaviorReportManager_Ready_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MisbehaviorReportManager_Ready_Call) Return(valCh <-chan struct{}) *MisbehaviorReportManager_Ready_Call {
	_c.Call.Return(valCh)
	return _c
}

func (_c *MisbehaviorReportManager_Ready_Call) RunAndReturn(run func() <-chan struct{}) *MisbehaviorReportManager_Ready_Call {
	_c.Call.Return(run)
	return _c
}

// Start provides a mock function for the type MisbehaviorReportManager
func (_mock *MisbehaviorReportManager) Start(signalerContext irrecoverable.SignalerContext) {
	_mock.Called(signalerContext)
	return
}

// MisbehaviorReportManager_Start_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Start'
type MisbehaviorReportManager_Start_Call struct {
	*mock.Call
}

// Start is a helper method to define mock.On call
//   - signalerContext irrecoverable.SignalerContext
func (_e *MisbehaviorReportManager_Expecter) Start(signalerContext interface{}) *MisbehaviorReportManager_Start_Call {
	return &MisbehaviorReportManager_Start_Call{Call: _e.mock.On("Start", signalerContext)}
}

func (_c *MisbehaviorReportManager_Start_Call) Run(run func(signalerContext irrecoverable.SignalerContext)) *MisbehaviorReportManager_Start_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 irrecoverable.SignalerContext
		if args[0] != nil {
			arg0 = args[0].(irrecoverable.SignalerContext)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MisbehaviorReportManager_Start_Call) Return() *MisbehaviorReportManager_Start_Call {
	_c.Call.Return()
	return _c
}

func (_c *MisbehaviorReportManager_Start_Call) RunAndReturn(run func(signalerContext irrecoverable.SignalerContext)) *MisbehaviorReportManager_Start_Call {
	_c.Run(run)
	return _c
}

// NewBlobGetter creates a new instance of BlobGetter. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewBlobGetter(t interface {
	mock.TestingT
	Cleanup(func())
}) *BlobGetter {
	mock := &BlobGetter{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// BlobGetter is an autogenerated mock type for the BlobGetter type
type BlobGetter struct {
	mock.Mock
}

type BlobGetter_Expecter struct {
	mock *mock.Mock
}

func (_m *BlobGetter) EXPECT() *BlobGetter_Expecter {
	return &BlobGetter_Expecter{mock: &_m.Mock}
}

// GetBlob provides a mock function for the type BlobGetter
func (_mock *BlobGetter) GetBlob(ctx context.Context, c cid.Cid) (blobs.Blob, error) {
	ret := _mock.Called(ctx, c)

	if len(ret) == 0 {
		panic("no return value specified for GetBlob")
	}

	var r0 blobs.Blob
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, cid.Cid) (blobs.Blob, error)); ok {
		return returnFunc(ctx, c)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, cid.Cid) blobs.Blob); ok {
		r0 = returnFunc(ctx, c)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(blobs.Blob)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, cid.Cid) error); ok {
		r1 = returnFunc(ctx, c)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// BlobGetter_GetBlob_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBlob'
type BlobGetter_GetBlob_Call struct {
	*mock.Call
}

// GetBlob is a helper method to define mock.On call
//   - ctx context.Context
//   - c cid.Cid
func (_e *BlobGetter_Expecter) GetBlob(ctx interface{}, c interface{}) *BlobGetter_GetBlob_Call {
	return &BlobGetter_GetBlob_Call{Call: _e.mock.On("GetBlob", ctx, c)}
}

func (_c *BlobGetter_GetBlob_Call) Run(run func(ctx context.Context, c cid.Cid)) *BlobGetter_GetBlob_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 cid.Cid
		if args[1] != nil {
			arg1 = args[1].(cid.Cid)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *BlobGetter_GetBlob_Call) Return(v blobs.Blob, err error) *BlobGetter_GetBlob_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *BlobGetter_GetBlob_Call) RunAndReturn(run func(ctx context.Context, c cid.Cid) (blobs.Blob, error)) *BlobGetter_GetBlob_Call {
	_c.Call.Return(run)
	return _c
}

// GetBlobs provides a mock function for the type BlobGetter
func (_mock *BlobGetter) GetBlobs(ctx context.Context, ks []cid.Cid) <-chan blobs.Blob {
	ret := _mock.Called(ctx, ks)

	if len(ret) == 0 {
		panic("no return value specified for GetBlobs")
	}

	var r0 <-chan blobs.Blob
	if returnFunc, ok := ret.Get(0).(func(context.Context, []cid.Cid) <-chan blobs.Blob); ok {
		r0 = returnFunc(ctx, ks)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan blobs.Blob)
		}
	}
	return r0
}

// BlobGetter_GetBlobs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBlobs'
type BlobGetter_GetBlobs_Call struct {
	*mock.Call
}

// GetBlobs is a helper method to define mock.On call
//   - ctx context.Context
//   - ks []cid.Cid
func (_e *BlobGetter_Expecter) GetBlobs(ctx interface{}, ks interface{}) *BlobGetter_GetBlobs_Call {
	return &BlobGetter_GetBlobs_Call{Call: _e.mock.On("GetBlobs", ctx, ks)}
}

func (_c *BlobGetter_GetBlobs_Call) Run(run func(ctx context.Context, ks []cid.Cid)) *BlobGetter_GetBlobs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 []cid.Cid
		if args[1] != nil {
			arg1 = args[1].([]cid.Cid)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *BlobGetter_GetBlobs_Call) Return(vCh <-chan blobs.Blob) *BlobGetter_GetBlobs_Call {
	_c.Call.Return(vCh)
	return _c
}

func (_c *BlobGetter_GetBlobs_Call) RunAndReturn(run func(ctx context.Context, ks []cid.Cid) <-chan blobs.Blob) *BlobGetter_GetBlobs_Call {
	_c.Call.Return(run)
	return _c
}

// NewBlobService creates a new instance of BlobService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewBlobService(t interface {
	mock.TestingT
	Cleanup(func())
}) *BlobService {
	mock := &BlobService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// BlobService is an autogenerated mock type for the BlobService type
type BlobService struct {
	mock.Mock
}

type BlobService_Expecter struct {
	mock *mock.Mock
}

func (_m *BlobService) EXPECT() *BlobService_Expecter {
	return &BlobService_Expecter{mock: &_m.Mock}
}

// AddBlob provides a mock function for the type BlobService
func (_mock *BlobService) AddBlob(ctx context.Context, b blobs.Blob) error {
	ret := _mock.Called(ctx, b)

	if len(ret) == 0 {
		panic("no return value specified for AddBlob")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, blobs.Blob) error); ok {
		r0 = returnFunc(ctx, b)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// BlobService_AddBlob_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddBlob'
type BlobService_AddBlob_Call struct {
	*mock.Call
}

// AddBlob is a helper method to define mock.On call
//   - ctx context.Context
//   - b blobs.Blob
func (_e *BlobService_Expecter) AddBlob(ctx interface{}, b interface{}) *BlobService_AddBlob_Call {
	return &BlobService_AddBlob_Call{Call: _e.mock.On("AddBlob", ctx, b)}
}

func (_c *BlobService_AddBlob_Call) Run(run func(ctx context.Context, b blobs.Blob)) *BlobService_AddBlob_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 blobs.Blob
		if args[1] != nil {
			arg1 = args[1].(blobs.Blob)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *BlobService_AddBlob_Call) Return(err error) *BlobService_AddBlob_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *BlobService_AddBlob_Call) RunAndReturn(run func(ctx context.Context, b blobs.Blob) error) *BlobService_AddBlob_Call {
	_c.Call.Return(run)
	return _c
}

// AddBlobs provides a mock function for the type BlobService
func (_mock *BlobService) AddBlobs(ctx context.Context, bs []blobs.Blob) error {
	ret := _mock.Called(ctx, bs)

	if len(ret) == 0 {
		panic("no return value specified for AddBlobs")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, []blobs.Blob) error); ok {
		r0 = returnFunc(ctx, bs)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// BlobService_AddBlobs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddBlobs'
type BlobService_AddBlobs_Call struct {
	*mock.Call
}

// AddBlobs is a helper method to define mock.On call
//   - ctx context.Context
//   - bs []blobs.Blob
func (_e *BlobService_Expecter) AddBlobs(ctx interface{}, bs interface{}) *BlobService_AddBlobs_Call {
	return &BlobService_AddBlobs_Call{Call: _e.mock.On("AddBlobs", ctx, bs)}
}

func (_c *BlobService_AddBlobs_Call) Run(run func(ctx context.Context, bs []blobs.Blob)) *BlobService_AddBlobs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 []blobs.Blob
		if args[1] != nil {
			arg1 = args[1].([]blobs.Blob)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *BlobService_AddBlobs_Call) Return(err error) *BlobService_AddBlobs_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *BlobService_AddBlobs_Call) RunAndReturn(run func(ctx context.Context, bs []blobs.Blob) error) *BlobService_AddBlobs_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteBlob provides a mock function for the type BlobService
func (_mock *BlobService) DeleteBlob(ctx context.Context, c cid.Cid) error {
	ret := _mock.Called(ctx, c)

	if len(ret) == 0 {
		panic("no return value specified for DeleteBlob")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, cid.Cid) error); ok {
		r0 = returnFunc(ctx, c)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// BlobService_DeleteBlob_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteBlob'
type BlobService_DeleteBlob_Call struct {
	*mock.Call
}

// DeleteBlob is a helper method to define mock.On call
//   - ctx context.Context
//   - c cid.Cid
func (_e *BlobService_Expecter) DeleteBlob(ctx interface{}, c interface{}) *BlobService_DeleteBlob_Call {
	return &BlobService_DeleteBlob_Call{Call: _e.mock.On("DeleteBlob", ctx, c)}
}

func (_c *BlobService_DeleteBlob_Call) Run(run func(ctx context.Context, c cid.Cid)) *BlobService_DeleteBlob_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 cid.Cid
		if args[1] != nil {
			arg1 = args[1].(cid.Cid)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *BlobService_DeleteBlob_Call) Return(err error) *BlobService_DeleteBlob_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *BlobService_DeleteBlob_Call) RunAndReturn(run func(ctx context.Context, c cid.Cid) error) *BlobService_DeleteBlob_Call {
	_c.Call.Return(run)
	return _c
}

// Done provides a mock function for the type BlobService
func (_mock *BlobService) Done() <-chan struct{} {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Done")
	}

	var r0 <-chan struct{}
	if returnFunc, ok := ret.Get(0).(func() <-chan struct{}); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan struct{})
		}
	}
	return r0
}

// BlobService_Done_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Done'
type BlobService_Done_Call struct {
	*mock.Call
}

// Done is a helper method to define mock.On call
func (_e *BlobService_Expecter) Done() *BlobService_Done_Call {
	return &BlobService_Done_Call{Call: _e.mock.On("Done")}
}

func (_c *BlobService_Done_Call) Run(run func()) *BlobService_Done_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *BlobService_Done_Call) Return(valCh <-chan struct{}) *BlobService_Done_Call {
	_c.Call.Return(valCh)
	return _c
}

func (_c *BlobService_Done_Call) RunAndReturn(run func() <-chan struct{}) *BlobService_Done_Call {
	_c.Call.Return(run)
	return _c
}

// GetBlob provides a mock function for the type BlobService
func (_mock *BlobService) GetBlob(ctx context.Context, c cid.Cid) (blobs.Blob, error) {
	ret := _mock.Called(ctx, c)

	if len(ret) == 0 {
		panic("no return value specified for GetBlob")
	}

	var r0 blobs.Blob
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, cid.Cid) (blobs.Blob, error)); ok {
		return returnFunc(ctx, c)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, cid.Cid) blobs.Blob); ok {
		r0 = returnFunc(ctx, c)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(blobs.Blob)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, cid.Cid) error); ok {
		r1 = returnFunc(ctx, c)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// BlobService_GetBlob_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBlob'
type BlobService_GetBlob_Call struct {
	*mock.Call
}

// GetBlob is a helper method to define mock.On call
//   - ctx context.Context
//   - c cid.Cid
func (_e *BlobService_Expecter) GetBlob(ctx interface{}, c interface{}) *BlobService_GetBlob_Call {
	return &BlobService_GetBlob_Call{Call: _e.mock.On("GetBlob", ctx, c)}
}

func (_c *BlobService_GetBlob_Call) Run(run func(ctx context.Context, c cid.Cid)) *BlobService_GetBlob_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 cid.Cid
		if args[1] != nil {
			arg1 = args[1].(cid.Cid)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *BlobService_GetBlob_Call) Return(v blobs.Blob, err error) *BlobService_GetBlob_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *BlobService_GetBlob_Call) RunAndReturn(run func(ctx context.Context, c cid.Cid) (blobs.Blob, error)) *BlobService_GetBlob_Call {
	_c.Call.Return(run)
	return _c
}

// GetBlobs provides a mock function for the type BlobService
func (_mock *BlobService) GetBlobs(ctx context.Context, ks []cid.Cid) <-chan blobs.Blob {
	ret := _mock.Called(ctx, ks)

	if len(ret) == 0 {
		panic("no return value specified for GetBlobs")
	}

	var r0 <-chan blobs.Blob
	if returnFunc, ok := ret.Get(0).(func(context.Context, []cid.Cid) <-chan blobs.Blob); ok {
		r0 = returnFunc(ctx, ks)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan blobs.Blob)
		}
	}
	return r0
}

// BlobService_GetBlobs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBlobs'
type BlobService_GetBlobs_Call struct {
	*mock.Call
}

// GetBlobs is a helper method to define mock.On call
//   - ctx context.Context
//   - ks []cid.Cid
func (_e *BlobService_Expecter) GetBlobs(ctx interface{}, ks interface{}) *BlobService_GetBlobs_Call {
	return &BlobService_GetBlobs_Call{Call: _e.mock.On("GetBlobs", ctx, ks)}
}

func (_c *BlobService_GetBlobs_Call) Run(run func(ctx context.Context, ks []cid.Cid)) *BlobService_GetBlobs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 []cid.Cid
		if args[1] != nil {
			arg1 = args[1].([]cid.Cid)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *BlobService_GetBlobs_Call) Return(vCh <-chan blobs.Blob) *BlobService_GetBlobs_Call {
	_c.Call.Return(vCh)
	return _c
}

func (_c *BlobService_GetBlobs_Call) RunAndReturn(run func(ctx context.Context, ks []cid.Cid) <-chan blobs.Blob) *BlobService_GetBlobs_Call {
	_c.Call.Return(run)
	return _c
}

// GetSession provides a mock function for the type BlobService
func (_mock *BlobService) GetSession(ctx context.Context) network.BlobGetter {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetSession")
	}

	var r0 network.BlobGetter
	if returnFunc, ok := ret.Get(0).(func(context.Context) network.BlobGetter); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(network.BlobGetter)
		}
	}
	return r0
}

// BlobService_GetSession_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSession'
type BlobService_GetSession_Call struct {
	*mock.Call
}

// GetSession is a helper method to define mock.On call
//   - ctx context.Context
func (_e *BlobService_Expecter) GetSession(ctx interface{}) *BlobService_GetSession_Call {
	return &BlobService_GetSession_Call{Call: _e.mock.On("GetSession", ctx)}
}

func (_c *BlobService_GetSession_Call) Run(run func(ctx context.Context)) *BlobService_GetSession_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *BlobService_GetSession_Call) Return(blobGetter network.BlobGetter) *BlobService_GetSession_Call {
	_c.Call.Return(blobGetter)
	return _c
}

func (_c *BlobService_GetSession_Call) RunAndReturn(run func(ctx context.Context) network.BlobGetter) *BlobService_GetSession_Call {
	_c.Call.Return(run)
	return _c
}

// Ready provides a mock function for the type BlobService
func (_mock *BlobService) Ready() <-chan struct{} {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Ready")
	}

	var r0 <-chan struct{}
	if returnFunc, ok := ret.Get(0).(func() <-chan struct{}); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan struct{})
		}
	}
	return r0
}

// BlobService_Ready_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Ready'
type BlobService_Ready_Call struct {
	*mock.Call
}

// Ready is a helper method to define mock.On call
func (_e *BlobService_Expecter) Ready() *BlobService_Ready_Call {
	return &BlobService_Ready_Call{Call: _e.mock.On("Ready")}
}

func (_c *BlobService_Ready_Call) Run(run func()) *BlobService_Ready_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *BlobService_Ready_Call) Return(valCh <-chan struct{}) *BlobService_Ready_Call {
	_c.Call.Return(valCh)
	return _c
}

func (_c *BlobService_Ready_Call) RunAndReturn(run func() <-chan struct{}) *BlobService_Ready_Call {
	_c.Call.Return(run)
	return _c
}

// Start provides a mock function for the type BlobService
func (_mock *BlobService) Start(signalerContext irrecoverable.SignalerContext) {
	_mock.Called(signalerContext)
	return
}

// BlobService_Start_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Start'
type BlobService_Start_Call struct {
	*mock.Call
}

// Start is a helper method to define mock.On call
//   - signalerContext irrecoverable.SignalerContext
func (_e *BlobService_Expecter) Start(signalerContext interface{}) *BlobService_Start_Call {
	return &BlobService_Start_Call{Call: _e.mock.On("Start", signalerContext)}
}

func (_c *BlobService_Start_Call) Run(run func(signalerContext irrecoverable.SignalerContext)) *BlobService_Start_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 irrecoverable.SignalerContext
		if args[0] != nil {
			arg0 = args[0].(irrecoverable.SignalerContext)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *BlobService_Start_Call) Return() *BlobService_Start_Call {
	_c.Call.Return()
	return _c
}

func (_c *BlobService_Start_Call) RunAndReturn(run func(signalerContext irrecoverable.SignalerContext)) *BlobService_Start_Call {
	_c.Run(run)
	return _c
}

// TriggerReprovide provides a mock function for the type BlobService
func (_mock *BlobService) TriggerReprovide(ctx context.Context) error {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for TriggerReprovide")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// BlobService_TriggerReprovide_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TriggerReprovide'
type BlobService_TriggerReprovide_Call struct {
	*mock.Call
}

// TriggerReprovide is a helper method to define mock.On call
//   - ctx context.Context
func (_e *BlobService_Expecter) TriggerReprovide(ctx interface{}) *BlobService_TriggerReprovide_Call {
	return &BlobService_TriggerReprovide_Call{Call: _e.mock.On("TriggerReprovide", ctx)}
}

func (_c *BlobService_TriggerReprovide_Call) Run(run func(ctx context.Context)) *BlobService_TriggerReprovide_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *BlobService_TriggerReprovide_Call) Return(err error) *BlobService_TriggerReprovide_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *BlobService_TriggerReprovide_Call) RunAndReturn(run func(ctx context.Context) error) *BlobService_TriggerReprovide_Call {
	_c.Call.Return(run)
	return _c
}

// NewCodec creates a new instance of Codec. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewCodec(t interface {
	mock.TestingT
	Cleanup(func())
}) *Codec {
	mock := &Codec{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Codec is an autogenerated mock type for the Codec type
type Codec struct {
	mock.Mock
}

type Codec_Expecter struct {
	mock *mock.Mock
}

func (_m *Codec) EXPECT() *Codec_Expecter {
	return &Codec_Expecter{mock: &_m.Mock}
}

// Decode provides a mock function for the type Codec
func (_mock *Codec) Decode(data []byte) (messages.UntrustedMessage, error) {
	ret := _mock.Called(data)

	if len(ret) == 0 {
		panic("no return value specified for Decode")
	}

	var r0 messages.UntrustedMessage
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]byte) (messages.UntrustedMessage, error)); ok {
		return returnFunc(data)
	}
	if returnFunc, ok := ret.Get(0).(func([]byte) messages.UntrustedMessage); ok {
		r0 = returnFunc(data)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(messages.UntrustedMessage)
		}
	}
	if returnFunc, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = returnFunc(data)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Codec_Decode_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Decode'
type Codec_Decode_Call struct {
	*mock.Call
}

// Decode is a helper method to define mock.On call
//   - data []byte
func (_e *Codec_Expecter) Decode(data interface{}) *Codec_Decode_Call {
	return &Codec_Decode_Call{Call: _e.mock.On("Decode", data)}
}

func (_c *Codec_Decode_Call) Run(run func(data []byte)) *Codec_Decode_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []byte
		if args[0] != nil {
			arg0 = args[0].([]byte)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Codec_Decode_Call) Return(untrustedMessage messages.UntrustedMessage, err error) *Codec_Decode_Call {
	_c.Call.Return(untrustedMessage, err)
	return _c
}

func (_c *Codec_Decode_Call) RunAndReturn(run func(data []byte) (messages.UntrustedMessage, error)) *Codec_Decode_Call {
	_c.Call.Return(run)
	return _c
}

// Encode provides a mock function for the type Codec
func (_mock *Codec) Encode(v interface{}) ([]byte, error) {
	ret := _mock.Called(v)

	if len(ret) == 0 {
		panic("no return value specified for Encode")
	}

	var r0 []byte
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(interface{}) ([]byte, error)); ok {
		return returnFunc(v)
	}
	if returnFunc, ok := ret.Get(0).(func(interface{}) []byte); ok {
		r0 = returnFunc(v)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(interface{}) error); ok {
		r1 = returnFunc(v)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Codec_Encode_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Encode'
type Codec_Encode_Call struct {
	*mock.Call
}

// Encode is a helper method to define mock.On call
//   - v interface{}
func (_e *Codec_Expecter) Encode(v interface{}) *Codec_Encode_Call {
	return &Codec_Encode_Call{Call: _e.mock.On("Encode", v)}
}

func (_c *Codec_Encode_Call) Run(run func(v interface{})) *Codec_Encode_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 interface{}
		if args[0] != nil {
			arg0 = args[0].(interface{})
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Codec_Encode_Call) Return(bytes []byte, err error) *Codec_Encode_Call {
	_c.Call.Return(bytes, err)
	return _c
}

func (_c *Codec_Encode_Call) RunAndReturn(run func(v interface{}) ([]byte, error)) *Codec_Encode_Call {
	_c.Call.Return(run)
	return _c
}

// NewDecoder provides a mock function for the type Codec
func (_mock *Codec) NewDecoder(r io.Reader) network.Decoder {
	ret := _mock.Called(r)

	if len(ret) == 0 {
		panic("no return value specified for NewDecoder")
	}

	var r0 network.Decoder
	if returnFunc, ok := ret.Get(0).(func(io.Reader) network.Decoder); ok {
		r0 = returnFunc(r)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(network.Decoder)
		}
	}
	return r0
}

// Codec_NewDecoder_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NewDecoder'
type Codec_NewDecoder_Call struct {
	*mock.Call
}

// NewDecoder is a helper method to define mock.On call
//   - r io.Reader
func (_e *Codec_Expecter) NewDecoder(r interface{}) *Codec_NewDecoder_Call {
	return &Codec_NewDecoder_Call{Call: _e.mock.On("NewDecoder", r)}
}

func (_c *Codec_NewDecoder_Call) Run(run func(r io.Reader)) *Codec_NewDecoder_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 io.Reader
		if args[0] != nil {
			arg0 = args[0].(io.Reader)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Codec_NewDecoder_Call) Return(decoder network.Decoder) *Codec_NewDecoder_Call {
	_c.Call.Return(decoder)
	return _c
}

func (_c *Codec_NewDecoder_Call) RunAndReturn(run func(r io.Reader) network.Decoder) *Codec_NewDecoder_Call {
	_c.Call.Return(run)
	return _c
}

// NewEncoder provides a mock function for the type Codec
func (_mock *Codec) NewEncoder(w io.Writer) network.Encoder {
	ret := _mock.Called(w)

	if len(ret) == 0 {
		panic("no return value specified for NewEncoder")
	}

	var r0 network.Encoder
	if returnFunc, ok := ret.Get(0).(func(io.Writer) network.Encoder); ok {
		r0 = returnFunc(w)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(network.Encoder)
		}
	}
	return r0
}

// Codec_NewEncoder_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NewEncoder'
type Codec_NewEncoder_Call struct {
	*mock.Call
}

// NewEncoder is a helper method to define mock.On call
//   - w io.Writer
func (_e *Codec_Expecter) NewEncoder(w interface{}) *Codec_NewEncoder_Call {
	return &Codec_NewEncoder_Call{Call: _e.mock.On("NewEncoder", w)}
}

func (_c *Codec_NewEncoder_Call) Run(run func(w io.Writer)) *Codec_NewEncoder_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 io.Writer
		if args[0] != nil {
			arg0 = args[0].(io.Writer)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Codec_NewEncoder_Call) Return(encoder network.Encoder) *Codec_NewEncoder_Call {
	_c.Call.Return(encoder)
	return _c
}

func (_c *Codec_NewEncoder_Call) RunAndReturn(run func(w io.Writer) network.Encoder) *Codec_NewEncoder_Call {
	_c.Call.Return(run)
	return _c
}

// NewEncoder creates a new instance of Encoder. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewEncoder(t interface {
	mock.TestingT
	Cleanup(func())
}) *Encoder {
	mock := &Encoder{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Encoder is an autogenerated mock type for the Encoder type
type Encoder struct {
	mock.Mock
}

type Encoder_Expecter struct {
	mock *mock.Mock
}

func (_m *Encoder) EXPECT() *Encoder_Expecter {
	return &Encoder_Expecter{mock: &_m.Mock}
}

// Encode provides a mock function for the type Encoder
func (_mock *Encoder) Encode(v interface{}) error {
	ret := _mock.Called(v)

	if len(ret) == 0 {
		panic("no return value specified for Encode")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(interface{}) error); ok {
		r0 = returnFunc(v)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Encoder_Encode_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Encode'
type Encoder_Encode_Call struct {
	*mock.Call
}

// Encode is a helper method to define mock.On call
//   - v interface{}
func (_e *Encoder_Expecter) Encode(v interface{}) *Encoder_Encode_Call {
	return &Encoder_Encode_Call{Call: _e.mock.On("Encode", v)}
}

func (_c *Encoder_Encode_Call) Run(run func(v interface{})) *Encoder_Encode_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 interface{}
		if args[0] != nil {
			arg0 = args[0].(interface{})
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Encoder_Encode_Call) Return(err error) *Encoder_Encode_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Encoder_Encode_Call) RunAndReturn(run func(v interface{}) error) *Encoder_Encode_Call {
	_c.Call.Return(run)
	return _c
}

// NewDecoder creates a new instance of Decoder. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewDecoder(t interface {
	mock.TestingT
	Cleanup(func())
}) *Decoder {
	mock := &Decoder{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Decoder is an autogenerated mock type for the Decoder type
type Decoder struct {
	mock.Mock
}

type Decoder_Expecter struct {
	mock *mock.Mock
}

func (_m *Decoder) EXPECT() *Decoder_Expecter {
	return &Decoder_Expecter{mock: &_m.Mock}
}

// Decode provides a mock function for the type Decoder
func (_mock *Decoder) Decode() (messages.UntrustedMessage, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Decode")
	}

	var r0 messages.UntrustedMessage
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (messages.UntrustedMessage, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() messages.UntrustedMessage); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(messages.UntrustedMessage)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Decoder_Decode_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Decode'
type Decoder_Decode_Call struct {
	*mock.Call
}

// Decode is a helper method to define mock.On call
func (_e *Decoder_Expecter) Decode() *Decoder_Decode_Call {
	return &Decoder_Decode_Call{Call: _e.mock.On("Decode")}
}

func (_c *Decoder_Decode_Call) Run(run func()) *Decoder_Decode_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Decoder_Decode_Call) Return(untrustedMessage messages.UntrustedMessage, err error) *Decoder_Decode_Call {
	_c.Call.Return(untrustedMessage, err)
	return _c
}

func (_c *Decoder_Decode_Call) RunAndReturn(run func() (messages.UntrustedMessage, error)) *Decoder_Decode_Call {
	_c.Call.Return(run)
	return _c
}

// NewCompressor creates a new instance of Compressor. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewCompressor(t interface {
	mock.TestingT
	Cleanup(func())
}) *Compressor {
	mock := &Compressor{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Compressor is an autogenerated mock type for the Compressor type
type Compressor struct {
	mock.Mock
}

type Compressor_Expecter struct {
	mock *mock.Mock
}

func (_m *Compressor) EXPECT() *Compressor_Expecter {
	return &Compressor_Expecter{mock: &_m.Mock}
}

// NewReader provides a mock function for the type Compressor
func (_mock *Compressor) NewReader(reader io.Reader) (io.ReadCloser, error) {
	ret := _mock.Called(reader)

	if len(ret) == 0 {
		panic("no return value specified for NewReader")
	}

	var r0 io.ReadCloser
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(io.Reader) (io.ReadCloser, error)); ok {
		return returnFunc(reader)
	}
	if returnFunc, ok := ret.Get(0).(func(io.Reader) io.ReadCloser); ok {
		r0 = returnFunc(reader)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(io.ReadCloser)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(io.Reader) error); ok {
		r1 = returnFunc(reader)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Compressor_NewReader_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NewReader'
type Compressor_NewReader_Call struct {
	*mock.Call
}

// NewReader is a helper method to define mock.On call
//   - reader io.Reader
func (_e *Compressor_Expecter) NewReader(reader interface{}) *Compressor_NewReader_Call {
	return &Compressor_NewReader_Call{Call: _e.mock.On("NewReader", reader)}
}

func (_c *Compressor_NewReader_Call) Run(run func(reader io.Reader)) *Compressor_NewReader_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 io.Reader
		if args[0] != nil {
			arg0 = args[0].(io.Reader)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Compressor_NewReader_Call) Return(readCloser io.ReadCloser, err error) *Compressor_NewReader_Call {
	_c.Call.Return(readCloser, err)
	return _c
}

func (_c *Compressor_NewReader_Call) RunAndReturn(run func(reader io.Reader) (io.ReadCloser, error)) *Compressor_NewReader_Call {
	_c.Call.Return(run)
	return _c
}

// NewWriter provides a mock function for the type Compressor
func (_mock *Compressor) NewWriter(writer io.Writer) (network.WriteCloseFlusher, error) {
	ret := _mock.Called(writer)

	if len(ret) == 0 {
		panic("no return value specified for NewWriter")
	}

	var r0 network.WriteCloseFlusher
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(io.Writer) (network.WriteCloseFlusher, error)); ok {
		return returnFunc(writer)
	}
	if returnFunc, ok := ret.Get(0).(func(io.Writer) network.WriteCloseFlusher); ok {
		r0 = returnFunc(writer)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(network.WriteCloseFlusher)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(io.Writer) error); ok {
		r1 = returnFunc(writer)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Compressor_NewWriter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NewWriter'
type Compressor_NewWriter_Call struct {
	*mock.Call
}

// NewWriter is a helper method to define mock.On call
//   - writer io.Writer
func (_e *Compressor_Expecter) NewWriter(writer interface{}) *Compressor_NewWriter_Call {
	return &Compressor_NewWriter_Call{Call: _e.mock.On("NewWriter", writer)}
}

func (_c *Compressor_NewWriter_Call) Run(run func(writer io.Writer)) *Compressor_NewWriter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 io.Writer
		if args[0] != nil {
			arg0 = args[0].(io.Writer)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Compressor_NewWriter_Call) Return(writeCloseFlusher network.WriteCloseFlusher, err error) *Compressor_NewWriter_Call {
	_c.Call.Return(writeCloseFlusher, err)
	return _c
}

func (_c *Compressor_NewWriter_Call) RunAndReturn(run func(writer io.Writer) (network.WriteCloseFlusher, error)) *Compressor_NewWriter_Call {
	_c.Call.Return(run)
	return _c
}

// NewWriteCloseFlusher creates a new instance of WriteCloseFlusher. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewWriteCloseFlusher(t interface {
	mock.TestingT
	Cleanup(func())
}) *WriteCloseFlusher {
	mock := &WriteCloseFlusher{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// WriteCloseFlusher is an autogenerated mock type for the WriteCloseFlusher type
type WriteCloseFlusher struct {
	mock.Mock
}

type WriteCloseFlusher_Expecter struct {
	mock *mock.Mock
}

func (_m *WriteCloseFlusher) EXPECT() *WriteCloseFlusher_Expecter {
	return &WriteCloseFlusher_Expecter{mock: &_m.Mock}
}

// Close provides a mock function for the type WriteCloseFlusher
func (_mock *WriteCloseFlusher) Close() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Close")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// WriteCloseFlusher_Close_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Close'
type WriteCloseFlusher_Close_Call struct {
	*mock.Call
}

// Close is a helper method to define mock.On call
func (_e *WriteCloseFlusher_Expecter) Close() *WriteCloseFlusher_Close_Call {
	return &WriteCloseFlusher_Close_Call{Call: _e.mock.On("Close")}
}

func (_c *WriteCloseFlusher_Close_Call) Run(run func()) *WriteCloseFlusher_Close_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *WriteCloseFlusher_Close_Call) Return(err error) *WriteCloseFlusher_Close_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *WriteCloseFlusher_Close_Call) RunAndReturn(run func() error) *WriteCloseFlusher_Close_Call {
	_c.Call.Return(run)
	return _c
}

// Flush provides a mock function for the type WriteCloseFlusher
func (_mock *WriteCloseFlusher) Flush() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Flush")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// WriteCloseFlusher_Flush_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Flush'
type WriteCloseFlusher_Flush_Call struct {
	*mock.Call
}

// Flush is a helper method to define mock.On call
func (_e *WriteCloseFlusher_Expecter) Flush() *WriteCloseFlusher_Flush_Call {
	return &WriteCloseFlusher_Flush_Call{Call: _e.mock.On("Flush")}
}

func (_c *WriteCloseFlusher_Flush_Call) Run(run func()) *WriteCloseFlusher_Flush_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *WriteCloseFlusher_Flush_Call) Return(err error) *WriteCloseFlusher_Flush_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *WriteCloseFlusher_Flush_Call) RunAndReturn(run func() error) *WriteCloseFlusher_Flush_Call {
	_c.Call.Return(run)
	return _c
}

// Write provides a mock function for the type WriteCloseFlusher
func (_mock *WriteCloseFlusher) Write(p []byte) (int, error) {
	ret := _mock.Called(p)

	if len(ret) == 0 {
		panic("no return value specified for Write")
	}

	var r0 int
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]byte) (int, error)); ok {
		return returnFunc(p)
	}
	if returnFunc, ok := ret.Get(0).(func([]byte) int); ok {
		r0 = returnFunc(p)
	} else {
		r0 = ret.Get(0).(int)
	}
	if returnFunc, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = returnFunc(p)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// WriteCloseFlusher_Write_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Write'
type WriteCloseFlusher_Write_Call struct {
	*mock.Call
}

// Write is a helper method to define mock.On call
//   - p []byte
func (_e *WriteCloseFlusher_Expecter) Write(p interface{}) *WriteCloseFlusher_Write_Call {
	return &WriteCloseFlusher_Write_Call{Call: _e.mock.On("Write", p)}
}

func (_c *WriteCloseFlusher_Write_Call) Run(run func(p []byte)) *WriteCloseFlusher_Write_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []byte
		if args[0] != nil {
			arg0 = args[0].([]byte)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *WriteCloseFlusher_Write_Call) Return(n int, err error) *WriteCloseFlusher_Write_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *WriteCloseFlusher_Write_Call) RunAndReturn(run func(p []byte) (int, error)) *WriteCloseFlusher_Write_Call {
	_c.Call.Return(run)
	return _c
}

// NewConduitFactory creates a new instance of ConduitFactory. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewConduitFactory(t interface {
	mock.TestingT
	Cleanup(func())
}) *ConduitFactory {
	mock := &ConduitFactory{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// ConduitFactory is an autogenerated mock type for the ConduitFactory type
type ConduitFactory struct {
	mock.Mock
}

type ConduitFactory_Expecter struct {
	mock *mock.Mock
}

func (_m *ConduitFactory) EXPECT() *ConduitFactory_Expecter {
	return &ConduitFactory_Expecter{mock: &_m.Mock}
}

// NewConduit provides a mock function for the type ConduitFactory
func (_mock *ConduitFactory) NewConduit(context1 context.Context, channel channels.Channel) (network.Conduit, error) {
	ret := _mock.Called(context1, channel)

	if len(ret) == 0 {
		panic("no return value specified for NewConduit")
	}

	var r0 network.Conduit
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, channels.Channel) (network.Conduit, error)); ok {
		return returnFunc(context1, channel)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, channels.Channel) network.Conduit); ok {
		r0 = returnFunc(context1, channel)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(network.Conduit)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, channels.Channel) error); ok {
		r1 = returnFunc(context1, channel)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ConduitFactory_NewConduit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NewConduit'
type ConduitFactory_NewConduit_Call struct {
	*mock.Call
}

// NewConduit is a helper method to define mock.On call
//   - context1 context.Context
//   - channel channels.Channel
func (_e *ConduitFactory_Expecter) NewConduit(context1 interface{}, channel interface{}) *ConduitFactory_NewConduit_Call {
	return &ConduitFactory_NewConduit_Call{Call: _e.mock.On("NewConduit", context1, channel)}
}

func (_c *ConduitFactory_NewConduit_Call) Run(run func(context1 context.Context, channel channels.Channel)) *ConduitFactory_NewConduit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 channels.Channel
		if args[1] != nil {
			arg1 = args[1].(channels.Channel)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ConduitFactory_NewConduit_Call) Return(conduit network.Conduit, err error) *ConduitFactory_NewConduit_Call {
	_c.Call.Return(conduit, err)
	return _c
}

func (_c *ConduitFactory_NewConduit_Call) RunAndReturn(run func(context1 context.Context, channel channels.Channel) (network.Conduit, error)) *ConduitFactory_NewConduit_Call {
	_c.Call.Return(run)
	return _c
}

// RegisterAdapter provides a mock function for the type ConduitFactory
func (_mock *ConduitFactory) RegisterAdapter(conduitAdapter network.ConduitAdapter) error {
	ret := _mock.Called(conduitAdapter)

	if len(ret) == 0 {
		panic("no return value specified for RegisterAdapter")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(network.ConduitAdapter) error); ok {
		r0 = returnFunc(conduitAdapter)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ConduitFactory_RegisterAdapter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RegisterAdapter'
type ConduitFactory_RegisterAdapter_Call struct {
	*mock.Call
}

// RegisterAdapter is a helper method to define mock.On call
//   - conduitAdapter network.ConduitAdapter
func (_e *ConduitFactory_Expecter) RegisterAdapter(conduitAdapter interface{}) *ConduitFactory_RegisterAdapter_Call {
	return &ConduitFactory_RegisterAdapter_Call{Call: _e.mock.On("RegisterAdapter", conduitAdapter)}
}

func (_c *ConduitFactory_RegisterAdapter_Call) Run(run func(conduitAdapter network.ConduitAdapter)) *ConduitFactory_RegisterAdapter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 network.ConduitAdapter
		if args[0] != nil {
			arg0 = args[0].(network.ConduitAdapter)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ConduitFactory_RegisterAdapter_Call) Return(err error) *ConduitFactory_RegisterAdapter_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ConduitFactory_RegisterAdapter_Call) RunAndReturn(run func(conduitAdapter network.ConduitAdapter) error) *ConduitFactory_RegisterAdapter_Call {
	_c.Call.Return(run)
	return _c
}

// NewConduit creates a new instance of Conduit. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewConduit(t interface {
	mock.TestingT
	Cleanup(func())
}) *Conduit {
	mock := &Conduit{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Conduit is an autogenerated mock type for the Conduit type
type Conduit struct {
	mock.Mock
}

type Conduit_Expecter struct {
	mock *mock.Mock
}

func (_m *Conduit) EXPECT() *Conduit_Expecter {
	return &Conduit_Expecter{mock: &_m.Mock}
}

// Close provides a mock function for the type Conduit
func (_mock *Conduit) Close() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Close")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Conduit_Close_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Close'
type Conduit_Close_Call struct {
	*mock.Call
}

// Close is a helper method to define mock.On call
func (_e *Conduit_Expecter) Close() *Conduit_Close_Call {
	return &Conduit_Close_Call{Call: _e.mock.On("Close")}
}

func (_c *Conduit_Close_Call) Run(run func()) *Conduit_Close_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Conduit_Close_Call) Return(err error) *Conduit_Close_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Conduit_Close_Call) RunAndReturn(run func() error) *Conduit_Close_Call {
	_c.Call.Return(run)
	return _c
}

// Multicast provides a mock function for the type Conduit
func (_mock *Conduit) Multicast(event interface{}, num uint, targetIDs ...flow.Identifier) error {
	// flow.Identifier
	_va := make([]interface{}, len(targetIDs))
	for _i := range targetIDs {
		_va[_i] = targetIDs[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, event, num)
	_ca = append(_ca, _va...)
	ret := _mock.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Multicast")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(interface{}, uint, ...flow.Identifier) error); ok {
		r0 = returnFunc(event, num, targetIDs...)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Conduit_Multicast_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Multicast'
type Conduit_Multicast_Call struct {
	*mock.Call
}

// Multicast is a helper method to define mock.On call
//   - event interface{}
//   - num uint
//   - targetIDs ...flow.Identifier
func (_e *Conduit_Expecter) Multicast(event interface{}, num interface{}, targetIDs ...interface{}) *Conduit_Multicast_Call {
	return &Conduit_Multicast_Call{Call: _e.mock.On("Multicast",
		append([]interface{}{event, num}, targetIDs...)...)}
}

func (_c *Conduit_Multicast_Call) Run(run func(event interface{}, num uint, targetIDs ...flow.Identifier)) *Conduit_Multicast_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 interface{}
		if args[0] != nil {
			arg0 = args[0].(interface{})
		}
		var arg1 uint
		if args[1] != nil {
			arg1 = args[1].(uint)
		}
		var arg2 []flow.Identifier
		variadicArgs := make([]flow.Identifier, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(flow.Identifier)
			}
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *Conduit_Multicast_Call) Return(err error) *Conduit_Multicast_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Conduit_Multicast_Call) RunAndReturn(run func(event interface{}, num uint, targetIDs ...flow.Identifier) error) *Conduit_Multicast_Call {
	_c.Call.Return(run)
	return _c
}

// Publish provides a mock function for the type Conduit
func (_mock *Conduit) Publish(event interface{}, targetIDs ...flow.Identifier) error {
	// flow.Identifier
	_va := make([]interface{}, len(targetIDs))
	for _i := range targetIDs {
		_va[_i] = targetIDs[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, event)
	_ca = append(_ca, _va...)
	ret := _mock.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Publish")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(interface{}, ...flow.Identifier) error); ok {
		r0 = returnFunc(event, targetIDs...)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Conduit_Publish_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Publish'
type Conduit_Publish_Call struct {
	*mock.Call
}

// Publish is a helper method to define mock.On call
//   - event interface{}
//   - targetIDs ...flow.Identifier
func (_e *Conduit_Expecter) Publish(event interface{}, targetIDs ...interface{}) *Conduit_Publish_Call {
	return &Conduit_Publish_Call{Call: _e.mock.On("Publish",
		append([]interface{}{event}, targetIDs...)...)}
}

func (_c *Conduit_Publish_Call) Run(run func(event interface{}, targetIDs ...flow.Identifier)) *Conduit_Publish_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 interface{}
		if args[0] != nil {
			arg0 = args[0].(interface{})
		}
		var arg1 []flow.Identifier
		variadicArgs := make([]flow.Identifier, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(flow.Identifier)
			}
		}
		arg1 = variadicArgs
		run(
			arg0,
			arg1...,
		)
	})
	return _c
}

func (_c *Conduit_Publish_Call) Return(err error) *Conduit_Publish_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Conduit_Publish_Call) RunAndReturn(run func(event interface{}, targetIDs ...flow.Identifier) error) *Conduit_Publish_Call {
	_c.Call.Return(run)
	return _c
}

// ReportMisbehavior provides a mock function for the type Conduit
func (_mock *Conduit) ReportMisbehavior(misbehaviorReport network.MisbehaviorReport) {
	_mock.Called(misbehaviorReport)
	return
}

// Conduit_ReportMisbehavior_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReportMisbehavior'
type Conduit_ReportMisbehavior_Call struct {
	*mock.Call
}

// ReportMisbehavior is a helper method to define mock.On call
//   - misbehaviorReport network.MisbehaviorReport
func (_e *Conduit_Expecter) ReportMisbehavior(misbehaviorReport interface{}) *Conduit_ReportMisbehavior_Call {
	return &Conduit_ReportMisbehavior_Call{Call: _e.mock.On("ReportMisbehavior", misbehaviorReport)}
}

func (_c *Conduit_ReportMisbehavior_Call) Run(run func(misbehaviorReport network.MisbehaviorReport)) *Conduit_ReportMisbehavior_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 network.MisbehaviorReport
		if args[0] != nil {
			arg0 = args[0].(network.MisbehaviorReport)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Conduit_ReportMisbehavior_Call) Return() *Conduit_ReportMisbehavior_Call {
	_c.Call.Return()
	return _c
}

func (_c *Conduit_ReportMisbehavior_Call) RunAndReturn(run func(misbehaviorReport network.MisbehaviorReport)) *Conduit_ReportMisbehavior_Call {
	_c.Run(run)
	return _c
}

// Unicast provides a mock function for the type Conduit
func (_mock *Conduit) Unicast(event interface{}, targetID flow.Identifier) error {
	ret := _mock.Called(event, targetID)

	if len(ret) == 0 {
		panic("no return value specified for Unicast")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(interface{}, flow.Identifier) error); ok {
		r0 = returnFunc(event, targetID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Conduit_Unicast_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Unicast'
type Conduit_Unicast_Call struct {
	*mock.Call
}

// Unicast is a helper method to define mock.On call
//   - event interface{}
//   - targetID flow.Identifier
func (_e *Conduit_Expecter) Unicast(event interface{}, targetID interface{}) *Conduit_Unicast_Call {
	return &Conduit_Unicast_Call{Call: _e.mock.On("Unicast", event, targetID)}
}

func (_c *Conduit_Unicast_Call) Run(run func(event interface{}, targetID flow.Identifier)) *Conduit_Unicast_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 interface{}
		if args[0] != nil {
			arg0 = args[0].(interface{})
		}
		var arg1 flow.Identifier
		if args[1] != nil {
			arg1 = args[1].(flow.Identifier)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Conduit_Unicast_Call) Return(err error) *Conduit_Unicast_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Conduit_Unicast_Call) RunAndReturn(run func(event interface{}, targetID flow.Identifier) error) *Conduit_Unicast_Call {
	_c.Call.Return(run)
	return _c
}

// NewDisallowListNotificationConsumer creates a new instance of DisallowListNotificationConsumer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewDisallowListNotificationConsumer(t interface {
	mock.TestingT
	Cleanup(func())
}) *DisallowListNotificationConsumer {
	mock := &DisallowListNotificationConsumer{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// DisallowListNotificationConsumer is an autogenerated mock type for the DisallowListNotificationConsumer type
type DisallowListNotificationConsumer struct {
	mock.Mock
}

type DisallowListNotificationConsumer_Expecter struct {
	mock *mock.Mock
}

func (_m *DisallowListNotificationConsumer) EXPECT() *DisallowListNotificationConsumer_Expecter {
	return &DisallowListNotificationConsumer_Expecter{mock: &_m.Mock}
}

// OnAllowListNotification provides a mock function for the type DisallowListNotificationConsumer
func (_mock *DisallowListNotificationConsumer) OnAllowListNotification(allowListingUpdate *network.AllowListingUpdate) {
	_mock.Called(allowListingUpdate)
	return
}

// DisallowListNotificationConsumer_OnAllowListNotification_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnAllowListNotification'
type DisallowListNotificationConsumer_OnAllowListNotification_Call struct {
	*mock.Call
}

// OnAllowListNotification is a helper method to define mock.On call
//   - allowListingUpdate *network.AllowListingUpdate
func (_e *DisallowListNotificationConsumer_Expecter) OnAllowListNotification(allowListingUpdate interface{}) *DisallowListNotificationConsumer_OnAllowListNotification_Call {
	return &DisallowListNotificationConsumer_OnAllowListNotification_Call{Call: _e.mock.On("OnAllowListNotification", allowListingUpdate)}
}

func (_c *DisallowListNotificationConsumer_OnAllowListNotification_Call) Run(run func(allowListingUpdate *network.AllowListingUpdate)) *DisallowListNotificationConsumer_OnAllowListNotification_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *network.AllowListingUpdate
		if args[0] != nil {
			arg0 = args[0].(*network.AllowListingUpdate)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *DisallowListNotificationConsumer_OnAllowListNotification_Call) Return() *DisallowListNotificationConsumer_OnAllowListNotification_Call {
	_c.Call.Return()
	return _c
}

func (_c *DisallowListNotificationConsumer_OnAllowListNotification_Call) RunAndReturn(run func(allowListingUpdate *network.AllowListingUpdate)) *DisallowListNotificationConsumer_OnAllowListNotification_Call {
	_c.Run(run)
	return _c
}

// OnDisallowListNotification provides a mock function for the type DisallowListNotificationConsumer
func (_mock *DisallowListNotificationConsumer) OnDisallowListNotification(disallowListingUpdate *network.DisallowListingUpdate) {
	_mock.Called(disallowListingUpdate)
	return
}

// DisallowListNotificationConsumer_OnDisallowListNotification_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnDisallowListNotification'
type DisallowListNotificationConsumer_OnDisallowListNotification_Call struct {
	*mock.Call
}

// OnDisallowListNotification is a helper method to define mock.On call
//   - disallowListingUpdate *network.DisallowListingUpdate
func (_e *DisallowListNotificationConsumer_Expecter) OnDisallowListNotification(disallowListingUpdate interface{}) *DisallowListNotificationConsumer_OnDisallowListNotification_Call {
	return &DisallowListNotificationConsumer_OnDisallowListNotification_Call{Call: _e.mock.On("OnDisallowListNotification", disallowListingUpdate)}
}

func (_c *DisallowListNotificationConsumer_OnDisallowListNotification_Call) Run(run func(disallowListingUpdate *network.DisallowListingUpdate)) *DisallowListNotificationConsumer_OnDisallowListNotification_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *network.DisallowListingUpdate
		if args[0] != nil {
			arg0 = args[0].(*network.DisallowListingUpdate)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *DisallowListNotificationConsumer_OnDisallowListNotification_Call) Return() *DisallowListNotificationConsumer_OnDisallowListNotification_Call {
	_c.Call.Return()
	return _c
}

func (_c *DisallowListNotificationConsumer_OnDisallowListNotification_Call) RunAndReturn(run func(disallowListingUpdate *network.DisallowListingUpdate)) *DisallowListNotificationConsumer_OnDisallowListNotification_Call {
	_c.Run(run)
	return _c
}

// NewEngine creates a new instance of Engine. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewEngine(t interface {
	mock.TestingT
	Cleanup(func())
}) *Engine {
	mock := &Engine{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Engine is an autogenerated mock type for the Engine type
type Engine struct {
	mock.Mock
}

type Engine_Expecter struct {
	mock *mock.Mock
}

func (_m *Engine) EXPECT() *Engine_Expecter {
	return &Engine_Expecter{mock: &_m.Mock}
}

// Done provides a mock function for the type Engine
func (_mock *Engine) Done() <-chan struct{} {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Done")
	}

	var r0 <-chan struct{}
	if returnFunc, ok := ret.Get(0).(func() <-chan struct{}); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan struct{})
		}
	}
	return r0
}

// Engine_Done_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Done'
type Engine_Done_Call struct {
	*mock.Call
}

// Done is a helper method to define mock.On call
func (_e *Engine_Expecter) Done() *Engine_Done_Call {
	return &Engine_Done_Call{Call: _e.mock.On("Done")}
}

func (_c *Engine_Done_Call) Run(run func()) *Engine_Done_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Engine_Done_Call) Return(valCh <-chan struct{}) *Engine_Done_Call {
	_c.Call.Return(valCh)
	return _c
}

func (_c *Engine_Done_Call) RunAndReturn(run func() <-chan struct{}) *Engine_Done_Call {
	_c.Call.Return(run)
	return _c
}

// Process provides a mock function for the type Engine
func (_mock *Engine) Process(channel channels.Channel, originID flow.Identifier, event interface{}) error {
	ret := _mock.Called(channel, originID, event)

	if len(ret) == 0 {
		panic("no return value specified for Process")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(channels.Channel, flow.Identifier, interface{}) error); ok {
		r0 = returnFunc(channel, originID, event)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Engine_Process_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Process'
type Engine_Process_Call struct {
	*mock.Call
}

// Process is a helper method to define mock.On call
//   - channel channels.Channel
//   - originID flow.Identifier
//   - event interface{}
func (_e *Engine_Expecter) Process(channel interface{}, originID interface{}, event interface{}) *Engine_Process_Call {
	return &Engine_Process_Call{Call: _e.mock.On("Process", channel, originID, event)}
}

func (_c *Engine_Process_Call) Run(run func(channel channels.Channel, originID flow.Identifier, event interface{})) *Engine_Process_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 channels.Channel
		if args[0] != nil {
			arg0 = args[0].(channels.Channel)
		}
		var arg1 flow.Identifier
		if args[1] != nil {
			arg1 = args[1].(flow.Identifier)
		}
		var arg2 interface{}
		if args[2] != nil {
			arg2 = args[2].(interface{})
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Engine_Process_Call) Return(err error) *Engine_Process_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Engine_Process_Call) RunAndReturn(run func(channel channels.Channel, originID flow.Identifier, event interface{}) error) *Engine_Process_Call {
	_c.Call.Return(run)
	return _c
}

// ProcessLocal provides a mock function for the type Engine
func (_mock *Engine) ProcessLocal(event interface{}) error {
	ret := _mock.Called(event)

	if len(ret) == 0 {
		panic("no return value specified for ProcessLocal")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(interface{}) error); ok {
		r0 = returnFunc(event)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Engine_ProcessLocal_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ProcessLocal'
type Engine_ProcessLocal_Call struct {
	*mock.Call
}

// ProcessLocal is a helper method to define mock.On call
//   - event interface{}
func (_e *Engine_Expecter) ProcessLocal(event interface{}) *Engine_ProcessLocal_Call {
	return &Engine_ProcessLocal_Call{Call: _e.mock.On("ProcessLocal", event)}
}

func (_c *Engine_ProcessLocal_Call) Run(run func(event interface{})) *Engine_ProcessLocal_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 interface{}
		if args[0] != nil {
			arg0 = args[0].(interface{})
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Engine_ProcessLocal_Call) Return(err error) *Engine_ProcessLocal_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Engine_ProcessLocal_Call) RunAndReturn(run func(event interface{}) error) *Engine_ProcessLocal_Call {
	_c.Call.Return(run)
	return _c
}

// Ready provides a mock function for the type Engine
func (_mock *Engine) Ready() <-chan struct{} {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Ready")
	}

	var r0 <-chan struct{}
	if returnFunc, ok := ret.Get(0).(func() <-chan struct{}); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan struct{})
		}
	}
	return r0
}

// Engine_Ready_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Ready'
type Engine_Ready_Call struct {
	*mock.Call
}

// Ready is a helper method to define mock.On call
func (_e *Engine_Expecter) Ready() *Engine_Ready_Call {
	return &Engine_Ready_Call{Call: _e.mock.On("Ready")}
}

func (_c *Engine_Ready_Call) Run(run func()) *Engine_Ready_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Engine_Ready_Call) Return(valCh <-chan struct{}) *Engine_Ready_Call {
	_c.Call.Return(valCh)
	return _c
}

func (_c *Engine_Ready_Call) RunAndReturn(run func() <-chan struct{}) *Engine_Ready_Call {
	_c.Call.Return(run)
	return _c
}

// Submit provides a mock function for the type Engine
func (_mock *Engine) Submit(channel channels.Channel, originID flow.Identifier, event interface{}) {
	_mock.Called(channel, originID, event)
	return
}

// Engine_Submit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Submit'
type Engine_Submit_Call struct {
	*mock.Call
}

// Submit is a helper method to define mock.On call
//   - channel channels.Channel
//   - originID flow.Identifier
//   - event interface{}
func (_e *Engine_Expecter) Submit(channel interface{}, originID interface{}, event interface{}) *Engine_Submit_Call {
	return &Engine_Submit_Call{Call: _e.mock.On("Submit", channel, originID, event)}
}

func (_c *Engine_Submit_Call) Run(run func(channel channels.Channel, originID flow.Identifier, event interface{})) *Engine_Submit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 channels.Channel
		if args[0] != nil {
			arg0 = args[0].(channels.Channel)
		}
		var arg1 flow.Identifier
		if args[1] != nil {
			arg1 = args[1].(flow.Identifier)
		}
		var arg2 interface{}
		if args[2] != nil {
			arg2 = args[2].(interface{})
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Engine_Submit_Call) Return() *Engine_Submit_Call {
	_c.Call.Return()
	return _c
}

func (_c *Engine_Submit_Call) RunAndReturn(run func(channel channels.Channel, originID flow.Identifier, event interface{})) *Engine_Submit_Call {
	_c.Run(run)
	return _c
}

// SubmitLocal provides a mock function for the type Engine
func (_mock *Engine) SubmitLocal(event interface{}) {
	_mock.Called(event)
	return
}

// Engine_SubmitLocal_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SubmitLocal'
type Engine_SubmitLocal_Call struct {
	*mock.Call
}

// SubmitLocal is a helper method to define mock.On call
//   - event interface{}
func (_e *Engine_Expecter) SubmitLocal(event interface{}) *Engine_SubmitLocal_Call {
	return &Engine_SubmitLocal_Call{Call: _e.mock.On("SubmitLocal", event)}
}

func (_c *Engine_SubmitLocal_Call) Run(run func(event interface{})) *Engine_SubmitLocal_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 interface{}
		if args[0] != nil {
			arg0 = args[0].(interface{})
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Engine_SubmitLocal_Call) Return() *Engine_SubmitLocal_Call {
	_c.Call.Return()
	return _c
}

func (_c *Engine_SubmitLocal_Call) RunAndReturn(run func(event interface{})) *Engine_SubmitLocal_Call {
	_c.Run(run)
	return _c
}

// NewMessageProcessor creates a new instance of MessageProcessor. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMessageProcessor(t interface {
	mock.TestingT
	Cleanup(func())
}) *MessageProcessor {
	mock := &MessageProcessor{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MessageProcessor is an autogenerated mock type for the MessageProcessor type
type MessageProcessor struct {
	mock.Mock
}

type MessageProcessor_Expecter struct {
	mock *mock.Mock
}

func (_m *MessageProcessor) EXPECT() *MessageProcessor_Expecter {
	return &MessageProcessor_Expecter{mock: &_m.Mock}
}

// Process provides a mock function for the type MessageProcessor
func (_mock *MessageProcessor) Process(channel channels.Channel, originID flow.Identifier, message interface{}) error {
	ret := _mock.Called(channel, originID, message)

	if len(ret) == 0 {
		panic("no return value specified for Process")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(channels.Channel, flow.Identifier, interface{}) error); ok {
		r0 = returnFunc(channel, originID, message)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MessageProcessor_Process_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Process'
type MessageProcessor_Process_Call struct {
	*mock.Call
}

// Process is a helper method to define mock.On call
//   - channel channels.Channel
//   - originID flow.Identifier
//   - message interface{}
func (_e *MessageProcessor_Expecter) Process(channel interface{}, originID interface{}, message interface{}) *MessageProcessor_Process_Call {
	return &MessageProcessor_Process_Call{Call: _e.mock.On("Process", channel, originID, message)}
}

func (_c *MessageProcessor_Process_Call) Run(run func(channel channels.Channel, originID flow.Identifier, message interface{})) *MessageProcessor_Process_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 channels.Channel
		if args[0] != nil {
			arg0 = args[0].(channels.Channel)
		}
		var arg1 flow.Identifier
		if args[1] != nil {
			arg1 = args[1].(flow.Identifier)
		}
		var arg2 interface{}
		if args[2] != nil {
			arg2 = args[2].(interface{})
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MessageProcessor_Process_Call) Return(err error) *MessageProcessor_Process_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MessageProcessor_Process_Call) RunAndReturn(run func(channel channels.Channel, originID flow.Identifier, message interface{}) error) *MessageProcessor_Process_Call {
	_c.Call.Return(run)
	return _c
}

// NewIncomingMessageScope creates a new instance of IncomingMessageScope. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIncomingMessageScope(t interface {
	mock.TestingT
	Cleanup(func())
}) *IncomingMessageScope {
	mock := &IncomingMessageScope{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// IncomingMessageScope is an autogenerated mock type for the IncomingMessageScope type
type IncomingMessageScope struct {
	mock.Mock
}

type IncomingMessageScope_Expecter struct {
	mock *mock.Mock
}

func (_m *IncomingMessageScope) EXPECT() *IncomingMessageScope_Expecter {
	return &IncomingMessageScope_Expecter{mock: &_m.Mock}
}

// Channel provides a mock function for the type IncomingMessageScope
func (_mock *IncomingMessageScope) Channel() channels.Channel {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Channel")
	}

	var r0 channels.Channel
	if returnFunc, ok := ret.Get(0).(func() channels.Channel); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(channels.Channel)
	}
	return r0
}

// IncomingMessageScope_Channel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Channel'
type IncomingMessageScope_Channel_Call struct {
	*mock.Call
}

// Channel is a helper method to define mock.On call
func (_e *IncomingMessageScope_Expecter) Channel() *IncomingMessageScope_Channel_Call {
	return &IncomingMessageScope_Channel_Call{Call: _e.mock.On("Channel")}
}

func (_c *IncomingMessageScope_Channel_Call) Run(run func()) *IncomingMessageScope_Channel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *IncomingMessageScope_Channel_Call) Return(channel channels.Channel) *IncomingMessageScope_Channel_Call {
	_c.Call.Return(channel)
	return _c
}

func (_c *IncomingMessageScope_Channel_Call) RunAndReturn(run func() channels.Channel) *IncomingMessageScope_Channel_Call {
	_c.Call.Return(run)
	return _c
}

// DecodedPayload provides a mock function for the type IncomingMessageScope
func (_mock *IncomingMessageScope) DecodedPayload() interface{} {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for DecodedPayload")
	}

	var r0 interface{}
	if returnFunc, ok := ret.Get(0).(func() interface{}); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}
	return r0
}

// IncomingMessageScope_DecodedPayload_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DecodedPayload'
type IncomingMessageScope_DecodedPayload_Call struct {
	*mock.Call
}

// DecodedPayload is a helper method to define mock.On call
func (_e *IncomingMessageScope_Expecter) DecodedPayload() *IncomingMessageScope_DecodedPayload_Call {
	return &IncomingMessageScope_DecodedPayload_Call{Call: _e.mock.On("DecodedPayload")}
}

func (_c *IncomingMessageScope_DecodedPayload_Call) Run(run func()) *IncomingMessageScope_DecodedPayload_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *IncomingMessageScope_DecodedPayload_Call) Return(ifaceVal interface{}) *IncomingMessageScope_DecodedPayload_Call {
	_c.Call.Return(ifaceVal)
	return _c
}

func (_c *IncomingMessageScope_DecodedPayload_Call) RunAndReturn(run func() interface{}) *IncomingMessageScope_DecodedPayload_Call {
	_c.Call.Return(run)
	return _c
}

// EventID provides a mock function for the type IncomingMessageScope
func (_mock *IncomingMessageScope) EventID() []byte {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for EventID")
	}

	var r0 []byte
	if returnFunc, ok := ret.Get(0).(func() []byte); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}
	return r0
}

// IncomingMessageScope_EventID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EventID'
type IncomingMessageScope_EventID_Call struct {
	*mock.Call
}

// EventID is a helper method to define mock.On call
func (_e *IncomingMessageScope_Expecter) EventID() *IncomingMessageScope_EventID_Call {
	return &IncomingMessageScope_EventID_Call{Call: _e.mock.On("EventID")}
}

func (_c *IncomingMessageScope_EventID_Call) Run(run func()) *IncomingMessageScope_EventID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *IncomingMessageScope_EventID_Call) Return(bytes []byte) *IncomingMessageScope_EventID_Call {
	_c.Call.Return(bytes)
	return _c
}

func (_c *IncomingMessageScope_EventID_Call) RunAndReturn(run func() []byte) *IncomingMessageScope_EventID_Call {
	_c.Call.Return(run)
	return _c
}

// OriginId provides a mock function for the type IncomingMessageScope
func (_mock *IncomingMessageScope) OriginId() flow.Identifier {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for OriginId")
	}

	var r0 flow.Identifier
	if returnFunc, ok := ret.Get(0).(func() flow.Identifier); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.Identifier)
		}
	}
	return r0
}

// IncomingMessageScope_OriginId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OriginId'
type IncomingMessageScope_OriginId_Call struct {
	*mock.Call
}

// OriginId is a helper method to define mock.On call
func (_e *IncomingMessageScope_Expecter) OriginId() *IncomingMessageScope_OriginId_Call {
	return &IncomingMessageScope_OriginId_Call{Call: _e.mock.On("OriginId")}
}

func (_c *IncomingMessageScope_OriginId_Call) Run(run func()) *IncomingMessageScope_OriginId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *IncomingMessageScope_OriginId_Call) Return(identifier flow.Identifier) *IncomingMessageScope_OriginId_Call {
	_c.Call.Return(identifier)
	return _c
}

func (_c *IncomingMessageScope_OriginId_Call) RunAndReturn(run func() flow.Identifier) *IncomingMessageScope_OriginId_Call {
	_c.Call.Return(run)
	return _c
}

// PayloadType provides a mock function for the type IncomingMessageScope
func (_mock *IncomingMessageScope) PayloadType() string {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for PayloadType")
	}

	var r0 string
	if returnFunc, ok := ret.Get(0).(func() string); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(string)
	}
	return r0
}

// IncomingMessageScope_PayloadType_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PayloadType'
type IncomingMessageScope_PayloadType_Call struct {
	*mock.Call
}

// PayloadType is a helper method to define mock.On call
func (_e *IncomingMessageScope_Expecter) PayloadType() *IncomingMessageScope_PayloadType_Call {
	return &IncomingMessageScope_PayloadType_Call{Call: _e.mock.On("PayloadType")}
}

func (_c *IncomingMessageScope_PayloadType_Call) Run(run func()) *IncomingMessageScope_PayloadType_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *IncomingMessageScope_PayloadType_Call) Return(s string) *IncomingMessageScope_PayloadType_Call {
	_c.Call.Return(s)
	return _c
}

func (_c *IncomingMessageScope_PayloadType_Call) RunAndReturn(run func() string) *IncomingMessageScope_PayloadType_Call {
	_c.Call.Return(run)
	return _c
}

// Proto provides a mock function for the type IncomingMessageScope
func (_mock *IncomingMessageScope) Proto() *message.Message {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Proto")
	}

	var r0 *message.Message
	if returnFunc, ok := ret.Get(0).(func() *message.Message); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*message.Message)
		}
	}
	return r0
}

// IncomingMessageScope_Proto_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Proto'
type IncomingMessageScope_Proto_Call struct {
	*mock.Call
}

// Proto is a helper method to define mock.On call
func (_e *IncomingMessageScope_Expecter) Proto() *IncomingMessageScope_Proto_Call {
	return &IncomingMessageScope_Proto_Call{Call: _e.mock.On("Proto")}
}

func (_c *IncomingMessageScope_Proto_Call) Run(run func()) *IncomingMessageScope_Proto_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *IncomingMessageScope_Proto_Call) Return(message1 *message.Message) *IncomingMessageScope_Proto_Call {
	_c.Call.Return(message1)
	return _c
}

func (_c *IncomingMessageScope_Proto_Call) RunAndReturn(run func() *message.Message) *IncomingMessageScope_Proto_Call {
	_c.Call.Return(run)
	return _c
}

// Protocol provides a mock function for the type IncomingMessageScope
func (_mock *IncomingMessageScope) Protocol() message.ProtocolType {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Protocol")
	}

	var r0 message.ProtocolType
	if returnFunc, ok := ret.Get(0).(func() message.ProtocolType); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(message.ProtocolType)
	}
	return r0
}

// IncomingMessageScope_Protocol_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Protocol'
type IncomingMessageScope_Protocol_Call struct {
	*mock.Call
}

// Protocol is a helper method to define mock.On call
func (_e *IncomingMessageScope_Expecter) Protocol() *IncomingMessageScope_Protocol_Call {
	return &IncomingMessageScope_Protocol_Call{Call: _e.mock.On("Protocol")}
}

func (_c *IncomingMessageScope_Protocol_Call) Run(run func()) *IncomingMessageScope_Protocol_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *IncomingMessageScope_Protocol_Call) Return(protocolType message.ProtocolType) *IncomingMessageScope_Protocol_Call {
	_c.Call.Return(protocolType)
	return _c
}

func (_c *IncomingMessageScope_Protocol_Call) RunAndReturn(run func() message.ProtocolType) *IncomingMessageScope_Protocol_Call {
	_c.Call.Return(run)
	return _c
}

// Size provides a mock function for the type IncomingMessageScope
func (_mock *IncomingMessageScope) Size() int {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Size")
	}

	var r0 int
	if returnFunc, ok := ret.Get(0).(func() int); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(int)
	}
	return r0
}

// IncomingMessageScope_Size_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Size'
type IncomingMessageScope_Size_Call struct {
	*mock.Call
}

// Size is a helper method to define mock.On call
func (_e *IncomingMessageScope_Expecter) Size() *IncomingMessageScope_Size_Call {
	return &IncomingMessageScope_Size_Call{Call: _e.mock.On("Size")}
}

func (_c *IncomingMessageScope_Size_Call) Run(run func()) *IncomingMessageScope_Size_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *IncomingMessageScope_Size_Call) Return(n int) *IncomingMessageScope_Size_Call {
	_c.Call.Return(n)
	return _c
}

func (_c *IncomingMessageScope_Size_Call) RunAndReturn(run func() int) *IncomingMessageScope_Size_Call {
	_c.Call.Return(run)
	return _c
}

// TargetIDs provides a mock function for the type IncomingMessageScope
func (_mock *IncomingMessageScope) TargetIDs() flow.IdentifierList {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for TargetIDs")
	}

	var r0 flow.IdentifierList
	if returnFunc, ok := ret.Get(0).(func() flow.IdentifierList); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.IdentifierList)
		}
	}
	return r0
}

// IncomingMessageScope_TargetIDs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TargetIDs'
type IncomingMessageScope_TargetIDs_Call struct {
	*mock.Call
}

// TargetIDs is a helper method to define mock.On call
func (_e *IncomingMessageScope_Expecter) TargetIDs() *IncomingMessageScope_TargetIDs_Call {
	return &IncomingMessageScope_TargetIDs_Call{Call: _e.mock.On("TargetIDs")}
}

func (_c *IncomingMessageScope_TargetIDs_Call) Run(run func()) *IncomingMessageScope_TargetIDs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *IncomingMessageScope_TargetIDs_Call) Return(identifierList flow.IdentifierList) *IncomingMessageScope_TargetIDs_Call {
	_c.Call.Return(identifierList)
	return _c
}

func (_c *IncomingMessageScope_TargetIDs_Call) RunAndReturn(run func() flow.IdentifierList) *IncomingMessageScope_TargetIDs_Call {
	_c.Call.Return(run)
	return _c
}

// NewOutgoingMessageScope creates a new instance of OutgoingMessageScope. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewOutgoingMessageScope(t interface {
	mock.TestingT
	Cleanup(func())
}) *OutgoingMessageScope {
	mock := &OutgoingMessageScope{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// OutgoingMessageScope is an autogenerated mock type for the OutgoingMessageScope type
type OutgoingMessageScope struct {
	mock.Mock
}

type OutgoingMessageScope_Expecter struct {
	mock *mock.Mock
}

func (_m *OutgoingMessageScope) EXPECT() *OutgoingMessageScope_Expecter {
	return &OutgoingMessageScope_Expecter{mock: &_m.Mock}
}

// PayloadType provides a mock function for the type OutgoingMessageScope
func (_mock *OutgoingMessageScope) PayloadType() string {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for PayloadType")
	}

	var r0 string
	if returnFunc, ok := ret.Get(0).(func() string); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(string)
	}
	return r0
}

// OutgoingMessageScope_PayloadType_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PayloadType'
type OutgoingMessageScope_PayloadType_Call struct {
	*mock.Call
}

// PayloadType is a helper method to define mock.On call
func (_e *OutgoingMessageScope_Expecter) PayloadType() *OutgoingMessageScope_PayloadType_Call {
	return &OutgoingMessageScope_PayloadType_Call{Call: _e.mock.On("PayloadType")}
}

func (_c *OutgoingMessageScope_PayloadType_Call) Run(run func()) *OutgoingMessageScope_PayloadType_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *OutgoingMessageScope_PayloadType_Call) Return(s string) *OutgoingMessageScope_PayloadType_Call {
	_c.Call.Return(s)
	return _c
}

func (_c *OutgoingMessageScope_PayloadType_Call) RunAndReturn(run func() string) *OutgoingMessageScope_PayloadType_Call {
	_c.Call.Return(run)
	return _c
}

// Proto provides a mock function for the type OutgoingMessageScope
func (_mock *OutgoingMessageScope) Proto() *message.Message {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Proto")
	}

	var r0 *message.Message
	if returnFunc, ok := ret.Get(0).(func() *message.Message); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*message.Message)
		}
	}
	return r0
}

// OutgoingMessageScope_Proto_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Proto'
type OutgoingMessageScope_Proto_Call struct {
	*mock.Call
}

// Proto is a helper method to define mock.On call
func (_e *OutgoingMessageScope_Expecter) Proto() *OutgoingMessageScope_Proto_Call {
	return &OutgoingMessageScope_Proto_Call{Call: _e.mock.On("Proto")}
}

func (_c *OutgoingMessageScope_Proto_Call) Run(run func()) *OutgoingMessageScope_Proto_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *OutgoingMessageScope_Proto_Call) Return(message1 *message.Message) *OutgoingMessageScope_Proto_Call {
	_c.Call.Return(message1)
	return _c
}

func (_c *OutgoingMessageScope_Proto_Call) RunAndReturn(run func() *message.Message) *OutgoingMessageScope_Proto_Call {
	_c.Call.Return(run)
	return _c
}

// Size provides a mock function for the type OutgoingMessageScope
func (_mock *OutgoingMessageScope) Size() int {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Size")
	}

	var r0 int
	if returnFunc, ok := ret.Get(0).(func() int); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(int)
	}
	return r0
}

// OutgoingMessageScope_Size_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Size'
type OutgoingMessageScope_Size_Call struct {
	*mock.Call
}

// Size is a helper method to define mock.On call
func (_e *OutgoingMessageScope_Expecter) Size() *OutgoingMessageScope_Size_Call {
	return &OutgoingMessageScope_Size_Call{Call: _e.mock.On("Size")}
}

func (_c *OutgoingMessageScope_Size_Call) Run(run func()) *OutgoingMessageScope_Size_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *OutgoingMessageScope_Size_Call) Return(n int) *OutgoingMessageScope_Size_Call {
	_c.Call.Return(n)
	return _c
}

func (_c *OutgoingMessageScope_Size_Call) RunAndReturn(run func() int) *OutgoingMessageScope_Size_Call {
	_c.Call.Return(run)
	return _c
}

// TargetIds provides a mock function for the type OutgoingMessageScope
func (_mock *OutgoingMessageScope) TargetIds() flow.IdentifierList {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for TargetIds")
	}

	var r0 flow.IdentifierList
	if returnFunc, ok := ret.Get(0).(func() flow.IdentifierList); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.IdentifierList)
		}
	}
	return r0
}

// OutgoingMessageScope_TargetIds_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TargetIds'
type OutgoingMessageScope_TargetIds_Call struct {
	*mock.Call
}

// TargetIds is a helper method to define mock.On call
func (_e *OutgoingMessageScope_Expecter) TargetIds() *OutgoingMessageScope_TargetIds_Call {
	return &OutgoingMessageScope_TargetIds_Call{Call: _e.mock.On("TargetIds")}
}

func (_c *OutgoingMessageScope_TargetIds_Call) Run(run func()) *OutgoingMessageScope_TargetIds_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *OutgoingMessageScope_TargetIds_Call) Return(identifierList flow.IdentifierList) *OutgoingMessageScope_TargetIds_Call {
	_c.Call.Return(identifierList)
	return _c
}

func (_c *OutgoingMessageScope_TargetIds_Call) RunAndReturn(run func() flow.IdentifierList) *OutgoingMessageScope_TargetIds_Call {
	_c.Call.Return(run)
	return _c
}

// Topic provides a mock function for the type OutgoingMessageScope
func (_mock *OutgoingMessageScope) Topic() channels.Topic {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Topic")
	}

	var r0 channels.Topic
	if returnFunc, ok := ret.Get(0).(func() channels.Topic); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(channels.Topic)
	}
	return r0
}

// OutgoingMessageScope_Topic_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Topic'
type OutgoingMessageScope_Topic_Call struct {
	*mock.Call
}

// Topic is a helper method to define mock.On call
func (_e *OutgoingMessageScope_Expecter) Topic() *OutgoingMessageScope_Topic_Call {
	return &OutgoingMessageScope_Topic_Call{Call: _e.mock.On("Topic")}
}

func (_c *OutgoingMessageScope_Topic_Call) Run(run func()) *OutgoingMessageScope_Topic_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *OutgoingMessageScope_Topic_Call) Return(topic channels.Topic) *OutgoingMessageScope_Topic_Call {
	_c.Call.Return(topic)
	return _c
}

func (_c *OutgoingMessageScope_Topic_Call) RunAndReturn(run func() channels.Topic) *OutgoingMessageScope_Topic_Call {
	_c.Call.Return(run)
	return _c
}

// NewEngineRegistry creates a new instance of EngineRegistry. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewEngineRegistry(t interface {
	mock.TestingT
	Cleanup(func())
}) *EngineRegistry {
	mock := &EngineRegistry{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// EngineRegistry is an autogenerated mock type for the EngineRegistry type
type EngineRegistry struct {
	mock.Mock
}

type EngineRegistry_Expecter struct {
	mock *mock.Mock
}

func (_m *EngineRegistry) EXPECT() *EngineRegistry_Expecter {
	return &EngineRegistry_Expecter{mock: &_m.Mock}
}

// Done provides a mock function for the type EngineRegistry
func (_mock *EngineRegistry) Done() <-chan struct{} {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Done")
	}

	var r0 <-chan struct{}
	if returnFunc, ok := ret.Get(0).(func() <-chan struct{}); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan struct{})
		}
	}
	return r0
}

// EngineRegistry_Done_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Done'
type EngineRegistry_Done_Call struct {
	*mock.Call
}

// Done is a helper method to define mock.On call
func (_e *EngineRegistry_Expecter) Done() *EngineRegistry_Done_Call {
	return &EngineRegistry_Done_Call{Call: _e.mock.On("Done")}
}

func (_c *EngineRegistry_Done_Call) Run(run func()) *EngineRegistry_Done_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *EngineRegistry_Done_Call) Return(valCh <-chan struct{}) *EngineRegistry_Done_Call {
	_c.Call.Return(valCh)
	return _c
}

func (_c *EngineRegistry_Done_Call) RunAndReturn(run func() <-chan struct{}) *EngineRegistry_Done_Call {
	_c.Call.Return(run)
	return _c
}

// Ready provides a mock function for the type EngineRegistry
func (_mock *EngineRegistry) Ready() <-chan struct{} {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Ready")
	}

	var r0 <-chan struct{}
	if returnFunc, ok := ret.Get(0).(func() <-chan struct{}); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan struct{})
		}
	}
	return r0
}

// EngineRegistry_Ready_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Ready'
type EngineRegistry_Ready_Call struct {
	*mock.Call
}

// Ready is a helper method to define mock.On call
func (_e *EngineRegistry_Expecter) Ready() *EngineRegistry_Ready_Call {
	return &EngineRegistry_Ready_Call{Call: _e.mock.On("Ready")}
}

func (_c *EngineRegistry_Ready_Call) Run(run func()) *EngineRegistry_Ready_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *EngineRegistry_Ready_Call) Return(valCh <-chan struct{}) *EngineRegistry_Ready_Call {
	_c.Call.Return(valCh)
	return _c
}

func (_c *EngineRegistry_Ready_Call) RunAndReturn(run func() <-chan struct{}) *EngineRegistry_Ready_Call {
	_c.Call.Return(run)
	return _c
}

// Register provides a mock function for the type EngineRegistry
func (_mock *EngineRegistry) Register(channel channels.Channel, messageProcessor network.MessageProcessor) (network.Conduit, error) {
	ret := _mock.Called(channel, messageProcessor)

	if len(ret) == 0 {
		panic("no return value specified for Register")
	}

	var r0 network.Conduit
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(channels.Channel, network.MessageProcessor) (network.Conduit, error)); ok {
		return returnFunc(channel, messageProcessor)
	}
	if returnFunc, ok := ret.Get(0).(func(channels.Channel, network.MessageProcessor) network.Conduit); ok {
		r0 = returnFunc(channel, messageProcessor)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(network.Conduit)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(channels.Channel, network.MessageProcessor) error); ok {
		r1 = returnFunc(channel, messageProcessor)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// EngineRegistry_Register_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Register'
type EngineRegistry_Register_Call struct {
	*mock.Call
}

// Register is a helper method to define mock.On call
//   - channel channels.Channel
//   - messageProcessor network.MessageProcessor
func (_e *EngineRegistry_Expecter) Register(channel interface{}, messageProcessor interface{}) *EngineRegistry_Register_Call {
	return &EngineRegistry_Register_Call{Call: _e.mock.On("Register", channel, messageProcessor)}
}

func (_c *EngineRegistry_Register_Call) Run(run func(channel channels.Channel, messageProcessor network.MessageProcessor)) *EngineRegistry_Register_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 channels.Channel
		if args[0] != nil {
			arg0 = args[0].(channels.Channel)
		}
		var arg1 network.MessageProcessor
		if args[1] != nil {
			arg1 = args[1].(network.MessageProcessor)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *EngineRegistry_Register_Call) Return(conduit network.Conduit, err error) *EngineRegistry_Register_Call {
	_c.Call.Return(conduit, err)
	return _c
}

func (_c *EngineRegistry_Register_Call) RunAndReturn(run func(channel channels.Channel, messageProcessor network.MessageProcessor) (network.Conduit, error)) *EngineRegistry_Register_Call {
	_c.Call.Return(run)
	return _c
}

// RegisterBlobService provides a mock function for the type EngineRegistry
func (_mock *EngineRegistry) RegisterBlobService(channel channels.Channel, store datastore.Batching, opts ...network.BlobServiceOption) (network.BlobService, error) {
	// network.BlobServiceOption
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, channel, store)
	_ca = append(_ca, _va...)
	ret := _mock.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RegisterBlobService")
	}

	var r0 network.BlobService
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(channels.Channel, datastore.Batching, ...network.BlobServiceOption) (network.BlobService, error)); ok {
		return returnFunc(channel, store, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(channels.Channel, datastore.Batching, ...network.BlobServiceOption) network.BlobService); ok {
		r0 = returnFunc(channel, store, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(network.BlobService)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(channels.Channel, datastore.Batching, ...network.BlobServiceOption) error); ok {
		r1 = returnFunc(channel, store, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// EngineRegistry_RegisterBlobService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RegisterBlobService'
type EngineRegistry_RegisterBlobService_Call struct {
	*mock.Call
}

// RegisterBlobService is a helper method to define mock.On call
//   - channel channels.Channel
//   - store datastore.Batching
//   - opts ...network.BlobServiceOption
func (_e *EngineRegistry_Expecter) RegisterBlobService(channel interface{}, store interface{}, opts ...interface{}) *EngineRegistry_RegisterBlobService_Call {
	return &EngineRegistry_RegisterBlobService_Call{Call: _e.mock.On("RegisterBlobService",
		append([]interface{}{channel, store}, opts...)...)}
}

func (_c *EngineRegistry_RegisterBlobService_Call) Run(run func(channel channels.Channel, store datastore.Batching, opts ...network.BlobServiceOption)) *EngineRegistry_RegisterBlobService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 channels.Channel
		if args[0] != nil {
			arg0 = args[0].(channels.Channel)
		}
		var arg1 datastore.Batching
		if args[1] != nil {
			arg1 = args[1].(datastore.Batching)
		}
		var arg2 []network.BlobServiceOption
		variadicArgs := make([]network.BlobServiceOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(network.BlobServiceOption)
			}
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *EngineRegistry_RegisterBlobService_Call) Return(blobService network.BlobService, err error) *EngineRegistry_RegisterBlobService_Call {
	_c.Call.Return(blobService, err)
	return _c
}

func (_c *EngineRegistry_RegisterBlobService_Call) RunAndReturn(run func(channel channels.Channel, store datastore.Batching, opts ...network.BlobServiceOption) (network.BlobService, error)) *EngineRegistry_RegisterBlobService_Call {
	_c.Call.Return(run)
	return _c
}

// RegisterPingService provides a mock function for the type EngineRegistry
func (_mock *EngineRegistry) RegisterPingService(pingProtocolID protocol.ID, pingInfoProvider network.PingInfoProvider) (network.PingService, error) {
	ret := _mock.Called(pingProtocolID, pingInfoProvider)

	if len(ret) == 0 {
		panic("no return value specified for RegisterPingService")
	}

	var r0 network.PingService
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(protocol.ID, network.PingInfoProvider) (network.PingService, error)); ok {
		return returnFunc(pingProtocolID, pingInfoProvider)
	}
	if returnFunc, ok := ret.Get(0).(func(protocol.ID, network.PingInfoProvider) network.PingService); ok {
		r0 = returnFunc(pingProtocolID, pingInfoProvider)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(network.PingService)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(protocol.ID, network.PingInfoProvider) error); ok {
		r1 = returnFunc(pingProtocolID, pingInfoProvider)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// EngineRegistry_RegisterPingService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RegisterPingService'
type EngineRegistry_RegisterPingService_Call struct {
	*mock.Call
}

// RegisterPingService is a helper method to define mock.On call
//   - pingProtocolID protocol.ID
//   - pingInfoProvider network.PingInfoProvider
func (_e *EngineRegistry_Expecter) RegisterPingService(pingProtocolID interface{}, pingInfoProvider interface{}) *EngineRegistry_RegisterPingService_Call {
	return &EngineRegistry_RegisterPingService_Call{Call: _e.mock.On("RegisterPingService", pingProtocolID, pingInfoProvider)}
}

func (_c *EngineRegistry_RegisterPingService_Call) Run(run func(pingProtocolID protocol.ID, pingInfoProvider network.PingInfoProvider)) *EngineRegistry_RegisterPingService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 protocol.ID
		if args[0] != nil {
			arg0 = args[0].(protocol.ID)
		}
		var arg1 network.PingInfoProvider
		if args[1] != nil {
			arg1 = args[1].(network.PingInfoProvider)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *EngineRegistry_RegisterPingService_Call) Return(pingService network.PingService, err error) *EngineRegistry_RegisterPingService_Call {
	_c.Call.Return(pingService, err)
	return _c
}

func (_c *EngineRegistry_RegisterPingService_Call) RunAndReturn(run func(pingProtocolID protocol.ID, pingInfoProvider network.PingInfoProvider) (network.PingService, error)) *EngineRegistry_RegisterPingService_Call {
	_c.Call.Return(run)
	return _c
}

// Start provides a mock function for the type EngineRegistry
func (_mock *EngineRegistry) Start(signalerContext irrecoverable.SignalerContext) {
	_mock.Called(signalerContext)
	return
}

// EngineRegistry_Start_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Start'
type EngineRegistry_Start_Call struct {
	*mock.Call
}

// Start is a helper method to define mock.On call
//   - signalerContext irrecoverable.SignalerContext
func (_e *EngineRegistry_Expecter) Start(signalerContext interface{}) *EngineRegistry_Start_Call {
	return &EngineRegistry_Start_Call{Call: _e.mock.On("Start", signalerContext)}
}

func (_c *EngineRegistry_Start_Call) Run(run func(signalerContext irrecoverable.SignalerContext)) *EngineRegistry_Start_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 irrecoverable.SignalerContext
		if args[0] != nil {
			arg0 = args[0].(irrecoverable.SignalerContext)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *EngineRegistry_Start_Call) Return() *EngineRegistry_Start_Call {
	_c.Call.Return()
	return _c
}

func (_c *EngineRegistry_Start_Call) RunAndReturn(run func(signalerContext irrecoverable.SignalerContext)) *EngineRegistry_Start_Call {
	_c.Run(run)
	return _c
}

// NewConduitAdapter creates a new instance of ConduitAdapter. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewConduitAdapter(t interface {
	mock.TestingT
	Cleanup(func())
}) *ConduitAdapter {
	mock := &ConduitAdapter{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// ConduitAdapter is an autogenerated mock type for the ConduitAdapter type
type ConduitAdapter struct {
	mock.Mock
}

type ConduitAdapter_Expecter struct {
	mock *mock.Mock
}

func (_m *ConduitAdapter) EXPECT() *ConduitAdapter_Expecter {
	return &ConduitAdapter_Expecter{mock: &_m.Mock}
}

// MulticastOnChannel provides a mock function for the type ConduitAdapter
func (_mock *ConduitAdapter) MulticastOnChannel(channel channels.Channel, ifaceVal interface{}, v uint, identifiers ...flow.Identifier) error {
	// flow.Identifier
	_va := make([]interface{}, len(identifiers))
	for _i := range identifiers {
		_va[_i] = identifiers[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, channel, ifaceVal, v)
	_ca = append(_ca, _va...)
	ret := _mock.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MulticastOnChannel")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(channels.Channel, interface{}, uint, ...flow.Identifier) error); ok {
		r0 = returnFunc(channel, ifaceVal, v, identifiers...)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ConduitAdapter_MulticastOnChannel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MulticastOnChannel'
type ConduitAdapter_MulticastOnChannel_Call struct {
	*mock.Call
}

// MulticastOnChannel is a helper method to define mock.On call
//   - channel channels.Channel
//   - ifaceVal interface{}
//   - v uint
//   - identifiers ...flow.Identifier
func (_e *ConduitAdapter_Expecter) MulticastOnChannel(channel interface{}, ifaceVal interface{}, v interface{}, identifiers ...interface{}) *ConduitAdapter_MulticastOnChannel_Call {
	return &ConduitAdapter_MulticastOnChannel_Call{Call: _e.mock.On("MulticastOnChannel",
		append([]interface{}{channel, ifaceVal, v}, identifiers...)...)}
}

func (_c *ConduitAdapter_MulticastOnChannel_Call) Run(run func(channel channels.Channel, ifaceVal interface{}, v uint, identifiers ...flow.Identifier)) *ConduitAdapter_MulticastOnChannel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 channels.Channel
		if args[0] != nil {
			arg0 = args[0].(channels.Channel)
		}
		var arg1 interface{}
		if args[1] != nil {
			arg1 = args[1].(interface{})
		}
		var arg2 uint
		if args[2] != nil {
			arg2 = args[2].(uint)
		}
		var arg3 []flow.Identifier
		variadicArgs := make([]flow.Identifier, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(flow.Identifier)
			}
		}
		arg3 = variadicArgs
		run(
			arg0,
			arg1,
			arg2,
			arg3...,
		)
	})
	return _c
}

func (_c *ConduitAdapter_MulticastOnChannel_Call) Return(err error) *ConduitAdapter_MulticastOnChannel_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ConduitAdapter_MulticastOnChannel_Call) RunAndReturn(run func(channel channels.Channel, ifaceVal interface{}, v uint, identifiers ...flow.Identifier) error) *ConduitAdapter_MulticastOnChannel_Call {
	_c.Call.Return(run)
	return _c
}

// PublishOnChannel provides a mock function for the type ConduitAdapter
func (_mock *ConduitAdapter) PublishOnChannel(channel channels.Channel, ifaceVal interface{}, identifiers ...flow.Identifier) error {
	// flow.Identifier
	_va := make([]interface{}, len(identifiers))
	for _i := range identifiers {
		_va[_i] = identifiers[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, channel, ifaceVal)
	_ca = append(_ca, _va...)
	ret := _mock.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PublishOnChannel")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(channels.Channel, interface{}, ...flow.Identifier) error); ok {
		r0 = returnFunc(channel, ifaceVal, identifiers...)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ConduitAdapter_PublishOnChannel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PublishOnChannel'
type ConduitAdapter_PublishOnChannel_Call struct {
	*mock.Call
}

// PublishOnChannel is a helper method to define mock.On call
//   - channel channels.Channel
//   - ifaceVal interface{}
//   - identifiers ...flow.Identifier
func (_e *ConduitAdapter_Expecter) PublishOnChannel(channel interface{}, ifaceVal interface{}, identifiers ...interface{}) *ConduitAdapter_PublishOnChannel_Call {
	return &ConduitAdapter_PublishOnChannel_Call{Call: _e.mock.On("PublishOnChannel",
		append([]interface{}{channel, ifaceVal}, identifiers...)...)}
}

func (_c *ConduitAdapter_PublishOnChannel_Call) Run(run func(channel channels.Channel, ifaceVal interface{}, identifiers ...flow.Identifier)) *ConduitAdapter_PublishOnChannel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 channels.Channel
		if args[0] != nil {
			arg0 = args[0].(channels.Channel)
		}
		var arg1 interface{}
		if args[1] != nil {
			arg1 = args[1].(interface{})
		}
		var arg2 []flow.Identifier
		variadicArgs := make([]flow.Identifier, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(flow.Identifier)
			}
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *ConduitAdapter_PublishOnChannel_Call) Return(err error) *ConduitAdapter_PublishOnChannel_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ConduitAdapter_PublishOnChannel_Call) RunAndReturn(run func(channel channels.Channel, ifaceVal interface{}, identifiers ...flow.Identifier) error) *ConduitAdapter_PublishOnChannel_Call {
	_c.Call.Return(run)
	return _c
}

// ReportMisbehaviorOnChannel provides a mock function for the type ConduitAdapter
func (_mock *ConduitAdapter) ReportMisbehaviorOnChannel(channel channels.Channel, report network.MisbehaviorReport) {
	_mock.Called(channel, report)
	return
}

// ConduitAdapter_ReportMisbehaviorOnChannel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReportMisbehaviorOnChannel'
type ConduitAdapter_ReportMisbehaviorOnChannel_Call struct {
	*mock.Call
}

// ReportMisbehaviorOnChannel is a helper method to define mock.On call
//   - channel channels.Channel
//   - report network.MisbehaviorReport
func (_e *ConduitAdapter_Expecter) ReportMisbehaviorOnChannel(channel interface{}, report interface{}) *ConduitAdapter_ReportMisbehaviorOnChannel_Call {
	return &ConduitAdapter_ReportMisbehaviorOnChannel_Call{Call: _e.mock.On("ReportMisbehaviorOnChannel", channel, report)}
}

func (_c *ConduitAdapter_ReportMisbehaviorOnChannel_Call) Run(run func(channel channels.Channel, report network.MisbehaviorReport)) *ConduitAdapter_ReportMisbehaviorOnChannel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 channels.Channel
		if args[0] != nil {
			arg0 = args[0].(channels.Channel)
		}
		var arg1 network.MisbehaviorReport
		if args[1] != nil {
			arg1 = args[1].(network.MisbehaviorReport)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ConduitAdapter_ReportMisbehaviorOnChannel_Call) Return() *ConduitAdapter_ReportMisbehaviorOnChannel_Call {
	_c.Call.Return()
	return _c
}

func (_c *ConduitAdapter_ReportMisbehaviorOnChannel_Call) RunAndReturn(run func(channel channels.Channel, report network.MisbehaviorReport)) *ConduitAdapter_ReportMisbehaviorOnChannel_Call {
	_c.Run(run)
	return _c
}

// UnRegisterChannel provides a mock function for the type ConduitAdapter
func (_mock *ConduitAdapter) UnRegisterChannel(channel channels.Channel) error {
	ret := _mock.Called(channel)

	if len(ret) == 0 {
		panic("no return value specified for UnRegisterChannel")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(channels.Channel) error); ok {
		r0 = returnFunc(channel)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ConduitAdapter_UnRegisterChannel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnRegisterChannel'
type ConduitAdapter_UnRegisterChannel_Call struct {
	*mock.Call
}

// UnRegisterChannel is a helper method to define mock.On call
//   - channel channels.Channel
func (_e *ConduitAdapter_Expecter) UnRegisterChannel(channel interface{}) *ConduitAdapter_UnRegisterChannel_Call {
	return &ConduitAdapter_UnRegisterChannel_Call{Call: _e.mock.On("UnRegisterChannel", channel)}
}

func (_c *ConduitAdapter_UnRegisterChannel_Call) Run(run func(channel channels.Channel)) *ConduitAdapter_UnRegisterChannel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 channels.Channel
		if args[0] != nil {
			arg0 = args[0].(channels.Channel)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ConduitAdapter_UnRegisterChannel_Call) Return(err error) *ConduitAdapter_UnRegisterChannel_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ConduitAdapter_UnRegisterChannel_Call) RunAndReturn(run func(channel channels.Channel) error) *ConduitAdapter_UnRegisterChannel_Call {
	_c.Call.Return(run)
	return _c
}

// UnicastOnChannel provides a mock function for the type ConduitAdapter
func (_mock *ConduitAdapter) UnicastOnChannel(channel channels.Channel, ifaceVal interface{}, identifier flow.Identifier) error {
	ret := _mock.Called(channel, ifaceVal, identifier)

	if len(ret) == 0 {
		panic("no return value specified for UnicastOnChannel")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(channels.Channel, interface{}, flow.Identifier) error); ok {
		r0 = returnFunc(channel, ifaceVal, identifier)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ConduitAdapter_UnicastOnChannel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnicastOnChannel'
type ConduitAdapter_UnicastOnChannel_Call struct {
	*mock.Call
}

// UnicastOnChannel is a helper method to define mock.On call
//   - channel channels.Channel
//   - ifaceVal interface{}
//   - identifier flow.Identifier
func (_e *ConduitAdapter_Expecter) UnicastOnChannel(channel interface{}, ifaceVal interface{}, identifier interface{}) *ConduitAdapter_UnicastOnChannel_Call {
	return &ConduitAdapter_UnicastOnChannel_Call{Call: _e.mock.On("UnicastOnChannel", channel, ifaceVal, identifier)}
}

func (_c *ConduitAdapter_UnicastOnChannel_Call) Run(run func(channel channels.Channel, ifaceVal interface{}, identifier flow.Identifier)) *ConduitAdapter_UnicastOnChannel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 channels.Channel
		if args[0] != nil {
			arg0 = args[0].(channels.Channel)
		}
		var arg1 interface{}
		if args[1] != nil {
			arg1 = args[1].(interface{})
		}
		var arg2 flow.Identifier
		if args[2] != nil {
			arg2 = args[2].(flow.Identifier)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *ConduitAdapter_UnicastOnChannel_Call) Return(err error) *ConduitAdapter_UnicastOnChannel_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ConduitAdapter_UnicastOnChannel_Call) RunAndReturn(run func(channel channels.Channel, ifaceVal interface{}, identifier flow.Identifier) error) *ConduitAdapter_UnicastOnChannel_Call {
	_c.Call.Return(run)
	return _c
}

// NewUnderlay creates a new instance of Underlay. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewUnderlay(t interface {
	mock.TestingT
	Cleanup(func())
}) *Underlay {
	mock := &Underlay{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Underlay is an autogenerated mock type for the Underlay type
type Underlay struct {
	mock.Mock
}

type Underlay_Expecter struct {
	mock *mock.Mock
}

func (_m *Underlay) EXPECT() *Underlay_Expecter {
	return &Underlay_Expecter{mock: &_m.Mock}
}

// Done provides a mock function for the type Underlay
func (_mock *Underlay) Done() <-chan struct{} {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Done")
	}

	var r0 <-chan struct{}
	if returnFunc, ok := ret.Get(0).(func() <-chan struct{}); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan struct{})
		}
	}
	return r0
}

// Underlay_Done_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Done'
type Underlay_Done_Call struct {
	*mock.Call
}

// Done is a helper method to define mock.On call
func (_e *Underlay_Expecter) Done() *Underlay_Done_Call {
	return &Underlay_Done_Call{Call: _e.mock.On("Done")}
}

func (_c *Underlay_Done_Call) Run(run func()) *Underlay_Done_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Underlay_Done_Call) Return(valCh <-chan struct{}) *Underlay_Done_Call {
	_c.Call.Return(valCh)
	return _c
}

func (_c *Underlay_Done_Call) RunAndReturn(run func() <-chan struct{}) *Underlay_Done_Call {
	_c.Call.Return(run)
	return _c
}

// OnAllowListNotification provides a mock function for the type Underlay
func (_mock *Underlay) OnAllowListNotification(allowListingUpdate *network.AllowListingUpdate) {
	_mock.Called(allowListingUpdate)
	return
}

// Underlay_OnAllowListNotification_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnAllowListNotification'
type Underlay_OnAllowListNotification_Call struct {
	*mock.Call
}

// OnAllowListNotification is a helper method to define mock.On call
//   - allowListingUpdate *network.AllowListingUpdate
func (_e *Underlay_Expecter) OnAllowListNotification(allowListingUpdate interface{}) *Underlay_OnAllowListNotification_Call {
	return &Underlay_OnAllowListNotification_Call{Call: _e.mock.On("OnAllowListNotification", allowListingUpdate)}
}

func (_c *Underlay_OnAllowListNotification_Call) Run(run func(allowListingUpdate *network.AllowListingUpdate)) *Underlay_OnAllowListNotification_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *network.AllowListingUpdate
		if args[0] != nil {
			arg0 = args[0].(*network.AllowListingUpdate)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Underlay_OnAllowListNotification_Call) Return() *Underlay_OnAllowListNotification_Call {
	_c.Call.Return()
	return _c
}

func (_c *Underlay_OnAllowListNotification_Call) RunAndReturn(run func(allowListingUpdate *network.AllowListingUpdate)) *Underlay_OnAllowListNotification_Call {
	_c.Run(run)
	return _c
}

// OnDisallowListNotification provides a mock function for the type Underlay
func (_mock *Underlay) OnDisallowListNotification(disallowListingUpdate *network.DisallowListingUpdate) {
	_mock.Called(disallowListingUpdate)
	return
}

// Underlay_OnDisallowListNotification_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnDisallowListNotification'
type Underlay_OnDisallowListNotification_Call struct {
	*mock.Call
}

// OnDisallowListNotification is a helper method to define mock.On call
//   - disallowListingUpdate *network.DisallowListingUpdate
func (_e *Underlay_Expecter) OnDisallowListNotification(disallowListingUpdate interface{}) *Underlay_OnDisallowListNotification_Call {
	return &Underlay_OnDisallowListNotification_Call{Call: _e.mock.On("OnDisallowListNotification", disallowListingUpdate)}
}

func (_c *Underlay_OnDisallowListNotification_Call) Run(run func(disallowListingUpdate *network.DisallowListingUpdate)) *Underlay_OnDisallowListNotification_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *network.DisallowListingUpdate
		if args[0] != nil {
			arg0 = args[0].(*network.DisallowListingUpdate)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Underlay_OnDisallowListNotification_Call) Return() *Underlay_OnDisallowListNotification_Call {
	_c.Call.Return()
	return _c
}

func (_c *Underlay_OnDisallowListNotification_Call) RunAndReturn(run func(disallowListingUpdate *network.DisallowListingUpdate)) *Underlay_OnDisallowListNotification_Call {
	_c.Run(run)
	return _c
}

// Ready provides a mock function for the type Underlay
func (_mock *Underlay) Ready() <-chan struct{} {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Ready")
	}

	var r0 <-chan struct{}
	if returnFunc, ok := ret.Get(0).(func() <-chan struct{}); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan struct{})
		}
	}
	return r0
}

// Underlay_Ready_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Ready'
type Underlay_Ready_Call struct {
	*mock.Call
}

// Ready is a helper method to define mock.On call
func (_e *Underlay_Expecter) Ready() *Underlay_Ready_Call {
	return &Underlay_Ready_Call{Call: _e.mock.On("Ready")}
}

func (_c *Underlay_Ready_Call) Run(run func()) *Underlay_Ready_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Underlay_Ready_Call) Return(valCh <-chan struct{}) *Underlay_Ready_Call {
	_c.Call.Return(valCh)
	return _c
}

func (_c *Underlay_Ready_Call) RunAndReturn(run func() <-chan struct{}) *Underlay_Ready_Call {
	_c.Call.Return(run)
	return _c
}

// Subscribe provides a mock function for the type Underlay
func (_mock *Underlay) Subscribe(channel channels.Channel) error {
	ret := _mock.Called(channel)

	if len(ret) == 0 {
		panic("no return value specified for Subscribe")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(channels.Channel) error); ok {
		r0 = returnFunc(channel)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Underlay_Subscribe_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Subscribe'
type Underlay_Subscribe_Call struct {
	*mock.Call
}

// Subscribe is a helper method to define mock.On call
//   - channel channels.Channel
func (_e *Underlay_Expecter) Subscribe(channel interface{}) *Underlay_Subscribe_Call {
	return &Underlay_Subscribe_Call{Call: _e.mock.On("Subscribe", channel)}
}

func (_c *Underlay_Subscribe_Call) Run(run func(channel channels.Channel)) *Underlay_Subscribe_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 channels.Channel
		if args[0] != nil {
			arg0 = args[0].(channels.Channel)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Underlay_Subscribe_Call) Return(err error) *Underlay_Subscribe_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Underlay_Subscribe_Call) RunAndReturn(run func(channel channels.Channel) error) *Underlay_Subscribe_Call {
	_c.Call.Return(run)
	return _c
}

// Unsubscribe provides a mock function for the type Underlay
func (_mock *Underlay) Unsubscribe(channel channels.Channel) error {
	ret := _mock.Called(channel)

	if len(ret) == 0 {
		panic("no return value specified for Unsubscribe")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(channels.Channel) error); ok {
		r0 = returnFunc(channel)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Underlay_Unsubscribe_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Unsubscribe'
type Underlay_Unsubscribe_Call struct {
	*mock.Call
}

// Unsubscribe is a helper method to define mock.On call
//   - channel channels.Channel
func (_e *Underlay_Expecter) Unsubscribe(channel interface{}) *Underlay_Unsubscribe_Call {
	return &Underlay_Unsubscribe_Call{Call: _e.mock.On("Unsubscribe", channel)}
}

func (_c *Underlay_Unsubscribe_Call) Run(run func(channel channels.Channel)) *Underlay_Unsubscribe_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 channels.Channel
		if args[0] != nil {
			arg0 = args[0].(channels.Channel)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Underlay_Unsubscribe_Call) Return(err error) *Underlay_Unsubscribe_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Underlay_Unsubscribe_Call) RunAndReturn(run func(channel channels.Channel) error) *Underlay_Unsubscribe_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateNodeAddresses provides a mock function for the type Underlay
func (_mock *Underlay) UpdateNodeAddresses() {
	_mock.Called()
	return
}

// Underlay_UpdateNodeAddresses_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateNodeAddresses'
type Underlay_UpdateNodeAddresses_Call struct {
	*mock.Call
}

// UpdateNodeAddresses is a helper method to define mock.On call
func (_e *Underlay_Expecter) UpdateNodeAddresses() *Underlay_UpdateNodeAddresses_Call {
	return &Underlay_UpdateNodeAddresses_Call{Call: _e.mock.On("UpdateNodeAddresses")}
}

func (_c *Underlay_UpdateNodeAddresses_Call) Run(run func()) *Underlay_UpdateNodeAddresses_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Underlay_UpdateNodeAddresses_Call) Return() *Underlay_UpdateNodeAddresses_Call {
	_c.Call.Return()
	return _c
}

func (_c *Underlay_UpdateNodeAddresses_Call) RunAndReturn(run func()) *Underlay_UpdateNodeAddresses_Call {
	_c.Run(run)
	return _c
}

// NewConnection creates a new instance of Connection. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewConnection(t interface {
	mock.TestingT
	Cleanup(func())
}) *Connection {
	mock := &Connection{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Connection is an autogenerated mock type for the Connection type
type Connection struct {
	mock.Mock
}

type Connection_Expecter struct {
	mock *mock.Mock
}

func (_m *Connection) EXPECT() *Connection_Expecter {
	return &Connection_Expecter{mock: &_m.Mock}
}

// Receive provides a mock function for the type Connection
func (_mock *Connection) Receive() (interface{}, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Receive")
	}

	var r0 interface{}
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (interface{}, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() interface{}); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Connection_Receive_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Receive'
type Connection_Receive_Call struct {
	*mock.Call
}

// Receive is a helper method to define mock.On call
func (_e *Connection_Expecter) Receive() *Connection_Receive_Call {
	return &Connection_Receive_Call{Call: _e.mock.On("Receive")}
}

func (_c *Connection_Receive_Call) Run(run func()) *Connection_Receive_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Connection_Receive_Call) Return(ifaceVal interface{}, err error) *Connection_Receive_Call {
	_c.Call.Return(ifaceVal, err)
	return _c
}

func (_c *Connection_Receive_Call) RunAndReturn(run func() (interface{}, error)) *Connection_Receive_Call {
	_c.Call.Return(run)
	return _c
}

// Send provides a mock function for the type Connection
func (_mock *Connection) Send(msg interface{}) error {
	ret := _mock.Called(msg)

	if len(ret) == 0 {
		panic("no return value specified for Send")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(interface{}) error); ok {
		r0 = returnFunc(msg)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Connection_Send_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Send'
type Connection_Send_Call struct {
	*mock.Call
}

// Send is a helper method to define mock.On call
//   - msg interface{}
func (_e *Connection_Expecter) Send(msg interface{}) *Connection_Send_Call {
	return &Connection_Send_Call{Call: _e.mock.On("Send", msg)}
}

func (_c *Connection_Send_Call) Run(run func(msg interface{})) *Connection_Send_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 interface{}
		if args[0] != nil {
			arg0 = args[0].(interface{})
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Connection_Send_Call) Return(err error) *Connection_Send_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Connection_Send_Call) RunAndReturn(run func(msg interface{}) error) *Connection_Send_Call {
	_c.Call.Return(run)
	return _c
}

// NewMisbehaviorReportConsumer creates a new instance of MisbehaviorReportConsumer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMisbehaviorReportConsumer(t interface {
	mock.TestingT
	Cleanup(func())
}) *MisbehaviorReportConsumer {
	mock := &MisbehaviorReportConsumer{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MisbehaviorReportConsumer is an autogenerated mock type for the MisbehaviorReportConsumer type
type MisbehaviorReportConsumer struct {
	mock.Mock
}

type MisbehaviorReportConsumer_Expecter struct {
	mock *mock.Mock
}

func (_m *MisbehaviorReportConsumer) EXPECT() *MisbehaviorReportConsumer_Expecter {
	return &MisbehaviorReportConsumer_Expecter{mock: &_m.Mock}
}

// ReportMisbehaviorOnChannel provides a mock function for the type MisbehaviorReportConsumer
func (_mock *MisbehaviorReportConsumer) ReportMisbehaviorOnChannel(channel channels.Channel, report network.MisbehaviorReport) {
	_mock.Called(channel, report)
	return
}

// MisbehaviorReportConsumer_ReportMisbehaviorOnChannel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReportMisbehaviorOnChannel'
type MisbehaviorReportConsumer_ReportMisbehaviorOnChannel_Call struct {
	*mock.Call
}

// ReportMisbehaviorOnChannel is a helper method to define mock.On call
//   - channel channels.Channel
//   - report network.MisbehaviorReport
func (_e *MisbehaviorReportConsumer_Expecter) ReportMisbehaviorOnChannel(channel interface{}, report interface{}) *MisbehaviorReportConsumer_ReportMisbehaviorOnChannel_Call {
	return &MisbehaviorReportConsumer_ReportMisbehaviorOnChannel_Call{Call: _e.mock.On("ReportMisbehaviorOnChannel", channel, report)}
}

func (_c *MisbehaviorReportConsumer_ReportMisbehaviorOnChannel_Call) Run(run func(channel channels.Channel, report network.MisbehaviorReport)) *MisbehaviorReportConsumer_ReportMisbehaviorOnChannel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 channels.Channel
		if args[0] != nil {
			arg0 = args[0].(channels.Channel)
		}
		var arg1 network.MisbehaviorReport
		if args[1] != nil {
			arg1 = args[1].(network.MisbehaviorReport)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MisbehaviorReportConsumer_ReportMisbehaviorOnChannel_Call) Return() *MisbehaviorReportConsumer_ReportMisbehaviorOnChannel_Call {
	_c.Call.Return()
	return _c
}

func (_c *MisbehaviorReportConsumer_ReportMisbehaviorOnChannel_Call) RunAndReturn(run func(channel channels.Channel, report network.MisbehaviorReport)) *MisbehaviorReportConsumer_ReportMisbehaviorOnChannel_Call {
	_c.Run(run)
	return _c
}

// NewPingInfoProvider creates a new instance of PingInfoProvider. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewPingInfoProvider(t interface {
	mock.TestingT
	Cleanup(func())
}) *PingInfoProvider {
	mock := &PingInfoProvider{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// PingInfoProvider is an autogenerated mock type for the PingInfoProvider type
type PingInfoProvider struct {
	mock.Mock
}

type PingInfoProvider_Expecter struct {
	mock *mock.Mock
}

func (_m *PingInfoProvider) EXPECT() *PingInfoProvider_Expecter {
	return &PingInfoProvider_Expecter{mock: &_m.Mock}
}

// HotstuffView provides a mock function for the type PingInfoProvider
func (_mock *PingInfoProvider) HotstuffView() uint64 {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for HotstuffView")
	}

	var r0 uint64
	if returnFunc, ok := ret.Get(0).(func() uint64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint64)
	}
	return r0
}

// PingInfoProvider_HotstuffView_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HotstuffView'
type PingInfoProvider_HotstuffView_Call struct {
	*mock.Call
}

// HotstuffView is a helper method to define mock.On call
func (_e *PingInfoProvider_Expecter) HotstuffView() *PingInfoProvider_HotstuffView_Call {
	return &PingInfoProvider_HotstuffView_Call{Call: _e.mock.On("HotstuffView")}
}

func (_c *PingInfoProvider_HotstuffView_Call) Run(run func()) *PingInfoProvider_HotstuffView_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *PingInfoProvider_HotstuffView_Call) Return(v uint64) *PingInfoProvider_HotstuffView_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *PingInfoProvider_HotstuffView_Call) RunAndReturn(run func() uint64) *PingInfoProvider_HotstuffView_Call {
	_c.Call.Return(run)
	return _c
}

// SealedBlockHeight provides a mock function for the type PingInfoProvider
func (_mock *PingInfoProvider) SealedBlockHeight() uint64 {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for SealedBlockHeight")
	}

	var r0 uint64
	if returnFunc, ok := ret.Get(0).(func() uint64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint64)
	}
	return r0
}

// PingInfoProvider_SealedBlockHeight_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SealedBlockHeight'
type PingInfoProvider_SealedBlockHeight_Call struct {
	*mock.Call
}

// SealedBlockHeight is a helper method to define mock.On call
func (_e *PingInfoProvider_Expecter) SealedBlockHeight() *PingInfoProvider_SealedBlockHeight_Call {
	return &PingInfoProvider_SealedBlockHeight_Call{Call: _e.mock.On("SealedBlockHeight")}
}

func (_c *PingInfoProvider_SealedBlockHeight_Call) Run(run func()) *PingInfoProvider_SealedBlockHeight_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *PingInfoProvider_SealedBlockHeight_Call) Return(v uint64) *PingInfoProvider_SealedBlockHeight_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *PingInfoProvider_SealedBlockHeight_Call) RunAndReturn(run func() uint64) *PingInfoProvider_SealedBlockHeight_Call {
	_c.Call.Return(run)
	return _c
}

// SoftwareVersion provides a mock function for the type PingInfoProvider
func (_mock *PingInfoProvider) SoftwareVersion() string {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for SoftwareVersion")
	}

	var r0 string
	if returnFunc, ok := ret.Get(0).(func() string); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(string)
	}
	return r0
}

// PingInfoProvider_SoftwareVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SoftwareVersion'
type PingInfoProvider_SoftwareVersion_Call struct {
	*mock.Call
}

// SoftwareVersion is a helper method to define mock.On call
func (_e *PingInfoProvider_Expecter) SoftwareVersion() *PingInfoProvider_SoftwareVersion_Call {
	return &PingInfoProvider_SoftwareVersion_Call{Call: _e.mock.On("SoftwareVersion")}
}

func (_c *PingInfoProvider_SoftwareVersion_Call) Run(run func()) *PingInfoProvider_SoftwareVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *PingInfoProvider_SoftwareVersion_Call) Return(s string) *PingInfoProvider_SoftwareVersion_Call {
	_c.Call.Return(s)
	return _c
}

func (_c *PingInfoProvider_SoftwareVersion_Call) RunAndReturn(run func() string) *PingInfoProvider_SoftwareVersion_Call {
	_c.Call.Return(run)
	return _c
}

// NewPingService creates a new instance of PingService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewPingService(t interface {
	mock.TestingT
	Cleanup(func())
}) *PingService {
	mock := &PingService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// PingService is an autogenerated mock type for the PingService type
type PingService struct {
	mock.Mock
}

type PingService_Expecter struct {
	mock *mock.Mock
}

func (_m *PingService) EXPECT() *PingService_Expecter {
	return &PingService_Expecter{mock: &_m.Mock}
}

// Ping provides a mock function for the type PingService
func (_mock *PingService) Ping(ctx context.Context, peerID peer.ID) (message.PingResponse, time.Duration, error) {
	ret := _mock.Called(ctx, peerID)

	if len(ret) == 0 {
		panic("no return value specified for Ping")
	}

	var r0 message.PingResponse
	var r1 time.Duration
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, peer.ID) (message.PingResponse, time.Duration, error)); ok {
		return returnFunc(ctx, peerID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, peer.ID) message.PingResponse); ok {
		r0 = returnFunc(ctx, peerID)
	} else {
		r0 = ret.Get(0).(message.PingResponse)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, peer.ID) time.Duration); ok {
		r1 = returnFunc(ctx, peerID)
	} else {
		r1 = ret.Get(1).(time.Duration)
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, peer.ID) error); ok {
		r2 = returnFunc(ctx, peerID)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// PingService_Ping_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Ping'
type PingService_Ping_Call struct {
	*mock.Call
}

// Ping is a helper method to define mock.On call
//   - ctx context.Context
//   - peerID peer.ID
func (_e *PingService_Expecter) Ping(ctx interface{}, peerID interface{}) *PingService_Ping_Call {
	return &PingService_Ping_Call{Call: _e.mock.On("Ping", ctx, peerID)}
}

func (_c *PingService_Ping_Call) Run(run func(ctx context.Context, peerID peer.ID)) *PingService_Ping_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 peer.ID
		if args[1] != nil {
			arg1 = args[1].(peer.ID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *PingService_Ping_Call) Return(pingResponse message.PingResponse, duration time.Duration, err error) *PingService_Ping_Call {
	_c.Call.Return(pingResponse, duration, err)
	return _c
}

func (_c *PingService_Ping_Call) RunAndReturn(run func(ctx context.Context, peerID peer.ID) (message.PingResponse, time.Duration, error)) *PingService_Ping_Call {
	_c.Call.Return(run)
	return _c
}

// NewMessageQueue creates a new instance of MessageQueue. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMessageQueue(t interface {
	mock.TestingT
	Cleanup(func())
}) *MessageQueue {
	mock := &MessageQueue{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MessageQueue is an autogenerated mock type for the MessageQueue type
type MessageQueue struct {
	mock.Mock
}

type MessageQueue_Expecter struct {
	mock *mock.Mock
}

func (_m *MessageQueue) EXPECT() *MessageQueue_Expecter {
	return &MessageQueue_Expecter{mock: &_m.Mock}
}

// Insert provides a mock function for the type MessageQueue
func (_mock *MessageQueue) Insert(message1 interface{}) error {
	ret := _mock.Called(message1)

	if len(ret) == 0 {
		panic("no return value specified for Insert")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(interface{}) error); ok {
		r0 = returnFunc(message1)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MessageQueue_Insert_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Insert'
type MessageQueue_Insert_Call struct {
	*mock.Call
}

// Insert is a helper method to define mock.On call
//   - message1 interface{}
func (_e *MessageQueue_Expecter) Insert(message1 interface{}) *MessageQueue_Insert_Call {
	return &MessageQueue_Insert_Call{Call: _e.mock.On("Insert", message1)}
}

func (_c *MessageQueue_Insert_Call) Run(run func(message1 interface{})) *MessageQueue_Insert_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 interface{}
		if args[0] != nil {
			arg0 = args[0].(interface{})
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MessageQueue_Insert_Call) Return(err error) *MessageQueue_Insert_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MessageQueue_Insert_Call) RunAndReturn(run func(message1 interface{}) error) *MessageQueue_Insert_Call {
	_c.Call.Return(run)
	return _c
}

// Len provides a mock function for the type MessageQueue
func (_mock *MessageQueue) Len() int {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Len")
	}

	var r0 int
	if returnFunc, ok := ret.Get(0).(func() int); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(int)
	}
	return r0
}

// MessageQueue_Len_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Len'
type MessageQueue_Len_Call struct {
	*mock.Call
}

// Len is a helper method to define mock.On call
func (_e *MessageQueue_Expecter) Len() *MessageQueue_Len_Call {
	return &MessageQueue_Len_Call{Call: _e.mock.On("Len")}
}

func (_c *MessageQueue_Len_Call) Run(run func()) *MessageQueue_Len_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MessageQueue_Len_Call) Return(n int) *MessageQueue_Len_Call {
	_c.Call.Return(n)
	return _c
}

func (_c *MessageQueue_Len_Call) RunAndReturn(run func() int) *MessageQueue_Len_Call {
	_c.Call.Return(run)
	return _c
}

// Remove provides a mock function for the type MessageQueue
func (_mock *MessageQueue) Remove() interface{} {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Remove")
	}

	var r0 interface{}
	if returnFunc, ok := ret.Get(0).(func() interface{}); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}
	return r0
}

// MessageQueue_Remove_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Remove'
type MessageQueue_Remove_Call struct {
	*mock.Call
}

// Remove is a helper method to define mock.On call
func (_e *MessageQueue_Expecter) Remove() *MessageQueue_Remove_Call {
	return &MessageQueue_Remove_Call{Call: _e.mock.On("Remove")}
}

func (_c *MessageQueue_Remove_Call) Run(run func()) *MessageQueue_Remove_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MessageQueue_Remove_Call) Return(ifaceVal interface{}) *MessageQueue_Remove_Call {
	_c.Call.Return(ifaceVal)
	return _c
}

func (_c *MessageQueue_Remove_Call) RunAndReturn(run func() interface{}) *MessageQueue_Remove_Call {
	_c.Call.Return(run)
	return _c
}

// NewBasicResolver creates a new instance of BasicResolver. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewBasicResolver(t interface {
	mock.TestingT
	Cleanup(func())
}) *BasicResolver {
	mock := &BasicResolver{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// BasicResolver is an autogenerated mock type for the BasicResolver type
type BasicResolver struct {
	mock.Mock
}

type BasicResolver_Expecter struct {
	mock *mock.Mock
}

func (_m *BasicResolver) EXPECT() *BasicResolver_Expecter {
	return &BasicResolver_Expecter{mock: &_m.Mock}
}

// LookupIPAddr provides a mock function for the type BasicResolver
func (_mock *BasicResolver) LookupIPAddr(context1 context.Context, s string) ([]net.IPAddr, error) {
	ret := _mock.Called(context1, s)

	if len(ret) == 0 {
		panic("no return value specified for LookupIPAddr")
	}

	var r0 []net.IPAddr
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) ([]net.IPAddr, error)); ok {
		return returnFunc(context1, s)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) []net.IPAddr); ok {
		r0 = returnFunc(context1, s)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]net.IPAddr)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(context1, s)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// BasicResolver_LookupIPAddr_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LookupIPAddr'
type BasicResolver_LookupIPAddr_Call struct {
	*mock.Call
}

// LookupIPAddr is a helper method to define mock.On call
//   - context1 context.Context
//   - s string
func (_e *BasicResolver_Expecter) LookupIPAddr(context1 interface{}, s interface{}) *BasicResolver_LookupIPAddr_Call {
	return &BasicResolver_LookupIPAddr_Call{Call: _e.mock.On("LookupIPAddr", context1, s)}
}

func (_c *BasicResolver_LookupIPAddr_Call) Run(run func(context1 context.Context, s string)) *BasicResolver_LookupIPAddr_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *BasicResolver_LookupIPAddr_Call) Return(iPAddrs []net.IPAddr, err error) *BasicResolver_LookupIPAddr_Call {
	_c.Call.Return(iPAddrs, err)
	return _c
}

func (_c *BasicResolver_LookupIPAddr_Call) RunAndReturn(run func(context1 context.Context, s string) ([]net.IPAddr, error)) *BasicResolver_LookupIPAddr_Call {
	_c.Call.Return(run)
	return _c
}

// LookupTXT provides a mock function for the type BasicResolver
func (_mock *BasicResolver) LookupTXT(context1 context.Context, s string) ([]string, error) {
	ret := _mock.Called(context1, s)

	if len(ret) == 0 {
		panic("no return value specified for LookupTXT")
	}

	var r0 []string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) ([]string, error)); ok {
		return returnFunc(context1, s)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) []string); ok {
		r0 = returnFunc(context1, s)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(context1, s)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// BasicResolver_LookupTXT_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LookupTXT'
type BasicResolver_LookupTXT_Call struct {
	*mock.Call
}

// LookupTXT is a helper method to define mock.On call
//   - context1 context.Context
//   - s string
func (_e *BasicResolver_Expecter) LookupTXT(context1 interface{}, s interface{}) *BasicResolver_LookupTXT_Call {
	return &BasicResolver_LookupTXT_Call{Call: _e.mock.On("LookupTXT", context1, s)}
}

func (_c *BasicResolver_LookupTXT_Call) Run(run func(context1 context.Context, s string)) *BasicResolver_LookupTXT_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *BasicResolver_LookupTXT_Call) Return(strings []string, err error) *BasicResolver_LookupTXT_Call {
	_c.Call.Return(strings, err)
	return _c
}

func (_c *BasicResolver_LookupTXT_Call) RunAndReturn(run func(context1 context.Context, s string) ([]string, error)) *BasicResolver_LookupTXT_Call {
	_c.Call.Return(run)
	return _c
}

// NewSubscriptionManager creates a new instance of SubscriptionManager. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewSubscriptionManager(t interface {
	mock.TestingT
	Cleanup(func())
}) *SubscriptionManager {
	mock := &SubscriptionManager{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// SubscriptionManager is an autogenerated mock type for the SubscriptionManager type
type SubscriptionManager struct {
	mock.Mock
}

type SubscriptionManager_Expecter struct {
	mock *mock.Mock
}

func (_m *SubscriptionManager) EXPECT() *SubscriptionManager_Expecter {
	return &SubscriptionManager_Expecter{mock: &_m.Mock}
}

// Channels provides a mock function for the type SubscriptionManager
func (_mock *SubscriptionManager) Channels() channels.ChannelList {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Channels")
	}

	var r0 channels.ChannelList
	if returnFunc, ok := ret.Get(0).(func() channels.ChannelList); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(channels.ChannelList)
		}
	}
	return r0
}

// SubscriptionManager_Channels_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Channels'
type SubscriptionManager_Channels_Call struct {
	*mock.Call
}

// Channels is a helper method to define mock.On call
func (_e *SubscriptionManager_Expecter) Channels() *SubscriptionManager_Channels_Call {
	return &SubscriptionManager_Channels_Call{Call: _e.mock.On("Channels")}
}

func (_c *SubscriptionManager_Channels_Call) Run(run func()) *SubscriptionManager_Channels_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *SubscriptionManager_Channels_Call) Return(channelList channels.ChannelList) *SubscriptionManager_Channels_Call {
	_c.Call.Return(channelList)
	return _c
}

func (_c *SubscriptionManager_Channels_Call) RunAndReturn(run func() channels.ChannelList) *SubscriptionManager_Channels_Call {
	_c.Call.Return(run)
	return _c
}

// GetEngine provides a mock function for the type SubscriptionManager
func (_mock *SubscriptionManager) GetEngine(channel channels.Channel) (network.MessageProcessor, error) {
	ret := _mock.Called(channel)

	if len(ret) == 0 {
		panic("no return value specified for GetEngine")
	}

	var r0 network.MessageProcessor
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(channels.Channel) (network.MessageProcessor, error)); ok {
		return returnFunc(channel)
	}
	if returnFunc, ok := ret.Get(0).(func(channels.Channel) network.MessageProcessor); ok {
		r0 = returnFunc(channel)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(network.MessageProcessor)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(channels.Channel) error); ok {
		r1 = returnFunc(channel)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// SubscriptionManager_GetEngine_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEngine'
type SubscriptionManager_GetEngine_Call struct {
	*mock.Call
}

// GetEngine is a helper method to define mock.On call
//   - channel channels.Channel
func (_e *SubscriptionManager_Expecter) GetEngine(channel interface{}) *SubscriptionManager_GetEngine_Call {
	return &SubscriptionManager_GetEngine_Call{Call: _e.mock.On("GetEngine", channel)}
}

func (_c *SubscriptionManager_GetEngine_Call) Run(run func(channel channels.Channel)) *SubscriptionManager_GetEngine_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 channels.Channel
		if args[0] != nil {
			arg0 = args[0].(channels.Channel)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *SubscriptionManager_GetEngine_Call) Return(messageProcessor network.MessageProcessor, err error) *SubscriptionManager_GetEngine_Call {
	_c.Call.Return(messageProcessor, err)
	return _c
}

func (_c *SubscriptionManager_GetEngine_Call) RunAndReturn(run func(channel channels.Channel) (network.MessageProcessor, error)) *SubscriptionManager_GetEngine_Call {
	_c.Call.Return(run)
	return _c
}

// Register provides a mock function for the type SubscriptionManager
func (_mock *SubscriptionManager) Register(channel channels.Channel, engine network.MessageProcessor) error {
	ret := _mock.Called(channel, engine)

	if len(ret) == 0 {
		panic("no return value specified for Register")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(channels.Channel, network.MessageProcessor) error); ok {
		r0 = returnFunc(channel, engine)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// SubscriptionManager_Register_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Register'
type SubscriptionManager_Register_Call struct {
	*mock.Call
}

// Register is a helper method to define mock.On call
//   - channel channels.Channel
//   - engine network.MessageProcessor
func (_e *SubscriptionManager_Expecter) Register(channel interface{}, engine interface{}) *SubscriptionManager_Register_Call {
	return &SubscriptionManager_Register_Call{Call: _e.mock.On("Register", channel, engine)}
}

func (_c *SubscriptionManager_Register_Call) Run(run func(channel channels.Channel, engine network.MessageProcessor)) *SubscriptionManager_Register_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 channels.Channel
		if args[0] != nil {
			arg0 = args[0].(channels.Channel)
		}
		var arg1 network.MessageProcessor
		if args[1] != nil {
			arg1 = args[1].(network.MessageProcessor)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *SubscriptionManager_Register_Call) Return(err error) *SubscriptionManager_Register_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *SubscriptionManager_Register_Call) RunAndReturn(run func(channel channels.Channel, engine network.MessageProcessor) error) *SubscriptionManager_Register_Call {
	_c.Call.Return(run)
	return _c
}

// Unregister provides a mock function for the type SubscriptionManager
func (_mock *SubscriptionManager) Unregister(channel channels.Channel) error {
	ret := _mock.Called(channel)

	if len(ret) == 0 {
		panic("no return value specified for Unregister")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(channels.Channel) error); ok {
		r0 = returnFunc(channel)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// SubscriptionManager_Unregister_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Unregister'
type SubscriptionManager_Unregister_Call struct {
	*mock.Call
}

// Unregister is a helper method to define mock.On call
//   - channel channels.Channel
func (_e *SubscriptionManager_Expecter) Unregister(channel interface{}) *SubscriptionManager_Unregister_Call {
	return &SubscriptionManager_Unregister_Call{Call: _e.mock.On("Unregister", channel)}
}

func (_c *SubscriptionManager_Unregister_Call) Run(run func(channel channels.Channel)) *SubscriptionManager_Unregister_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 channels.Channel
		if args[0] != nil {
			arg0 = args[0].(channels.Channel)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *SubscriptionManager_Unregister_Call) Return(err error) *SubscriptionManager_Unregister_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *SubscriptionManager_Unregister_Call) RunAndReturn(run func(channel channels.Channel) error) *SubscriptionManager_Unregister_Call {
	_c.Call.Return(run)
	return _c
}

// NewTopology creates a new instance of Topology. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewTopology(t interface {
	mock.TestingT
	Cleanup(func())
}) *Topology {
	mock := &Topology{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Topology is an autogenerated mock type for the Topology type
type Topology struct {
	mock.Mock
}

type Topology_Expecter struct {
	mock *mock.Mock
}

func (_m *Topology) EXPECT() *Topology_Expecter {
	return &Topology_Expecter{mock: &_m.Mock}
}

// Fanout provides a mock function for the type Topology
func (_mock *Topology) Fanout(ids flow.IdentityList) flow.IdentityList {
	ret := _mock.Called(ids)

	if len(ret) == 0 {
		panic("no return value specified for Fanout")
	}

	var r0 flow.IdentityList
	if returnFunc, ok := ret.Get(0).(func(flow.IdentityList) flow.IdentityList); ok {
		r0 = returnFunc(ids)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.IdentityList)
		}
	}
	return r0
}

// Topology_Fanout_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Fanout'
type Topology_Fanout_Call struct {
	*mock.Call
}

// Fanout is a helper method to define mock.On call
//   - ids flow.IdentityList
func (_e *Topology_Expecter) Fanout(ids interface{}) *Topology_Fanout_Call {
	return &Topology_Fanout_Call{Call: _e.mock.On("Fanout", ids)}
}

func (_c *Topology_Fanout_Call) Run(run func(ids flow.IdentityList)) *Topology_Fanout_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.IdentityList
		if args[0] != nil {
			arg0 = args[0].(flow.IdentityList)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Topology_Fanout_Call) Return(v flow.IdentityList) *Topology_Fanout_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *Topology_Fanout_Call) RunAndReturn(run func(ids flow.IdentityList) flow.IdentityList) *Topology_Fanout_Call {
	_c.Call.Return(run)
	return _c
}

// NewMessageValidator creates a new instance of MessageValidator. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMessageValidator(t interface {
	mock.TestingT
	Cleanup(func())
}) *MessageValidator {
	mock := &MessageValidator{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MessageValidator is an autogenerated mock type for the MessageValidator type
type MessageValidator struct {
	mock.Mock
}

type MessageValidator_Expecter struct {
	mock *mock.Mock
}

func (_m *MessageValidator) EXPECT() *MessageValidator_Expecter {
	return &MessageValidator_Expecter{mock: &_m.Mock}
}

// Validate provides a mock function for the type MessageValidator
func (_mock *MessageValidator) Validate(msg network.IncomingMessageScope) bool {
	ret := _mock.Called(msg)

	if len(ret) == 0 {
		panic("no return value specified for Validate")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(network.IncomingMessageScope) bool); ok {
		r0 = returnFunc(msg)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// MessageValidator_Validate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Validate'
type MessageValidator_Validate_Call struct {
	*mock.Call
}

// Validate is a helper method to define mock.On call
//   - msg network.IncomingMessageScope
func (_e *MessageValidator_Expecter) Validate(msg interface{}) *MessageValidator_Validate_Call {
	return &MessageValidator_Validate_Call{Call: _e.mock.On("Validate", msg)}
}

func (_c *MessageValidator_Validate_Call) Run(run func(msg network.IncomingMessageScope)) *MessageValidator_Validate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 network.IncomingMessageScope
		if args[0] != nil {
			arg0 = args[0].(network.IncomingMessageScope)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MessageValidator_Validate_Call) Return(b bool) *MessageValidator_Validate_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *MessageValidator_Validate_Call) RunAndReturn(run func(msg network.IncomingMessageScope) bool) *MessageValidator_Validate_Call {
	_c.Call.Return(run)
	return _c
}

// NewViolationsConsumer creates a new instance of ViolationsConsumer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewViolationsConsumer(t interface {
	mock.TestingT
	Cleanup(func())
}) *ViolationsConsumer {
	mock := &ViolationsConsumer{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// ViolationsConsumer is an autogenerated mock type for the ViolationsConsumer type
type ViolationsConsumer struct {
	mock.Mock
}

type ViolationsConsumer_Expecter struct {
	mock *mock.Mock
}

func (_m *ViolationsConsumer) EXPECT() *ViolationsConsumer_Expecter {
	return &ViolationsConsumer_Expecter{mock: &_m.Mock}
}

// OnInvalidMsgError provides a mock function for the type ViolationsConsumer
func (_mock *ViolationsConsumer) OnInvalidMsgError(violation *network.Violation) {
	_mock.Called(violation)
	return
}

// ViolationsConsumer_OnInvalidMsgError_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnInvalidMsgError'
type ViolationsConsumer_OnInvalidMsgError_Call struct {
	*mock.Call
}

// OnInvalidMsgError is a helper method to define mock.On call
//   - violation *network.Violation
func (_e *ViolationsConsumer_Expecter) OnInvalidMsgError(violation interface{}) *ViolationsConsumer_OnInvalidMsgError_Call {
	return &ViolationsConsumer_OnInvalidMsgError_Call{Call: _e.mock.On("OnInvalidMsgError", violation)}
}

func (_c *ViolationsConsumer_OnInvalidMsgError_Call) Run(run func(violation *network.Violation)) *ViolationsConsumer_OnInvalidMsgError_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *network.Violation
		if args[0] != nil {
			arg0 = args[0].(*network.Violation)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ViolationsConsumer_OnInvalidMsgError_Call) Return() *ViolationsConsumer_OnInvalidMsgError_Call {
	_c.Call.Return()
	return _c
}

func (_c *ViolationsConsumer_OnInvalidMsgError_Call) RunAndReturn(run func(violation *network.Violation)) *ViolationsConsumer_OnInvalidMsgError_Call {
	_c.Run(run)
	return _c
}

// OnSenderEjectedError provides a mock function for the type ViolationsConsumer
func (_mock *ViolationsConsumer) OnSenderEjectedError(violation *network.Violation) {
	_mock.Called(violation)
	return
}

// ViolationsConsumer_OnSenderEjectedError_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnSenderEjectedError'
type ViolationsConsumer_OnSenderEjectedError_Call struct {
	*mock.Call
}

// OnSenderEjectedError is a helper method to define mock.On call
//   - violation *network.Violation
func (_e *ViolationsConsumer_Expecter) OnSenderEjectedError(violation interface{}) *ViolationsConsumer_OnSenderEjectedError_Call {
	return &ViolationsConsumer_OnSenderEjectedError_Call{Call: _e.mock.On("OnSenderEjectedError", violation)}
}

func (_c *ViolationsConsumer_OnSenderEjectedError_Call) Run(run func(violation *network.Violation)) *ViolationsConsumer_OnSenderEjectedError_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *network.Violation
		if args[0] != nil {
			arg0 = args[0].(*network.Violation)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ViolationsConsumer_OnSenderEjectedError_Call) Return() *ViolationsConsumer_OnSenderEjectedError_Call {
	_c.Call.Return()
	return _c
}

func (_c *ViolationsConsumer_OnSenderEjectedError_Call) RunAndReturn(run func(violation *network.Violation)) *ViolationsConsumer_OnSenderEjectedError_Call {
	_c.Run(run)
	return _c
}

// OnUnAuthorizedSenderError provides a mock function for the type ViolationsConsumer
func (_mock *ViolationsConsumer) OnUnAuthorizedSenderError(violation *network.Violation) {
	_mock.Called(violation)
	return
}

// ViolationsConsumer_OnUnAuthorizedSenderError_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnUnAuthorizedSenderError'
type ViolationsConsumer_OnUnAuthorizedSenderError_Call struct {
	*mock.Call
}

// OnUnAuthorizedSenderError is a helper method to define mock.On call
//   - violation *network.Violation
func (_e *ViolationsConsumer_Expecter) OnUnAuthorizedSenderError(violation interface{}) *ViolationsConsumer_OnUnAuthorizedSenderError_Call {
	return &ViolationsConsumer_OnUnAuthorizedSenderError_Call{Call: _e.mock.On("OnUnAuthorizedSenderError", violation)}
}

func (_c *ViolationsConsumer_OnUnAuthorizedSenderError_Call) Run(run func(violation *network.Violation)) *ViolationsConsumer_OnUnAuthorizedSenderError_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *network.Violation
		if args[0] != nil {
			arg0 = args[0].(*network.Violation)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ViolationsConsumer_OnUnAuthorizedSenderError_Call) Return() *ViolationsConsumer_OnUnAuthorizedSenderError_Call {
	_c.Call.Return()
	return _c
}

func (_c *ViolationsConsumer_OnUnAuthorizedSenderError_Call) RunAndReturn(run func(violation *network.Violation)) *ViolationsConsumer_OnUnAuthorizedSenderError_Call {
	_c.Run(run)
	return _c
}

// OnUnauthorizedPublishOnChannel provides a mock function for the type ViolationsConsumer
func (_mock *ViolationsConsumer) OnUnauthorizedPublishOnChannel(violation *network.Violation) {
	_mock.Called(violation)
	return
}

// ViolationsConsumer_OnUnauthorizedPublishOnChannel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnUnauthorizedPublishOnChannel'
type ViolationsConsumer_OnUnauthorizedPublishOnChannel_Call struct {
	*mock.Call
}

// OnUnauthorizedPublishOnChannel is a helper method to define mock.On call
//   - violation *network.Violation
func (_e *ViolationsConsumer_Expecter) OnUnauthorizedPublishOnChannel(violation interface{}) *ViolationsConsumer_OnUnauthorizedPublishOnChannel_Call {
	return &ViolationsConsumer_OnUnauthorizedPublishOnChannel_Call{Call: _e.mock.On("OnUnauthorizedPublishOnChannel", violation)}
}

func (_c *ViolationsConsumer_OnUnauthorizedPublishOnChannel_Call) Run(run func(violation *network.Violation)) *ViolationsConsumer_OnUnauthorizedPublishOnChannel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *network.Violation
		if args[0] != nil {
			arg0 = args[0].(*network.Violation)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ViolationsConsumer_OnUnauthorizedPublishOnChannel_Call) Return() *ViolationsConsumer_OnUnauthorizedPublishOnChannel_Call {
	_c.Call.Return()
	return _c
}

func (_c *ViolationsConsumer_OnUnauthorizedPublishOnChannel_Call) RunAndReturn(run func(violation *network.Violation)) *ViolationsConsumer_OnUnauthorizedPublishOnChannel_Call {
	_c.Run(run)
	return _c
}

// OnUnauthorizedUnicastOnChannel provides a mock function for the type ViolationsConsumer
func (_mock *ViolationsConsumer) OnUnauthorizedUnicastOnChannel(violation *network.Violation) {
	_mock.Called(violation)
	return
}

// ViolationsConsumer_OnUnauthorizedUnicastOnChannel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnUnauthorizedUnicastOnChannel'
type ViolationsConsumer_OnUnauthorizedUnicastOnChannel_Call struct {
	*mock.Call
}

// OnUnauthorizedUnicastOnChannel is a helper method to define mock.On call
//   - violation *network.Violation
func (_e *ViolationsConsumer_Expecter) OnUnauthorizedUnicastOnChannel(violation interface{}) *ViolationsConsumer_OnUnauthorizedUnicastOnChannel_Call {
	return &ViolationsConsumer_OnUnauthorizedUnicastOnChannel_Call{Call: _e.mock.On("OnUnauthorizedUnicastOnChannel", violation)}
}

func (_c *ViolationsConsumer_OnUnauthorizedUnicastOnChannel_Call) Run(run func(violation *network.Violation)) *ViolationsConsumer_OnUnauthorizedUnicastOnChannel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *network.Violation
		if args[0] != nil {
			arg0 = args[0].(*network.Violation)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ViolationsConsumer_OnUnauthorizedUnicastOnChannel_Call) Return() *ViolationsConsumer_OnUnauthorizedUnicastOnChannel_Call {
	_c.Call.Return()
	return _c
}

func (_c *ViolationsConsumer_OnUnauthorizedUnicastOnChannel_Call) RunAndReturn(run func(violation *network.Violation)) *ViolationsConsumer_OnUnauthorizedUnicastOnChannel_Call {
	_c.Run(run)
	return _c
}

// OnUnexpectedError provides a mock function for the type ViolationsConsumer
func (_mock *ViolationsConsumer) OnUnexpectedError(violation *network.Violation) {
	_mock.Called(violation)
	return
}

// ViolationsConsumer_OnUnexpectedError_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnUnexpectedError'
type ViolationsConsumer_OnUnexpectedError_Call struct {
	*mock.Call
}

// OnUnexpectedError is a helper method to define mock.On call
//   - violation *network.Violation
func (_e *ViolationsConsumer_Expecter) OnUnexpectedError(violation interface{}) *ViolationsConsumer_OnUnexpectedError_Call {
	return &ViolationsConsumer_OnUnexpectedError_Call{Call: _e.mock.On("OnUnexpectedError", violation)}
}

func (_c *ViolationsConsumer_OnUnexpectedError_Call) Run(run func(violation *network.Violation)) *ViolationsConsumer_OnUnexpectedError_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *network.Violation
		if args[0] != nil {
			arg0 = args[0].(*network.Violation)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ViolationsConsumer_OnUnexpectedError_Call) Return() *ViolationsConsumer_OnUnexpectedError_Call {
	_c.Call.Return()
	return _c
}

func (_c *ViolationsConsumer_OnUnexpectedError_Call) RunAndReturn(run func(violation *network.Violation)) *ViolationsConsumer_OnUnexpectedError_Call {
	_c.Run(run)
	return _c
}

// OnUnknownMsgTypeError provides a mock function for the type ViolationsConsumer
func (_mock *ViolationsConsumer) OnUnknownMsgTypeError(violation *network.Violation) {
	_mock.Called(violation)
	return
}

// ViolationsConsumer_OnUnknownMsgTypeError_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnUnknownMsgTypeError'
type ViolationsConsumer_OnUnknownMsgTypeError_Call struct {
	*mock.Call
}

// OnUnknownMsgTypeError is a helper method to define mock.On call
//   - violation *network.Violation
func (_e *ViolationsConsumer_Expecter) OnUnknownMsgTypeError(violation interface{}) *ViolationsConsumer_OnUnknownMsgTypeError_Call {
	return &ViolationsConsumer_OnUnknownMsgTypeError_Call{Call: _e.mock.On("OnUnknownMsgTypeError", violation)}
}

func (_c *ViolationsConsumer_OnUnknownMsgTypeError_Call) Run(run func(violation *network.Violation)) *ViolationsConsumer_OnUnknownMsgTypeError_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *network.Violation
		if args[0] != nil {
			arg0 = args[0].(*network.Violation)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ViolationsConsumer_OnUnknownMsgTypeError_Call) Return() *ViolationsConsumer_OnUnknownMsgTypeError_Call {
	_c.Call.Return()
	return _c
}

func (_c *ViolationsConsumer_OnUnknownMsgTypeError_Call) RunAndReturn(run func(violation *network.Violation)) *ViolationsConsumer_OnUnknownMsgTypeError_Call {
	_c.Run(run)
	return _c
}
