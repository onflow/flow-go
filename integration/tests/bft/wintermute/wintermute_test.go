package wintermute

import (
	"fmt"
	"testing"
	"time"

	"github.com/stretchr/testify/require"
	"github.com/stretchr/testify/suite"

	"github.com/onflow/flow-go/model/flow"
)

// wintermuteTimeout corresponds to the timeout the wintermute orchestrator have to conduct the attack.
const wintermuteTimeout = 1 * time.Minute

type WintermuteTestSuit struct {
	Suite
}

func TestWintermuteAttackTestSuite(t *testing.T) {
	suite.Run(t, new(WintermuteTestSuit))
}

// TestWintermuteAttack
func (w *WintermuteTestSuit) TestWintermuteAttack() {

	corruptedResult := w.waitForExecutionResultCorruption()

	block := w.BlockState.WaitForBlockById(w.T(), corruptedResult.BlockID)

	// waits for the execution receipt of blockB from both execution nodes, and makes sure that there is no execution fork.
	receiptB1 := w.ReceiptState.WaitForReceiptFrom(w.T(), block.Header.ID(), w.exe1Id)
	w.T().Logf("receipt for block generated by execution node-1: %x result ID: %x\n", w.exe1Id, receiptB1.ExecutionResult.ID())
	receiptB2 := w.ReceiptState.WaitForReceiptFrom(w.T(), block.Header.ID(), w.exe2Id)
	w.T().Logf("receipt for block generated by execution node-2: %x result ID: %x\n", w.exe2Id, receiptB2.ExecutionResult.ID())

	for i := 0; i < len(corruptedResult.Chunks); i++ {
		w.ApprovalState.WaitForTotalApprovalsFrom(w.T(), flow.IdentifierList{w.ver1Id, w.ver2Id, w.ver3Id}, corruptedResult.ID(), uint64(i), 2)
	}

	w.BlockState.WaitForSealed(w.T(), block.Header.Height)
}

// waitForExecutionResultCorruption waits within a timeout till wintermute orchestrator corrupts an execution result.
// It returns the corrupted execution result by wintermute orchestrator.
func (w *WintermuteTestSuit) waitForExecutionResultCorruption() *flow.ExecutionResult {
	var corruptedResult *flow.ExecutionResult

	require.Eventually(w.T(), func() bool {
		corrupted, original, conducted := w.Orchestrator.AttackState()
		if !conducted {
			w.T().Logf("pending wintermute orchestrator to conduct attack")
			return false
		}

		corruptedResult = &corrupted

		w.T().Logf("wintermute orchesterator conducted corruption, original result: %x, corrupted result: %x", original.ID(), corrupted.ID())
		return true
	}, wintermuteTimeout, 5*time.Second,
		fmt.Sprintf("orchestrator could not conduct execution result corruption within %v seconds", wintermuteTimeout))

	return corruptedResult
}
