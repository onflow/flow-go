package verification

import (
	"context"
	"testing"

	sdk "github.com/onflow/flow-go-sdk"
	"github.com/stretchr/testify/require"
	"github.com/stretchr/testify/suite"

	"github.com/onflow/flow-go/integration/tests/common"
	"github.com/onflow/flow-go/integration/tests/common/approvalstate"
	"github.com/onflow/flow-go/integration/tests/common/blockstate"
	"github.com/onflow/flow-go/integration/tests/common/receiptstate"
	"github.com/onflow/flow-go/model/flow"
)

func TestVerificationTestSuite(t *testing.T) {
	suite.Run(t, new(VerificationTestSuite))
}

type VerificationTestSuite struct {
	Suite
}

// TestVerificationNodeHappyPath verifies the integration of verification and execution nodes over the
// happy path of successfully issuing a result approval for the first chunk of the first block of the testnet.
func (suite *VerificationTestSuite) TestVerificationNodeHappyPath() {
	testVerificationNodeHappyPath(suite.T(), suite.exe1ID, suite.verID, suite.BlockState, suite.ReceiptState, suite.ApprovalState)
}

// TestSealingAndVerificationHappyPath evaluates the health of the happy path of verification and sealing. It
// deploys a transaction into the testnet hence causing an execution result with more than
// one chunk, assigns all chunks to the same single verification node in this testnet, and then verifies whether verification node
// generates a result approval for all chunks of that execution result.
// It also enables sealing based on result approvals and verifies whether the block of that specific multi-chunk execution result is sealed
// affected by the emitted result approvals.
func (suite *VerificationTestSuite) TestSealingAndVerificationHappyPath() {
	// wait for next height finalized (potentially first height), called blockA, just to make sure consensus progresses.
	blockA := suite.BlockState.WaitForHighestFinalizedProgress(suite.T())
	suite.T().Logf("blockA generated, height: %v ID: %v\n", blockA.Header.Height, blockA.Header.ID())

	// sends a transaction
	err := suite.AccessClient().DeployContract(context.Background(), sdk.Identifier(suite.net.Root().ID()), common.CounterContract)
	require.NoError(suite.T(), err, "could not deploy counter")

	// waits until for a different state commitment for a finalized block, call that block blockB,
	// which has more than one chunk on its execution result.
	blockB, _ := common.WaitUntilFinalizedStateCommitmentChanged(suite.T(), suite.BlockState, suite.ReceiptState, common.WithMinimumChunks(2))
	suite.T().Logf("got blockB height %v ID %v\n", blockB.Header.Height, blockB.Header.ID())

	// waits for the execution receipt of blockB from both execution nodes, and makes sure that there is no execution fork.
	receiptB1 := suite.ReceiptState.WaitForReceiptFrom(suite.T(), blockB.Header.ID(), suite.exe1ID)
	suite.T().Logf("receipt for blockB generated by execution node-1: %x result ID: %x\n", suite.exe1ID, receiptB1.ExecutionResult.ID())
	receiptB2 := suite.ReceiptState.WaitForReceiptFrom(suite.T(), blockB.Header.ID(), suite.exe2ID)
	suite.T().Logf("receipt for blockB generated by execution node-2: %x result ID: %x\n", suite.exe2ID, receiptB2.ExecutionResult.ID())

	require.Equal(suite.T(), receiptB1.ExecutionResult.ID(), receiptB2.ExecutionResult.ID(), "execution fork happened at blockB")
	resultB := receiptB1.ExecutionResult
	resultBId := resultB.ID()
	// re-evaluates that resultB has more than one chunk.
	require.Greater(suite.T(), len(resultB.Chunks), 1)
	suite.T().Logf("receipt for blockB generated: result ID: %x with %d chunks\n", resultBId, len(resultB.Chunks))

	// waits till result approval emits for all chunks of resultB
	for i := 0; i < len(resultB.Chunks); i++ {
		suite.ApprovalState.WaitForResultApproval(suite.T(), suite.verID, resultBId, uint64(i))
	}

	// waits until blockB is sealed by consensus nodes after result approvals for all of its chunks emitted.
	suite.BlockState.WaitForSealed(suite.T(), blockB.Header.Height)
}

// TestSystemChunkIDsShouldBeDifferent evaluates that system chunk of consecutive blocks that
// do not cause state change have different chunk Ids.
func (suite *VerificationTestSuite) TestSystemChunkIDsShouldBeDifferent() {
	// // wait for next height finalized (potentially first height), called blockA
	blockA := suite.BlockState.WaitForHighestFinalizedProgress(suite.T())
	suite.T().Logf("blockA generated, height: %v ID: %v\n", blockA.Header.Height, blockA.Header.ID())

	// waits for the next finalized block after blockA, called blockB.
	blockB := suite.BlockState.WaitForFinalizedChild(suite.T(), blockA)
	suite.T().Logf("blockB generated, height: %v ID: %v\n", blockB.Header.Height, blockB.Header.ID())

	// waits for execution receipt for blockA from execution node, called receiptA.
	receiptA := suite.ReceiptState.WaitForReceiptFrom(suite.T(), blockA.Header.ID(), suite.exe1ID)
	resultAId := receiptA.ExecutionResult.ID()
	suite.T().Logf("receipt for blockA generated: result ID: %x\n", resultAId)

	// waits for execution receipt for blockB from execution node, called receiptB.
	receiptB := suite.ReceiptState.WaitForReceiptFrom(suite.T(), blockB.Header.ID(), suite.exe1ID)
	resultBId := receiptB.ExecutionResult.ID()
	suite.T().Logf("receipt for blockB generated: result ID: %x\n", resultBId)

	// Todo: drop this part once system chunk changes the state
	// requires that execution state is not changed between block A and B
	stateA, err := receiptA.ExecutionResult.FinalStateCommitment()
	require.NoError(suite.T(), err)
	stateB, err := receiptB.ExecutionResult.FinalStateCommitment()
	require.NoError(suite.T(), err)
	require.Equal(suite.T(), stateA, stateB)

	// computes ids of system chunk for result A and B
	systemChunkAId := receiptA.ExecutionResult.Chunks[0].ID()
	systemChunkBId := receiptB.ExecutionResult.Chunks[0].ID()

	// requires that system chunk Id of execution results be different
	require.NotEqual(suite.T(), systemChunkAId, systemChunkBId)
}

func testVerificationNodeHappyPath(t *testing.T,
	exeID flow.Identifier,
	verID flow.Identifier,
	blocks *blockstate.BlockState,
	receipts *receiptstate.ReceiptState,
	approvals *approvalstate.ResultApprovalState) {

	// wait for next height finalized (potentially first height), called blockA
	blockA := blocks.WaitForHighestFinalizedProgress(t)
	t.Logf("blockA generated, height: %v ID: %v\n", blockA.Header.Height, blockA.Header.ID())

	// waits for execution receipt for blockA from execution node, called receiptA
	receiptA := receipts.WaitForReceiptFrom(t, blockA.Header.ID(), exeID)
	resultID := receiptA.ExecutionResult.ID()
	t.Logf("receipt for blockA generated: result ID: %x\n", resultID)

	// wait for a result approval from verification node
	approvals.WaitForResultApproval(t, verID, resultID, uint64(0))
}
