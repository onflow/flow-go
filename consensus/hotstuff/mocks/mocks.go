// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mocks

import (
	"context"
	"time"

	"github.com/onflow/crypto"
	"github.com/onflow/flow-go/consensus/hotstuff"
	"github.com/onflow/flow-go/consensus/hotstuff/model"
	"github.com/onflow/flow-go/model/flow"
	"github.com/onflow/flow-go/module/irrecoverable"
	"github.com/rs/zerolog"
	mock "github.com/stretchr/testify/mock"
)

// NewBlockProducer creates a new instance of BlockProducer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewBlockProducer(t interface {
	mock.TestingT
	Cleanup(func())
}) *BlockProducer {
	mock := &BlockProducer{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// BlockProducer is an autogenerated mock type for the BlockProducer type
type BlockProducer struct {
	mock.Mock
}

type BlockProducer_Expecter struct {
	mock *mock.Mock
}

func (_m *BlockProducer) EXPECT() *BlockProducer_Expecter {
	return &BlockProducer_Expecter{mock: &_m.Mock}
}

// MakeBlockProposal provides a mock function for the type BlockProducer
func (_mock *BlockProducer) MakeBlockProposal(view uint64, qc *flow.QuorumCertificate, lastViewTC *flow.TimeoutCertificate) (*flow.ProposalHeader, error) {
	ret := _mock.Called(view, qc, lastViewTC)

	if len(ret) == 0 {
		panic("no return value specified for MakeBlockProposal")
	}

	var r0 *flow.ProposalHeader
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(uint64, *flow.QuorumCertificate, *flow.TimeoutCertificate) (*flow.ProposalHeader, error)); ok {
		return returnFunc(view, qc, lastViewTC)
	}
	if returnFunc, ok := ret.Get(0).(func(uint64, *flow.QuorumCertificate, *flow.TimeoutCertificate) *flow.ProposalHeader); ok {
		r0 = returnFunc(view, qc, lastViewTC)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.ProposalHeader)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(uint64, *flow.QuorumCertificate, *flow.TimeoutCertificate) error); ok {
		r1 = returnFunc(view, qc, lastViewTC)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// BlockProducer_MakeBlockProposal_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MakeBlockProposal'
type BlockProducer_MakeBlockProposal_Call struct {
	*mock.Call
}

// MakeBlockProposal is a helper method to define mock.On call
//   - view uint64
//   - qc *flow.QuorumCertificate
//   - lastViewTC *flow.TimeoutCertificate
func (_e *BlockProducer_Expecter) MakeBlockProposal(view interface{}, qc interface{}, lastViewTC interface{}) *BlockProducer_MakeBlockProposal_Call {
	return &BlockProducer_MakeBlockProposal_Call{Call: _e.mock.On("MakeBlockProposal", view, qc, lastViewTC)}
}

func (_c *BlockProducer_MakeBlockProposal_Call) Run(run func(view uint64, qc *flow.QuorumCertificate, lastViewTC *flow.TimeoutCertificate)) *BlockProducer_MakeBlockProposal_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		var arg1 *flow.QuorumCertificate
		if args[1] != nil {
			arg1 = args[1].(*flow.QuorumCertificate)
		}
		var arg2 *flow.TimeoutCertificate
		if args[2] != nil {
			arg2 = args[2].(*flow.TimeoutCertificate)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *BlockProducer_MakeBlockProposal_Call) Return(proposalHeader *flow.ProposalHeader, err error) *BlockProducer_MakeBlockProposal_Call {
	_c.Call.Return(proposalHeader, err)
	return _c
}

func (_c *BlockProducer_MakeBlockProposal_Call) RunAndReturn(run func(view uint64, qc *flow.QuorumCertificate, lastViewTC *flow.TimeoutCertificate) (*flow.ProposalHeader, error)) *BlockProducer_MakeBlockProposal_Call {
	_c.Call.Return(run)
	return _c
}

// NewReplicas creates a new instance of Replicas. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewReplicas(t interface {
	mock.TestingT
	Cleanup(func())
}) *Replicas {
	mock := &Replicas{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Replicas is an autogenerated mock type for the Replicas type
type Replicas struct {
	mock.Mock
}

type Replicas_Expecter struct {
	mock *mock.Mock
}

func (_m *Replicas) EXPECT() *Replicas_Expecter {
	return &Replicas_Expecter{mock: &_m.Mock}
}

// DKG provides a mock function for the type Replicas
func (_mock *Replicas) DKG(view uint64) (hotstuff.DKG, error) {
	ret := _mock.Called(view)

	if len(ret) == 0 {
		panic("no return value specified for DKG")
	}

	var r0 hotstuff.DKG
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(uint64) (hotstuff.DKG, error)); ok {
		return returnFunc(view)
	}
	if returnFunc, ok := ret.Get(0).(func(uint64) hotstuff.DKG); ok {
		r0 = returnFunc(view)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(hotstuff.DKG)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(uint64) error); ok {
		r1 = returnFunc(view)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Replicas_DKG_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DKG'
type Replicas_DKG_Call struct {
	*mock.Call
}

// DKG is a helper method to define mock.On call
//   - view uint64
func (_e *Replicas_Expecter) DKG(view interface{}) *Replicas_DKG_Call {
	return &Replicas_DKG_Call{Call: _e.mock.On("DKG", view)}
}

func (_c *Replicas_DKG_Call) Run(run func(view uint64)) *Replicas_DKG_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Replicas_DKG_Call) Return(dKG hotstuff.DKG, err error) *Replicas_DKG_Call {
	_c.Call.Return(dKG, err)
	return _c
}

func (_c *Replicas_DKG_Call) RunAndReturn(run func(view uint64) (hotstuff.DKG, error)) *Replicas_DKG_Call {
	_c.Call.Return(run)
	return _c
}

// IdentitiesByEpoch provides a mock function for the type Replicas
func (_mock *Replicas) IdentitiesByEpoch(view uint64) (flow.IdentitySkeletonList, error) {
	ret := _mock.Called(view)

	if len(ret) == 0 {
		panic("no return value specified for IdentitiesByEpoch")
	}

	var r0 flow.IdentitySkeletonList
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(uint64) (flow.IdentitySkeletonList, error)); ok {
		return returnFunc(view)
	}
	if returnFunc, ok := ret.Get(0).(func(uint64) flow.IdentitySkeletonList); ok {
		r0 = returnFunc(view)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.IdentitySkeletonList)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(uint64) error); ok {
		r1 = returnFunc(view)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Replicas_IdentitiesByEpoch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IdentitiesByEpoch'
type Replicas_IdentitiesByEpoch_Call struct {
	*mock.Call
}

// IdentitiesByEpoch is a helper method to define mock.On call
//   - view uint64
func (_e *Replicas_Expecter) IdentitiesByEpoch(view interface{}) *Replicas_IdentitiesByEpoch_Call {
	return &Replicas_IdentitiesByEpoch_Call{Call: _e.mock.On("IdentitiesByEpoch", view)}
}

func (_c *Replicas_IdentitiesByEpoch_Call) Run(run func(view uint64)) *Replicas_IdentitiesByEpoch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Replicas_IdentitiesByEpoch_Call) Return(v flow.IdentitySkeletonList, err error) *Replicas_IdentitiesByEpoch_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *Replicas_IdentitiesByEpoch_Call) RunAndReturn(run func(view uint64) (flow.IdentitySkeletonList, error)) *Replicas_IdentitiesByEpoch_Call {
	_c.Call.Return(run)
	return _c
}

// IdentityByEpoch provides a mock function for the type Replicas
func (_mock *Replicas) IdentityByEpoch(view uint64, participantID flow.Identifier) (*flow.IdentitySkeleton, error) {
	ret := _mock.Called(view, participantID)

	if len(ret) == 0 {
		panic("no return value specified for IdentityByEpoch")
	}

	var r0 *flow.IdentitySkeleton
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(uint64, flow.Identifier) (*flow.IdentitySkeleton, error)); ok {
		return returnFunc(view, participantID)
	}
	if returnFunc, ok := ret.Get(0).(func(uint64, flow.Identifier) *flow.IdentitySkeleton); ok {
		r0 = returnFunc(view, participantID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.IdentitySkeleton)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(uint64, flow.Identifier) error); ok {
		r1 = returnFunc(view, participantID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Replicas_IdentityByEpoch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IdentityByEpoch'
type Replicas_IdentityByEpoch_Call struct {
	*mock.Call
}

// IdentityByEpoch is a helper method to define mock.On call
//   - view uint64
//   - participantID flow.Identifier
func (_e *Replicas_Expecter) IdentityByEpoch(view interface{}, participantID interface{}) *Replicas_IdentityByEpoch_Call {
	return &Replicas_IdentityByEpoch_Call{Call: _e.mock.On("IdentityByEpoch", view, participantID)}
}

func (_c *Replicas_IdentityByEpoch_Call) Run(run func(view uint64, participantID flow.Identifier)) *Replicas_IdentityByEpoch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		var arg1 flow.Identifier
		if args[1] != nil {
			arg1 = args[1].(flow.Identifier)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Replicas_IdentityByEpoch_Call) Return(identitySkeleton *flow.IdentitySkeleton, err error) *Replicas_IdentityByEpoch_Call {
	_c.Call.Return(identitySkeleton, err)
	return _c
}

func (_c *Replicas_IdentityByEpoch_Call) RunAndReturn(run func(view uint64, participantID flow.Identifier) (*flow.IdentitySkeleton, error)) *Replicas_IdentityByEpoch_Call {
	_c.Call.Return(run)
	return _c
}

// LeaderForView provides a mock function for the type Replicas
func (_mock *Replicas) LeaderForView(view uint64) (flow.Identifier, error) {
	ret := _mock.Called(view)

	if len(ret) == 0 {
		panic("no return value specified for LeaderForView")
	}

	var r0 flow.Identifier
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(uint64) (flow.Identifier, error)); ok {
		return returnFunc(view)
	}
	if returnFunc, ok := ret.Get(0).(func(uint64) flow.Identifier); ok {
		r0 = returnFunc(view)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.Identifier)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(uint64) error); ok {
		r1 = returnFunc(view)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Replicas_LeaderForView_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LeaderForView'
type Replicas_LeaderForView_Call struct {
	*mock.Call
}

// LeaderForView is a helper method to define mock.On call
//   - view uint64
func (_e *Replicas_Expecter) LeaderForView(view interface{}) *Replicas_LeaderForView_Call {
	return &Replicas_LeaderForView_Call{Call: _e.mock.On("LeaderForView", view)}
}

func (_c *Replicas_LeaderForView_Call) Run(run func(view uint64)) *Replicas_LeaderForView_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Replicas_LeaderForView_Call) Return(identifier flow.Identifier, err error) *Replicas_LeaderForView_Call {
	_c.Call.Return(identifier, err)
	return _c
}

func (_c *Replicas_LeaderForView_Call) RunAndReturn(run func(view uint64) (flow.Identifier, error)) *Replicas_LeaderForView_Call {
	_c.Call.Return(run)
	return _c
}

// QuorumThresholdForView provides a mock function for the type Replicas
func (_mock *Replicas) QuorumThresholdForView(view uint64) (uint64, error) {
	ret := _mock.Called(view)

	if len(ret) == 0 {
		panic("no return value specified for QuorumThresholdForView")
	}

	var r0 uint64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(uint64) (uint64, error)); ok {
		return returnFunc(view)
	}
	if returnFunc, ok := ret.Get(0).(func(uint64) uint64); ok {
		r0 = returnFunc(view)
	} else {
		r0 = ret.Get(0).(uint64)
	}
	if returnFunc, ok := ret.Get(1).(func(uint64) error); ok {
		r1 = returnFunc(view)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Replicas_QuorumThresholdForView_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'QuorumThresholdForView'
type Replicas_QuorumThresholdForView_Call struct {
	*mock.Call
}

// QuorumThresholdForView is a helper method to define mock.On call
//   - view uint64
func (_e *Replicas_Expecter) QuorumThresholdForView(view interface{}) *Replicas_QuorumThresholdForView_Call {
	return &Replicas_QuorumThresholdForView_Call{Call: _e.mock.On("QuorumThresholdForView", view)}
}

func (_c *Replicas_QuorumThresholdForView_Call) Run(run func(view uint64)) *Replicas_QuorumThresholdForView_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Replicas_QuorumThresholdForView_Call) Return(v uint64, err error) *Replicas_QuorumThresholdForView_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *Replicas_QuorumThresholdForView_Call) RunAndReturn(run func(view uint64) (uint64, error)) *Replicas_QuorumThresholdForView_Call {
	_c.Call.Return(run)
	return _c
}

// Self provides a mock function for the type Replicas
func (_mock *Replicas) Self() flow.Identifier {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Self")
	}

	var r0 flow.Identifier
	if returnFunc, ok := ret.Get(0).(func() flow.Identifier); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.Identifier)
		}
	}
	return r0
}

// Replicas_Self_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Self'
type Replicas_Self_Call struct {
	*mock.Call
}

// Self is a helper method to define mock.On call
func (_e *Replicas_Expecter) Self() *Replicas_Self_Call {
	return &Replicas_Self_Call{Call: _e.mock.On("Self")}
}

func (_c *Replicas_Self_Call) Run(run func()) *Replicas_Self_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Replicas_Self_Call) Return(identifier flow.Identifier) *Replicas_Self_Call {
	_c.Call.Return(identifier)
	return _c
}

func (_c *Replicas_Self_Call) RunAndReturn(run func() flow.Identifier) *Replicas_Self_Call {
	_c.Call.Return(run)
	return _c
}

// TimeoutThresholdForView provides a mock function for the type Replicas
func (_mock *Replicas) TimeoutThresholdForView(view uint64) (uint64, error) {
	ret := _mock.Called(view)

	if len(ret) == 0 {
		panic("no return value specified for TimeoutThresholdForView")
	}

	var r0 uint64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(uint64) (uint64, error)); ok {
		return returnFunc(view)
	}
	if returnFunc, ok := ret.Get(0).(func(uint64) uint64); ok {
		r0 = returnFunc(view)
	} else {
		r0 = ret.Get(0).(uint64)
	}
	if returnFunc, ok := ret.Get(1).(func(uint64) error); ok {
		r1 = returnFunc(view)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Replicas_TimeoutThresholdForView_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimeoutThresholdForView'
type Replicas_TimeoutThresholdForView_Call struct {
	*mock.Call
}

// TimeoutThresholdForView is a helper method to define mock.On call
//   - view uint64
func (_e *Replicas_Expecter) TimeoutThresholdForView(view interface{}) *Replicas_TimeoutThresholdForView_Call {
	return &Replicas_TimeoutThresholdForView_Call{Call: _e.mock.On("TimeoutThresholdForView", view)}
}

func (_c *Replicas_TimeoutThresholdForView_Call) Run(run func(view uint64)) *Replicas_TimeoutThresholdForView_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Replicas_TimeoutThresholdForView_Call) Return(v uint64, err error) *Replicas_TimeoutThresholdForView_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *Replicas_TimeoutThresholdForView_Call) RunAndReturn(run func(view uint64) (uint64, error)) *Replicas_TimeoutThresholdForView_Call {
	_c.Call.Return(run)
	return _c
}

// NewDynamicCommittee creates a new instance of DynamicCommittee. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewDynamicCommittee(t interface {
	mock.TestingT
	Cleanup(func())
}) *DynamicCommittee {
	mock := &DynamicCommittee{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// DynamicCommittee is an autogenerated mock type for the DynamicCommittee type
type DynamicCommittee struct {
	mock.Mock
}

type DynamicCommittee_Expecter struct {
	mock *mock.Mock
}

func (_m *DynamicCommittee) EXPECT() *DynamicCommittee_Expecter {
	return &DynamicCommittee_Expecter{mock: &_m.Mock}
}

// DKG provides a mock function for the type DynamicCommittee
func (_mock *DynamicCommittee) DKG(view uint64) (hotstuff.DKG, error) {
	ret := _mock.Called(view)

	if len(ret) == 0 {
		panic("no return value specified for DKG")
	}

	var r0 hotstuff.DKG
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(uint64) (hotstuff.DKG, error)); ok {
		return returnFunc(view)
	}
	if returnFunc, ok := ret.Get(0).(func(uint64) hotstuff.DKG); ok {
		r0 = returnFunc(view)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(hotstuff.DKG)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(uint64) error); ok {
		r1 = returnFunc(view)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// DynamicCommittee_DKG_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DKG'
type DynamicCommittee_DKG_Call struct {
	*mock.Call
}

// DKG is a helper method to define mock.On call
//   - view uint64
func (_e *DynamicCommittee_Expecter) DKG(view interface{}) *DynamicCommittee_DKG_Call {
	return &DynamicCommittee_DKG_Call{Call: _e.mock.On("DKG", view)}
}

func (_c *DynamicCommittee_DKG_Call) Run(run func(view uint64)) *DynamicCommittee_DKG_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *DynamicCommittee_DKG_Call) Return(dKG hotstuff.DKG, err error) *DynamicCommittee_DKG_Call {
	_c.Call.Return(dKG, err)
	return _c
}

func (_c *DynamicCommittee_DKG_Call) RunAndReturn(run func(view uint64) (hotstuff.DKG, error)) *DynamicCommittee_DKG_Call {
	_c.Call.Return(run)
	return _c
}

// IdentitiesByBlock provides a mock function for the type DynamicCommittee
func (_mock *DynamicCommittee) IdentitiesByBlock(blockID flow.Identifier) (flow.IdentityList, error) {
	ret := _mock.Called(blockID)

	if len(ret) == 0 {
		panic("no return value specified for IdentitiesByBlock")
	}

	var r0 flow.IdentityList
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (flow.IdentityList, error)); ok {
		return returnFunc(blockID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) flow.IdentityList); ok {
		r0 = returnFunc(blockID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.IdentityList)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(blockID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// DynamicCommittee_IdentitiesByBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IdentitiesByBlock'
type DynamicCommittee_IdentitiesByBlock_Call struct {
	*mock.Call
}

// IdentitiesByBlock is a helper method to define mock.On call
//   - blockID flow.Identifier
func (_e *DynamicCommittee_Expecter) IdentitiesByBlock(blockID interface{}) *DynamicCommittee_IdentitiesByBlock_Call {
	return &DynamicCommittee_IdentitiesByBlock_Call{Call: _e.mock.On("IdentitiesByBlock", blockID)}
}

func (_c *DynamicCommittee_IdentitiesByBlock_Call) Run(run func(blockID flow.Identifier)) *DynamicCommittee_IdentitiesByBlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *DynamicCommittee_IdentitiesByBlock_Call) Return(v flow.IdentityList, err error) *DynamicCommittee_IdentitiesByBlock_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *DynamicCommittee_IdentitiesByBlock_Call) RunAndReturn(run func(blockID flow.Identifier) (flow.IdentityList, error)) *DynamicCommittee_IdentitiesByBlock_Call {
	_c.Call.Return(run)
	return _c
}

// IdentitiesByEpoch provides a mock function for the type DynamicCommittee
func (_mock *DynamicCommittee) IdentitiesByEpoch(view uint64) (flow.IdentitySkeletonList, error) {
	ret := _mock.Called(view)

	if len(ret) == 0 {
		panic("no return value specified for IdentitiesByEpoch")
	}

	var r0 flow.IdentitySkeletonList
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(uint64) (flow.IdentitySkeletonList, error)); ok {
		return returnFunc(view)
	}
	if returnFunc, ok := ret.Get(0).(func(uint64) flow.IdentitySkeletonList); ok {
		r0 = returnFunc(view)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.IdentitySkeletonList)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(uint64) error); ok {
		r1 = returnFunc(view)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// DynamicCommittee_IdentitiesByEpoch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IdentitiesByEpoch'
type DynamicCommittee_IdentitiesByEpoch_Call struct {
	*mock.Call
}

// IdentitiesByEpoch is a helper method to define mock.On call
//   - view uint64
func (_e *DynamicCommittee_Expecter) IdentitiesByEpoch(view interface{}) *DynamicCommittee_IdentitiesByEpoch_Call {
	return &DynamicCommittee_IdentitiesByEpoch_Call{Call: _e.mock.On("IdentitiesByEpoch", view)}
}

func (_c *DynamicCommittee_IdentitiesByEpoch_Call) Run(run func(view uint64)) *DynamicCommittee_IdentitiesByEpoch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *DynamicCommittee_IdentitiesByEpoch_Call) Return(v flow.IdentitySkeletonList, err error) *DynamicCommittee_IdentitiesByEpoch_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *DynamicCommittee_IdentitiesByEpoch_Call) RunAndReturn(run func(view uint64) (flow.IdentitySkeletonList, error)) *DynamicCommittee_IdentitiesByEpoch_Call {
	_c.Call.Return(run)
	return _c
}

// IdentityByBlock provides a mock function for the type DynamicCommittee
func (_mock *DynamicCommittee) IdentityByBlock(blockID flow.Identifier, participantID flow.Identifier) (*flow.Identity, error) {
	ret := _mock.Called(blockID, participantID)

	if len(ret) == 0 {
		panic("no return value specified for IdentityByBlock")
	}

	var r0 *flow.Identity
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, flow.Identifier) (*flow.Identity, error)); ok {
		return returnFunc(blockID, participantID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, flow.Identifier) *flow.Identity); ok {
		r0 = returnFunc(blockID, participantID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.Identity)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier, flow.Identifier) error); ok {
		r1 = returnFunc(blockID, participantID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// DynamicCommittee_IdentityByBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IdentityByBlock'
type DynamicCommittee_IdentityByBlock_Call struct {
	*mock.Call
}

// IdentityByBlock is a helper method to define mock.On call
//   - blockID flow.Identifier
//   - participantID flow.Identifier
func (_e *DynamicCommittee_Expecter) IdentityByBlock(blockID interface{}, participantID interface{}) *DynamicCommittee_IdentityByBlock_Call {
	return &DynamicCommittee_IdentityByBlock_Call{Call: _e.mock.On("IdentityByBlock", blockID, participantID)}
}

func (_c *DynamicCommittee_IdentityByBlock_Call) Run(run func(blockID flow.Identifier, participantID flow.Identifier)) *DynamicCommittee_IdentityByBlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		var arg1 flow.Identifier
		if args[1] != nil {
			arg1 = args[1].(flow.Identifier)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *DynamicCommittee_IdentityByBlock_Call) Return(identity *flow.Identity, err error) *DynamicCommittee_IdentityByBlock_Call {
	_c.Call.Return(identity, err)
	return _c
}

func (_c *DynamicCommittee_IdentityByBlock_Call) RunAndReturn(run func(blockID flow.Identifier, participantID flow.Identifier) (*flow.Identity, error)) *DynamicCommittee_IdentityByBlock_Call {
	_c.Call.Return(run)
	return _c
}

// IdentityByEpoch provides a mock function for the type DynamicCommittee
func (_mock *DynamicCommittee) IdentityByEpoch(view uint64, participantID flow.Identifier) (*flow.IdentitySkeleton, error) {
	ret := _mock.Called(view, participantID)

	if len(ret) == 0 {
		panic("no return value specified for IdentityByEpoch")
	}

	var r0 *flow.IdentitySkeleton
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(uint64, flow.Identifier) (*flow.IdentitySkeleton, error)); ok {
		return returnFunc(view, participantID)
	}
	if returnFunc, ok := ret.Get(0).(func(uint64, flow.Identifier) *flow.IdentitySkeleton); ok {
		r0 = returnFunc(view, participantID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.IdentitySkeleton)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(uint64, flow.Identifier) error); ok {
		r1 = returnFunc(view, participantID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// DynamicCommittee_IdentityByEpoch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IdentityByEpoch'
type DynamicCommittee_IdentityByEpoch_Call struct {
	*mock.Call
}

// IdentityByEpoch is a helper method to define mock.On call
//   - view uint64
//   - participantID flow.Identifier
func (_e *DynamicCommittee_Expecter) IdentityByEpoch(view interface{}, participantID interface{}) *DynamicCommittee_IdentityByEpoch_Call {
	return &DynamicCommittee_IdentityByEpoch_Call{Call: _e.mock.On("IdentityByEpoch", view, participantID)}
}

func (_c *DynamicCommittee_IdentityByEpoch_Call) Run(run func(view uint64, participantID flow.Identifier)) *DynamicCommittee_IdentityByEpoch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		var arg1 flow.Identifier
		if args[1] != nil {
			arg1 = args[1].(flow.Identifier)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *DynamicCommittee_IdentityByEpoch_Call) Return(identitySkeleton *flow.IdentitySkeleton, err error) *DynamicCommittee_IdentityByEpoch_Call {
	_c.Call.Return(identitySkeleton, err)
	return _c
}

func (_c *DynamicCommittee_IdentityByEpoch_Call) RunAndReturn(run func(view uint64, participantID flow.Identifier) (*flow.IdentitySkeleton, error)) *DynamicCommittee_IdentityByEpoch_Call {
	_c.Call.Return(run)
	return _c
}

// LeaderForView provides a mock function for the type DynamicCommittee
func (_mock *DynamicCommittee) LeaderForView(view uint64) (flow.Identifier, error) {
	ret := _mock.Called(view)

	if len(ret) == 0 {
		panic("no return value specified for LeaderForView")
	}

	var r0 flow.Identifier
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(uint64) (flow.Identifier, error)); ok {
		return returnFunc(view)
	}
	if returnFunc, ok := ret.Get(0).(func(uint64) flow.Identifier); ok {
		r0 = returnFunc(view)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.Identifier)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(uint64) error); ok {
		r1 = returnFunc(view)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// DynamicCommittee_LeaderForView_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LeaderForView'
type DynamicCommittee_LeaderForView_Call struct {
	*mock.Call
}

// LeaderForView is a helper method to define mock.On call
//   - view uint64
func (_e *DynamicCommittee_Expecter) LeaderForView(view interface{}) *DynamicCommittee_LeaderForView_Call {
	return &DynamicCommittee_LeaderForView_Call{Call: _e.mock.On("LeaderForView", view)}
}

func (_c *DynamicCommittee_LeaderForView_Call) Run(run func(view uint64)) *DynamicCommittee_LeaderForView_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *DynamicCommittee_LeaderForView_Call) Return(identifier flow.Identifier, err error) *DynamicCommittee_LeaderForView_Call {
	_c.Call.Return(identifier, err)
	return _c
}

func (_c *DynamicCommittee_LeaderForView_Call) RunAndReturn(run func(view uint64) (flow.Identifier, error)) *DynamicCommittee_LeaderForView_Call {
	_c.Call.Return(run)
	return _c
}

// QuorumThresholdForView provides a mock function for the type DynamicCommittee
func (_mock *DynamicCommittee) QuorumThresholdForView(view uint64) (uint64, error) {
	ret := _mock.Called(view)

	if len(ret) == 0 {
		panic("no return value specified for QuorumThresholdForView")
	}

	var r0 uint64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(uint64) (uint64, error)); ok {
		return returnFunc(view)
	}
	if returnFunc, ok := ret.Get(0).(func(uint64) uint64); ok {
		r0 = returnFunc(view)
	} else {
		r0 = ret.Get(0).(uint64)
	}
	if returnFunc, ok := ret.Get(1).(func(uint64) error); ok {
		r1 = returnFunc(view)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// DynamicCommittee_QuorumThresholdForView_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'QuorumThresholdForView'
type DynamicCommittee_QuorumThresholdForView_Call struct {
	*mock.Call
}

// QuorumThresholdForView is a helper method to define mock.On call
//   - view uint64
func (_e *DynamicCommittee_Expecter) QuorumThresholdForView(view interface{}) *DynamicCommittee_QuorumThresholdForView_Call {
	return &DynamicCommittee_QuorumThresholdForView_Call{Call: _e.mock.On("QuorumThresholdForView", view)}
}

func (_c *DynamicCommittee_QuorumThresholdForView_Call) Run(run func(view uint64)) *DynamicCommittee_QuorumThresholdForView_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *DynamicCommittee_QuorumThresholdForView_Call) Return(v uint64, err error) *DynamicCommittee_QuorumThresholdForView_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *DynamicCommittee_QuorumThresholdForView_Call) RunAndReturn(run func(view uint64) (uint64, error)) *DynamicCommittee_QuorumThresholdForView_Call {
	_c.Call.Return(run)
	return _c
}

// Self provides a mock function for the type DynamicCommittee
func (_mock *DynamicCommittee) Self() flow.Identifier {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Self")
	}

	var r0 flow.Identifier
	if returnFunc, ok := ret.Get(0).(func() flow.Identifier); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.Identifier)
		}
	}
	return r0
}

// DynamicCommittee_Self_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Self'
type DynamicCommittee_Self_Call struct {
	*mock.Call
}

// Self is a helper method to define mock.On call
func (_e *DynamicCommittee_Expecter) Self() *DynamicCommittee_Self_Call {
	return &DynamicCommittee_Self_Call{Call: _e.mock.On("Self")}
}

func (_c *DynamicCommittee_Self_Call) Run(run func()) *DynamicCommittee_Self_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *DynamicCommittee_Self_Call) Return(identifier flow.Identifier) *DynamicCommittee_Self_Call {
	_c.Call.Return(identifier)
	return _c
}

func (_c *DynamicCommittee_Self_Call) RunAndReturn(run func() flow.Identifier) *DynamicCommittee_Self_Call {
	_c.Call.Return(run)
	return _c
}

// TimeoutThresholdForView provides a mock function for the type DynamicCommittee
func (_mock *DynamicCommittee) TimeoutThresholdForView(view uint64) (uint64, error) {
	ret := _mock.Called(view)

	if len(ret) == 0 {
		panic("no return value specified for TimeoutThresholdForView")
	}

	var r0 uint64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(uint64) (uint64, error)); ok {
		return returnFunc(view)
	}
	if returnFunc, ok := ret.Get(0).(func(uint64) uint64); ok {
		r0 = returnFunc(view)
	} else {
		r0 = ret.Get(0).(uint64)
	}
	if returnFunc, ok := ret.Get(1).(func(uint64) error); ok {
		r1 = returnFunc(view)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// DynamicCommittee_TimeoutThresholdForView_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimeoutThresholdForView'
type DynamicCommittee_TimeoutThresholdForView_Call struct {
	*mock.Call
}

// TimeoutThresholdForView is a helper method to define mock.On call
//   - view uint64
func (_e *DynamicCommittee_Expecter) TimeoutThresholdForView(view interface{}) *DynamicCommittee_TimeoutThresholdForView_Call {
	return &DynamicCommittee_TimeoutThresholdForView_Call{Call: _e.mock.On("TimeoutThresholdForView", view)}
}

func (_c *DynamicCommittee_TimeoutThresholdForView_Call) Run(run func(view uint64)) *DynamicCommittee_TimeoutThresholdForView_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *DynamicCommittee_TimeoutThresholdForView_Call) Return(v uint64, err error) *DynamicCommittee_TimeoutThresholdForView_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *DynamicCommittee_TimeoutThresholdForView_Call) RunAndReturn(run func(view uint64) (uint64, error)) *DynamicCommittee_TimeoutThresholdForView_Call {
	_c.Call.Return(run)
	return _c
}

// NewBlockSignerDecoder creates a new instance of BlockSignerDecoder. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewBlockSignerDecoder(t interface {
	mock.TestingT
	Cleanup(func())
}) *BlockSignerDecoder {
	mock := &BlockSignerDecoder{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// BlockSignerDecoder is an autogenerated mock type for the BlockSignerDecoder type
type BlockSignerDecoder struct {
	mock.Mock
}

type BlockSignerDecoder_Expecter struct {
	mock *mock.Mock
}

func (_m *BlockSignerDecoder) EXPECT() *BlockSignerDecoder_Expecter {
	return &BlockSignerDecoder_Expecter{mock: &_m.Mock}
}

// DecodeSignerIDs provides a mock function for the type BlockSignerDecoder
func (_mock *BlockSignerDecoder) DecodeSignerIDs(header *flow.Header) (flow.IdentifierList, error) {
	ret := _mock.Called(header)

	if len(ret) == 0 {
		panic("no return value specified for DecodeSignerIDs")
	}

	var r0 flow.IdentifierList
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*flow.Header) (flow.IdentifierList, error)); ok {
		return returnFunc(header)
	}
	if returnFunc, ok := ret.Get(0).(func(*flow.Header) flow.IdentifierList); ok {
		r0 = returnFunc(header)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.IdentifierList)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*flow.Header) error); ok {
		r1 = returnFunc(header)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// BlockSignerDecoder_DecodeSignerIDs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DecodeSignerIDs'
type BlockSignerDecoder_DecodeSignerIDs_Call struct {
	*mock.Call
}

// DecodeSignerIDs is a helper method to define mock.On call
//   - header *flow.Header
func (_e *BlockSignerDecoder_Expecter) DecodeSignerIDs(header interface{}) *BlockSignerDecoder_DecodeSignerIDs_Call {
	return &BlockSignerDecoder_DecodeSignerIDs_Call{Call: _e.mock.On("DecodeSignerIDs", header)}
}

func (_c *BlockSignerDecoder_DecodeSignerIDs_Call) Run(run func(header *flow.Header)) *BlockSignerDecoder_DecodeSignerIDs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *flow.Header
		if args[0] != nil {
			arg0 = args[0].(*flow.Header)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *BlockSignerDecoder_DecodeSignerIDs_Call) Return(identifierList flow.IdentifierList, err error) *BlockSignerDecoder_DecodeSignerIDs_Call {
	_c.Call.Return(identifierList, err)
	return _c
}

func (_c *BlockSignerDecoder_DecodeSignerIDs_Call) RunAndReturn(run func(header *flow.Header) (flow.IdentifierList, error)) *BlockSignerDecoder_DecodeSignerIDs_Call {
	_c.Call.Return(run)
	return _c
}

// NewDKG creates a new instance of DKG. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewDKG(t interface {
	mock.TestingT
	Cleanup(func())
}) *DKG {
	mock := &DKG{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// DKG is an autogenerated mock type for the DKG type
type DKG struct {
	mock.Mock
}

type DKG_Expecter struct {
	mock *mock.Mock
}

func (_m *DKG) EXPECT() *DKG_Expecter {
	return &DKG_Expecter{mock: &_m.Mock}
}

// GroupKey provides a mock function for the type DKG
func (_mock *DKG) GroupKey() crypto.PublicKey {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GroupKey")
	}

	var r0 crypto.PublicKey
	if returnFunc, ok := ret.Get(0).(func() crypto.PublicKey); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(crypto.PublicKey)
		}
	}
	return r0
}

// DKG_GroupKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GroupKey'
type DKG_GroupKey_Call struct {
	*mock.Call
}

// GroupKey is a helper method to define mock.On call
func (_e *DKG_Expecter) GroupKey() *DKG_GroupKey_Call {
	return &DKG_GroupKey_Call{Call: _e.mock.On("GroupKey")}
}

func (_c *DKG_GroupKey_Call) Run(run func()) *DKG_GroupKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *DKG_GroupKey_Call) Return(publicKey crypto.PublicKey) *DKG_GroupKey_Call {
	_c.Call.Return(publicKey)
	return _c
}

func (_c *DKG_GroupKey_Call) RunAndReturn(run func() crypto.PublicKey) *DKG_GroupKey_Call {
	_c.Call.Return(run)
	return _c
}

// Index provides a mock function for the type DKG
func (_mock *DKG) Index(nodeID flow.Identifier) (uint, error) {
	ret := _mock.Called(nodeID)

	if len(ret) == 0 {
		panic("no return value specified for Index")
	}

	var r0 uint
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (uint, error)); ok {
		return returnFunc(nodeID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) uint); ok {
		r0 = returnFunc(nodeID)
	} else {
		r0 = ret.Get(0).(uint)
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(nodeID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// DKG_Index_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Index'
type DKG_Index_Call struct {
	*mock.Call
}

// Index is a helper method to define mock.On call
//   - nodeID flow.Identifier
func (_e *DKG_Expecter) Index(nodeID interface{}) *DKG_Index_Call {
	return &DKG_Index_Call{Call: _e.mock.On("Index", nodeID)}
}

func (_c *DKG_Index_Call) Run(run func(nodeID flow.Identifier)) *DKG_Index_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *DKG_Index_Call) Return(v uint, err error) *DKG_Index_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *DKG_Index_Call) RunAndReturn(run func(nodeID flow.Identifier) (uint, error)) *DKG_Index_Call {
	_c.Call.Return(run)
	return _c
}

// KeyShare provides a mock function for the type DKG
func (_mock *DKG) KeyShare(nodeID flow.Identifier) (crypto.PublicKey, error) {
	ret := _mock.Called(nodeID)

	if len(ret) == 0 {
		panic("no return value specified for KeyShare")
	}

	var r0 crypto.PublicKey
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (crypto.PublicKey, error)); ok {
		return returnFunc(nodeID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) crypto.PublicKey); ok {
		r0 = returnFunc(nodeID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(crypto.PublicKey)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(nodeID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// DKG_KeyShare_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'KeyShare'
type DKG_KeyShare_Call struct {
	*mock.Call
}

// KeyShare is a helper method to define mock.On call
//   - nodeID flow.Identifier
func (_e *DKG_Expecter) KeyShare(nodeID interface{}) *DKG_KeyShare_Call {
	return &DKG_KeyShare_Call{Call: _e.mock.On("KeyShare", nodeID)}
}

func (_c *DKG_KeyShare_Call) Run(run func(nodeID flow.Identifier)) *DKG_KeyShare_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *DKG_KeyShare_Call) Return(publicKey crypto.PublicKey, err error) *DKG_KeyShare_Call {
	_c.Call.Return(publicKey, err)
	return _c
}

func (_c *DKG_KeyShare_Call) RunAndReturn(run func(nodeID flow.Identifier) (crypto.PublicKey, error)) *DKG_KeyShare_Call {
	_c.Call.Return(run)
	return _c
}

// KeyShares provides a mock function for the type DKG
func (_mock *DKG) KeyShares() []crypto.PublicKey {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for KeyShares")
	}

	var r0 []crypto.PublicKey
	if returnFunc, ok := ret.Get(0).(func() []crypto.PublicKey); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]crypto.PublicKey)
		}
	}
	return r0
}

// DKG_KeyShares_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'KeyShares'
type DKG_KeyShares_Call struct {
	*mock.Call
}

// KeyShares is a helper method to define mock.On call
func (_e *DKG_Expecter) KeyShares() *DKG_KeyShares_Call {
	return &DKG_KeyShares_Call{Call: _e.mock.On("KeyShares")}
}

func (_c *DKG_KeyShares_Call) Run(run func()) *DKG_KeyShares_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *DKG_KeyShares_Call) Return(publicKeys []crypto.PublicKey) *DKG_KeyShares_Call {
	_c.Call.Return(publicKeys)
	return _c
}

func (_c *DKG_KeyShares_Call) RunAndReturn(run func() []crypto.PublicKey) *DKG_KeyShares_Call {
	_c.Call.Return(run)
	return _c
}

// NodeID provides a mock function for the type DKG
func (_mock *DKG) NodeID(index uint) (flow.Identifier, error) {
	ret := _mock.Called(index)

	if len(ret) == 0 {
		panic("no return value specified for NodeID")
	}

	var r0 flow.Identifier
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(uint) (flow.Identifier, error)); ok {
		return returnFunc(index)
	}
	if returnFunc, ok := ret.Get(0).(func(uint) flow.Identifier); ok {
		r0 = returnFunc(index)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.Identifier)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(uint) error); ok {
		r1 = returnFunc(index)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// DKG_NodeID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NodeID'
type DKG_NodeID_Call struct {
	*mock.Call
}

// NodeID is a helper method to define mock.On call
//   - index uint
func (_e *DKG_Expecter) NodeID(index interface{}) *DKG_NodeID_Call {
	return &DKG_NodeID_Call{Call: _e.mock.On("NodeID", index)}
}

func (_c *DKG_NodeID_Call) Run(run func(index uint)) *DKG_NodeID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint
		if args[0] != nil {
			arg0 = args[0].(uint)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *DKG_NodeID_Call) Return(identifier flow.Identifier, err error) *DKG_NodeID_Call {
	_c.Call.Return(identifier, err)
	return _c
}

func (_c *DKG_NodeID_Call) RunAndReturn(run func(index uint) (flow.Identifier, error)) *DKG_NodeID_Call {
	_c.Call.Return(run)
	return _c
}

// Size provides a mock function for the type DKG
func (_mock *DKG) Size() uint {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Size")
	}

	var r0 uint
	if returnFunc, ok := ret.Get(0).(func() uint); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint)
	}
	return r0
}

// DKG_Size_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Size'
type DKG_Size_Call struct {
	*mock.Call
}

// Size is a helper method to define mock.On call
func (_e *DKG_Expecter) Size() *DKG_Size_Call {
	return &DKG_Size_Call{Call: _e.mock.On("Size")}
}

func (_c *DKG_Size_Call) Run(run func()) *DKG_Size_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *DKG_Size_Call) Return(v uint) *DKG_Size_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *DKG_Size_Call) RunAndReturn(run func() uint) *DKG_Size_Call {
	_c.Call.Return(run)
	return _c
}

// NewProposalViolationConsumer creates a new instance of ProposalViolationConsumer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewProposalViolationConsumer(t interface {
	mock.TestingT
	Cleanup(func())
}) *ProposalViolationConsumer {
	mock := &ProposalViolationConsumer{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// ProposalViolationConsumer is an autogenerated mock type for the ProposalViolationConsumer type
type ProposalViolationConsumer struct {
	mock.Mock
}

type ProposalViolationConsumer_Expecter struct {
	mock *mock.Mock
}

func (_m *ProposalViolationConsumer) EXPECT() *ProposalViolationConsumer_Expecter {
	return &ProposalViolationConsumer_Expecter{mock: &_m.Mock}
}

// OnDoubleProposeDetected provides a mock function for the type ProposalViolationConsumer
func (_mock *ProposalViolationConsumer) OnDoubleProposeDetected(block *model.Block, block1 *model.Block) {
	_mock.Called(block, block1)
	return
}

// ProposalViolationConsumer_OnDoubleProposeDetected_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnDoubleProposeDetected'
type ProposalViolationConsumer_OnDoubleProposeDetected_Call struct {
	*mock.Call
}

// OnDoubleProposeDetected is a helper method to define mock.On call
//   - block *model.Block
//   - block1 *model.Block
func (_e *ProposalViolationConsumer_Expecter) OnDoubleProposeDetected(block interface{}, block1 interface{}) *ProposalViolationConsumer_OnDoubleProposeDetected_Call {
	return &ProposalViolationConsumer_OnDoubleProposeDetected_Call{Call: _e.mock.On("OnDoubleProposeDetected", block, block1)}
}

func (_c *ProposalViolationConsumer_OnDoubleProposeDetected_Call) Run(run func(block *model.Block, block1 *model.Block)) *ProposalViolationConsumer_OnDoubleProposeDetected_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Block
		if args[0] != nil {
			arg0 = args[0].(*model.Block)
		}
		var arg1 *model.Block
		if args[1] != nil {
			arg1 = args[1].(*model.Block)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ProposalViolationConsumer_OnDoubleProposeDetected_Call) Return() *ProposalViolationConsumer_OnDoubleProposeDetected_Call {
	_c.Call.Return()
	return _c
}

func (_c *ProposalViolationConsumer_OnDoubleProposeDetected_Call) RunAndReturn(run func(block *model.Block, block1 *model.Block)) *ProposalViolationConsumer_OnDoubleProposeDetected_Call {
	_c.Run(run)
	return _c
}

// OnInvalidBlockDetected provides a mock function for the type ProposalViolationConsumer
func (_mock *ProposalViolationConsumer) OnInvalidBlockDetected(err flow.Slashable[model.InvalidProposalError]) {
	_mock.Called(err)
	return
}

// ProposalViolationConsumer_OnInvalidBlockDetected_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnInvalidBlockDetected'
type ProposalViolationConsumer_OnInvalidBlockDetected_Call struct {
	*mock.Call
}

// OnInvalidBlockDetected is a helper method to define mock.On call
//   - err flow.Slashable[model.InvalidProposalError]
func (_e *ProposalViolationConsumer_Expecter) OnInvalidBlockDetected(err interface{}) *ProposalViolationConsumer_OnInvalidBlockDetected_Call {
	return &ProposalViolationConsumer_OnInvalidBlockDetected_Call{Call: _e.mock.On("OnInvalidBlockDetected", err)}
}

func (_c *ProposalViolationConsumer_OnInvalidBlockDetected_Call) Run(run func(err flow.Slashable[model.InvalidProposalError])) *ProposalViolationConsumer_OnInvalidBlockDetected_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Slashable[model.InvalidProposalError]
		if args[0] != nil {
			arg0 = args[0].(flow.Slashable[model.InvalidProposalError])
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ProposalViolationConsumer_OnInvalidBlockDetected_Call) Return() *ProposalViolationConsumer_OnInvalidBlockDetected_Call {
	_c.Call.Return()
	return _c
}

func (_c *ProposalViolationConsumer_OnInvalidBlockDetected_Call) RunAndReturn(run func(err flow.Slashable[model.InvalidProposalError])) *ProposalViolationConsumer_OnInvalidBlockDetected_Call {
	_c.Run(run)
	return _c
}

// NewVoteAggregationViolationConsumer creates a new instance of VoteAggregationViolationConsumer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewVoteAggregationViolationConsumer(t interface {
	mock.TestingT
	Cleanup(func())
}) *VoteAggregationViolationConsumer {
	mock := &VoteAggregationViolationConsumer{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// VoteAggregationViolationConsumer is an autogenerated mock type for the VoteAggregationViolationConsumer type
type VoteAggregationViolationConsumer struct {
	mock.Mock
}

type VoteAggregationViolationConsumer_Expecter struct {
	mock *mock.Mock
}

func (_m *VoteAggregationViolationConsumer) EXPECT() *VoteAggregationViolationConsumer_Expecter {
	return &VoteAggregationViolationConsumer_Expecter{mock: &_m.Mock}
}

// OnDoubleVotingDetected provides a mock function for the type VoteAggregationViolationConsumer
func (_mock *VoteAggregationViolationConsumer) OnDoubleVotingDetected(vote *model.Vote, vote1 *model.Vote) {
	_mock.Called(vote, vote1)
	return
}

// VoteAggregationViolationConsumer_OnDoubleVotingDetected_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnDoubleVotingDetected'
type VoteAggregationViolationConsumer_OnDoubleVotingDetected_Call struct {
	*mock.Call
}

// OnDoubleVotingDetected is a helper method to define mock.On call
//   - vote *model.Vote
//   - vote1 *model.Vote
func (_e *VoteAggregationViolationConsumer_Expecter) OnDoubleVotingDetected(vote interface{}, vote1 interface{}) *VoteAggregationViolationConsumer_OnDoubleVotingDetected_Call {
	return &VoteAggregationViolationConsumer_OnDoubleVotingDetected_Call{Call: _e.mock.On("OnDoubleVotingDetected", vote, vote1)}
}

func (_c *VoteAggregationViolationConsumer_OnDoubleVotingDetected_Call) Run(run func(vote *model.Vote, vote1 *model.Vote)) *VoteAggregationViolationConsumer_OnDoubleVotingDetected_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Vote
		if args[0] != nil {
			arg0 = args[0].(*model.Vote)
		}
		var arg1 *model.Vote
		if args[1] != nil {
			arg1 = args[1].(*model.Vote)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *VoteAggregationViolationConsumer_OnDoubleVotingDetected_Call) Return() *VoteAggregationViolationConsumer_OnDoubleVotingDetected_Call {
	_c.Call.Return()
	return _c
}

func (_c *VoteAggregationViolationConsumer_OnDoubleVotingDetected_Call) RunAndReturn(run func(vote *model.Vote, vote1 *model.Vote)) *VoteAggregationViolationConsumer_OnDoubleVotingDetected_Call {
	_c.Run(run)
	return _c
}

// OnInvalidVoteDetected provides a mock function for the type VoteAggregationViolationConsumer
func (_mock *VoteAggregationViolationConsumer) OnInvalidVoteDetected(err model.InvalidVoteError) {
	_mock.Called(err)
	return
}

// VoteAggregationViolationConsumer_OnInvalidVoteDetected_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnInvalidVoteDetected'
type VoteAggregationViolationConsumer_OnInvalidVoteDetected_Call struct {
	*mock.Call
}

// OnInvalidVoteDetected is a helper method to define mock.On call
//   - err model.InvalidVoteError
func (_e *VoteAggregationViolationConsumer_Expecter) OnInvalidVoteDetected(err interface{}) *VoteAggregationViolationConsumer_OnInvalidVoteDetected_Call {
	return &VoteAggregationViolationConsumer_OnInvalidVoteDetected_Call{Call: _e.mock.On("OnInvalidVoteDetected", err)}
}

func (_c *VoteAggregationViolationConsumer_OnInvalidVoteDetected_Call) Run(run func(err model.InvalidVoteError)) *VoteAggregationViolationConsumer_OnInvalidVoteDetected_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 model.InvalidVoteError
		if args[0] != nil {
			arg0 = args[0].(model.InvalidVoteError)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *VoteAggregationViolationConsumer_OnInvalidVoteDetected_Call) Return() *VoteAggregationViolationConsumer_OnInvalidVoteDetected_Call {
	_c.Call.Return()
	return _c
}

func (_c *VoteAggregationViolationConsumer_OnInvalidVoteDetected_Call) RunAndReturn(run func(err model.InvalidVoteError)) *VoteAggregationViolationConsumer_OnInvalidVoteDetected_Call {
	_c.Run(run)
	return _c
}

// OnVoteForInvalidBlockDetected provides a mock function for the type VoteAggregationViolationConsumer
func (_mock *VoteAggregationViolationConsumer) OnVoteForInvalidBlockDetected(vote *model.Vote, invalidProposal *model.SignedProposal) {
	_mock.Called(vote, invalidProposal)
	return
}

// VoteAggregationViolationConsumer_OnVoteForInvalidBlockDetected_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnVoteForInvalidBlockDetected'
type VoteAggregationViolationConsumer_OnVoteForInvalidBlockDetected_Call struct {
	*mock.Call
}

// OnVoteForInvalidBlockDetected is a helper method to define mock.On call
//   - vote *model.Vote
//   - invalidProposal *model.SignedProposal
func (_e *VoteAggregationViolationConsumer_Expecter) OnVoteForInvalidBlockDetected(vote interface{}, invalidProposal interface{}) *VoteAggregationViolationConsumer_OnVoteForInvalidBlockDetected_Call {
	return &VoteAggregationViolationConsumer_OnVoteForInvalidBlockDetected_Call{Call: _e.mock.On("OnVoteForInvalidBlockDetected", vote, invalidProposal)}
}

func (_c *VoteAggregationViolationConsumer_OnVoteForInvalidBlockDetected_Call) Run(run func(vote *model.Vote, invalidProposal *model.SignedProposal)) *VoteAggregationViolationConsumer_OnVoteForInvalidBlockDetected_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Vote
		if args[0] != nil {
			arg0 = args[0].(*model.Vote)
		}
		var arg1 *model.SignedProposal
		if args[1] != nil {
			arg1 = args[1].(*model.SignedProposal)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *VoteAggregationViolationConsumer_OnVoteForInvalidBlockDetected_Call) Return() *VoteAggregationViolationConsumer_OnVoteForInvalidBlockDetected_Call {
	_c.Call.Return()
	return _c
}

func (_c *VoteAggregationViolationConsumer_OnVoteForInvalidBlockDetected_Call) RunAndReturn(run func(vote *model.Vote, invalidProposal *model.SignedProposal)) *VoteAggregationViolationConsumer_OnVoteForInvalidBlockDetected_Call {
	_c.Run(run)
	return _c
}

// NewTimeoutAggregationViolationConsumer creates a new instance of TimeoutAggregationViolationConsumer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewTimeoutAggregationViolationConsumer(t interface {
	mock.TestingT
	Cleanup(func())
}) *TimeoutAggregationViolationConsumer {
	mock := &TimeoutAggregationViolationConsumer{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// TimeoutAggregationViolationConsumer is an autogenerated mock type for the TimeoutAggregationViolationConsumer type
type TimeoutAggregationViolationConsumer struct {
	mock.Mock
}

type TimeoutAggregationViolationConsumer_Expecter struct {
	mock *mock.Mock
}

func (_m *TimeoutAggregationViolationConsumer) EXPECT() *TimeoutAggregationViolationConsumer_Expecter {
	return &TimeoutAggregationViolationConsumer_Expecter{mock: &_m.Mock}
}

// OnDoubleTimeoutDetected provides a mock function for the type TimeoutAggregationViolationConsumer
func (_mock *TimeoutAggregationViolationConsumer) OnDoubleTimeoutDetected(timeoutObject *model.TimeoutObject, timeoutObject1 *model.TimeoutObject) {
	_mock.Called(timeoutObject, timeoutObject1)
	return
}

// TimeoutAggregationViolationConsumer_OnDoubleTimeoutDetected_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnDoubleTimeoutDetected'
type TimeoutAggregationViolationConsumer_OnDoubleTimeoutDetected_Call struct {
	*mock.Call
}

// OnDoubleTimeoutDetected is a helper method to define mock.On call
//   - timeoutObject *model.TimeoutObject
//   - timeoutObject1 *model.TimeoutObject
func (_e *TimeoutAggregationViolationConsumer_Expecter) OnDoubleTimeoutDetected(timeoutObject interface{}, timeoutObject1 interface{}) *TimeoutAggregationViolationConsumer_OnDoubleTimeoutDetected_Call {
	return &TimeoutAggregationViolationConsumer_OnDoubleTimeoutDetected_Call{Call: _e.mock.On("OnDoubleTimeoutDetected", timeoutObject, timeoutObject1)}
}

func (_c *TimeoutAggregationViolationConsumer_OnDoubleTimeoutDetected_Call) Run(run func(timeoutObject *model.TimeoutObject, timeoutObject1 *model.TimeoutObject)) *TimeoutAggregationViolationConsumer_OnDoubleTimeoutDetected_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.TimeoutObject
		if args[0] != nil {
			arg0 = args[0].(*model.TimeoutObject)
		}
		var arg1 *model.TimeoutObject
		if args[1] != nil {
			arg1 = args[1].(*model.TimeoutObject)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *TimeoutAggregationViolationConsumer_OnDoubleTimeoutDetected_Call) Return() *TimeoutAggregationViolationConsumer_OnDoubleTimeoutDetected_Call {
	_c.Call.Return()
	return _c
}

func (_c *TimeoutAggregationViolationConsumer_OnDoubleTimeoutDetected_Call) RunAndReturn(run func(timeoutObject *model.TimeoutObject, timeoutObject1 *model.TimeoutObject)) *TimeoutAggregationViolationConsumer_OnDoubleTimeoutDetected_Call {
	_c.Run(run)
	return _c
}

// OnInvalidTimeoutDetected provides a mock function for the type TimeoutAggregationViolationConsumer
func (_mock *TimeoutAggregationViolationConsumer) OnInvalidTimeoutDetected(err model.InvalidTimeoutError) {
	_mock.Called(err)
	return
}

// TimeoutAggregationViolationConsumer_OnInvalidTimeoutDetected_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnInvalidTimeoutDetected'
type TimeoutAggregationViolationConsumer_OnInvalidTimeoutDetected_Call struct {
	*mock.Call
}

// OnInvalidTimeoutDetected is a helper method to define mock.On call
//   - err model.InvalidTimeoutError
func (_e *TimeoutAggregationViolationConsumer_Expecter) OnInvalidTimeoutDetected(err interface{}) *TimeoutAggregationViolationConsumer_OnInvalidTimeoutDetected_Call {
	return &TimeoutAggregationViolationConsumer_OnInvalidTimeoutDetected_Call{Call: _e.mock.On("OnInvalidTimeoutDetected", err)}
}

func (_c *TimeoutAggregationViolationConsumer_OnInvalidTimeoutDetected_Call) Run(run func(err model.InvalidTimeoutError)) *TimeoutAggregationViolationConsumer_OnInvalidTimeoutDetected_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 model.InvalidTimeoutError
		if args[0] != nil {
			arg0 = args[0].(model.InvalidTimeoutError)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *TimeoutAggregationViolationConsumer_OnInvalidTimeoutDetected_Call) Return() *TimeoutAggregationViolationConsumer_OnInvalidTimeoutDetected_Call {
	_c.Call.Return()
	return _c
}

func (_c *TimeoutAggregationViolationConsumer_OnInvalidTimeoutDetected_Call) RunAndReturn(run func(err model.InvalidTimeoutError)) *TimeoutAggregationViolationConsumer_OnInvalidTimeoutDetected_Call {
	_c.Run(run)
	return _c
}

// NewFinalizationConsumer creates a new instance of FinalizationConsumer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewFinalizationConsumer(t interface {
	mock.TestingT
	Cleanup(func())
}) *FinalizationConsumer {
	mock := &FinalizationConsumer{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// FinalizationConsumer is an autogenerated mock type for the FinalizationConsumer type
type FinalizationConsumer struct {
	mock.Mock
}

type FinalizationConsumer_Expecter struct {
	mock *mock.Mock
}

func (_m *FinalizationConsumer) EXPECT() *FinalizationConsumer_Expecter {
	return &FinalizationConsumer_Expecter{mock: &_m.Mock}
}

// OnBlockIncorporated provides a mock function for the type FinalizationConsumer
func (_mock *FinalizationConsumer) OnBlockIncorporated(block *model.Block) {
	_mock.Called(block)
	return
}

// FinalizationConsumer_OnBlockIncorporated_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnBlockIncorporated'
type FinalizationConsumer_OnBlockIncorporated_Call struct {
	*mock.Call
}

// OnBlockIncorporated is a helper method to define mock.On call
//   - block *model.Block
func (_e *FinalizationConsumer_Expecter) OnBlockIncorporated(block interface{}) *FinalizationConsumer_OnBlockIncorporated_Call {
	return &FinalizationConsumer_OnBlockIncorporated_Call{Call: _e.mock.On("OnBlockIncorporated", block)}
}

func (_c *FinalizationConsumer_OnBlockIncorporated_Call) Run(run func(block *model.Block)) *FinalizationConsumer_OnBlockIncorporated_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Block
		if args[0] != nil {
			arg0 = args[0].(*model.Block)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *FinalizationConsumer_OnBlockIncorporated_Call) Return() *FinalizationConsumer_OnBlockIncorporated_Call {
	_c.Call.Return()
	return _c
}

func (_c *FinalizationConsumer_OnBlockIncorporated_Call) RunAndReturn(run func(block *model.Block)) *FinalizationConsumer_OnBlockIncorporated_Call {
	_c.Run(run)
	return _c
}

// OnFinalizedBlock provides a mock function for the type FinalizationConsumer
func (_mock *FinalizationConsumer) OnFinalizedBlock(block *model.Block) {
	_mock.Called(block)
	return
}

// FinalizationConsumer_OnFinalizedBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnFinalizedBlock'
type FinalizationConsumer_OnFinalizedBlock_Call struct {
	*mock.Call
}

// OnFinalizedBlock is a helper method to define mock.On call
//   - block *model.Block
func (_e *FinalizationConsumer_Expecter) OnFinalizedBlock(block interface{}) *FinalizationConsumer_OnFinalizedBlock_Call {
	return &FinalizationConsumer_OnFinalizedBlock_Call{Call: _e.mock.On("OnFinalizedBlock", block)}
}

func (_c *FinalizationConsumer_OnFinalizedBlock_Call) Run(run func(block *model.Block)) *FinalizationConsumer_OnFinalizedBlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Block
		if args[0] != nil {
			arg0 = args[0].(*model.Block)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *FinalizationConsumer_OnFinalizedBlock_Call) Return() *FinalizationConsumer_OnFinalizedBlock_Call {
	_c.Call.Return()
	return _c
}

func (_c *FinalizationConsumer_OnFinalizedBlock_Call) RunAndReturn(run func(block *model.Block)) *FinalizationConsumer_OnFinalizedBlock_Call {
	_c.Run(run)
	return _c
}

// NewParticipantConsumer creates a new instance of ParticipantConsumer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewParticipantConsumer(t interface {
	mock.TestingT
	Cleanup(func())
}) *ParticipantConsumer {
	mock := &ParticipantConsumer{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// ParticipantConsumer is an autogenerated mock type for the ParticipantConsumer type
type ParticipantConsumer struct {
	mock.Mock
}

type ParticipantConsumer_Expecter struct {
	mock *mock.Mock
}

func (_m *ParticipantConsumer) EXPECT() *ParticipantConsumer_Expecter {
	return &ParticipantConsumer_Expecter{mock: &_m.Mock}
}

// OnCurrentViewDetails provides a mock function for the type ParticipantConsumer
func (_mock *ParticipantConsumer) OnCurrentViewDetails(currentView uint64, finalizedView uint64, currentLeader flow.Identifier) {
	_mock.Called(currentView, finalizedView, currentLeader)
	return
}

// ParticipantConsumer_OnCurrentViewDetails_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnCurrentViewDetails'
type ParticipantConsumer_OnCurrentViewDetails_Call struct {
	*mock.Call
}

// OnCurrentViewDetails is a helper method to define mock.On call
//   - currentView uint64
//   - finalizedView uint64
//   - currentLeader flow.Identifier
func (_e *ParticipantConsumer_Expecter) OnCurrentViewDetails(currentView interface{}, finalizedView interface{}, currentLeader interface{}) *ParticipantConsumer_OnCurrentViewDetails_Call {
	return &ParticipantConsumer_OnCurrentViewDetails_Call{Call: _e.mock.On("OnCurrentViewDetails", currentView, finalizedView, currentLeader)}
}

func (_c *ParticipantConsumer_OnCurrentViewDetails_Call) Run(run func(currentView uint64, finalizedView uint64, currentLeader flow.Identifier)) *ParticipantConsumer_OnCurrentViewDetails_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		var arg1 uint64
		if args[1] != nil {
			arg1 = args[1].(uint64)
		}
		var arg2 flow.Identifier
		if args[2] != nil {
			arg2 = args[2].(flow.Identifier)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *ParticipantConsumer_OnCurrentViewDetails_Call) Return() *ParticipantConsumer_OnCurrentViewDetails_Call {
	_c.Call.Return()
	return _c
}

func (_c *ParticipantConsumer_OnCurrentViewDetails_Call) RunAndReturn(run func(currentView uint64, finalizedView uint64, currentLeader flow.Identifier)) *ParticipantConsumer_OnCurrentViewDetails_Call {
	_c.Run(run)
	return _c
}

// OnEventProcessed provides a mock function for the type ParticipantConsumer
func (_mock *ParticipantConsumer) OnEventProcessed() {
	_mock.Called()
	return
}

// ParticipantConsumer_OnEventProcessed_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnEventProcessed'
type ParticipantConsumer_OnEventProcessed_Call struct {
	*mock.Call
}

// OnEventProcessed is a helper method to define mock.On call
func (_e *ParticipantConsumer_Expecter) OnEventProcessed() *ParticipantConsumer_OnEventProcessed_Call {
	return &ParticipantConsumer_OnEventProcessed_Call{Call: _e.mock.On("OnEventProcessed")}
}

func (_c *ParticipantConsumer_OnEventProcessed_Call) Run(run func()) *ParticipantConsumer_OnEventProcessed_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ParticipantConsumer_OnEventProcessed_Call) Return() *ParticipantConsumer_OnEventProcessed_Call {
	_c.Call.Return()
	return _c
}

func (_c *ParticipantConsumer_OnEventProcessed_Call) RunAndReturn(run func()) *ParticipantConsumer_OnEventProcessed_Call {
	_c.Run(run)
	return _c
}

// OnLocalTimeout provides a mock function for the type ParticipantConsumer
func (_mock *ParticipantConsumer) OnLocalTimeout(currentView uint64) {
	_mock.Called(currentView)
	return
}

// ParticipantConsumer_OnLocalTimeout_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnLocalTimeout'
type ParticipantConsumer_OnLocalTimeout_Call struct {
	*mock.Call
}

// OnLocalTimeout is a helper method to define mock.On call
//   - currentView uint64
func (_e *ParticipantConsumer_Expecter) OnLocalTimeout(currentView interface{}) *ParticipantConsumer_OnLocalTimeout_Call {
	return &ParticipantConsumer_OnLocalTimeout_Call{Call: _e.mock.On("OnLocalTimeout", currentView)}
}

func (_c *ParticipantConsumer_OnLocalTimeout_Call) Run(run func(currentView uint64)) *ParticipantConsumer_OnLocalTimeout_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ParticipantConsumer_OnLocalTimeout_Call) Return() *ParticipantConsumer_OnLocalTimeout_Call {
	_c.Call.Return()
	return _c
}

func (_c *ParticipantConsumer_OnLocalTimeout_Call) RunAndReturn(run func(currentView uint64)) *ParticipantConsumer_OnLocalTimeout_Call {
	_c.Run(run)
	return _c
}

// OnPartialTc provides a mock function for the type ParticipantConsumer
func (_mock *ParticipantConsumer) OnPartialTc(currentView uint64, partialTc *hotstuff.PartialTcCreated) {
	_mock.Called(currentView, partialTc)
	return
}

// ParticipantConsumer_OnPartialTc_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnPartialTc'
type ParticipantConsumer_OnPartialTc_Call struct {
	*mock.Call
}

// OnPartialTc is a helper method to define mock.On call
//   - currentView uint64
//   - partialTc *hotstuff.PartialTcCreated
func (_e *ParticipantConsumer_Expecter) OnPartialTc(currentView interface{}, partialTc interface{}) *ParticipantConsumer_OnPartialTc_Call {
	return &ParticipantConsumer_OnPartialTc_Call{Call: _e.mock.On("OnPartialTc", currentView, partialTc)}
}

func (_c *ParticipantConsumer_OnPartialTc_Call) Run(run func(currentView uint64, partialTc *hotstuff.PartialTcCreated)) *ParticipantConsumer_OnPartialTc_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		var arg1 *hotstuff.PartialTcCreated
		if args[1] != nil {
			arg1 = args[1].(*hotstuff.PartialTcCreated)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ParticipantConsumer_OnPartialTc_Call) Return() *ParticipantConsumer_OnPartialTc_Call {
	_c.Call.Return()
	return _c
}

func (_c *ParticipantConsumer_OnPartialTc_Call) RunAndReturn(run func(currentView uint64, partialTc *hotstuff.PartialTcCreated)) *ParticipantConsumer_OnPartialTc_Call {
	_c.Run(run)
	return _c
}

// OnQcTriggeredViewChange provides a mock function for the type ParticipantConsumer
func (_mock *ParticipantConsumer) OnQcTriggeredViewChange(oldView uint64, newView uint64, qc *flow.QuorumCertificate) {
	_mock.Called(oldView, newView, qc)
	return
}

// ParticipantConsumer_OnQcTriggeredViewChange_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnQcTriggeredViewChange'
type ParticipantConsumer_OnQcTriggeredViewChange_Call struct {
	*mock.Call
}

// OnQcTriggeredViewChange is a helper method to define mock.On call
//   - oldView uint64
//   - newView uint64
//   - qc *flow.QuorumCertificate
func (_e *ParticipantConsumer_Expecter) OnQcTriggeredViewChange(oldView interface{}, newView interface{}, qc interface{}) *ParticipantConsumer_OnQcTriggeredViewChange_Call {
	return &ParticipantConsumer_OnQcTriggeredViewChange_Call{Call: _e.mock.On("OnQcTriggeredViewChange", oldView, newView, qc)}
}

func (_c *ParticipantConsumer_OnQcTriggeredViewChange_Call) Run(run func(oldView uint64, newView uint64, qc *flow.QuorumCertificate)) *ParticipantConsumer_OnQcTriggeredViewChange_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		var arg1 uint64
		if args[1] != nil {
			arg1 = args[1].(uint64)
		}
		var arg2 *flow.QuorumCertificate
		if args[2] != nil {
			arg2 = args[2].(*flow.QuorumCertificate)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *ParticipantConsumer_OnQcTriggeredViewChange_Call) Return() *ParticipantConsumer_OnQcTriggeredViewChange_Call {
	_c.Call.Return()
	return _c
}

func (_c *ParticipantConsumer_OnQcTriggeredViewChange_Call) RunAndReturn(run func(oldView uint64, newView uint64, qc *flow.QuorumCertificate)) *ParticipantConsumer_OnQcTriggeredViewChange_Call {
	_c.Run(run)
	return _c
}

// OnReceiveProposal provides a mock function for the type ParticipantConsumer
func (_mock *ParticipantConsumer) OnReceiveProposal(currentView uint64, proposal *model.SignedProposal) {
	_mock.Called(currentView, proposal)
	return
}

// ParticipantConsumer_OnReceiveProposal_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnReceiveProposal'
type ParticipantConsumer_OnReceiveProposal_Call struct {
	*mock.Call
}

// OnReceiveProposal is a helper method to define mock.On call
//   - currentView uint64
//   - proposal *model.SignedProposal
func (_e *ParticipantConsumer_Expecter) OnReceiveProposal(currentView interface{}, proposal interface{}) *ParticipantConsumer_OnReceiveProposal_Call {
	return &ParticipantConsumer_OnReceiveProposal_Call{Call: _e.mock.On("OnReceiveProposal", currentView, proposal)}
}

func (_c *ParticipantConsumer_OnReceiveProposal_Call) Run(run func(currentView uint64, proposal *model.SignedProposal)) *ParticipantConsumer_OnReceiveProposal_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		var arg1 *model.SignedProposal
		if args[1] != nil {
			arg1 = args[1].(*model.SignedProposal)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ParticipantConsumer_OnReceiveProposal_Call) Return() *ParticipantConsumer_OnReceiveProposal_Call {
	_c.Call.Return()
	return _c
}

func (_c *ParticipantConsumer_OnReceiveProposal_Call) RunAndReturn(run func(currentView uint64, proposal *model.SignedProposal)) *ParticipantConsumer_OnReceiveProposal_Call {
	_c.Run(run)
	return _c
}

// OnReceiveQc provides a mock function for the type ParticipantConsumer
func (_mock *ParticipantConsumer) OnReceiveQc(currentView uint64, qc *flow.QuorumCertificate) {
	_mock.Called(currentView, qc)
	return
}

// ParticipantConsumer_OnReceiveQc_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnReceiveQc'
type ParticipantConsumer_OnReceiveQc_Call struct {
	*mock.Call
}

// OnReceiveQc is a helper method to define mock.On call
//   - currentView uint64
//   - qc *flow.QuorumCertificate
func (_e *ParticipantConsumer_Expecter) OnReceiveQc(currentView interface{}, qc interface{}) *ParticipantConsumer_OnReceiveQc_Call {
	return &ParticipantConsumer_OnReceiveQc_Call{Call: _e.mock.On("OnReceiveQc", currentView, qc)}
}

func (_c *ParticipantConsumer_OnReceiveQc_Call) Run(run func(currentView uint64, qc *flow.QuorumCertificate)) *ParticipantConsumer_OnReceiveQc_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		var arg1 *flow.QuorumCertificate
		if args[1] != nil {
			arg1 = args[1].(*flow.QuorumCertificate)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ParticipantConsumer_OnReceiveQc_Call) Return() *ParticipantConsumer_OnReceiveQc_Call {
	_c.Call.Return()
	return _c
}

func (_c *ParticipantConsumer_OnReceiveQc_Call) RunAndReturn(run func(currentView uint64, qc *flow.QuorumCertificate)) *ParticipantConsumer_OnReceiveQc_Call {
	_c.Run(run)
	return _c
}

// OnReceiveTc provides a mock function for the type ParticipantConsumer
func (_mock *ParticipantConsumer) OnReceiveTc(currentView uint64, tc *flow.TimeoutCertificate) {
	_mock.Called(currentView, tc)
	return
}

// ParticipantConsumer_OnReceiveTc_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnReceiveTc'
type ParticipantConsumer_OnReceiveTc_Call struct {
	*mock.Call
}

// OnReceiveTc is a helper method to define mock.On call
//   - currentView uint64
//   - tc *flow.TimeoutCertificate
func (_e *ParticipantConsumer_Expecter) OnReceiveTc(currentView interface{}, tc interface{}) *ParticipantConsumer_OnReceiveTc_Call {
	return &ParticipantConsumer_OnReceiveTc_Call{Call: _e.mock.On("OnReceiveTc", currentView, tc)}
}

func (_c *ParticipantConsumer_OnReceiveTc_Call) Run(run func(currentView uint64, tc *flow.TimeoutCertificate)) *ParticipantConsumer_OnReceiveTc_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		var arg1 *flow.TimeoutCertificate
		if args[1] != nil {
			arg1 = args[1].(*flow.TimeoutCertificate)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ParticipantConsumer_OnReceiveTc_Call) Return() *ParticipantConsumer_OnReceiveTc_Call {
	_c.Call.Return()
	return _c
}

func (_c *ParticipantConsumer_OnReceiveTc_Call) RunAndReturn(run func(currentView uint64, tc *flow.TimeoutCertificate)) *ParticipantConsumer_OnReceiveTc_Call {
	_c.Run(run)
	return _c
}

// OnStart provides a mock function for the type ParticipantConsumer
func (_mock *ParticipantConsumer) OnStart(currentView uint64) {
	_mock.Called(currentView)
	return
}

// ParticipantConsumer_OnStart_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnStart'
type ParticipantConsumer_OnStart_Call struct {
	*mock.Call
}

// OnStart is a helper method to define mock.On call
//   - currentView uint64
func (_e *ParticipantConsumer_Expecter) OnStart(currentView interface{}) *ParticipantConsumer_OnStart_Call {
	return &ParticipantConsumer_OnStart_Call{Call: _e.mock.On("OnStart", currentView)}
}

func (_c *ParticipantConsumer_OnStart_Call) Run(run func(currentView uint64)) *ParticipantConsumer_OnStart_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ParticipantConsumer_OnStart_Call) Return() *ParticipantConsumer_OnStart_Call {
	_c.Call.Return()
	return _c
}

func (_c *ParticipantConsumer_OnStart_Call) RunAndReturn(run func(currentView uint64)) *ParticipantConsumer_OnStart_Call {
	_c.Run(run)
	return _c
}

// OnStartingTimeout provides a mock function for the type ParticipantConsumer
func (_mock *ParticipantConsumer) OnStartingTimeout(timerInfo model.TimerInfo) {
	_mock.Called(timerInfo)
	return
}

// ParticipantConsumer_OnStartingTimeout_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnStartingTimeout'
type ParticipantConsumer_OnStartingTimeout_Call struct {
	*mock.Call
}

// OnStartingTimeout is a helper method to define mock.On call
//   - timerInfo model.TimerInfo
func (_e *ParticipantConsumer_Expecter) OnStartingTimeout(timerInfo interface{}) *ParticipantConsumer_OnStartingTimeout_Call {
	return &ParticipantConsumer_OnStartingTimeout_Call{Call: _e.mock.On("OnStartingTimeout", timerInfo)}
}

func (_c *ParticipantConsumer_OnStartingTimeout_Call) Run(run func(timerInfo model.TimerInfo)) *ParticipantConsumer_OnStartingTimeout_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 model.TimerInfo
		if args[0] != nil {
			arg0 = args[0].(model.TimerInfo)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ParticipantConsumer_OnStartingTimeout_Call) Return() *ParticipantConsumer_OnStartingTimeout_Call {
	_c.Call.Return()
	return _c
}

func (_c *ParticipantConsumer_OnStartingTimeout_Call) RunAndReturn(run func(timerInfo model.TimerInfo)) *ParticipantConsumer_OnStartingTimeout_Call {
	_c.Run(run)
	return _c
}

// OnTcTriggeredViewChange provides a mock function for the type ParticipantConsumer
func (_mock *ParticipantConsumer) OnTcTriggeredViewChange(oldView uint64, newView uint64, tc *flow.TimeoutCertificate) {
	_mock.Called(oldView, newView, tc)
	return
}

// ParticipantConsumer_OnTcTriggeredViewChange_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnTcTriggeredViewChange'
type ParticipantConsumer_OnTcTriggeredViewChange_Call struct {
	*mock.Call
}

// OnTcTriggeredViewChange is a helper method to define mock.On call
//   - oldView uint64
//   - newView uint64
//   - tc *flow.TimeoutCertificate
func (_e *ParticipantConsumer_Expecter) OnTcTriggeredViewChange(oldView interface{}, newView interface{}, tc interface{}) *ParticipantConsumer_OnTcTriggeredViewChange_Call {
	return &ParticipantConsumer_OnTcTriggeredViewChange_Call{Call: _e.mock.On("OnTcTriggeredViewChange", oldView, newView, tc)}
}

func (_c *ParticipantConsumer_OnTcTriggeredViewChange_Call) Run(run func(oldView uint64, newView uint64, tc *flow.TimeoutCertificate)) *ParticipantConsumer_OnTcTriggeredViewChange_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		var arg1 uint64
		if args[1] != nil {
			arg1 = args[1].(uint64)
		}
		var arg2 *flow.TimeoutCertificate
		if args[2] != nil {
			arg2 = args[2].(*flow.TimeoutCertificate)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *ParticipantConsumer_OnTcTriggeredViewChange_Call) Return() *ParticipantConsumer_OnTcTriggeredViewChange_Call {
	_c.Call.Return()
	return _c
}

func (_c *ParticipantConsumer_OnTcTriggeredViewChange_Call) RunAndReturn(run func(oldView uint64, newView uint64, tc *flow.TimeoutCertificate)) *ParticipantConsumer_OnTcTriggeredViewChange_Call {
	_c.Run(run)
	return _c
}

// OnViewChange provides a mock function for the type ParticipantConsumer
func (_mock *ParticipantConsumer) OnViewChange(oldView uint64, newView uint64) {
	_mock.Called(oldView, newView)
	return
}

// ParticipantConsumer_OnViewChange_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnViewChange'
type ParticipantConsumer_OnViewChange_Call struct {
	*mock.Call
}

// OnViewChange is a helper method to define mock.On call
//   - oldView uint64
//   - newView uint64
func (_e *ParticipantConsumer_Expecter) OnViewChange(oldView interface{}, newView interface{}) *ParticipantConsumer_OnViewChange_Call {
	return &ParticipantConsumer_OnViewChange_Call{Call: _e.mock.On("OnViewChange", oldView, newView)}
}

func (_c *ParticipantConsumer_OnViewChange_Call) Run(run func(oldView uint64, newView uint64)) *ParticipantConsumer_OnViewChange_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		var arg1 uint64
		if args[1] != nil {
			arg1 = args[1].(uint64)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ParticipantConsumer_OnViewChange_Call) Return() *ParticipantConsumer_OnViewChange_Call {
	_c.Call.Return()
	return _c
}

func (_c *ParticipantConsumer_OnViewChange_Call) RunAndReturn(run func(oldView uint64, newView uint64)) *ParticipantConsumer_OnViewChange_Call {
	_c.Run(run)
	return _c
}

// NewVoteCollectorConsumer creates a new instance of VoteCollectorConsumer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewVoteCollectorConsumer(t interface {
	mock.TestingT
	Cleanup(func())
}) *VoteCollectorConsumer {
	mock := &VoteCollectorConsumer{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// VoteCollectorConsumer is an autogenerated mock type for the VoteCollectorConsumer type
type VoteCollectorConsumer struct {
	mock.Mock
}

type VoteCollectorConsumer_Expecter struct {
	mock *mock.Mock
}

func (_m *VoteCollectorConsumer) EXPECT() *VoteCollectorConsumer_Expecter {
	return &VoteCollectorConsumer_Expecter{mock: &_m.Mock}
}

// OnQcConstructedFromVotes provides a mock function for the type VoteCollectorConsumer
func (_mock *VoteCollectorConsumer) OnQcConstructedFromVotes(quorumCertificate *flow.QuorumCertificate) {
	_mock.Called(quorumCertificate)
	return
}

// VoteCollectorConsumer_OnQcConstructedFromVotes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnQcConstructedFromVotes'
type VoteCollectorConsumer_OnQcConstructedFromVotes_Call struct {
	*mock.Call
}

// OnQcConstructedFromVotes is a helper method to define mock.On call
//   - quorumCertificate *flow.QuorumCertificate
func (_e *VoteCollectorConsumer_Expecter) OnQcConstructedFromVotes(quorumCertificate interface{}) *VoteCollectorConsumer_OnQcConstructedFromVotes_Call {
	return &VoteCollectorConsumer_OnQcConstructedFromVotes_Call{Call: _e.mock.On("OnQcConstructedFromVotes", quorumCertificate)}
}

func (_c *VoteCollectorConsumer_OnQcConstructedFromVotes_Call) Run(run func(quorumCertificate *flow.QuorumCertificate)) *VoteCollectorConsumer_OnQcConstructedFromVotes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *flow.QuorumCertificate
		if args[0] != nil {
			arg0 = args[0].(*flow.QuorumCertificate)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *VoteCollectorConsumer_OnQcConstructedFromVotes_Call) Return() *VoteCollectorConsumer_OnQcConstructedFromVotes_Call {
	_c.Call.Return()
	return _c
}

func (_c *VoteCollectorConsumer_OnQcConstructedFromVotes_Call) RunAndReturn(run func(quorumCertificate *flow.QuorumCertificate)) *VoteCollectorConsumer_OnQcConstructedFromVotes_Call {
	_c.Run(run)
	return _c
}

// OnVoteProcessed provides a mock function for the type VoteCollectorConsumer
func (_mock *VoteCollectorConsumer) OnVoteProcessed(vote *model.Vote) {
	_mock.Called(vote)
	return
}

// VoteCollectorConsumer_OnVoteProcessed_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnVoteProcessed'
type VoteCollectorConsumer_OnVoteProcessed_Call struct {
	*mock.Call
}

// OnVoteProcessed is a helper method to define mock.On call
//   - vote *model.Vote
func (_e *VoteCollectorConsumer_Expecter) OnVoteProcessed(vote interface{}) *VoteCollectorConsumer_OnVoteProcessed_Call {
	return &VoteCollectorConsumer_OnVoteProcessed_Call{Call: _e.mock.On("OnVoteProcessed", vote)}
}

func (_c *VoteCollectorConsumer_OnVoteProcessed_Call) Run(run func(vote *model.Vote)) *VoteCollectorConsumer_OnVoteProcessed_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Vote
		if args[0] != nil {
			arg0 = args[0].(*model.Vote)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *VoteCollectorConsumer_OnVoteProcessed_Call) Return() *VoteCollectorConsumer_OnVoteProcessed_Call {
	_c.Call.Return()
	return _c
}

func (_c *VoteCollectorConsumer_OnVoteProcessed_Call) RunAndReturn(run func(vote *model.Vote)) *VoteCollectorConsumer_OnVoteProcessed_Call {
	_c.Run(run)
	return _c
}

// NewTimeoutCollectorConsumer creates a new instance of TimeoutCollectorConsumer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewTimeoutCollectorConsumer(t interface {
	mock.TestingT
	Cleanup(func())
}) *TimeoutCollectorConsumer {
	mock := &TimeoutCollectorConsumer{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// TimeoutCollectorConsumer is an autogenerated mock type for the TimeoutCollectorConsumer type
type TimeoutCollectorConsumer struct {
	mock.Mock
}

type TimeoutCollectorConsumer_Expecter struct {
	mock *mock.Mock
}

func (_m *TimeoutCollectorConsumer) EXPECT() *TimeoutCollectorConsumer_Expecter {
	return &TimeoutCollectorConsumer_Expecter{mock: &_m.Mock}
}

// OnNewQcDiscovered provides a mock function for the type TimeoutCollectorConsumer
func (_mock *TimeoutCollectorConsumer) OnNewQcDiscovered(certificate *flow.QuorumCertificate) {
	_mock.Called(certificate)
	return
}

// TimeoutCollectorConsumer_OnNewQcDiscovered_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnNewQcDiscovered'
type TimeoutCollectorConsumer_OnNewQcDiscovered_Call struct {
	*mock.Call
}

// OnNewQcDiscovered is a helper method to define mock.On call
//   - certificate *flow.QuorumCertificate
func (_e *TimeoutCollectorConsumer_Expecter) OnNewQcDiscovered(certificate interface{}) *TimeoutCollectorConsumer_OnNewQcDiscovered_Call {
	return &TimeoutCollectorConsumer_OnNewQcDiscovered_Call{Call: _e.mock.On("OnNewQcDiscovered", certificate)}
}

func (_c *TimeoutCollectorConsumer_OnNewQcDiscovered_Call) Run(run func(certificate *flow.QuorumCertificate)) *TimeoutCollectorConsumer_OnNewQcDiscovered_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *flow.QuorumCertificate
		if args[0] != nil {
			arg0 = args[0].(*flow.QuorumCertificate)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *TimeoutCollectorConsumer_OnNewQcDiscovered_Call) Return() *TimeoutCollectorConsumer_OnNewQcDiscovered_Call {
	_c.Call.Return()
	return _c
}

func (_c *TimeoutCollectorConsumer_OnNewQcDiscovered_Call) RunAndReturn(run func(certificate *flow.QuorumCertificate)) *TimeoutCollectorConsumer_OnNewQcDiscovered_Call {
	_c.Run(run)
	return _c
}

// OnNewTcDiscovered provides a mock function for the type TimeoutCollectorConsumer
func (_mock *TimeoutCollectorConsumer) OnNewTcDiscovered(certificate *flow.TimeoutCertificate) {
	_mock.Called(certificate)
	return
}

// TimeoutCollectorConsumer_OnNewTcDiscovered_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnNewTcDiscovered'
type TimeoutCollectorConsumer_OnNewTcDiscovered_Call struct {
	*mock.Call
}

// OnNewTcDiscovered is a helper method to define mock.On call
//   - certificate *flow.TimeoutCertificate
func (_e *TimeoutCollectorConsumer_Expecter) OnNewTcDiscovered(certificate interface{}) *TimeoutCollectorConsumer_OnNewTcDiscovered_Call {
	return &TimeoutCollectorConsumer_OnNewTcDiscovered_Call{Call: _e.mock.On("OnNewTcDiscovered", certificate)}
}

func (_c *TimeoutCollectorConsumer_OnNewTcDiscovered_Call) Run(run func(certificate *flow.TimeoutCertificate)) *TimeoutCollectorConsumer_OnNewTcDiscovered_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *flow.TimeoutCertificate
		if args[0] != nil {
			arg0 = args[0].(*flow.TimeoutCertificate)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *TimeoutCollectorConsumer_OnNewTcDiscovered_Call) Return() *TimeoutCollectorConsumer_OnNewTcDiscovered_Call {
	_c.Call.Return()
	return _c
}

func (_c *TimeoutCollectorConsumer_OnNewTcDiscovered_Call) RunAndReturn(run func(certificate *flow.TimeoutCertificate)) *TimeoutCollectorConsumer_OnNewTcDiscovered_Call {
	_c.Run(run)
	return _c
}

// OnPartialTcCreated provides a mock function for the type TimeoutCollectorConsumer
func (_mock *TimeoutCollectorConsumer) OnPartialTcCreated(view uint64, newestQC *flow.QuorumCertificate, lastViewTC *flow.TimeoutCertificate) {
	_mock.Called(view, newestQC, lastViewTC)
	return
}

// TimeoutCollectorConsumer_OnPartialTcCreated_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnPartialTcCreated'
type TimeoutCollectorConsumer_OnPartialTcCreated_Call struct {
	*mock.Call
}

// OnPartialTcCreated is a helper method to define mock.On call
//   - view uint64
//   - newestQC *flow.QuorumCertificate
//   - lastViewTC *flow.TimeoutCertificate
func (_e *TimeoutCollectorConsumer_Expecter) OnPartialTcCreated(view interface{}, newestQC interface{}, lastViewTC interface{}) *TimeoutCollectorConsumer_OnPartialTcCreated_Call {
	return &TimeoutCollectorConsumer_OnPartialTcCreated_Call{Call: _e.mock.On("OnPartialTcCreated", view, newestQC, lastViewTC)}
}

func (_c *TimeoutCollectorConsumer_OnPartialTcCreated_Call) Run(run func(view uint64, newestQC *flow.QuorumCertificate, lastViewTC *flow.TimeoutCertificate)) *TimeoutCollectorConsumer_OnPartialTcCreated_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		var arg1 *flow.QuorumCertificate
		if args[1] != nil {
			arg1 = args[1].(*flow.QuorumCertificate)
		}
		var arg2 *flow.TimeoutCertificate
		if args[2] != nil {
			arg2 = args[2].(*flow.TimeoutCertificate)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *TimeoutCollectorConsumer_OnPartialTcCreated_Call) Return() *TimeoutCollectorConsumer_OnPartialTcCreated_Call {
	_c.Call.Return()
	return _c
}

func (_c *TimeoutCollectorConsumer_OnPartialTcCreated_Call) RunAndReturn(run func(view uint64, newestQC *flow.QuorumCertificate, lastViewTC *flow.TimeoutCertificate)) *TimeoutCollectorConsumer_OnPartialTcCreated_Call {
	_c.Run(run)
	return _c
}

// OnTcConstructedFromTimeouts provides a mock function for the type TimeoutCollectorConsumer
func (_mock *TimeoutCollectorConsumer) OnTcConstructedFromTimeouts(certificate *flow.TimeoutCertificate) {
	_mock.Called(certificate)
	return
}

// TimeoutCollectorConsumer_OnTcConstructedFromTimeouts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnTcConstructedFromTimeouts'
type TimeoutCollectorConsumer_OnTcConstructedFromTimeouts_Call struct {
	*mock.Call
}

// OnTcConstructedFromTimeouts is a helper method to define mock.On call
//   - certificate *flow.TimeoutCertificate
func (_e *TimeoutCollectorConsumer_Expecter) OnTcConstructedFromTimeouts(certificate interface{}) *TimeoutCollectorConsumer_OnTcConstructedFromTimeouts_Call {
	return &TimeoutCollectorConsumer_OnTcConstructedFromTimeouts_Call{Call: _e.mock.On("OnTcConstructedFromTimeouts", certificate)}
}

func (_c *TimeoutCollectorConsumer_OnTcConstructedFromTimeouts_Call) Run(run func(certificate *flow.TimeoutCertificate)) *TimeoutCollectorConsumer_OnTcConstructedFromTimeouts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *flow.TimeoutCertificate
		if args[0] != nil {
			arg0 = args[0].(*flow.TimeoutCertificate)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *TimeoutCollectorConsumer_OnTcConstructedFromTimeouts_Call) Return() *TimeoutCollectorConsumer_OnTcConstructedFromTimeouts_Call {
	_c.Call.Return()
	return _c
}

func (_c *TimeoutCollectorConsumer_OnTcConstructedFromTimeouts_Call) RunAndReturn(run func(certificate *flow.TimeoutCertificate)) *TimeoutCollectorConsumer_OnTcConstructedFromTimeouts_Call {
	_c.Run(run)
	return _c
}

// OnTimeoutProcessed provides a mock function for the type TimeoutCollectorConsumer
func (_mock *TimeoutCollectorConsumer) OnTimeoutProcessed(timeout *model.TimeoutObject) {
	_mock.Called(timeout)
	return
}

// TimeoutCollectorConsumer_OnTimeoutProcessed_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnTimeoutProcessed'
type TimeoutCollectorConsumer_OnTimeoutProcessed_Call struct {
	*mock.Call
}

// OnTimeoutProcessed is a helper method to define mock.On call
//   - timeout *model.TimeoutObject
func (_e *TimeoutCollectorConsumer_Expecter) OnTimeoutProcessed(timeout interface{}) *TimeoutCollectorConsumer_OnTimeoutProcessed_Call {
	return &TimeoutCollectorConsumer_OnTimeoutProcessed_Call{Call: _e.mock.On("OnTimeoutProcessed", timeout)}
}

func (_c *TimeoutCollectorConsumer_OnTimeoutProcessed_Call) Run(run func(timeout *model.TimeoutObject)) *TimeoutCollectorConsumer_OnTimeoutProcessed_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.TimeoutObject
		if args[0] != nil {
			arg0 = args[0].(*model.TimeoutObject)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *TimeoutCollectorConsumer_OnTimeoutProcessed_Call) Return() *TimeoutCollectorConsumer_OnTimeoutProcessed_Call {
	_c.Call.Return()
	return _c
}

func (_c *TimeoutCollectorConsumer_OnTimeoutProcessed_Call) RunAndReturn(run func(timeout *model.TimeoutObject)) *TimeoutCollectorConsumer_OnTimeoutProcessed_Call {
	_c.Run(run)
	return _c
}

// NewCommunicatorConsumer creates a new instance of CommunicatorConsumer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewCommunicatorConsumer(t interface {
	mock.TestingT
	Cleanup(func())
}) *CommunicatorConsumer {
	mock := &CommunicatorConsumer{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// CommunicatorConsumer is an autogenerated mock type for the CommunicatorConsumer type
type CommunicatorConsumer struct {
	mock.Mock
}

type CommunicatorConsumer_Expecter struct {
	mock *mock.Mock
}

func (_m *CommunicatorConsumer) EXPECT() *CommunicatorConsumer_Expecter {
	return &CommunicatorConsumer_Expecter{mock: &_m.Mock}
}

// OnOwnProposal provides a mock function for the type CommunicatorConsumer
func (_mock *CommunicatorConsumer) OnOwnProposal(proposal *flow.ProposalHeader, targetPublicationTime time.Time) {
	_mock.Called(proposal, targetPublicationTime)
	return
}

// CommunicatorConsumer_OnOwnProposal_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnOwnProposal'
type CommunicatorConsumer_OnOwnProposal_Call struct {
	*mock.Call
}

// OnOwnProposal is a helper method to define mock.On call
//   - proposal *flow.ProposalHeader
//   - targetPublicationTime time.Time
func (_e *CommunicatorConsumer_Expecter) OnOwnProposal(proposal interface{}, targetPublicationTime interface{}) *CommunicatorConsumer_OnOwnProposal_Call {
	return &CommunicatorConsumer_OnOwnProposal_Call{Call: _e.mock.On("OnOwnProposal", proposal, targetPublicationTime)}
}

func (_c *CommunicatorConsumer_OnOwnProposal_Call) Run(run func(proposal *flow.ProposalHeader, targetPublicationTime time.Time)) *CommunicatorConsumer_OnOwnProposal_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *flow.ProposalHeader
		if args[0] != nil {
			arg0 = args[0].(*flow.ProposalHeader)
		}
		var arg1 time.Time
		if args[1] != nil {
			arg1 = args[1].(time.Time)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *CommunicatorConsumer_OnOwnProposal_Call) Return() *CommunicatorConsumer_OnOwnProposal_Call {
	_c.Call.Return()
	return _c
}

func (_c *CommunicatorConsumer_OnOwnProposal_Call) RunAndReturn(run func(proposal *flow.ProposalHeader, targetPublicationTime time.Time)) *CommunicatorConsumer_OnOwnProposal_Call {
	_c.Run(run)
	return _c
}

// OnOwnTimeout provides a mock function for the type CommunicatorConsumer
func (_mock *CommunicatorConsumer) OnOwnTimeout(timeout *model.TimeoutObject) {
	_mock.Called(timeout)
	return
}

// CommunicatorConsumer_OnOwnTimeout_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnOwnTimeout'
type CommunicatorConsumer_OnOwnTimeout_Call struct {
	*mock.Call
}

// OnOwnTimeout is a helper method to define mock.On call
//   - timeout *model.TimeoutObject
func (_e *CommunicatorConsumer_Expecter) OnOwnTimeout(timeout interface{}) *CommunicatorConsumer_OnOwnTimeout_Call {
	return &CommunicatorConsumer_OnOwnTimeout_Call{Call: _e.mock.On("OnOwnTimeout", timeout)}
}

func (_c *CommunicatorConsumer_OnOwnTimeout_Call) Run(run func(timeout *model.TimeoutObject)) *CommunicatorConsumer_OnOwnTimeout_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.TimeoutObject
		if args[0] != nil {
			arg0 = args[0].(*model.TimeoutObject)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *CommunicatorConsumer_OnOwnTimeout_Call) Return() *CommunicatorConsumer_OnOwnTimeout_Call {
	_c.Call.Return()
	return _c
}

func (_c *CommunicatorConsumer_OnOwnTimeout_Call) RunAndReturn(run func(timeout *model.TimeoutObject)) *CommunicatorConsumer_OnOwnTimeout_Call {
	_c.Run(run)
	return _c
}

// OnOwnVote provides a mock function for the type CommunicatorConsumer
func (_mock *CommunicatorConsumer) OnOwnVote(vote *model.Vote, recipientID flow.Identifier) {
	_mock.Called(vote, recipientID)
	return
}

// CommunicatorConsumer_OnOwnVote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnOwnVote'
type CommunicatorConsumer_OnOwnVote_Call struct {
	*mock.Call
}

// OnOwnVote is a helper method to define mock.On call
//   - vote *model.Vote
//   - recipientID flow.Identifier
func (_e *CommunicatorConsumer_Expecter) OnOwnVote(vote interface{}, recipientID interface{}) *CommunicatorConsumer_OnOwnVote_Call {
	return &CommunicatorConsumer_OnOwnVote_Call{Call: _e.mock.On("OnOwnVote", vote, recipientID)}
}

func (_c *CommunicatorConsumer_OnOwnVote_Call) Run(run func(vote *model.Vote, recipientID flow.Identifier)) *CommunicatorConsumer_OnOwnVote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Vote
		if args[0] != nil {
			arg0 = args[0].(*model.Vote)
		}
		var arg1 flow.Identifier
		if args[1] != nil {
			arg1 = args[1].(flow.Identifier)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *CommunicatorConsumer_OnOwnVote_Call) Return() *CommunicatorConsumer_OnOwnVote_Call {
	_c.Call.Return()
	return _c
}

func (_c *CommunicatorConsumer_OnOwnVote_Call) RunAndReturn(run func(vote *model.Vote, recipientID flow.Identifier)) *CommunicatorConsumer_OnOwnVote_Call {
	_c.Run(run)
	return _c
}

// NewFollowerConsumer creates a new instance of FollowerConsumer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewFollowerConsumer(t interface {
	mock.TestingT
	Cleanup(func())
}) *FollowerConsumer {
	mock := &FollowerConsumer{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// FollowerConsumer is an autogenerated mock type for the FollowerConsumer type
type FollowerConsumer struct {
	mock.Mock
}

type FollowerConsumer_Expecter struct {
	mock *mock.Mock
}

func (_m *FollowerConsumer) EXPECT() *FollowerConsumer_Expecter {
	return &FollowerConsumer_Expecter{mock: &_m.Mock}
}

// OnBlockIncorporated provides a mock function for the type FollowerConsumer
func (_mock *FollowerConsumer) OnBlockIncorporated(block *model.Block) {
	_mock.Called(block)
	return
}

// FollowerConsumer_OnBlockIncorporated_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnBlockIncorporated'
type FollowerConsumer_OnBlockIncorporated_Call struct {
	*mock.Call
}

// OnBlockIncorporated is a helper method to define mock.On call
//   - block *model.Block
func (_e *FollowerConsumer_Expecter) OnBlockIncorporated(block interface{}) *FollowerConsumer_OnBlockIncorporated_Call {
	return &FollowerConsumer_OnBlockIncorporated_Call{Call: _e.mock.On("OnBlockIncorporated", block)}
}

func (_c *FollowerConsumer_OnBlockIncorporated_Call) Run(run func(block *model.Block)) *FollowerConsumer_OnBlockIncorporated_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Block
		if args[0] != nil {
			arg0 = args[0].(*model.Block)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *FollowerConsumer_OnBlockIncorporated_Call) Return() *FollowerConsumer_OnBlockIncorporated_Call {
	_c.Call.Return()
	return _c
}

func (_c *FollowerConsumer_OnBlockIncorporated_Call) RunAndReturn(run func(block *model.Block)) *FollowerConsumer_OnBlockIncorporated_Call {
	_c.Run(run)
	return _c
}

// OnDoubleProposeDetected provides a mock function for the type FollowerConsumer
func (_mock *FollowerConsumer) OnDoubleProposeDetected(block *model.Block, block1 *model.Block) {
	_mock.Called(block, block1)
	return
}

// FollowerConsumer_OnDoubleProposeDetected_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnDoubleProposeDetected'
type FollowerConsumer_OnDoubleProposeDetected_Call struct {
	*mock.Call
}

// OnDoubleProposeDetected is a helper method to define mock.On call
//   - block *model.Block
//   - block1 *model.Block
func (_e *FollowerConsumer_Expecter) OnDoubleProposeDetected(block interface{}, block1 interface{}) *FollowerConsumer_OnDoubleProposeDetected_Call {
	return &FollowerConsumer_OnDoubleProposeDetected_Call{Call: _e.mock.On("OnDoubleProposeDetected", block, block1)}
}

func (_c *FollowerConsumer_OnDoubleProposeDetected_Call) Run(run func(block *model.Block, block1 *model.Block)) *FollowerConsumer_OnDoubleProposeDetected_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Block
		if args[0] != nil {
			arg0 = args[0].(*model.Block)
		}
		var arg1 *model.Block
		if args[1] != nil {
			arg1 = args[1].(*model.Block)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *FollowerConsumer_OnDoubleProposeDetected_Call) Return() *FollowerConsumer_OnDoubleProposeDetected_Call {
	_c.Call.Return()
	return _c
}

func (_c *FollowerConsumer_OnDoubleProposeDetected_Call) RunAndReturn(run func(block *model.Block, block1 *model.Block)) *FollowerConsumer_OnDoubleProposeDetected_Call {
	_c.Run(run)
	return _c
}

// OnFinalizedBlock provides a mock function for the type FollowerConsumer
func (_mock *FollowerConsumer) OnFinalizedBlock(block *model.Block) {
	_mock.Called(block)
	return
}

// FollowerConsumer_OnFinalizedBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnFinalizedBlock'
type FollowerConsumer_OnFinalizedBlock_Call struct {
	*mock.Call
}

// OnFinalizedBlock is a helper method to define mock.On call
//   - block *model.Block
func (_e *FollowerConsumer_Expecter) OnFinalizedBlock(block interface{}) *FollowerConsumer_OnFinalizedBlock_Call {
	return &FollowerConsumer_OnFinalizedBlock_Call{Call: _e.mock.On("OnFinalizedBlock", block)}
}

func (_c *FollowerConsumer_OnFinalizedBlock_Call) Run(run func(block *model.Block)) *FollowerConsumer_OnFinalizedBlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Block
		if args[0] != nil {
			arg0 = args[0].(*model.Block)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *FollowerConsumer_OnFinalizedBlock_Call) Return() *FollowerConsumer_OnFinalizedBlock_Call {
	_c.Call.Return()
	return _c
}

func (_c *FollowerConsumer_OnFinalizedBlock_Call) RunAndReturn(run func(block *model.Block)) *FollowerConsumer_OnFinalizedBlock_Call {
	_c.Run(run)
	return _c
}

// OnInvalidBlockDetected provides a mock function for the type FollowerConsumer
func (_mock *FollowerConsumer) OnInvalidBlockDetected(err flow.Slashable[model.InvalidProposalError]) {
	_mock.Called(err)
	return
}

// FollowerConsumer_OnInvalidBlockDetected_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnInvalidBlockDetected'
type FollowerConsumer_OnInvalidBlockDetected_Call struct {
	*mock.Call
}

// OnInvalidBlockDetected is a helper method to define mock.On call
//   - err flow.Slashable[model.InvalidProposalError]
func (_e *FollowerConsumer_Expecter) OnInvalidBlockDetected(err interface{}) *FollowerConsumer_OnInvalidBlockDetected_Call {
	return &FollowerConsumer_OnInvalidBlockDetected_Call{Call: _e.mock.On("OnInvalidBlockDetected", err)}
}

func (_c *FollowerConsumer_OnInvalidBlockDetected_Call) Run(run func(err flow.Slashable[model.InvalidProposalError])) *FollowerConsumer_OnInvalidBlockDetected_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Slashable[model.InvalidProposalError]
		if args[0] != nil {
			arg0 = args[0].(flow.Slashable[model.InvalidProposalError])
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *FollowerConsumer_OnInvalidBlockDetected_Call) Return() *FollowerConsumer_OnInvalidBlockDetected_Call {
	_c.Call.Return()
	return _c
}

func (_c *FollowerConsumer_OnInvalidBlockDetected_Call) RunAndReturn(run func(err flow.Slashable[model.InvalidProposalError])) *FollowerConsumer_OnInvalidBlockDetected_Call {
	_c.Run(run)
	return _c
}

// NewConsumer creates a new instance of Consumer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewConsumer(t interface {
	mock.TestingT
	Cleanup(func())
}) *Consumer {
	mock := &Consumer{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Consumer is an autogenerated mock type for the Consumer type
type Consumer struct {
	mock.Mock
}

type Consumer_Expecter struct {
	mock *mock.Mock
}

func (_m *Consumer) EXPECT() *Consumer_Expecter {
	return &Consumer_Expecter{mock: &_m.Mock}
}

// OnBlockIncorporated provides a mock function for the type Consumer
func (_mock *Consumer) OnBlockIncorporated(block *model.Block) {
	_mock.Called(block)
	return
}

// Consumer_OnBlockIncorporated_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnBlockIncorporated'
type Consumer_OnBlockIncorporated_Call struct {
	*mock.Call
}

// OnBlockIncorporated is a helper method to define mock.On call
//   - block *model.Block
func (_e *Consumer_Expecter) OnBlockIncorporated(block interface{}) *Consumer_OnBlockIncorporated_Call {
	return &Consumer_OnBlockIncorporated_Call{Call: _e.mock.On("OnBlockIncorporated", block)}
}

func (_c *Consumer_OnBlockIncorporated_Call) Run(run func(block *model.Block)) *Consumer_OnBlockIncorporated_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Block
		if args[0] != nil {
			arg0 = args[0].(*model.Block)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Consumer_OnBlockIncorporated_Call) Return() *Consumer_OnBlockIncorporated_Call {
	_c.Call.Return()
	return _c
}

func (_c *Consumer_OnBlockIncorporated_Call) RunAndReturn(run func(block *model.Block)) *Consumer_OnBlockIncorporated_Call {
	_c.Run(run)
	return _c
}

// OnCurrentViewDetails provides a mock function for the type Consumer
func (_mock *Consumer) OnCurrentViewDetails(currentView uint64, finalizedView uint64, currentLeader flow.Identifier) {
	_mock.Called(currentView, finalizedView, currentLeader)
	return
}

// Consumer_OnCurrentViewDetails_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnCurrentViewDetails'
type Consumer_OnCurrentViewDetails_Call struct {
	*mock.Call
}

// OnCurrentViewDetails is a helper method to define mock.On call
//   - currentView uint64
//   - finalizedView uint64
//   - currentLeader flow.Identifier
func (_e *Consumer_Expecter) OnCurrentViewDetails(currentView interface{}, finalizedView interface{}, currentLeader interface{}) *Consumer_OnCurrentViewDetails_Call {
	return &Consumer_OnCurrentViewDetails_Call{Call: _e.mock.On("OnCurrentViewDetails", currentView, finalizedView, currentLeader)}
}

func (_c *Consumer_OnCurrentViewDetails_Call) Run(run func(currentView uint64, finalizedView uint64, currentLeader flow.Identifier)) *Consumer_OnCurrentViewDetails_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		var arg1 uint64
		if args[1] != nil {
			arg1 = args[1].(uint64)
		}
		var arg2 flow.Identifier
		if args[2] != nil {
			arg2 = args[2].(flow.Identifier)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Consumer_OnCurrentViewDetails_Call) Return() *Consumer_OnCurrentViewDetails_Call {
	_c.Call.Return()
	return _c
}

func (_c *Consumer_OnCurrentViewDetails_Call) RunAndReturn(run func(currentView uint64, finalizedView uint64, currentLeader flow.Identifier)) *Consumer_OnCurrentViewDetails_Call {
	_c.Run(run)
	return _c
}

// OnDoubleProposeDetected provides a mock function for the type Consumer
func (_mock *Consumer) OnDoubleProposeDetected(block *model.Block, block1 *model.Block) {
	_mock.Called(block, block1)
	return
}

// Consumer_OnDoubleProposeDetected_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnDoubleProposeDetected'
type Consumer_OnDoubleProposeDetected_Call struct {
	*mock.Call
}

// OnDoubleProposeDetected is a helper method to define mock.On call
//   - block *model.Block
//   - block1 *model.Block
func (_e *Consumer_Expecter) OnDoubleProposeDetected(block interface{}, block1 interface{}) *Consumer_OnDoubleProposeDetected_Call {
	return &Consumer_OnDoubleProposeDetected_Call{Call: _e.mock.On("OnDoubleProposeDetected", block, block1)}
}

func (_c *Consumer_OnDoubleProposeDetected_Call) Run(run func(block *model.Block, block1 *model.Block)) *Consumer_OnDoubleProposeDetected_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Block
		if args[0] != nil {
			arg0 = args[0].(*model.Block)
		}
		var arg1 *model.Block
		if args[1] != nil {
			arg1 = args[1].(*model.Block)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Consumer_OnDoubleProposeDetected_Call) Return() *Consumer_OnDoubleProposeDetected_Call {
	_c.Call.Return()
	return _c
}

func (_c *Consumer_OnDoubleProposeDetected_Call) RunAndReturn(run func(block *model.Block, block1 *model.Block)) *Consumer_OnDoubleProposeDetected_Call {
	_c.Run(run)
	return _c
}

// OnEventProcessed provides a mock function for the type Consumer
func (_mock *Consumer) OnEventProcessed() {
	_mock.Called()
	return
}

// Consumer_OnEventProcessed_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnEventProcessed'
type Consumer_OnEventProcessed_Call struct {
	*mock.Call
}

// OnEventProcessed is a helper method to define mock.On call
func (_e *Consumer_Expecter) OnEventProcessed() *Consumer_OnEventProcessed_Call {
	return &Consumer_OnEventProcessed_Call{Call: _e.mock.On("OnEventProcessed")}
}

func (_c *Consumer_OnEventProcessed_Call) Run(run func()) *Consumer_OnEventProcessed_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Consumer_OnEventProcessed_Call) Return() *Consumer_OnEventProcessed_Call {
	_c.Call.Return()
	return _c
}

func (_c *Consumer_OnEventProcessed_Call) RunAndReturn(run func()) *Consumer_OnEventProcessed_Call {
	_c.Run(run)
	return _c
}

// OnFinalizedBlock provides a mock function for the type Consumer
func (_mock *Consumer) OnFinalizedBlock(block *model.Block) {
	_mock.Called(block)
	return
}

// Consumer_OnFinalizedBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnFinalizedBlock'
type Consumer_OnFinalizedBlock_Call struct {
	*mock.Call
}

// OnFinalizedBlock is a helper method to define mock.On call
//   - block *model.Block
func (_e *Consumer_Expecter) OnFinalizedBlock(block interface{}) *Consumer_OnFinalizedBlock_Call {
	return &Consumer_OnFinalizedBlock_Call{Call: _e.mock.On("OnFinalizedBlock", block)}
}

func (_c *Consumer_OnFinalizedBlock_Call) Run(run func(block *model.Block)) *Consumer_OnFinalizedBlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Block
		if args[0] != nil {
			arg0 = args[0].(*model.Block)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Consumer_OnFinalizedBlock_Call) Return() *Consumer_OnFinalizedBlock_Call {
	_c.Call.Return()
	return _c
}

func (_c *Consumer_OnFinalizedBlock_Call) RunAndReturn(run func(block *model.Block)) *Consumer_OnFinalizedBlock_Call {
	_c.Run(run)
	return _c
}

// OnInvalidBlockDetected provides a mock function for the type Consumer
func (_mock *Consumer) OnInvalidBlockDetected(err flow.Slashable[model.InvalidProposalError]) {
	_mock.Called(err)
	return
}

// Consumer_OnInvalidBlockDetected_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnInvalidBlockDetected'
type Consumer_OnInvalidBlockDetected_Call struct {
	*mock.Call
}

// OnInvalidBlockDetected is a helper method to define mock.On call
//   - err flow.Slashable[model.InvalidProposalError]
func (_e *Consumer_Expecter) OnInvalidBlockDetected(err interface{}) *Consumer_OnInvalidBlockDetected_Call {
	return &Consumer_OnInvalidBlockDetected_Call{Call: _e.mock.On("OnInvalidBlockDetected", err)}
}

func (_c *Consumer_OnInvalidBlockDetected_Call) Run(run func(err flow.Slashable[model.InvalidProposalError])) *Consumer_OnInvalidBlockDetected_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Slashable[model.InvalidProposalError]
		if args[0] != nil {
			arg0 = args[0].(flow.Slashable[model.InvalidProposalError])
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Consumer_OnInvalidBlockDetected_Call) Return() *Consumer_OnInvalidBlockDetected_Call {
	_c.Call.Return()
	return _c
}

func (_c *Consumer_OnInvalidBlockDetected_Call) RunAndReturn(run func(err flow.Slashable[model.InvalidProposalError])) *Consumer_OnInvalidBlockDetected_Call {
	_c.Run(run)
	return _c
}

// OnLocalTimeout provides a mock function for the type Consumer
func (_mock *Consumer) OnLocalTimeout(currentView uint64) {
	_mock.Called(currentView)
	return
}

// Consumer_OnLocalTimeout_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnLocalTimeout'
type Consumer_OnLocalTimeout_Call struct {
	*mock.Call
}

// OnLocalTimeout is a helper method to define mock.On call
//   - currentView uint64
func (_e *Consumer_Expecter) OnLocalTimeout(currentView interface{}) *Consumer_OnLocalTimeout_Call {
	return &Consumer_OnLocalTimeout_Call{Call: _e.mock.On("OnLocalTimeout", currentView)}
}

func (_c *Consumer_OnLocalTimeout_Call) Run(run func(currentView uint64)) *Consumer_OnLocalTimeout_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Consumer_OnLocalTimeout_Call) Return() *Consumer_OnLocalTimeout_Call {
	_c.Call.Return()
	return _c
}

func (_c *Consumer_OnLocalTimeout_Call) RunAndReturn(run func(currentView uint64)) *Consumer_OnLocalTimeout_Call {
	_c.Run(run)
	return _c
}

// OnOwnProposal provides a mock function for the type Consumer
func (_mock *Consumer) OnOwnProposal(proposal *flow.ProposalHeader, targetPublicationTime time.Time) {
	_mock.Called(proposal, targetPublicationTime)
	return
}

// Consumer_OnOwnProposal_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnOwnProposal'
type Consumer_OnOwnProposal_Call struct {
	*mock.Call
}

// OnOwnProposal is a helper method to define mock.On call
//   - proposal *flow.ProposalHeader
//   - targetPublicationTime time.Time
func (_e *Consumer_Expecter) OnOwnProposal(proposal interface{}, targetPublicationTime interface{}) *Consumer_OnOwnProposal_Call {
	return &Consumer_OnOwnProposal_Call{Call: _e.mock.On("OnOwnProposal", proposal, targetPublicationTime)}
}

func (_c *Consumer_OnOwnProposal_Call) Run(run func(proposal *flow.ProposalHeader, targetPublicationTime time.Time)) *Consumer_OnOwnProposal_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *flow.ProposalHeader
		if args[0] != nil {
			arg0 = args[0].(*flow.ProposalHeader)
		}
		var arg1 time.Time
		if args[1] != nil {
			arg1 = args[1].(time.Time)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Consumer_OnOwnProposal_Call) Return() *Consumer_OnOwnProposal_Call {
	_c.Call.Return()
	return _c
}

func (_c *Consumer_OnOwnProposal_Call) RunAndReturn(run func(proposal *flow.ProposalHeader, targetPublicationTime time.Time)) *Consumer_OnOwnProposal_Call {
	_c.Run(run)
	return _c
}

// OnOwnTimeout provides a mock function for the type Consumer
func (_mock *Consumer) OnOwnTimeout(timeout *model.TimeoutObject) {
	_mock.Called(timeout)
	return
}

// Consumer_OnOwnTimeout_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnOwnTimeout'
type Consumer_OnOwnTimeout_Call struct {
	*mock.Call
}

// OnOwnTimeout is a helper method to define mock.On call
//   - timeout *model.TimeoutObject
func (_e *Consumer_Expecter) OnOwnTimeout(timeout interface{}) *Consumer_OnOwnTimeout_Call {
	return &Consumer_OnOwnTimeout_Call{Call: _e.mock.On("OnOwnTimeout", timeout)}
}

func (_c *Consumer_OnOwnTimeout_Call) Run(run func(timeout *model.TimeoutObject)) *Consumer_OnOwnTimeout_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.TimeoutObject
		if args[0] != nil {
			arg0 = args[0].(*model.TimeoutObject)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Consumer_OnOwnTimeout_Call) Return() *Consumer_OnOwnTimeout_Call {
	_c.Call.Return()
	return _c
}

func (_c *Consumer_OnOwnTimeout_Call) RunAndReturn(run func(timeout *model.TimeoutObject)) *Consumer_OnOwnTimeout_Call {
	_c.Run(run)
	return _c
}

// OnOwnVote provides a mock function for the type Consumer
func (_mock *Consumer) OnOwnVote(vote *model.Vote, recipientID flow.Identifier) {
	_mock.Called(vote, recipientID)
	return
}

// Consumer_OnOwnVote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnOwnVote'
type Consumer_OnOwnVote_Call struct {
	*mock.Call
}

// OnOwnVote is a helper method to define mock.On call
//   - vote *model.Vote
//   - recipientID flow.Identifier
func (_e *Consumer_Expecter) OnOwnVote(vote interface{}, recipientID interface{}) *Consumer_OnOwnVote_Call {
	return &Consumer_OnOwnVote_Call{Call: _e.mock.On("OnOwnVote", vote, recipientID)}
}

func (_c *Consumer_OnOwnVote_Call) Run(run func(vote *model.Vote, recipientID flow.Identifier)) *Consumer_OnOwnVote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Vote
		if args[0] != nil {
			arg0 = args[0].(*model.Vote)
		}
		var arg1 flow.Identifier
		if args[1] != nil {
			arg1 = args[1].(flow.Identifier)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Consumer_OnOwnVote_Call) Return() *Consumer_OnOwnVote_Call {
	_c.Call.Return()
	return _c
}

func (_c *Consumer_OnOwnVote_Call) RunAndReturn(run func(vote *model.Vote, recipientID flow.Identifier)) *Consumer_OnOwnVote_Call {
	_c.Run(run)
	return _c
}

// OnPartialTc provides a mock function for the type Consumer
func (_mock *Consumer) OnPartialTc(currentView uint64, partialTc *hotstuff.PartialTcCreated) {
	_mock.Called(currentView, partialTc)
	return
}

// Consumer_OnPartialTc_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnPartialTc'
type Consumer_OnPartialTc_Call struct {
	*mock.Call
}

// OnPartialTc is a helper method to define mock.On call
//   - currentView uint64
//   - partialTc *hotstuff.PartialTcCreated
func (_e *Consumer_Expecter) OnPartialTc(currentView interface{}, partialTc interface{}) *Consumer_OnPartialTc_Call {
	return &Consumer_OnPartialTc_Call{Call: _e.mock.On("OnPartialTc", currentView, partialTc)}
}

func (_c *Consumer_OnPartialTc_Call) Run(run func(currentView uint64, partialTc *hotstuff.PartialTcCreated)) *Consumer_OnPartialTc_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		var arg1 *hotstuff.PartialTcCreated
		if args[1] != nil {
			arg1 = args[1].(*hotstuff.PartialTcCreated)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Consumer_OnPartialTc_Call) Return() *Consumer_OnPartialTc_Call {
	_c.Call.Return()
	return _c
}

func (_c *Consumer_OnPartialTc_Call) RunAndReturn(run func(currentView uint64, partialTc *hotstuff.PartialTcCreated)) *Consumer_OnPartialTc_Call {
	_c.Run(run)
	return _c
}

// OnQcTriggeredViewChange provides a mock function for the type Consumer
func (_mock *Consumer) OnQcTriggeredViewChange(oldView uint64, newView uint64, qc *flow.QuorumCertificate) {
	_mock.Called(oldView, newView, qc)
	return
}

// Consumer_OnQcTriggeredViewChange_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnQcTriggeredViewChange'
type Consumer_OnQcTriggeredViewChange_Call struct {
	*mock.Call
}

// OnQcTriggeredViewChange is a helper method to define mock.On call
//   - oldView uint64
//   - newView uint64
//   - qc *flow.QuorumCertificate
func (_e *Consumer_Expecter) OnQcTriggeredViewChange(oldView interface{}, newView interface{}, qc interface{}) *Consumer_OnQcTriggeredViewChange_Call {
	return &Consumer_OnQcTriggeredViewChange_Call{Call: _e.mock.On("OnQcTriggeredViewChange", oldView, newView, qc)}
}

func (_c *Consumer_OnQcTriggeredViewChange_Call) Run(run func(oldView uint64, newView uint64, qc *flow.QuorumCertificate)) *Consumer_OnQcTriggeredViewChange_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		var arg1 uint64
		if args[1] != nil {
			arg1 = args[1].(uint64)
		}
		var arg2 *flow.QuorumCertificate
		if args[2] != nil {
			arg2 = args[2].(*flow.QuorumCertificate)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Consumer_OnQcTriggeredViewChange_Call) Return() *Consumer_OnQcTriggeredViewChange_Call {
	_c.Call.Return()
	return _c
}

func (_c *Consumer_OnQcTriggeredViewChange_Call) RunAndReturn(run func(oldView uint64, newView uint64, qc *flow.QuorumCertificate)) *Consumer_OnQcTriggeredViewChange_Call {
	_c.Run(run)
	return _c
}

// OnReceiveProposal provides a mock function for the type Consumer
func (_mock *Consumer) OnReceiveProposal(currentView uint64, proposal *model.SignedProposal) {
	_mock.Called(currentView, proposal)
	return
}

// Consumer_OnReceiveProposal_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnReceiveProposal'
type Consumer_OnReceiveProposal_Call struct {
	*mock.Call
}

// OnReceiveProposal is a helper method to define mock.On call
//   - currentView uint64
//   - proposal *model.SignedProposal
func (_e *Consumer_Expecter) OnReceiveProposal(currentView interface{}, proposal interface{}) *Consumer_OnReceiveProposal_Call {
	return &Consumer_OnReceiveProposal_Call{Call: _e.mock.On("OnReceiveProposal", currentView, proposal)}
}

func (_c *Consumer_OnReceiveProposal_Call) Run(run func(currentView uint64, proposal *model.SignedProposal)) *Consumer_OnReceiveProposal_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		var arg1 *model.SignedProposal
		if args[1] != nil {
			arg1 = args[1].(*model.SignedProposal)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Consumer_OnReceiveProposal_Call) Return() *Consumer_OnReceiveProposal_Call {
	_c.Call.Return()
	return _c
}

func (_c *Consumer_OnReceiveProposal_Call) RunAndReturn(run func(currentView uint64, proposal *model.SignedProposal)) *Consumer_OnReceiveProposal_Call {
	_c.Run(run)
	return _c
}

// OnReceiveQc provides a mock function for the type Consumer
func (_mock *Consumer) OnReceiveQc(currentView uint64, qc *flow.QuorumCertificate) {
	_mock.Called(currentView, qc)
	return
}

// Consumer_OnReceiveQc_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnReceiveQc'
type Consumer_OnReceiveQc_Call struct {
	*mock.Call
}

// OnReceiveQc is a helper method to define mock.On call
//   - currentView uint64
//   - qc *flow.QuorumCertificate
func (_e *Consumer_Expecter) OnReceiveQc(currentView interface{}, qc interface{}) *Consumer_OnReceiveQc_Call {
	return &Consumer_OnReceiveQc_Call{Call: _e.mock.On("OnReceiveQc", currentView, qc)}
}

func (_c *Consumer_OnReceiveQc_Call) Run(run func(currentView uint64, qc *flow.QuorumCertificate)) *Consumer_OnReceiveQc_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		var arg1 *flow.QuorumCertificate
		if args[1] != nil {
			arg1 = args[1].(*flow.QuorumCertificate)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Consumer_OnReceiveQc_Call) Return() *Consumer_OnReceiveQc_Call {
	_c.Call.Return()
	return _c
}

func (_c *Consumer_OnReceiveQc_Call) RunAndReturn(run func(currentView uint64, qc *flow.QuorumCertificate)) *Consumer_OnReceiveQc_Call {
	_c.Run(run)
	return _c
}

// OnReceiveTc provides a mock function for the type Consumer
func (_mock *Consumer) OnReceiveTc(currentView uint64, tc *flow.TimeoutCertificate) {
	_mock.Called(currentView, tc)
	return
}

// Consumer_OnReceiveTc_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnReceiveTc'
type Consumer_OnReceiveTc_Call struct {
	*mock.Call
}

// OnReceiveTc is a helper method to define mock.On call
//   - currentView uint64
//   - tc *flow.TimeoutCertificate
func (_e *Consumer_Expecter) OnReceiveTc(currentView interface{}, tc interface{}) *Consumer_OnReceiveTc_Call {
	return &Consumer_OnReceiveTc_Call{Call: _e.mock.On("OnReceiveTc", currentView, tc)}
}

func (_c *Consumer_OnReceiveTc_Call) Run(run func(currentView uint64, tc *flow.TimeoutCertificate)) *Consumer_OnReceiveTc_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		var arg1 *flow.TimeoutCertificate
		if args[1] != nil {
			arg1 = args[1].(*flow.TimeoutCertificate)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Consumer_OnReceiveTc_Call) Return() *Consumer_OnReceiveTc_Call {
	_c.Call.Return()
	return _c
}

func (_c *Consumer_OnReceiveTc_Call) RunAndReturn(run func(currentView uint64, tc *flow.TimeoutCertificate)) *Consumer_OnReceiveTc_Call {
	_c.Run(run)
	return _c
}

// OnStart provides a mock function for the type Consumer
func (_mock *Consumer) OnStart(currentView uint64) {
	_mock.Called(currentView)
	return
}

// Consumer_OnStart_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnStart'
type Consumer_OnStart_Call struct {
	*mock.Call
}

// OnStart is a helper method to define mock.On call
//   - currentView uint64
func (_e *Consumer_Expecter) OnStart(currentView interface{}) *Consumer_OnStart_Call {
	return &Consumer_OnStart_Call{Call: _e.mock.On("OnStart", currentView)}
}

func (_c *Consumer_OnStart_Call) Run(run func(currentView uint64)) *Consumer_OnStart_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Consumer_OnStart_Call) Return() *Consumer_OnStart_Call {
	_c.Call.Return()
	return _c
}

func (_c *Consumer_OnStart_Call) RunAndReturn(run func(currentView uint64)) *Consumer_OnStart_Call {
	_c.Run(run)
	return _c
}

// OnStartingTimeout provides a mock function for the type Consumer
func (_mock *Consumer) OnStartingTimeout(timerInfo model.TimerInfo) {
	_mock.Called(timerInfo)
	return
}

// Consumer_OnStartingTimeout_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnStartingTimeout'
type Consumer_OnStartingTimeout_Call struct {
	*mock.Call
}

// OnStartingTimeout is a helper method to define mock.On call
//   - timerInfo model.TimerInfo
func (_e *Consumer_Expecter) OnStartingTimeout(timerInfo interface{}) *Consumer_OnStartingTimeout_Call {
	return &Consumer_OnStartingTimeout_Call{Call: _e.mock.On("OnStartingTimeout", timerInfo)}
}

func (_c *Consumer_OnStartingTimeout_Call) Run(run func(timerInfo model.TimerInfo)) *Consumer_OnStartingTimeout_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 model.TimerInfo
		if args[0] != nil {
			arg0 = args[0].(model.TimerInfo)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Consumer_OnStartingTimeout_Call) Return() *Consumer_OnStartingTimeout_Call {
	_c.Call.Return()
	return _c
}

func (_c *Consumer_OnStartingTimeout_Call) RunAndReturn(run func(timerInfo model.TimerInfo)) *Consumer_OnStartingTimeout_Call {
	_c.Run(run)
	return _c
}

// OnTcTriggeredViewChange provides a mock function for the type Consumer
func (_mock *Consumer) OnTcTriggeredViewChange(oldView uint64, newView uint64, tc *flow.TimeoutCertificate) {
	_mock.Called(oldView, newView, tc)
	return
}

// Consumer_OnTcTriggeredViewChange_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnTcTriggeredViewChange'
type Consumer_OnTcTriggeredViewChange_Call struct {
	*mock.Call
}

// OnTcTriggeredViewChange is a helper method to define mock.On call
//   - oldView uint64
//   - newView uint64
//   - tc *flow.TimeoutCertificate
func (_e *Consumer_Expecter) OnTcTriggeredViewChange(oldView interface{}, newView interface{}, tc interface{}) *Consumer_OnTcTriggeredViewChange_Call {
	return &Consumer_OnTcTriggeredViewChange_Call{Call: _e.mock.On("OnTcTriggeredViewChange", oldView, newView, tc)}
}

func (_c *Consumer_OnTcTriggeredViewChange_Call) Run(run func(oldView uint64, newView uint64, tc *flow.TimeoutCertificate)) *Consumer_OnTcTriggeredViewChange_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		var arg1 uint64
		if args[1] != nil {
			arg1 = args[1].(uint64)
		}
		var arg2 *flow.TimeoutCertificate
		if args[2] != nil {
			arg2 = args[2].(*flow.TimeoutCertificate)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Consumer_OnTcTriggeredViewChange_Call) Return() *Consumer_OnTcTriggeredViewChange_Call {
	_c.Call.Return()
	return _c
}

func (_c *Consumer_OnTcTriggeredViewChange_Call) RunAndReturn(run func(oldView uint64, newView uint64, tc *flow.TimeoutCertificate)) *Consumer_OnTcTriggeredViewChange_Call {
	_c.Run(run)
	return _c
}

// OnViewChange provides a mock function for the type Consumer
func (_mock *Consumer) OnViewChange(oldView uint64, newView uint64) {
	_mock.Called(oldView, newView)
	return
}

// Consumer_OnViewChange_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnViewChange'
type Consumer_OnViewChange_Call struct {
	*mock.Call
}

// OnViewChange is a helper method to define mock.On call
//   - oldView uint64
//   - newView uint64
func (_e *Consumer_Expecter) OnViewChange(oldView interface{}, newView interface{}) *Consumer_OnViewChange_Call {
	return &Consumer_OnViewChange_Call{Call: _e.mock.On("OnViewChange", oldView, newView)}
}

func (_c *Consumer_OnViewChange_Call) Run(run func(oldView uint64, newView uint64)) *Consumer_OnViewChange_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		var arg1 uint64
		if args[1] != nil {
			arg1 = args[1].(uint64)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Consumer_OnViewChange_Call) Return() *Consumer_OnViewChange_Call {
	_c.Call.Return()
	return _c
}

func (_c *Consumer_OnViewChange_Call) RunAndReturn(run func(oldView uint64, newView uint64)) *Consumer_OnViewChange_Call {
	_c.Run(run)
	return _c
}

// NewVoteAggregationConsumer creates a new instance of VoteAggregationConsumer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewVoteAggregationConsumer(t interface {
	mock.TestingT
	Cleanup(func())
}) *VoteAggregationConsumer {
	mock := &VoteAggregationConsumer{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// VoteAggregationConsumer is an autogenerated mock type for the VoteAggregationConsumer type
type VoteAggregationConsumer struct {
	mock.Mock
}

type VoteAggregationConsumer_Expecter struct {
	mock *mock.Mock
}

func (_m *VoteAggregationConsumer) EXPECT() *VoteAggregationConsumer_Expecter {
	return &VoteAggregationConsumer_Expecter{mock: &_m.Mock}
}

// OnDoubleVotingDetected provides a mock function for the type VoteAggregationConsumer
func (_mock *VoteAggregationConsumer) OnDoubleVotingDetected(vote *model.Vote, vote1 *model.Vote) {
	_mock.Called(vote, vote1)
	return
}

// VoteAggregationConsumer_OnDoubleVotingDetected_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnDoubleVotingDetected'
type VoteAggregationConsumer_OnDoubleVotingDetected_Call struct {
	*mock.Call
}

// OnDoubleVotingDetected is a helper method to define mock.On call
//   - vote *model.Vote
//   - vote1 *model.Vote
func (_e *VoteAggregationConsumer_Expecter) OnDoubleVotingDetected(vote interface{}, vote1 interface{}) *VoteAggregationConsumer_OnDoubleVotingDetected_Call {
	return &VoteAggregationConsumer_OnDoubleVotingDetected_Call{Call: _e.mock.On("OnDoubleVotingDetected", vote, vote1)}
}

func (_c *VoteAggregationConsumer_OnDoubleVotingDetected_Call) Run(run func(vote *model.Vote, vote1 *model.Vote)) *VoteAggregationConsumer_OnDoubleVotingDetected_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Vote
		if args[0] != nil {
			arg0 = args[0].(*model.Vote)
		}
		var arg1 *model.Vote
		if args[1] != nil {
			arg1 = args[1].(*model.Vote)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *VoteAggregationConsumer_OnDoubleVotingDetected_Call) Return() *VoteAggregationConsumer_OnDoubleVotingDetected_Call {
	_c.Call.Return()
	return _c
}

func (_c *VoteAggregationConsumer_OnDoubleVotingDetected_Call) RunAndReturn(run func(vote *model.Vote, vote1 *model.Vote)) *VoteAggregationConsumer_OnDoubleVotingDetected_Call {
	_c.Run(run)
	return _c
}

// OnInvalidVoteDetected provides a mock function for the type VoteAggregationConsumer
func (_mock *VoteAggregationConsumer) OnInvalidVoteDetected(err model.InvalidVoteError) {
	_mock.Called(err)
	return
}

// VoteAggregationConsumer_OnInvalidVoteDetected_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnInvalidVoteDetected'
type VoteAggregationConsumer_OnInvalidVoteDetected_Call struct {
	*mock.Call
}

// OnInvalidVoteDetected is a helper method to define mock.On call
//   - err model.InvalidVoteError
func (_e *VoteAggregationConsumer_Expecter) OnInvalidVoteDetected(err interface{}) *VoteAggregationConsumer_OnInvalidVoteDetected_Call {
	return &VoteAggregationConsumer_OnInvalidVoteDetected_Call{Call: _e.mock.On("OnInvalidVoteDetected", err)}
}

func (_c *VoteAggregationConsumer_OnInvalidVoteDetected_Call) Run(run func(err model.InvalidVoteError)) *VoteAggregationConsumer_OnInvalidVoteDetected_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 model.InvalidVoteError
		if args[0] != nil {
			arg0 = args[0].(model.InvalidVoteError)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *VoteAggregationConsumer_OnInvalidVoteDetected_Call) Return() *VoteAggregationConsumer_OnInvalidVoteDetected_Call {
	_c.Call.Return()
	return _c
}

func (_c *VoteAggregationConsumer_OnInvalidVoteDetected_Call) RunAndReturn(run func(err model.InvalidVoteError)) *VoteAggregationConsumer_OnInvalidVoteDetected_Call {
	_c.Run(run)
	return _c
}

// OnQcConstructedFromVotes provides a mock function for the type VoteAggregationConsumer
func (_mock *VoteAggregationConsumer) OnQcConstructedFromVotes(quorumCertificate *flow.QuorumCertificate) {
	_mock.Called(quorumCertificate)
	return
}

// VoteAggregationConsumer_OnQcConstructedFromVotes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnQcConstructedFromVotes'
type VoteAggregationConsumer_OnQcConstructedFromVotes_Call struct {
	*mock.Call
}

// OnQcConstructedFromVotes is a helper method to define mock.On call
//   - quorumCertificate *flow.QuorumCertificate
func (_e *VoteAggregationConsumer_Expecter) OnQcConstructedFromVotes(quorumCertificate interface{}) *VoteAggregationConsumer_OnQcConstructedFromVotes_Call {
	return &VoteAggregationConsumer_OnQcConstructedFromVotes_Call{Call: _e.mock.On("OnQcConstructedFromVotes", quorumCertificate)}
}

func (_c *VoteAggregationConsumer_OnQcConstructedFromVotes_Call) Run(run func(quorumCertificate *flow.QuorumCertificate)) *VoteAggregationConsumer_OnQcConstructedFromVotes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *flow.QuorumCertificate
		if args[0] != nil {
			arg0 = args[0].(*flow.QuorumCertificate)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *VoteAggregationConsumer_OnQcConstructedFromVotes_Call) Return() *VoteAggregationConsumer_OnQcConstructedFromVotes_Call {
	_c.Call.Return()
	return _c
}

func (_c *VoteAggregationConsumer_OnQcConstructedFromVotes_Call) RunAndReturn(run func(quorumCertificate *flow.QuorumCertificate)) *VoteAggregationConsumer_OnQcConstructedFromVotes_Call {
	_c.Run(run)
	return _c
}

// OnVoteForInvalidBlockDetected provides a mock function for the type VoteAggregationConsumer
func (_mock *VoteAggregationConsumer) OnVoteForInvalidBlockDetected(vote *model.Vote, invalidProposal *model.SignedProposal) {
	_mock.Called(vote, invalidProposal)
	return
}

// VoteAggregationConsumer_OnVoteForInvalidBlockDetected_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnVoteForInvalidBlockDetected'
type VoteAggregationConsumer_OnVoteForInvalidBlockDetected_Call struct {
	*mock.Call
}

// OnVoteForInvalidBlockDetected is a helper method to define mock.On call
//   - vote *model.Vote
//   - invalidProposal *model.SignedProposal
func (_e *VoteAggregationConsumer_Expecter) OnVoteForInvalidBlockDetected(vote interface{}, invalidProposal interface{}) *VoteAggregationConsumer_OnVoteForInvalidBlockDetected_Call {
	return &VoteAggregationConsumer_OnVoteForInvalidBlockDetected_Call{Call: _e.mock.On("OnVoteForInvalidBlockDetected", vote, invalidProposal)}
}

func (_c *VoteAggregationConsumer_OnVoteForInvalidBlockDetected_Call) Run(run func(vote *model.Vote, invalidProposal *model.SignedProposal)) *VoteAggregationConsumer_OnVoteForInvalidBlockDetected_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Vote
		if args[0] != nil {
			arg0 = args[0].(*model.Vote)
		}
		var arg1 *model.SignedProposal
		if args[1] != nil {
			arg1 = args[1].(*model.SignedProposal)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *VoteAggregationConsumer_OnVoteForInvalidBlockDetected_Call) Return() *VoteAggregationConsumer_OnVoteForInvalidBlockDetected_Call {
	_c.Call.Return()
	return _c
}

func (_c *VoteAggregationConsumer_OnVoteForInvalidBlockDetected_Call) RunAndReturn(run func(vote *model.Vote, invalidProposal *model.SignedProposal)) *VoteAggregationConsumer_OnVoteForInvalidBlockDetected_Call {
	_c.Run(run)
	return _c
}

// OnVoteProcessed provides a mock function for the type VoteAggregationConsumer
func (_mock *VoteAggregationConsumer) OnVoteProcessed(vote *model.Vote) {
	_mock.Called(vote)
	return
}

// VoteAggregationConsumer_OnVoteProcessed_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnVoteProcessed'
type VoteAggregationConsumer_OnVoteProcessed_Call struct {
	*mock.Call
}

// OnVoteProcessed is a helper method to define mock.On call
//   - vote *model.Vote
func (_e *VoteAggregationConsumer_Expecter) OnVoteProcessed(vote interface{}) *VoteAggregationConsumer_OnVoteProcessed_Call {
	return &VoteAggregationConsumer_OnVoteProcessed_Call{Call: _e.mock.On("OnVoteProcessed", vote)}
}

func (_c *VoteAggregationConsumer_OnVoteProcessed_Call) Run(run func(vote *model.Vote)) *VoteAggregationConsumer_OnVoteProcessed_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Vote
		if args[0] != nil {
			arg0 = args[0].(*model.Vote)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *VoteAggregationConsumer_OnVoteProcessed_Call) Return() *VoteAggregationConsumer_OnVoteProcessed_Call {
	_c.Call.Return()
	return _c
}

func (_c *VoteAggregationConsumer_OnVoteProcessed_Call) RunAndReturn(run func(vote *model.Vote)) *VoteAggregationConsumer_OnVoteProcessed_Call {
	_c.Run(run)
	return _c
}

// NewTimeoutAggregationConsumer creates a new instance of TimeoutAggregationConsumer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewTimeoutAggregationConsumer(t interface {
	mock.TestingT
	Cleanup(func())
}) *TimeoutAggregationConsumer {
	mock := &TimeoutAggregationConsumer{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// TimeoutAggregationConsumer is an autogenerated mock type for the TimeoutAggregationConsumer type
type TimeoutAggregationConsumer struct {
	mock.Mock
}

type TimeoutAggregationConsumer_Expecter struct {
	mock *mock.Mock
}

func (_m *TimeoutAggregationConsumer) EXPECT() *TimeoutAggregationConsumer_Expecter {
	return &TimeoutAggregationConsumer_Expecter{mock: &_m.Mock}
}

// OnDoubleTimeoutDetected provides a mock function for the type TimeoutAggregationConsumer
func (_mock *TimeoutAggregationConsumer) OnDoubleTimeoutDetected(timeoutObject *model.TimeoutObject, timeoutObject1 *model.TimeoutObject) {
	_mock.Called(timeoutObject, timeoutObject1)
	return
}

// TimeoutAggregationConsumer_OnDoubleTimeoutDetected_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnDoubleTimeoutDetected'
type TimeoutAggregationConsumer_OnDoubleTimeoutDetected_Call struct {
	*mock.Call
}

// OnDoubleTimeoutDetected is a helper method to define mock.On call
//   - timeoutObject *model.TimeoutObject
//   - timeoutObject1 *model.TimeoutObject
func (_e *TimeoutAggregationConsumer_Expecter) OnDoubleTimeoutDetected(timeoutObject interface{}, timeoutObject1 interface{}) *TimeoutAggregationConsumer_OnDoubleTimeoutDetected_Call {
	return &TimeoutAggregationConsumer_OnDoubleTimeoutDetected_Call{Call: _e.mock.On("OnDoubleTimeoutDetected", timeoutObject, timeoutObject1)}
}

func (_c *TimeoutAggregationConsumer_OnDoubleTimeoutDetected_Call) Run(run func(timeoutObject *model.TimeoutObject, timeoutObject1 *model.TimeoutObject)) *TimeoutAggregationConsumer_OnDoubleTimeoutDetected_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.TimeoutObject
		if args[0] != nil {
			arg0 = args[0].(*model.TimeoutObject)
		}
		var arg1 *model.TimeoutObject
		if args[1] != nil {
			arg1 = args[1].(*model.TimeoutObject)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *TimeoutAggregationConsumer_OnDoubleTimeoutDetected_Call) Return() *TimeoutAggregationConsumer_OnDoubleTimeoutDetected_Call {
	_c.Call.Return()
	return _c
}

func (_c *TimeoutAggregationConsumer_OnDoubleTimeoutDetected_Call) RunAndReturn(run func(timeoutObject *model.TimeoutObject, timeoutObject1 *model.TimeoutObject)) *TimeoutAggregationConsumer_OnDoubleTimeoutDetected_Call {
	_c.Run(run)
	return _c
}

// OnInvalidTimeoutDetected provides a mock function for the type TimeoutAggregationConsumer
func (_mock *TimeoutAggregationConsumer) OnInvalidTimeoutDetected(err model.InvalidTimeoutError) {
	_mock.Called(err)
	return
}

// TimeoutAggregationConsumer_OnInvalidTimeoutDetected_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnInvalidTimeoutDetected'
type TimeoutAggregationConsumer_OnInvalidTimeoutDetected_Call struct {
	*mock.Call
}

// OnInvalidTimeoutDetected is a helper method to define mock.On call
//   - err model.InvalidTimeoutError
func (_e *TimeoutAggregationConsumer_Expecter) OnInvalidTimeoutDetected(err interface{}) *TimeoutAggregationConsumer_OnInvalidTimeoutDetected_Call {
	return &TimeoutAggregationConsumer_OnInvalidTimeoutDetected_Call{Call: _e.mock.On("OnInvalidTimeoutDetected", err)}
}

func (_c *TimeoutAggregationConsumer_OnInvalidTimeoutDetected_Call) Run(run func(err model.InvalidTimeoutError)) *TimeoutAggregationConsumer_OnInvalidTimeoutDetected_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 model.InvalidTimeoutError
		if args[0] != nil {
			arg0 = args[0].(model.InvalidTimeoutError)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *TimeoutAggregationConsumer_OnInvalidTimeoutDetected_Call) Return() *TimeoutAggregationConsumer_OnInvalidTimeoutDetected_Call {
	_c.Call.Return()
	return _c
}

func (_c *TimeoutAggregationConsumer_OnInvalidTimeoutDetected_Call) RunAndReturn(run func(err model.InvalidTimeoutError)) *TimeoutAggregationConsumer_OnInvalidTimeoutDetected_Call {
	_c.Run(run)
	return _c
}

// OnNewQcDiscovered provides a mock function for the type TimeoutAggregationConsumer
func (_mock *TimeoutAggregationConsumer) OnNewQcDiscovered(certificate *flow.QuorumCertificate) {
	_mock.Called(certificate)
	return
}

// TimeoutAggregationConsumer_OnNewQcDiscovered_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnNewQcDiscovered'
type TimeoutAggregationConsumer_OnNewQcDiscovered_Call struct {
	*mock.Call
}

// OnNewQcDiscovered is a helper method to define mock.On call
//   - certificate *flow.QuorumCertificate
func (_e *TimeoutAggregationConsumer_Expecter) OnNewQcDiscovered(certificate interface{}) *TimeoutAggregationConsumer_OnNewQcDiscovered_Call {
	return &TimeoutAggregationConsumer_OnNewQcDiscovered_Call{Call: _e.mock.On("OnNewQcDiscovered", certificate)}
}

func (_c *TimeoutAggregationConsumer_OnNewQcDiscovered_Call) Run(run func(certificate *flow.QuorumCertificate)) *TimeoutAggregationConsumer_OnNewQcDiscovered_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *flow.QuorumCertificate
		if args[0] != nil {
			arg0 = args[0].(*flow.QuorumCertificate)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *TimeoutAggregationConsumer_OnNewQcDiscovered_Call) Return() *TimeoutAggregationConsumer_OnNewQcDiscovered_Call {
	_c.Call.Return()
	return _c
}

func (_c *TimeoutAggregationConsumer_OnNewQcDiscovered_Call) RunAndReturn(run func(certificate *flow.QuorumCertificate)) *TimeoutAggregationConsumer_OnNewQcDiscovered_Call {
	_c.Run(run)
	return _c
}

// OnNewTcDiscovered provides a mock function for the type TimeoutAggregationConsumer
func (_mock *TimeoutAggregationConsumer) OnNewTcDiscovered(certificate *flow.TimeoutCertificate) {
	_mock.Called(certificate)
	return
}

// TimeoutAggregationConsumer_OnNewTcDiscovered_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnNewTcDiscovered'
type TimeoutAggregationConsumer_OnNewTcDiscovered_Call struct {
	*mock.Call
}

// OnNewTcDiscovered is a helper method to define mock.On call
//   - certificate *flow.TimeoutCertificate
func (_e *TimeoutAggregationConsumer_Expecter) OnNewTcDiscovered(certificate interface{}) *TimeoutAggregationConsumer_OnNewTcDiscovered_Call {
	return &TimeoutAggregationConsumer_OnNewTcDiscovered_Call{Call: _e.mock.On("OnNewTcDiscovered", certificate)}
}

func (_c *TimeoutAggregationConsumer_OnNewTcDiscovered_Call) Run(run func(certificate *flow.TimeoutCertificate)) *TimeoutAggregationConsumer_OnNewTcDiscovered_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *flow.TimeoutCertificate
		if args[0] != nil {
			arg0 = args[0].(*flow.TimeoutCertificate)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *TimeoutAggregationConsumer_OnNewTcDiscovered_Call) Return() *TimeoutAggregationConsumer_OnNewTcDiscovered_Call {
	_c.Call.Return()
	return _c
}

func (_c *TimeoutAggregationConsumer_OnNewTcDiscovered_Call) RunAndReturn(run func(certificate *flow.TimeoutCertificate)) *TimeoutAggregationConsumer_OnNewTcDiscovered_Call {
	_c.Run(run)
	return _c
}

// OnPartialTcCreated provides a mock function for the type TimeoutAggregationConsumer
func (_mock *TimeoutAggregationConsumer) OnPartialTcCreated(view uint64, newestQC *flow.QuorumCertificate, lastViewTC *flow.TimeoutCertificate) {
	_mock.Called(view, newestQC, lastViewTC)
	return
}

// TimeoutAggregationConsumer_OnPartialTcCreated_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnPartialTcCreated'
type TimeoutAggregationConsumer_OnPartialTcCreated_Call struct {
	*mock.Call
}

// OnPartialTcCreated is a helper method to define mock.On call
//   - view uint64
//   - newestQC *flow.QuorumCertificate
//   - lastViewTC *flow.TimeoutCertificate
func (_e *TimeoutAggregationConsumer_Expecter) OnPartialTcCreated(view interface{}, newestQC interface{}, lastViewTC interface{}) *TimeoutAggregationConsumer_OnPartialTcCreated_Call {
	return &TimeoutAggregationConsumer_OnPartialTcCreated_Call{Call: _e.mock.On("OnPartialTcCreated", view, newestQC, lastViewTC)}
}

func (_c *TimeoutAggregationConsumer_OnPartialTcCreated_Call) Run(run func(view uint64, newestQC *flow.QuorumCertificate, lastViewTC *flow.TimeoutCertificate)) *TimeoutAggregationConsumer_OnPartialTcCreated_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		var arg1 *flow.QuorumCertificate
		if args[1] != nil {
			arg1 = args[1].(*flow.QuorumCertificate)
		}
		var arg2 *flow.TimeoutCertificate
		if args[2] != nil {
			arg2 = args[2].(*flow.TimeoutCertificate)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *TimeoutAggregationConsumer_OnPartialTcCreated_Call) Return() *TimeoutAggregationConsumer_OnPartialTcCreated_Call {
	_c.Call.Return()
	return _c
}

func (_c *TimeoutAggregationConsumer_OnPartialTcCreated_Call) RunAndReturn(run func(view uint64, newestQC *flow.QuorumCertificate, lastViewTC *flow.TimeoutCertificate)) *TimeoutAggregationConsumer_OnPartialTcCreated_Call {
	_c.Run(run)
	return _c
}

// OnTcConstructedFromTimeouts provides a mock function for the type TimeoutAggregationConsumer
func (_mock *TimeoutAggregationConsumer) OnTcConstructedFromTimeouts(certificate *flow.TimeoutCertificate) {
	_mock.Called(certificate)
	return
}

// TimeoutAggregationConsumer_OnTcConstructedFromTimeouts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnTcConstructedFromTimeouts'
type TimeoutAggregationConsumer_OnTcConstructedFromTimeouts_Call struct {
	*mock.Call
}

// OnTcConstructedFromTimeouts is a helper method to define mock.On call
//   - certificate *flow.TimeoutCertificate
func (_e *TimeoutAggregationConsumer_Expecter) OnTcConstructedFromTimeouts(certificate interface{}) *TimeoutAggregationConsumer_OnTcConstructedFromTimeouts_Call {
	return &TimeoutAggregationConsumer_OnTcConstructedFromTimeouts_Call{Call: _e.mock.On("OnTcConstructedFromTimeouts", certificate)}
}

func (_c *TimeoutAggregationConsumer_OnTcConstructedFromTimeouts_Call) Run(run func(certificate *flow.TimeoutCertificate)) *TimeoutAggregationConsumer_OnTcConstructedFromTimeouts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *flow.TimeoutCertificate
		if args[0] != nil {
			arg0 = args[0].(*flow.TimeoutCertificate)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *TimeoutAggregationConsumer_OnTcConstructedFromTimeouts_Call) Return() *TimeoutAggregationConsumer_OnTcConstructedFromTimeouts_Call {
	_c.Call.Return()
	return _c
}

func (_c *TimeoutAggregationConsumer_OnTcConstructedFromTimeouts_Call) RunAndReturn(run func(certificate *flow.TimeoutCertificate)) *TimeoutAggregationConsumer_OnTcConstructedFromTimeouts_Call {
	_c.Run(run)
	return _c
}

// OnTimeoutProcessed provides a mock function for the type TimeoutAggregationConsumer
func (_mock *TimeoutAggregationConsumer) OnTimeoutProcessed(timeout *model.TimeoutObject) {
	_mock.Called(timeout)
	return
}

// TimeoutAggregationConsumer_OnTimeoutProcessed_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnTimeoutProcessed'
type TimeoutAggregationConsumer_OnTimeoutProcessed_Call struct {
	*mock.Call
}

// OnTimeoutProcessed is a helper method to define mock.On call
//   - timeout *model.TimeoutObject
func (_e *TimeoutAggregationConsumer_Expecter) OnTimeoutProcessed(timeout interface{}) *TimeoutAggregationConsumer_OnTimeoutProcessed_Call {
	return &TimeoutAggregationConsumer_OnTimeoutProcessed_Call{Call: _e.mock.On("OnTimeoutProcessed", timeout)}
}

func (_c *TimeoutAggregationConsumer_OnTimeoutProcessed_Call) Run(run func(timeout *model.TimeoutObject)) *TimeoutAggregationConsumer_OnTimeoutProcessed_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.TimeoutObject
		if args[0] != nil {
			arg0 = args[0].(*model.TimeoutObject)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *TimeoutAggregationConsumer_OnTimeoutProcessed_Call) Return() *TimeoutAggregationConsumer_OnTimeoutProcessed_Call {
	_c.Call.Return()
	return _c
}

func (_c *TimeoutAggregationConsumer_OnTimeoutProcessed_Call) RunAndReturn(run func(timeout *model.TimeoutObject)) *TimeoutAggregationConsumer_OnTimeoutProcessed_Call {
	_c.Run(run)
	return _c
}

// NewEventHandler creates a new instance of EventHandler. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewEventHandler(t interface {
	mock.TestingT
	Cleanup(func())
}) *EventHandler {
	mock := &EventHandler{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// EventHandler is an autogenerated mock type for the EventHandler type
type EventHandler struct {
	mock.Mock
}

type EventHandler_Expecter struct {
	mock *mock.Mock
}

func (_m *EventHandler) EXPECT() *EventHandler_Expecter {
	return &EventHandler_Expecter{mock: &_m.Mock}
}

// OnLocalTimeout provides a mock function for the type EventHandler
func (_mock *EventHandler) OnLocalTimeout() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for OnLocalTimeout")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// EventHandler_OnLocalTimeout_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnLocalTimeout'
type EventHandler_OnLocalTimeout_Call struct {
	*mock.Call
}

// OnLocalTimeout is a helper method to define mock.On call
func (_e *EventHandler_Expecter) OnLocalTimeout() *EventHandler_OnLocalTimeout_Call {
	return &EventHandler_OnLocalTimeout_Call{Call: _e.mock.On("OnLocalTimeout")}
}

func (_c *EventHandler_OnLocalTimeout_Call) Run(run func()) *EventHandler_OnLocalTimeout_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *EventHandler_OnLocalTimeout_Call) Return(err error) *EventHandler_OnLocalTimeout_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *EventHandler_OnLocalTimeout_Call) RunAndReturn(run func() error) *EventHandler_OnLocalTimeout_Call {
	_c.Call.Return(run)
	return _c
}

// OnPartialTcCreated provides a mock function for the type EventHandler
func (_mock *EventHandler) OnPartialTcCreated(partialTC *hotstuff.PartialTcCreated) error {
	ret := _mock.Called(partialTC)

	if len(ret) == 0 {
		panic("no return value specified for OnPartialTcCreated")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*hotstuff.PartialTcCreated) error); ok {
		r0 = returnFunc(partialTC)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// EventHandler_OnPartialTcCreated_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnPartialTcCreated'
type EventHandler_OnPartialTcCreated_Call struct {
	*mock.Call
}

// OnPartialTcCreated is a helper method to define mock.On call
//   - partialTC *hotstuff.PartialTcCreated
func (_e *EventHandler_Expecter) OnPartialTcCreated(partialTC interface{}) *EventHandler_OnPartialTcCreated_Call {
	return &EventHandler_OnPartialTcCreated_Call{Call: _e.mock.On("OnPartialTcCreated", partialTC)}
}

func (_c *EventHandler_OnPartialTcCreated_Call) Run(run func(partialTC *hotstuff.PartialTcCreated)) *EventHandler_OnPartialTcCreated_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *hotstuff.PartialTcCreated
		if args[0] != nil {
			arg0 = args[0].(*hotstuff.PartialTcCreated)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *EventHandler_OnPartialTcCreated_Call) Return(err error) *EventHandler_OnPartialTcCreated_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *EventHandler_OnPartialTcCreated_Call) RunAndReturn(run func(partialTC *hotstuff.PartialTcCreated) error) *EventHandler_OnPartialTcCreated_Call {
	_c.Call.Return(run)
	return _c
}

// OnReceiveProposal provides a mock function for the type EventHandler
func (_mock *EventHandler) OnReceiveProposal(proposal *model.SignedProposal) error {
	ret := _mock.Called(proposal)

	if len(ret) == 0 {
		panic("no return value specified for OnReceiveProposal")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*model.SignedProposal) error); ok {
		r0 = returnFunc(proposal)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// EventHandler_OnReceiveProposal_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnReceiveProposal'
type EventHandler_OnReceiveProposal_Call struct {
	*mock.Call
}

// OnReceiveProposal is a helper method to define mock.On call
//   - proposal *model.SignedProposal
func (_e *EventHandler_Expecter) OnReceiveProposal(proposal interface{}) *EventHandler_OnReceiveProposal_Call {
	return &EventHandler_OnReceiveProposal_Call{Call: _e.mock.On("OnReceiveProposal", proposal)}
}

func (_c *EventHandler_OnReceiveProposal_Call) Run(run func(proposal *model.SignedProposal)) *EventHandler_OnReceiveProposal_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.SignedProposal
		if args[0] != nil {
			arg0 = args[0].(*model.SignedProposal)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *EventHandler_OnReceiveProposal_Call) Return(err error) *EventHandler_OnReceiveProposal_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *EventHandler_OnReceiveProposal_Call) RunAndReturn(run func(proposal *model.SignedProposal) error) *EventHandler_OnReceiveProposal_Call {
	_c.Call.Return(run)
	return _c
}

// OnReceiveQc provides a mock function for the type EventHandler
func (_mock *EventHandler) OnReceiveQc(qc *flow.QuorumCertificate) error {
	ret := _mock.Called(qc)

	if len(ret) == 0 {
		panic("no return value specified for OnReceiveQc")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*flow.QuorumCertificate) error); ok {
		r0 = returnFunc(qc)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// EventHandler_OnReceiveQc_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnReceiveQc'
type EventHandler_OnReceiveQc_Call struct {
	*mock.Call
}

// OnReceiveQc is a helper method to define mock.On call
//   - qc *flow.QuorumCertificate
func (_e *EventHandler_Expecter) OnReceiveQc(qc interface{}) *EventHandler_OnReceiveQc_Call {
	return &EventHandler_OnReceiveQc_Call{Call: _e.mock.On("OnReceiveQc", qc)}
}

func (_c *EventHandler_OnReceiveQc_Call) Run(run func(qc *flow.QuorumCertificate)) *EventHandler_OnReceiveQc_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *flow.QuorumCertificate
		if args[0] != nil {
			arg0 = args[0].(*flow.QuorumCertificate)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *EventHandler_OnReceiveQc_Call) Return(err error) *EventHandler_OnReceiveQc_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *EventHandler_OnReceiveQc_Call) RunAndReturn(run func(qc *flow.QuorumCertificate) error) *EventHandler_OnReceiveQc_Call {
	_c.Call.Return(run)
	return _c
}

// OnReceiveTc provides a mock function for the type EventHandler
func (_mock *EventHandler) OnReceiveTc(tc *flow.TimeoutCertificate) error {
	ret := _mock.Called(tc)

	if len(ret) == 0 {
		panic("no return value specified for OnReceiveTc")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*flow.TimeoutCertificate) error); ok {
		r0 = returnFunc(tc)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// EventHandler_OnReceiveTc_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnReceiveTc'
type EventHandler_OnReceiveTc_Call struct {
	*mock.Call
}

// OnReceiveTc is a helper method to define mock.On call
//   - tc *flow.TimeoutCertificate
func (_e *EventHandler_Expecter) OnReceiveTc(tc interface{}) *EventHandler_OnReceiveTc_Call {
	return &EventHandler_OnReceiveTc_Call{Call: _e.mock.On("OnReceiveTc", tc)}
}

func (_c *EventHandler_OnReceiveTc_Call) Run(run func(tc *flow.TimeoutCertificate)) *EventHandler_OnReceiveTc_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *flow.TimeoutCertificate
		if args[0] != nil {
			arg0 = args[0].(*flow.TimeoutCertificate)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *EventHandler_OnReceiveTc_Call) Return(err error) *EventHandler_OnReceiveTc_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *EventHandler_OnReceiveTc_Call) RunAndReturn(run func(tc *flow.TimeoutCertificate) error) *EventHandler_OnReceiveTc_Call {
	_c.Call.Return(run)
	return _c
}

// Start provides a mock function for the type EventHandler
func (_mock *EventHandler) Start(ctx context.Context) error {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Start")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// EventHandler_Start_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Start'
type EventHandler_Start_Call struct {
	*mock.Call
}

// Start is a helper method to define mock.On call
//   - ctx context.Context
func (_e *EventHandler_Expecter) Start(ctx interface{}) *EventHandler_Start_Call {
	return &EventHandler_Start_Call{Call: _e.mock.On("Start", ctx)}
}

func (_c *EventHandler_Start_Call) Run(run func(ctx context.Context)) *EventHandler_Start_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *EventHandler_Start_Call) Return(err error) *EventHandler_Start_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *EventHandler_Start_Call) RunAndReturn(run func(ctx context.Context) error) *EventHandler_Start_Call {
	_c.Call.Return(run)
	return _c
}

// TimeoutChannel provides a mock function for the type EventHandler
func (_mock *EventHandler) TimeoutChannel() <-chan time.Time {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for TimeoutChannel")
	}

	var r0 <-chan time.Time
	if returnFunc, ok := ret.Get(0).(func() <-chan time.Time); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan time.Time)
		}
	}
	return r0
}

// EventHandler_TimeoutChannel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimeoutChannel'
type EventHandler_TimeoutChannel_Call struct {
	*mock.Call
}

// TimeoutChannel is a helper method to define mock.On call
func (_e *EventHandler_Expecter) TimeoutChannel() *EventHandler_TimeoutChannel_Call {
	return &EventHandler_TimeoutChannel_Call{Call: _e.mock.On("TimeoutChannel")}
}

func (_c *EventHandler_TimeoutChannel_Call) Run(run func()) *EventHandler_TimeoutChannel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *EventHandler_TimeoutChannel_Call) Return(timeCh <-chan time.Time) *EventHandler_TimeoutChannel_Call {
	_c.Call.Return(timeCh)
	return _c
}

func (_c *EventHandler_TimeoutChannel_Call) RunAndReturn(run func() <-chan time.Time) *EventHandler_TimeoutChannel_Call {
	_c.Call.Return(run)
	return _c
}

// NewEventLoop creates a new instance of EventLoop. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewEventLoop(t interface {
	mock.TestingT
	Cleanup(func())
}) *EventLoop {
	mock := &EventLoop{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// EventLoop is an autogenerated mock type for the EventLoop type
type EventLoop struct {
	mock.Mock
}

type EventLoop_Expecter struct {
	mock *mock.Mock
}

func (_m *EventLoop) EXPECT() *EventLoop_Expecter {
	return &EventLoop_Expecter{mock: &_m.Mock}
}

// Done provides a mock function for the type EventLoop
func (_mock *EventLoop) Done() <-chan struct{} {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Done")
	}

	var r0 <-chan struct{}
	if returnFunc, ok := ret.Get(0).(func() <-chan struct{}); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan struct{})
		}
	}
	return r0
}

// EventLoop_Done_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Done'
type EventLoop_Done_Call struct {
	*mock.Call
}

// Done is a helper method to define mock.On call
func (_e *EventLoop_Expecter) Done() *EventLoop_Done_Call {
	return &EventLoop_Done_Call{Call: _e.mock.On("Done")}
}

func (_c *EventLoop_Done_Call) Run(run func()) *EventLoop_Done_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *EventLoop_Done_Call) Return(valCh <-chan struct{}) *EventLoop_Done_Call {
	_c.Call.Return(valCh)
	return _c
}

func (_c *EventLoop_Done_Call) RunAndReturn(run func() <-chan struct{}) *EventLoop_Done_Call {
	_c.Call.Return(run)
	return _c
}

// OnNewQcDiscovered provides a mock function for the type EventLoop
func (_mock *EventLoop) OnNewQcDiscovered(certificate *flow.QuorumCertificate) {
	_mock.Called(certificate)
	return
}

// EventLoop_OnNewQcDiscovered_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnNewQcDiscovered'
type EventLoop_OnNewQcDiscovered_Call struct {
	*mock.Call
}

// OnNewQcDiscovered is a helper method to define mock.On call
//   - certificate *flow.QuorumCertificate
func (_e *EventLoop_Expecter) OnNewQcDiscovered(certificate interface{}) *EventLoop_OnNewQcDiscovered_Call {
	return &EventLoop_OnNewQcDiscovered_Call{Call: _e.mock.On("OnNewQcDiscovered", certificate)}
}

func (_c *EventLoop_OnNewQcDiscovered_Call) Run(run func(certificate *flow.QuorumCertificate)) *EventLoop_OnNewQcDiscovered_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *flow.QuorumCertificate
		if args[0] != nil {
			arg0 = args[0].(*flow.QuorumCertificate)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *EventLoop_OnNewQcDiscovered_Call) Return() *EventLoop_OnNewQcDiscovered_Call {
	_c.Call.Return()
	return _c
}

func (_c *EventLoop_OnNewQcDiscovered_Call) RunAndReturn(run func(certificate *flow.QuorumCertificate)) *EventLoop_OnNewQcDiscovered_Call {
	_c.Run(run)
	return _c
}

// OnNewTcDiscovered provides a mock function for the type EventLoop
func (_mock *EventLoop) OnNewTcDiscovered(certificate *flow.TimeoutCertificate) {
	_mock.Called(certificate)
	return
}

// EventLoop_OnNewTcDiscovered_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnNewTcDiscovered'
type EventLoop_OnNewTcDiscovered_Call struct {
	*mock.Call
}

// OnNewTcDiscovered is a helper method to define mock.On call
//   - certificate *flow.TimeoutCertificate
func (_e *EventLoop_Expecter) OnNewTcDiscovered(certificate interface{}) *EventLoop_OnNewTcDiscovered_Call {
	return &EventLoop_OnNewTcDiscovered_Call{Call: _e.mock.On("OnNewTcDiscovered", certificate)}
}

func (_c *EventLoop_OnNewTcDiscovered_Call) Run(run func(certificate *flow.TimeoutCertificate)) *EventLoop_OnNewTcDiscovered_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *flow.TimeoutCertificate
		if args[0] != nil {
			arg0 = args[0].(*flow.TimeoutCertificate)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *EventLoop_OnNewTcDiscovered_Call) Return() *EventLoop_OnNewTcDiscovered_Call {
	_c.Call.Return()
	return _c
}

func (_c *EventLoop_OnNewTcDiscovered_Call) RunAndReturn(run func(certificate *flow.TimeoutCertificate)) *EventLoop_OnNewTcDiscovered_Call {
	_c.Run(run)
	return _c
}

// OnPartialTcCreated provides a mock function for the type EventLoop
func (_mock *EventLoop) OnPartialTcCreated(view uint64, newestQC *flow.QuorumCertificate, lastViewTC *flow.TimeoutCertificate) {
	_mock.Called(view, newestQC, lastViewTC)
	return
}

// EventLoop_OnPartialTcCreated_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnPartialTcCreated'
type EventLoop_OnPartialTcCreated_Call struct {
	*mock.Call
}

// OnPartialTcCreated is a helper method to define mock.On call
//   - view uint64
//   - newestQC *flow.QuorumCertificate
//   - lastViewTC *flow.TimeoutCertificate
func (_e *EventLoop_Expecter) OnPartialTcCreated(view interface{}, newestQC interface{}, lastViewTC interface{}) *EventLoop_OnPartialTcCreated_Call {
	return &EventLoop_OnPartialTcCreated_Call{Call: _e.mock.On("OnPartialTcCreated", view, newestQC, lastViewTC)}
}

func (_c *EventLoop_OnPartialTcCreated_Call) Run(run func(view uint64, newestQC *flow.QuorumCertificate, lastViewTC *flow.TimeoutCertificate)) *EventLoop_OnPartialTcCreated_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		var arg1 *flow.QuorumCertificate
		if args[1] != nil {
			arg1 = args[1].(*flow.QuorumCertificate)
		}
		var arg2 *flow.TimeoutCertificate
		if args[2] != nil {
			arg2 = args[2].(*flow.TimeoutCertificate)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *EventLoop_OnPartialTcCreated_Call) Return() *EventLoop_OnPartialTcCreated_Call {
	_c.Call.Return()
	return _c
}

func (_c *EventLoop_OnPartialTcCreated_Call) RunAndReturn(run func(view uint64, newestQC *flow.QuorumCertificate, lastViewTC *flow.TimeoutCertificate)) *EventLoop_OnPartialTcCreated_Call {
	_c.Run(run)
	return _c
}

// OnQcConstructedFromVotes provides a mock function for the type EventLoop
func (_mock *EventLoop) OnQcConstructedFromVotes(quorumCertificate *flow.QuorumCertificate) {
	_mock.Called(quorumCertificate)
	return
}

// EventLoop_OnQcConstructedFromVotes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnQcConstructedFromVotes'
type EventLoop_OnQcConstructedFromVotes_Call struct {
	*mock.Call
}

// OnQcConstructedFromVotes is a helper method to define mock.On call
//   - quorumCertificate *flow.QuorumCertificate
func (_e *EventLoop_Expecter) OnQcConstructedFromVotes(quorumCertificate interface{}) *EventLoop_OnQcConstructedFromVotes_Call {
	return &EventLoop_OnQcConstructedFromVotes_Call{Call: _e.mock.On("OnQcConstructedFromVotes", quorumCertificate)}
}

func (_c *EventLoop_OnQcConstructedFromVotes_Call) Run(run func(quorumCertificate *flow.QuorumCertificate)) *EventLoop_OnQcConstructedFromVotes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *flow.QuorumCertificate
		if args[0] != nil {
			arg0 = args[0].(*flow.QuorumCertificate)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *EventLoop_OnQcConstructedFromVotes_Call) Return() *EventLoop_OnQcConstructedFromVotes_Call {
	_c.Call.Return()
	return _c
}

func (_c *EventLoop_OnQcConstructedFromVotes_Call) RunAndReturn(run func(quorumCertificate *flow.QuorumCertificate)) *EventLoop_OnQcConstructedFromVotes_Call {
	_c.Run(run)
	return _c
}

// OnTcConstructedFromTimeouts provides a mock function for the type EventLoop
func (_mock *EventLoop) OnTcConstructedFromTimeouts(certificate *flow.TimeoutCertificate) {
	_mock.Called(certificate)
	return
}

// EventLoop_OnTcConstructedFromTimeouts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnTcConstructedFromTimeouts'
type EventLoop_OnTcConstructedFromTimeouts_Call struct {
	*mock.Call
}

// OnTcConstructedFromTimeouts is a helper method to define mock.On call
//   - certificate *flow.TimeoutCertificate
func (_e *EventLoop_Expecter) OnTcConstructedFromTimeouts(certificate interface{}) *EventLoop_OnTcConstructedFromTimeouts_Call {
	return &EventLoop_OnTcConstructedFromTimeouts_Call{Call: _e.mock.On("OnTcConstructedFromTimeouts", certificate)}
}

func (_c *EventLoop_OnTcConstructedFromTimeouts_Call) Run(run func(certificate *flow.TimeoutCertificate)) *EventLoop_OnTcConstructedFromTimeouts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *flow.TimeoutCertificate
		if args[0] != nil {
			arg0 = args[0].(*flow.TimeoutCertificate)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *EventLoop_OnTcConstructedFromTimeouts_Call) Return() *EventLoop_OnTcConstructedFromTimeouts_Call {
	_c.Call.Return()
	return _c
}

func (_c *EventLoop_OnTcConstructedFromTimeouts_Call) RunAndReturn(run func(certificate *flow.TimeoutCertificate)) *EventLoop_OnTcConstructedFromTimeouts_Call {
	_c.Run(run)
	return _c
}

// OnTimeoutProcessed provides a mock function for the type EventLoop
func (_mock *EventLoop) OnTimeoutProcessed(timeout *model.TimeoutObject) {
	_mock.Called(timeout)
	return
}

// EventLoop_OnTimeoutProcessed_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnTimeoutProcessed'
type EventLoop_OnTimeoutProcessed_Call struct {
	*mock.Call
}

// OnTimeoutProcessed is a helper method to define mock.On call
//   - timeout *model.TimeoutObject
func (_e *EventLoop_Expecter) OnTimeoutProcessed(timeout interface{}) *EventLoop_OnTimeoutProcessed_Call {
	return &EventLoop_OnTimeoutProcessed_Call{Call: _e.mock.On("OnTimeoutProcessed", timeout)}
}

func (_c *EventLoop_OnTimeoutProcessed_Call) Run(run func(timeout *model.TimeoutObject)) *EventLoop_OnTimeoutProcessed_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.TimeoutObject
		if args[0] != nil {
			arg0 = args[0].(*model.TimeoutObject)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *EventLoop_OnTimeoutProcessed_Call) Return() *EventLoop_OnTimeoutProcessed_Call {
	_c.Call.Return()
	return _c
}

func (_c *EventLoop_OnTimeoutProcessed_Call) RunAndReturn(run func(timeout *model.TimeoutObject)) *EventLoop_OnTimeoutProcessed_Call {
	_c.Run(run)
	return _c
}

// OnVoteProcessed provides a mock function for the type EventLoop
func (_mock *EventLoop) OnVoteProcessed(vote *model.Vote) {
	_mock.Called(vote)
	return
}

// EventLoop_OnVoteProcessed_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnVoteProcessed'
type EventLoop_OnVoteProcessed_Call struct {
	*mock.Call
}

// OnVoteProcessed is a helper method to define mock.On call
//   - vote *model.Vote
func (_e *EventLoop_Expecter) OnVoteProcessed(vote interface{}) *EventLoop_OnVoteProcessed_Call {
	return &EventLoop_OnVoteProcessed_Call{Call: _e.mock.On("OnVoteProcessed", vote)}
}

func (_c *EventLoop_OnVoteProcessed_Call) Run(run func(vote *model.Vote)) *EventLoop_OnVoteProcessed_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Vote
		if args[0] != nil {
			arg0 = args[0].(*model.Vote)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *EventLoop_OnVoteProcessed_Call) Return() *EventLoop_OnVoteProcessed_Call {
	_c.Call.Return()
	return _c
}

func (_c *EventLoop_OnVoteProcessed_Call) RunAndReturn(run func(vote *model.Vote)) *EventLoop_OnVoteProcessed_Call {
	_c.Run(run)
	return _c
}

// Ready provides a mock function for the type EventLoop
func (_mock *EventLoop) Ready() <-chan struct{} {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Ready")
	}

	var r0 <-chan struct{}
	if returnFunc, ok := ret.Get(0).(func() <-chan struct{}); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan struct{})
		}
	}
	return r0
}

// EventLoop_Ready_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Ready'
type EventLoop_Ready_Call struct {
	*mock.Call
}

// Ready is a helper method to define mock.On call
func (_e *EventLoop_Expecter) Ready() *EventLoop_Ready_Call {
	return &EventLoop_Ready_Call{Call: _e.mock.On("Ready")}
}

func (_c *EventLoop_Ready_Call) Run(run func()) *EventLoop_Ready_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *EventLoop_Ready_Call) Return(valCh <-chan struct{}) *EventLoop_Ready_Call {
	_c.Call.Return(valCh)
	return _c
}

func (_c *EventLoop_Ready_Call) RunAndReturn(run func() <-chan struct{}) *EventLoop_Ready_Call {
	_c.Call.Return(run)
	return _c
}

// Start provides a mock function for the type EventLoop
func (_mock *EventLoop) Start(signalerContext irrecoverable.SignalerContext) {
	_mock.Called(signalerContext)
	return
}

// EventLoop_Start_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Start'
type EventLoop_Start_Call struct {
	*mock.Call
}

// Start is a helper method to define mock.On call
//   - signalerContext irrecoverable.SignalerContext
func (_e *EventLoop_Expecter) Start(signalerContext interface{}) *EventLoop_Start_Call {
	return &EventLoop_Start_Call{Call: _e.mock.On("Start", signalerContext)}
}

func (_c *EventLoop_Start_Call) Run(run func(signalerContext irrecoverable.SignalerContext)) *EventLoop_Start_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 irrecoverable.SignalerContext
		if args[0] != nil {
			arg0 = args[0].(irrecoverable.SignalerContext)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *EventLoop_Start_Call) Return() *EventLoop_Start_Call {
	_c.Call.Return()
	return _c
}

func (_c *EventLoop_Start_Call) RunAndReturn(run func(signalerContext irrecoverable.SignalerContext)) *EventLoop_Start_Call {
	_c.Run(run)
	return _c
}

// SubmitProposal provides a mock function for the type EventLoop
func (_mock *EventLoop) SubmitProposal(proposal *model.SignedProposal) {
	_mock.Called(proposal)
	return
}

// EventLoop_SubmitProposal_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SubmitProposal'
type EventLoop_SubmitProposal_Call struct {
	*mock.Call
}

// SubmitProposal is a helper method to define mock.On call
//   - proposal *model.SignedProposal
func (_e *EventLoop_Expecter) SubmitProposal(proposal interface{}) *EventLoop_SubmitProposal_Call {
	return &EventLoop_SubmitProposal_Call{Call: _e.mock.On("SubmitProposal", proposal)}
}

func (_c *EventLoop_SubmitProposal_Call) Run(run func(proposal *model.SignedProposal)) *EventLoop_SubmitProposal_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.SignedProposal
		if args[0] != nil {
			arg0 = args[0].(*model.SignedProposal)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *EventLoop_SubmitProposal_Call) Return() *EventLoop_SubmitProposal_Call {
	_c.Call.Return()
	return _c
}

func (_c *EventLoop_SubmitProposal_Call) RunAndReturn(run func(proposal *model.SignedProposal)) *EventLoop_SubmitProposal_Call {
	_c.Run(run)
	return _c
}

// NewFinalizationRegistrar creates a new instance of FinalizationRegistrar. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewFinalizationRegistrar(t interface {
	mock.TestingT
	Cleanup(func())
}) *FinalizationRegistrar {
	mock := &FinalizationRegistrar{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// FinalizationRegistrar is an autogenerated mock type for the FinalizationRegistrar type
type FinalizationRegistrar struct {
	mock.Mock
}

type FinalizationRegistrar_Expecter struct {
	mock *mock.Mock
}

func (_m *FinalizationRegistrar) EXPECT() *FinalizationRegistrar_Expecter {
	return &FinalizationRegistrar_Expecter{mock: &_m.Mock}
}

// AddOnBlockFinalizedConsumer provides a mock function for the type FinalizationRegistrar
func (_mock *FinalizationRegistrar) AddOnBlockFinalizedConsumer(consumer func(block *model.Block)) {
	_mock.Called(consumer)
	return
}

// FinalizationRegistrar_AddOnBlockFinalizedConsumer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddOnBlockFinalizedConsumer'
type FinalizationRegistrar_AddOnBlockFinalizedConsumer_Call struct {
	*mock.Call
}

// AddOnBlockFinalizedConsumer is a helper method to define mock.On call
//   - consumer func(block *model.Block)
func (_e *FinalizationRegistrar_Expecter) AddOnBlockFinalizedConsumer(consumer interface{}) *FinalizationRegistrar_AddOnBlockFinalizedConsumer_Call {
	return &FinalizationRegistrar_AddOnBlockFinalizedConsumer_Call{Call: _e.mock.On("AddOnBlockFinalizedConsumer", consumer)}
}

func (_c *FinalizationRegistrar_AddOnBlockFinalizedConsumer_Call) Run(run func(consumer func(block *model.Block))) *FinalizationRegistrar_AddOnBlockFinalizedConsumer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 func(block *model.Block)
		if args[0] != nil {
			arg0 = args[0].(func(block *model.Block))
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *FinalizationRegistrar_AddOnBlockFinalizedConsumer_Call) Return() *FinalizationRegistrar_AddOnBlockFinalizedConsumer_Call {
	_c.Call.Return()
	return _c
}

func (_c *FinalizationRegistrar_AddOnBlockFinalizedConsumer_Call) RunAndReturn(run func(consumer func(block *model.Block))) *FinalizationRegistrar_AddOnBlockFinalizedConsumer_Call {
	_c.Run(run)
	return _c
}

// AddOnBlockIncorporatedConsumer provides a mock function for the type FinalizationRegistrar
func (_mock *FinalizationRegistrar) AddOnBlockIncorporatedConsumer(consumer func(block *model.Block)) {
	_mock.Called(consumer)
	return
}

// FinalizationRegistrar_AddOnBlockIncorporatedConsumer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddOnBlockIncorporatedConsumer'
type FinalizationRegistrar_AddOnBlockIncorporatedConsumer_Call struct {
	*mock.Call
}

// AddOnBlockIncorporatedConsumer is a helper method to define mock.On call
//   - consumer func(block *model.Block)
func (_e *FinalizationRegistrar_Expecter) AddOnBlockIncorporatedConsumer(consumer interface{}) *FinalizationRegistrar_AddOnBlockIncorporatedConsumer_Call {
	return &FinalizationRegistrar_AddOnBlockIncorporatedConsumer_Call{Call: _e.mock.On("AddOnBlockIncorporatedConsumer", consumer)}
}

func (_c *FinalizationRegistrar_AddOnBlockIncorporatedConsumer_Call) Run(run func(consumer func(block *model.Block))) *FinalizationRegistrar_AddOnBlockIncorporatedConsumer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 func(block *model.Block)
		if args[0] != nil {
			arg0 = args[0].(func(block *model.Block))
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *FinalizationRegistrar_AddOnBlockIncorporatedConsumer_Call) Return() *FinalizationRegistrar_AddOnBlockIncorporatedConsumer_Call {
	_c.Call.Return()
	return _c
}

func (_c *FinalizationRegistrar_AddOnBlockIncorporatedConsumer_Call) RunAndReturn(run func(consumer func(block *model.Block))) *FinalizationRegistrar_AddOnBlockIncorporatedConsumer_Call {
	_c.Run(run)
	return _c
}

// NewForks creates a new instance of Forks. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewForks(t interface {
	mock.TestingT
	Cleanup(func())
}) *Forks {
	mock := &Forks{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Forks is an autogenerated mock type for the Forks type
type Forks struct {
	mock.Mock
}

type Forks_Expecter struct {
	mock *mock.Mock
}

func (_m *Forks) EXPECT() *Forks_Expecter {
	return &Forks_Expecter{mock: &_m.Mock}
}

// AddCertifiedBlock provides a mock function for the type Forks
func (_mock *Forks) AddCertifiedBlock(certifiedBlock *model.CertifiedBlock) error {
	ret := _mock.Called(certifiedBlock)

	if len(ret) == 0 {
		panic("no return value specified for AddCertifiedBlock")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*model.CertifiedBlock) error); ok {
		r0 = returnFunc(certifiedBlock)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Forks_AddCertifiedBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddCertifiedBlock'
type Forks_AddCertifiedBlock_Call struct {
	*mock.Call
}

// AddCertifiedBlock is a helper method to define mock.On call
//   - certifiedBlock *model.CertifiedBlock
func (_e *Forks_Expecter) AddCertifiedBlock(certifiedBlock interface{}) *Forks_AddCertifiedBlock_Call {
	return &Forks_AddCertifiedBlock_Call{Call: _e.mock.On("AddCertifiedBlock", certifiedBlock)}
}

func (_c *Forks_AddCertifiedBlock_Call) Run(run func(certifiedBlock *model.CertifiedBlock)) *Forks_AddCertifiedBlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.CertifiedBlock
		if args[0] != nil {
			arg0 = args[0].(*model.CertifiedBlock)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Forks_AddCertifiedBlock_Call) Return(err error) *Forks_AddCertifiedBlock_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Forks_AddCertifiedBlock_Call) RunAndReturn(run func(certifiedBlock *model.CertifiedBlock) error) *Forks_AddCertifiedBlock_Call {
	_c.Call.Return(run)
	return _c
}

// AddValidatedBlock provides a mock function for the type Forks
func (_mock *Forks) AddValidatedBlock(proposal *model.Block) error {
	ret := _mock.Called(proposal)

	if len(ret) == 0 {
		panic("no return value specified for AddValidatedBlock")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*model.Block) error); ok {
		r0 = returnFunc(proposal)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Forks_AddValidatedBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddValidatedBlock'
type Forks_AddValidatedBlock_Call struct {
	*mock.Call
}

// AddValidatedBlock is a helper method to define mock.On call
//   - proposal *model.Block
func (_e *Forks_Expecter) AddValidatedBlock(proposal interface{}) *Forks_AddValidatedBlock_Call {
	return &Forks_AddValidatedBlock_Call{Call: _e.mock.On("AddValidatedBlock", proposal)}
}

func (_c *Forks_AddValidatedBlock_Call) Run(run func(proposal *model.Block)) *Forks_AddValidatedBlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Block
		if args[0] != nil {
			arg0 = args[0].(*model.Block)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Forks_AddValidatedBlock_Call) Return(err error) *Forks_AddValidatedBlock_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Forks_AddValidatedBlock_Call) RunAndReturn(run func(proposal *model.Block) error) *Forks_AddValidatedBlock_Call {
	_c.Call.Return(run)
	return _c
}

// FinalityProof provides a mock function for the type Forks
func (_mock *Forks) FinalityProof() (*hotstuff.FinalityProof, bool) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for FinalityProof")
	}

	var r0 *hotstuff.FinalityProof
	var r1 bool
	if returnFunc, ok := ret.Get(0).(func() (*hotstuff.FinalityProof, bool)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() *hotstuff.FinalityProof); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*hotstuff.FinalityProof)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() bool); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Get(1).(bool)
	}
	return r0, r1
}

// Forks_FinalityProof_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FinalityProof'
type Forks_FinalityProof_Call struct {
	*mock.Call
}

// FinalityProof is a helper method to define mock.On call
func (_e *Forks_Expecter) FinalityProof() *Forks_FinalityProof_Call {
	return &Forks_FinalityProof_Call{Call: _e.mock.On("FinalityProof")}
}

func (_c *Forks_FinalityProof_Call) Run(run func()) *Forks_FinalityProof_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Forks_FinalityProof_Call) Return(finalityProof *hotstuff.FinalityProof, b bool) *Forks_FinalityProof_Call {
	_c.Call.Return(finalityProof, b)
	return _c
}

func (_c *Forks_FinalityProof_Call) RunAndReturn(run func() (*hotstuff.FinalityProof, bool)) *Forks_FinalityProof_Call {
	_c.Call.Return(run)
	return _c
}

// FinalizedBlock provides a mock function for the type Forks
func (_mock *Forks) FinalizedBlock() *model.Block {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for FinalizedBlock")
	}

	var r0 *model.Block
	if returnFunc, ok := ret.Get(0).(func() *model.Block); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Block)
		}
	}
	return r0
}

// Forks_FinalizedBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FinalizedBlock'
type Forks_FinalizedBlock_Call struct {
	*mock.Call
}

// FinalizedBlock is a helper method to define mock.On call
func (_e *Forks_Expecter) FinalizedBlock() *Forks_FinalizedBlock_Call {
	return &Forks_FinalizedBlock_Call{Call: _e.mock.On("FinalizedBlock")}
}

func (_c *Forks_FinalizedBlock_Call) Run(run func()) *Forks_FinalizedBlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Forks_FinalizedBlock_Call) Return(block *model.Block) *Forks_FinalizedBlock_Call {
	_c.Call.Return(block)
	return _c
}

func (_c *Forks_FinalizedBlock_Call) RunAndReturn(run func() *model.Block) *Forks_FinalizedBlock_Call {
	_c.Call.Return(run)
	return _c
}

// FinalizedView provides a mock function for the type Forks
func (_mock *Forks) FinalizedView() uint64 {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for FinalizedView")
	}

	var r0 uint64
	if returnFunc, ok := ret.Get(0).(func() uint64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint64)
	}
	return r0
}

// Forks_FinalizedView_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FinalizedView'
type Forks_FinalizedView_Call struct {
	*mock.Call
}

// FinalizedView is a helper method to define mock.On call
func (_e *Forks_Expecter) FinalizedView() *Forks_FinalizedView_Call {
	return &Forks_FinalizedView_Call{Call: _e.mock.On("FinalizedView")}
}

func (_c *Forks_FinalizedView_Call) Run(run func()) *Forks_FinalizedView_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Forks_FinalizedView_Call) Return(v uint64) *Forks_FinalizedView_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *Forks_FinalizedView_Call) RunAndReturn(run func() uint64) *Forks_FinalizedView_Call {
	_c.Call.Return(run)
	return _c
}

// GetBlock provides a mock function for the type Forks
func (_mock *Forks) GetBlock(blockID flow.Identifier) (*model.Block, bool) {
	ret := _mock.Called(blockID)

	if len(ret) == 0 {
		panic("no return value specified for GetBlock")
	}

	var r0 *model.Block
	var r1 bool
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (*model.Block, bool)); ok {
		return returnFunc(blockID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) *model.Block); ok {
		r0 = returnFunc(blockID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Block)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) bool); ok {
		r1 = returnFunc(blockID)
	} else {
		r1 = ret.Get(1).(bool)
	}
	return r0, r1
}

// Forks_GetBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBlock'
type Forks_GetBlock_Call struct {
	*mock.Call
}

// GetBlock is a helper method to define mock.On call
//   - blockID flow.Identifier
func (_e *Forks_Expecter) GetBlock(blockID interface{}) *Forks_GetBlock_Call {
	return &Forks_GetBlock_Call{Call: _e.mock.On("GetBlock", blockID)}
}

func (_c *Forks_GetBlock_Call) Run(run func(blockID flow.Identifier)) *Forks_GetBlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Forks_GetBlock_Call) Return(block *model.Block, b bool) *Forks_GetBlock_Call {
	_c.Call.Return(block, b)
	return _c
}

func (_c *Forks_GetBlock_Call) RunAndReturn(run func(blockID flow.Identifier) (*model.Block, bool)) *Forks_GetBlock_Call {
	_c.Call.Return(run)
	return _c
}

// GetBlocksForView provides a mock function for the type Forks
func (_mock *Forks) GetBlocksForView(view uint64) []*model.Block {
	ret := _mock.Called(view)

	if len(ret) == 0 {
		panic("no return value specified for GetBlocksForView")
	}

	var r0 []*model.Block
	if returnFunc, ok := ret.Get(0).(func(uint64) []*model.Block); ok {
		r0 = returnFunc(view)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Block)
		}
	}
	return r0
}

// Forks_GetBlocksForView_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBlocksForView'
type Forks_GetBlocksForView_Call struct {
	*mock.Call
}

// GetBlocksForView is a helper method to define mock.On call
//   - view uint64
func (_e *Forks_Expecter) GetBlocksForView(view interface{}) *Forks_GetBlocksForView_Call {
	return &Forks_GetBlocksForView_Call{Call: _e.mock.On("GetBlocksForView", view)}
}

func (_c *Forks_GetBlocksForView_Call) Run(run func(view uint64)) *Forks_GetBlocksForView_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Forks_GetBlocksForView_Call) Return(blocks []*model.Block) *Forks_GetBlocksForView_Call {
	_c.Call.Return(blocks)
	return _c
}

func (_c *Forks_GetBlocksForView_Call) RunAndReturn(run func(view uint64) []*model.Block) *Forks_GetBlocksForView_Call {
	_c.Call.Return(run)
	return _c
}

// NewPaceMaker creates a new instance of PaceMaker. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewPaceMaker(t interface {
	mock.TestingT
	Cleanup(func())
}) *PaceMaker {
	mock := &PaceMaker{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// PaceMaker is an autogenerated mock type for the PaceMaker type
type PaceMaker struct {
	mock.Mock
}

type PaceMaker_Expecter struct {
	mock *mock.Mock
}

func (_m *PaceMaker) EXPECT() *PaceMaker_Expecter {
	return &PaceMaker_Expecter{mock: &_m.Mock}
}

// CurView provides a mock function for the type PaceMaker
func (_mock *PaceMaker) CurView() uint64 {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for CurView")
	}

	var r0 uint64
	if returnFunc, ok := ret.Get(0).(func() uint64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint64)
	}
	return r0
}

// PaceMaker_CurView_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CurView'
type PaceMaker_CurView_Call struct {
	*mock.Call
}

// CurView is a helper method to define mock.On call
func (_e *PaceMaker_Expecter) CurView() *PaceMaker_CurView_Call {
	return &PaceMaker_CurView_Call{Call: _e.mock.On("CurView")}
}

func (_c *PaceMaker_CurView_Call) Run(run func()) *PaceMaker_CurView_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *PaceMaker_CurView_Call) Return(v uint64) *PaceMaker_CurView_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *PaceMaker_CurView_Call) RunAndReturn(run func() uint64) *PaceMaker_CurView_Call {
	_c.Call.Return(run)
	return _c
}

// LastViewTC provides a mock function for the type PaceMaker
func (_mock *PaceMaker) LastViewTC() *flow.TimeoutCertificate {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for LastViewTC")
	}

	var r0 *flow.TimeoutCertificate
	if returnFunc, ok := ret.Get(0).(func() *flow.TimeoutCertificate); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.TimeoutCertificate)
		}
	}
	return r0
}

// PaceMaker_LastViewTC_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LastViewTC'
type PaceMaker_LastViewTC_Call struct {
	*mock.Call
}

// LastViewTC is a helper method to define mock.On call
func (_e *PaceMaker_Expecter) LastViewTC() *PaceMaker_LastViewTC_Call {
	return &PaceMaker_LastViewTC_Call{Call: _e.mock.On("LastViewTC")}
}

func (_c *PaceMaker_LastViewTC_Call) Run(run func()) *PaceMaker_LastViewTC_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *PaceMaker_LastViewTC_Call) Return(timeoutCertificate *flow.TimeoutCertificate) *PaceMaker_LastViewTC_Call {
	_c.Call.Return(timeoutCertificate)
	return _c
}

func (_c *PaceMaker_LastViewTC_Call) RunAndReturn(run func() *flow.TimeoutCertificate) *PaceMaker_LastViewTC_Call {
	_c.Call.Return(run)
	return _c
}

// NewestQC provides a mock function for the type PaceMaker
func (_mock *PaceMaker) NewestQC() *flow.QuorumCertificate {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for NewestQC")
	}

	var r0 *flow.QuorumCertificate
	if returnFunc, ok := ret.Get(0).(func() *flow.QuorumCertificate); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.QuorumCertificate)
		}
	}
	return r0
}

// PaceMaker_NewestQC_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NewestQC'
type PaceMaker_NewestQC_Call struct {
	*mock.Call
}

// NewestQC is a helper method to define mock.On call
func (_e *PaceMaker_Expecter) NewestQC() *PaceMaker_NewestQC_Call {
	return &PaceMaker_NewestQC_Call{Call: _e.mock.On("NewestQC")}
}

func (_c *PaceMaker_NewestQC_Call) Run(run func()) *PaceMaker_NewestQC_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *PaceMaker_NewestQC_Call) Return(quorumCertificate *flow.QuorumCertificate) *PaceMaker_NewestQC_Call {
	_c.Call.Return(quorumCertificate)
	return _c
}

func (_c *PaceMaker_NewestQC_Call) RunAndReturn(run func() *flow.QuorumCertificate) *PaceMaker_NewestQC_Call {
	_c.Call.Return(run)
	return _c
}

// ProcessQC provides a mock function for the type PaceMaker
func (_mock *PaceMaker) ProcessQC(qc *flow.QuorumCertificate) (*model.NewViewEvent, error) {
	ret := _mock.Called(qc)

	if len(ret) == 0 {
		panic("no return value specified for ProcessQC")
	}

	var r0 *model.NewViewEvent
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*flow.QuorumCertificate) (*model.NewViewEvent, error)); ok {
		return returnFunc(qc)
	}
	if returnFunc, ok := ret.Get(0).(func(*flow.QuorumCertificate) *model.NewViewEvent); ok {
		r0 = returnFunc(qc)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.NewViewEvent)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*flow.QuorumCertificate) error); ok {
		r1 = returnFunc(qc)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// PaceMaker_ProcessQC_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ProcessQC'
type PaceMaker_ProcessQC_Call struct {
	*mock.Call
}

// ProcessQC is a helper method to define mock.On call
//   - qc *flow.QuorumCertificate
func (_e *PaceMaker_Expecter) ProcessQC(qc interface{}) *PaceMaker_ProcessQC_Call {
	return &PaceMaker_ProcessQC_Call{Call: _e.mock.On("ProcessQC", qc)}
}

func (_c *PaceMaker_ProcessQC_Call) Run(run func(qc *flow.QuorumCertificate)) *PaceMaker_ProcessQC_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *flow.QuorumCertificate
		if args[0] != nil {
			arg0 = args[0].(*flow.QuorumCertificate)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PaceMaker_ProcessQC_Call) Return(newViewEvent *model.NewViewEvent, err error) *PaceMaker_ProcessQC_Call {
	_c.Call.Return(newViewEvent, err)
	return _c
}

func (_c *PaceMaker_ProcessQC_Call) RunAndReturn(run func(qc *flow.QuorumCertificate) (*model.NewViewEvent, error)) *PaceMaker_ProcessQC_Call {
	_c.Call.Return(run)
	return _c
}

// ProcessTC provides a mock function for the type PaceMaker
func (_mock *PaceMaker) ProcessTC(tc *flow.TimeoutCertificate) (*model.NewViewEvent, error) {
	ret := _mock.Called(tc)

	if len(ret) == 0 {
		panic("no return value specified for ProcessTC")
	}

	var r0 *model.NewViewEvent
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*flow.TimeoutCertificate) (*model.NewViewEvent, error)); ok {
		return returnFunc(tc)
	}
	if returnFunc, ok := ret.Get(0).(func(*flow.TimeoutCertificate) *model.NewViewEvent); ok {
		r0 = returnFunc(tc)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.NewViewEvent)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*flow.TimeoutCertificate) error); ok {
		r1 = returnFunc(tc)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// PaceMaker_ProcessTC_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ProcessTC'
type PaceMaker_ProcessTC_Call struct {
	*mock.Call
}

// ProcessTC is a helper method to define mock.On call
//   - tc *flow.TimeoutCertificate
func (_e *PaceMaker_Expecter) ProcessTC(tc interface{}) *PaceMaker_ProcessTC_Call {
	return &PaceMaker_ProcessTC_Call{Call: _e.mock.On("ProcessTC", tc)}
}

func (_c *PaceMaker_ProcessTC_Call) Run(run func(tc *flow.TimeoutCertificate)) *PaceMaker_ProcessTC_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *flow.TimeoutCertificate
		if args[0] != nil {
			arg0 = args[0].(*flow.TimeoutCertificate)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PaceMaker_ProcessTC_Call) Return(newViewEvent *model.NewViewEvent, err error) *PaceMaker_ProcessTC_Call {
	_c.Call.Return(newViewEvent, err)
	return _c
}

func (_c *PaceMaker_ProcessTC_Call) RunAndReturn(run func(tc *flow.TimeoutCertificate) (*model.NewViewEvent, error)) *PaceMaker_ProcessTC_Call {
	_c.Call.Return(run)
	return _c
}

// Start provides a mock function for the type PaceMaker
func (_mock *PaceMaker) Start(ctx context.Context) {
	_mock.Called(ctx)
	return
}

// PaceMaker_Start_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Start'
type PaceMaker_Start_Call struct {
	*mock.Call
}

// Start is a helper method to define mock.On call
//   - ctx context.Context
func (_e *PaceMaker_Expecter) Start(ctx interface{}) *PaceMaker_Start_Call {
	return &PaceMaker_Start_Call{Call: _e.mock.On("Start", ctx)}
}

func (_c *PaceMaker_Start_Call) Run(run func(ctx context.Context)) *PaceMaker_Start_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PaceMaker_Start_Call) Return() *PaceMaker_Start_Call {
	_c.Call.Return()
	return _c
}

func (_c *PaceMaker_Start_Call) RunAndReturn(run func(ctx context.Context)) *PaceMaker_Start_Call {
	_c.Run(run)
	return _c
}

// TargetPublicationTime provides a mock function for the type PaceMaker
func (_mock *PaceMaker) TargetPublicationTime(proposalView uint64, timeViewEntered time.Time, parentBlockId flow.Identifier) time.Time {
	ret := _mock.Called(proposalView, timeViewEntered, parentBlockId)

	if len(ret) == 0 {
		panic("no return value specified for TargetPublicationTime")
	}

	var r0 time.Time
	if returnFunc, ok := ret.Get(0).(func(uint64, time.Time, flow.Identifier) time.Time); ok {
		r0 = returnFunc(proposalView, timeViewEntered, parentBlockId)
	} else {
		r0 = ret.Get(0).(time.Time)
	}
	return r0
}

// PaceMaker_TargetPublicationTime_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TargetPublicationTime'
type PaceMaker_TargetPublicationTime_Call struct {
	*mock.Call
}

// TargetPublicationTime is a helper method to define mock.On call
//   - proposalView uint64
//   - timeViewEntered time.Time
//   - parentBlockId flow.Identifier
func (_e *PaceMaker_Expecter) TargetPublicationTime(proposalView interface{}, timeViewEntered interface{}, parentBlockId interface{}) *PaceMaker_TargetPublicationTime_Call {
	return &PaceMaker_TargetPublicationTime_Call{Call: _e.mock.On("TargetPublicationTime", proposalView, timeViewEntered, parentBlockId)}
}

func (_c *PaceMaker_TargetPublicationTime_Call) Run(run func(proposalView uint64, timeViewEntered time.Time, parentBlockId flow.Identifier)) *PaceMaker_TargetPublicationTime_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		var arg1 time.Time
		if args[1] != nil {
			arg1 = args[1].(time.Time)
		}
		var arg2 flow.Identifier
		if args[2] != nil {
			arg2 = args[2].(flow.Identifier)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *PaceMaker_TargetPublicationTime_Call) Return(time1 time.Time) *PaceMaker_TargetPublicationTime_Call {
	_c.Call.Return(time1)
	return _c
}

func (_c *PaceMaker_TargetPublicationTime_Call) RunAndReturn(run func(proposalView uint64, timeViewEntered time.Time, parentBlockId flow.Identifier) time.Time) *PaceMaker_TargetPublicationTime_Call {
	_c.Call.Return(run)
	return _c
}

// TimeoutChannel provides a mock function for the type PaceMaker
func (_mock *PaceMaker) TimeoutChannel() <-chan time.Time {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for TimeoutChannel")
	}

	var r0 <-chan time.Time
	if returnFunc, ok := ret.Get(0).(func() <-chan time.Time); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan time.Time)
		}
	}
	return r0
}

// PaceMaker_TimeoutChannel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimeoutChannel'
type PaceMaker_TimeoutChannel_Call struct {
	*mock.Call
}

// TimeoutChannel is a helper method to define mock.On call
func (_e *PaceMaker_Expecter) TimeoutChannel() *PaceMaker_TimeoutChannel_Call {
	return &PaceMaker_TimeoutChannel_Call{Call: _e.mock.On("TimeoutChannel")}
}

func (_c *PaceMaker_TimeoutChannel_Call) Run(run func()) *PaceMaker_TimeoutChannel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *PaceMaker_TimeoutChannel_Call) Return(timeCh <-chan time.Time) *PaceMaker_TimeoutChannel_Call {
	_c.Call.Return(timeCh)
	return _c
}

func (_c *PaceMaker_TimeoutChannel_Call) RunAndReturn(run func() <-chan time.Time) *PaceMaker_TimeoutChannel_Call {
	_c.Call.Return(run)
	return _c
}

// NewProposalDurationProvider creates a new instance of ProposalDurationProvider. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewProposalDurationProvider(t interface {
	mock.TestingT
	Cleanup(func())
}) *ProposalDurationProvider {
	mock := &ProposalDurationProvider{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// ProposalDurationProvider is an autogenerated mock type for the ProposalDurationProvider type
type ProposalDurationProvider struct {
	mock.Mock
}

type ProposalDurationProvider_Expecter struct {
	mock *mock.Mock
}

func (_m *ProposalDurationProvider) EXPECT() *ProposalDurationProvider_Expecter {
	return &ProposalDurationProvider_Expecter{mock: &_m.Mock}
}

// TargetPublicationTime provides a mock function for the type ProposalDurationProvider
func (_mock *ProposalDurationProvider) TargetPublicationTime(proposalView uint64, timeViewEntered time.Time, parentBlockId flow.Identifier) time.Time {
	ret := _mock.Called(proposalView, timeViewEntered, parentBlockId)

	if len(ret) == 0 {
		panic("no return value specified for TargetPublicationTime")
	}

	var r0 time.Time
	if returnFunc, ok := ret.Get(0).(func(uint64, time.Time, flow.Identifier) time.Time); ok {
		r0 = returnFunc(proposalView, timeViewEntered, parentBlockId)
	} else {
		r0 = ret.Get(0).(time.Time)
	}
	return r0
}

// ProposalDurationProvider_TargetPublicationTime_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TargetPublicationTime'
type ProposalDurationProvider_TargetPublicationTime_Call struct {
	*mock.Call
}

// TargetPublicationTime is a helper method to define mock.On call
//   - proposalView uint64
//   - timeViewEntered time.Time
//   - parentBlockId flow.Identifier
func (_e *ProposalDurationProvider_Expecter) TargetPublicationTime(proposalView interface{}, timeViewEntered interface{}, parentBlockId interface{}) *ProposalDurationProvider_TargetPublicationTime_Call {
	return &ProposalDurationProvider_TargetPublicationTime_Call{Call: _e.mock.On("TargetPublicationTime", proposalView, timeViewEntered, parentBlockId)}
}

func (_c *ProposalDurationProvider_TargetPublicationTime_Call) Run(run func(proposalView uint64, timeViewEntered time.Time, parentBlockId flow.Identifier)) *ProposalDurationProvider_TargetPublicationTime_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		var arg1 time.Time
		if args[1] != nil {
			arg1 = args[1].(time.Time)
		}
		var arg2 flow.Identifier
		if args[2] != nil {
			arg2 = args[2].(flow.Identifier)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *ProposalDurationProvider_TargetPublicationTime_Call) Return(time1 time.Time) *ProposalDurationProvider_TargetPublicationTime_Call {
	_c.Call.Return(time1)
	return _c
}

func (_c *ProposalDurationProvider_TargetPublicationTime_Call) RunAndReturn(run func(proposalView uint64, timeViewEntered time.Time, parentBlockId flow.Identifier) time.Time) *ProposalDurationProvider_TargetPublicationTime_Call {
	_c.Call.Return(run)
	return _c
}

// NewPersister creates a new instance of Persister. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewPersister(t interface {
	mock.TestingT
	Cleanup(func())
}) *Persister {
	mock := &Persister{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Persister is an autogenerated mock type for the Persister type
type Persister struct {
	mock.Mock
}

type Persister_Expecter struct {
	mock *mock.Mock
}

func (_m *Persister) EXPECT() *Persister_Expecter {
	return &Persister_Expecter{mock: &_m.Mock}
}

// GetLivenessData provides a mock function for the type Persister
func (_mock *Persister) GetLivenessData() (*hotstuff.LivenessData, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetLivenessData")
	}

	var r0 *hotstuff.LivenessData
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (*hotstuff.LivenessData, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() *hotstuff.LivenessData); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*hotstuff.LivenessData)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Persister_GetLivenessData_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLivenessData'
type Persister_GetLivenessData_Call struct {
	*mock.Call
}

// GetLivenessData is a helper method to define mock.On call
func (_e *Persister_Expecter) GetLivenessData() *Persister_GetLivenessData_Call {
	return &Persister_GetLivenessData_Call{Call: _e.mock.On("GetLivenessData")}
}

func (_c *Persister_GetLivenessData_Call) Run(run func()) *Persister_GetLivenessData_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Persister_GetLivenessData_Call) Return(livenessData *hotstuff.LivenessData, err error) *Persister_GetLivenessData_Call {
	_c.Call.Return(livenessData, err)
	return _c
}

func (_c *Persister_GetLivenessData_Call) RunAndReturn(run func() (*hotstuff.LivenessData, error)) *Persister_GetLivenessData_Call {
	_c.Call.Return(run)
	return _c
}

// GetSafetyData provides a mock function for the type Persister
func (_mock *Persister) GetSafetyData() (*hotstuff.SafetyData, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetSafetyData")
	}

	var r0 *hotstuff.SafetyData
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (*hotstuff.SafetyData, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() *hotstuff.SafetyData); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*hotstuff.SafetyData)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Persister_GetSafetyData_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSafetyData'
type Persister_GetSafetyData_Call struct {
	*mock.Call
}

// GetSafetyData is a helper method to define mock.On call
func (_e *Persister_Expecter) GetSafetyData() *Persister_GetSafetyData_Call {
	return &Persister_GetSafetyData_Call{Call: _e.mock.On("GetSafetyData")}
}

func (_c *Persister_GetSafetyData_Call) Run(run func()) *Persister_GetSafetyData_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Persister_GetSafetyData_Call) Return(safetyData *hotstuff.SafetyData, err error) *Persister_GetSafetyData_Call {
	_c.Call.Return(safetyData, err)
	return _c
}

func (_c *Persister_GetSafetyData_Call) RunAndReturn(run func() (*hotstuff.SafetyData, error)) *Persister_GetSafetyData_Call {
	_c.Call.Return(run)
	return _c
}

// PutLivenessData provides a mock function for the type Persister
func (_mock *Persister) PutLivenessData(livenessData *hotstuff.LivenessData) error {
	ret := _mock.Called(livenessData)

	if len(ret) == 0 {
		panic("no return value specified for PutLivenessData")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*hotstuff.LivenessData) error); ok {
		r0 = returnFunc(livenessData)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Persister_PutLivenessData_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutLivenessData'
type Persister_PutLivenessData_Call struct {
	*mock.Call
}

// PutLivenessData is a helper method to define mock.On call
//   - livenessData *hotstuff.LivenessData
func (_e *Persister_Expecter) PutLivenessData(livenessData interface{}) *Persister_PutLivenessData_Call {
	return &Persister_PutLivenessData_Call{Call: _e.mock.On("PutLivenessData", livenessData)}
}

func (_c *Persister_PutLivenessData_Call) Run(run func(livenessData *hotstuff.LivenessData)) *Persister_PutLivenessData_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *hotstuff.LivenessData
		if args[0] != nil {
			arg0 = args[0].(*hotstuff.LivenessData)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Persister_PutLivenessData_Call) Return(err error) *Persister_PutLivenessData_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Persister_PutLivenessData_Call) RunAndReturn(run func(livenessData *hotstuff.LivenessData) error) *Persister_PutLivenessData_Call {
	_c.Call.Return(run)
	return _c
}

// PutSafetyData provides a mock function for the type Persister
func (_mock *Persister) PutSafetyData(safetyData *hotstuff.SafetyData) error {
	ret := _mock.Called(safetyData)

	if len(ret) == 0 {
		panic("no return value specified for PutSafetyData")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*hotstuff.SafetyData) error); ok {
		r0 = returnFunc(safetyData)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Persister_PutSafetyData_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutSafetyData'
type Persister_PutSafetyData_Call struct {
	*mock.Call
}

// PutSafetyData is a helper method to define mock.On call
//   - safetyData *hotstuff.SafetyData
func (_e *Persister_Expecter) PutSafetyData(safetyData interface{}) *Persister_PutSafetyData_Call {
	return &Persister_PutSafetyData_Call{Call: _e.mock.On("PutSafetyData", safetyData)}
}

func (_c *Persister_PutSafetyData_Call) Run(run func(safetyData *hotstuff.SafetyData)) *Persister_PutSafetyData_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *hotstuff.SafetyData
		if args[0] != nil {
			arg0 = args[0].(*hotstuff.SafetyData)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Persister_PutSafetyData_Call) Return(err error) *Persister_PutSafetyData_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Persister_PutSafetyData_Call) RunAndReturn(run func(safetyData *hotstuff.SafetyData) error) *Persister_PutSafetyData_Call {
	_c.Call.Return(run)
	return _c
}

// NewPersisterReader creates a new instance of PersisterReader. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewPersisterReader(t interface {
	mock.TestingT
	Cleanup(func())
}) *PersisterReader {
	mock := &PersisterReader{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// PersisterReader is an autogenerated mock type for the PersisterReader type
type PersisterReader struct {
	mock.Mock
}

type PersisterReader_Expecter struct {
	mock *mock.Mock
}

func (_m *PersisterReader) EXPECT() *PersisterReader_Expecter {
	return &PersisterReader_Expecter{mock: &_m.Mock}
}

// GetLivenessData provides a mock function for the type PersisterReader
func (_mock *PersisterReader) GetLivenessData() (*hotstuff.LivenessData, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetLivenessData")
	}

	var r0 *hotstuff.LivenessData
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (*hotstuff.LivenessData, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() *hotstuff.LivenessData); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*hotstuff.LivenessData)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// PersisterReader_GetLivenessData_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLivenessData'
type PersisterReader_GetLivenessData_Call struct {
	*mock.Call
}

// GetLivenessData is a helper method to define mock.On call
func (_e *PersisterReader_Expecter) GetLivenessData() *PersisterReader_GetLivenessData_Call {
	return &PersisterReader_GetLivenessData_Call{Call: _e.mock.On("GetLivenessData")}
}

func (_c *PersisterReader_GetLivenessData_Call) Run(run func()) *PersisterReader_GetLivenessData_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *PersisterReader_GetLivenessData_Call) Return(livenessData *hotstuff.LivenessData, err error) *PersisterReader_GetLivenessData_Call {
	_c.Call.Return(livenessData, err)
	return _c
}

func (_c *PersisterReader_GetLivenessData_Call) RunAndReturn(run func() (*hotstuff.LivenessData, error)) *PersisterReader_GetLivenessData_Call {
	_c.Call.Return(run)
	return _c
}

// GetSafetyData provides a mock function for the type PersisterReader
func (_mock *PersisterReader) GetSafetyData() (*hotstuff.SafetyData, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetSafetyData")
	}

	var r0 *hotstuff.SafetyData
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (*hotstuff.SafetyData, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() *hotstuff.SafetyData); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*hotstuff.SafetyData)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// PersisterReader_GetSafetyData_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSafetyData'
type PersisterReader_GetSafetyData_Call struct {
	*mock.Call
}

// GetSafetyData is a helper method to define mock.On call
func (_e *PersisterReader_Expecter) GetSafetyData() *PersisterReader_GetSafetyData_Call {
	return &PersisterReader_GetSafetyData_Call{Call: _e.mock.On("GetSafetyData")}
}

func (_c *PersisterReader_GetSafetyData_Call) Run(run func()) *PersisterReader_GetSafetyData_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *PersisterReader_GetSafetyData_Call) Return(safetyData *hotstuff.SafetyData, err error) *PersisterReader_GetSafetyData_Call {
	_c.Call.Return(safetyData, err)
	return _c
}

func (_c *PersisterReader_GetSafetyData_Call) RunAndReturn(run func() (*hotstuff.SafetyData, error)) *PersisterReader_GetSafetyData_Call {
	_c.Call.Return(run)
	return _c
}

// NewRandomBeaconInspector creates a new instance of RandomBeaconInspector. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewRandomBeaconInspector(t interface {
	mock.TestingT
	Cleanup(func())
}) *RandomBeaconInspector {
	mock := &RandomBeaconInspector{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// RandomBeaconInspector is an autogenerated mock type for the RandomBeaconInspector type
type RandomBeaconInspector struct {
	mock.Mock
}

type RandomBeaconInspector_Expecter struct {
	mock *mock.Mock
}

func (_m *RandomBeaconInspector) EXPECT() *RandomBeaconInspector_Expecter {
	return &RandomBeaconInspector_Expecter{mock: &_m.Mock}
}

// EnoughShares provides a mock function for the type RandomBeaconInspector
func (_mock *RandomBeaconInspector) EnoughShares() bool {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for EnoughShares")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func() bool); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// RandomBeaconInspector_EnoughShares_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnoughShares'
type RandomBeaconInspector_EnoughShares_Call struct {
	*mock.Call
}

// EnoughShares is a helper method to define mock.On call
func (_e *RandomBeaconInspector_Expecter) EnoughShares() *RandomBeaconInspector_EnoughShares_Call {
	return &RandomBeaconInspector_EnoughShares_Call{Call: _e.mock.On("EnoughShares")}
}

func (_c *RandomBeaconInspector_EnoughShares_Call) Run(run func()) *RandomBeaconInspector_EnoughShares_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *RandomBeaconInspector_EnoughShares_Call) Return(b bool) *RandomBeaconInspector_EnoughShares_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *RandomBeaconInspector_EnoughShares_Call) RunAndReturn(run func() bool) *RandomBeaconInspector_EnoughShares_Call {
	_c.Call.Return(run)
	return _c
}

// Reconstruct provides a mock function for the type RandomBeaconInspector
func (_mock *RandomBeaconInspector) Reconstruct() (crypto.Signature, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Reconstruct")
	}

	var r0 crypto.Signature
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (crypto.Signature, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() crypto.Signature); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(crypto.Signature)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// RandomBeaconInspector_Reconstruct_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Reconstruct'
type RandomBeaconInspector_Reconstruct_Call struct {
	*mock.Call
}

// Reconstruct is a helper method to define mock.On call
func (_e *RandomBeaconInspector_Expecter) Reconstruct() *RandomBeaconInspector_Reconstruct_Call {
	return &RandomBeaconInspector_Reconstruct_Call{Call: _e.mock.On("Reconstruct")}
}

func (_c *RandomBeaconInspector_Reconstruct_Call) Run(run func()) *RandomBeaconInspector_Reconstruct_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *RandomBeaconInspector_Reconstruct_Call) Return(signature crypto.Signature, err error) *RandomBeaconInspector_Reconstruct_Call {
	_c.Call.Return(signature, err)
	return _c
}

func (_c *RandomBeaconInspector_Reconstruct_Call) RunAndReturn(run func() (crypto.Signature, error)) *RandomBeaconInspector_Reconstruct_Call {
	_c.Call.Return(run)
	return _c
}

// TrustedAdd provides a mock function for the type RandomBeaconInspector
func (_mock *RandomBeaconInspector) TrustedAdd(signerIndex int, share crypto.Signature) (bool, error) {
	ret := _mock.Called(signerIndex, share)

	if len(ret) == 0 {
		panic("no return value specified for TrustedAdd")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(int, crypto.Signature) (bool, error)); ok {
		return returnFunc(signerIndex, share)
	}
	if returnFunc, ok := ret.Get(0).(func(int, crypto.Signature) bool); ok {
		r0 = returnFunc(signerIndex, share)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(int, crypto.Signature) error); ok {
		r1 = returnFunc(signerIndex, share)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// RandomBeaconInspector_TrustedAdd_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TrustedAdd'
type RandomBeaconInspector_TrustedAdd_Call struct {
	*mock.Call
}

// TrustedAdd is a helper method to define mock.On call
//   - signerIndex int
//   - share crypto.Signature
func (_e *RandomBeaconInspector_Expecter) TrustedAdd(signerIndex interface{}, share interface{}) *RandomBeaconInspector_TrustedAdd_Call {
	return &RandomBeaconInspector_TrustedAdd_Call{Call: _e.mock.On("TrustedAdd", signerIndex, share)}
}

func (_c *RandomBeaconInspector_TrustedAdd_Call) Run(run func(signerIndex int, share crypto.Signature)) *RandomBeaconInspector_TrustedAdd_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 int
		if args[0] != nil {
			arg0 = args[0].(int)
		}
		var arg1 crypto.Signature
		if args[1] != nil {
			arg1 = args[1].(crypto.Signature)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *RandomBeaconInspector_TrustedAdd_Call) Return(enoughshares bool, exception error) *RandomBeaconInspector_TrustedAdd_Call {
	_c.Call.Return(enoughshares, exception)
	return _c
}

func (_c *RandomBeaconInspector_TrustedAdd_Call) RunAndReturn(run func(signerIndex int, share crypto.Signature) (bool, error)) *RandomBeaconInspector_TrustedAdd_Call {
	_c.Call.Return(run)
	return _c
}

// Verify provides a mock function for the type RandomBeaconInspector
func (_mock *RandomBeaconInspector) Verify(signerIndex int, share crypto.Signature) error {
	ret := _mock.Called(signerIndex, share)

	if len(ret) == 0 {
		panic("no return value specified for Verify")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(int, crypto.Signature) error); ok {
		r0 = returnFunc(signerIndex, share)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// RandomBeaconInspector_Verify_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Verify'
type RandomBeaconInspector_Verify_Call struct {
	*mock.Call
}

// Verify is a helper method to define mock.On call
//   - signerIndex int
//   - share crypto.Signature
func (_e *RandomBeaconInspector_Expecter) Verify(signerIndex interface{}, share interface{}) *RandomBeaconInspector_Verify_Call {
	return &RandomBeaconInspector_Verify_Call{Call: _e.mock.On("Verify", signerIndex, share)}
}

func (_c *RandomBeaconInspector_Verify_Call) Run(run func(signerIndex int, share crypto.Signature)) *RandomBeaconInspector_Verify_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 int
		if args[0] != nil {
			arg0 = args[0].(int)
		}
		var arg1 crypto.Signature
		if args[1] != nil {
			arg1 = args[1].(crypto.Signature)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *RandomBeaconInspector_Verify_Call) Return(err error) *RandomBeaconInspector_Verify_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *RandomBeaconInspector_Verify_Call) RunAndReturn(run func(signerIndex int, share crypto.Signature) error) *RandomBeaconInspector_Verify_Call {
	_c.Call.Return(run)
	return _c
}

// NewSafetyRules creates a new instance of SafetyRules. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewSafetyRules(t interface {
	mock.TestingT
	Cleanup(func())
}) *SafetyRules {
	mock := &SafetyRules{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// SafetyRules is an autogenerated mock type for the SafetyRules type
type SafetyRules struct {
	mock.Mock
}

type SafetyRules_Expecter struct {
	mock *mock.Mock
}

func (_m *SafetyRules) EXPECT() *SafetyRules_Expecter {
	return &SafetyRules_Expecter{mock: &_m.Mock}
}

// ProduceTimeout provides a mock function for the type SafetyRules
func (_mock *SafetyRules) ProduceTimeout(curView uint64, newestQC *flow.QuorumCertificate, lastViewTC *flow.TimeoutCertificate) (*model.TimeoutObject, error) {
	ret := _mock.Called(curView, newestQC, lastViewTC)

	if len(ret) == 0 {
		panic("no return value specified for ProduceTimeout")
	}

	var r0 *model.TimeoutObject
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(uint64, *flow.QuorumCertificate, *flow.TimeoutCertificate) (*model.TimeoutObject, error)); ok {
		return returnFunc(curView, newestQC, lastViewTC)
	}
	if returnFunc, ok := ret.Get(0).(func(uint64, *flow.QuorumCertificate, *flow.TimeoutCertificate) *model.TimeoutObject); ok {
		r0 = returnFunc(curView, newestQC, lastViewTC)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.TimeoutObject)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(uint64, *flow.QuorumCertificate, *flow.TimeoutCertificate) error); ok {
		r1 = returnFunc(curView, newestQC, lastViewTC)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// SafetyRules_ProduceTimeout_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ProduceTimeout'
type SafetyRules_ProduceTimeout_Call struct {
	*mock.Call
}

// ProduceTimeout is a helper method to define mock.On call
//   - curView uint64
//   - newestQC *flow.QuorumCertificate
//   - lastViewTC *flow.TimeoutCertificate
func (_e *SafetyRules_Expecter) ProduceTimeout(curView interface{}, newestQC interface{}, lastViewTC interface{}) *SafetyRules_ProduceTimeout_Call {
	return &SafetyRules_ProduceTimeout_Call{Call: _e.mock.On("ProduceTimeout", curView, newestQC, lastViewTC)}
}

func (_c *SafetyRules_ProduceTimeout_Call) Run(run func(curView uint64, newestQC *flow.QuorumCertificate, lastViewTC *flow.TimeoutCertificate)) *SafetyRules_ProduceTimeout_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		var arg1 *flow.QuorumCertificate
		if args[1] != nil {
			arg1 = args[1].(*flow.QuorumCertificate)
		}
		var arg2 *flow.TimeoutCertificate
		if args[2] != nil {
			arg2 = args[2].(*flow.TimeoutCertificate)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *SafetyRules_ProduceTimeout_Call) Return(timeoutObject *model.TimeoutObject, err error) *SafetyRules_ProduceTimeout_Call {
	_c.Call.Return(timeoutObject, err)
	return _c
}

func (_c *SafetyRules_ProduceTimeout_Call) RunAndReturn(run func(curView uint64, newestQC *flow.QuorumCertificate, lastViewTC *flow.TimeoutCertificate) (*model.TimeoutObject, error)) *SafetyRules_ProduceTimeout_Call {
	_c.Call.Return(run)
	return _c
}

// ProduceVote provides a mock function for the type SafetyRules
func (_mock *SafetyRules) ProduceVote(proposal *model.SignedProposal, curView uint64) (*model.Vote, error) {
	ret := _mock.Called(proposal, curView)

	if len(ret) == 0 {
		panic("no return value specified for ProduceVote")
	}

	var r0 *model.Vote
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*model.SignedProposal, uint64) (*model.Vote, error)); ok {
		return returnFunc(proposal, curView)
	}
	if returnFunc, ok := ret.Get(0).(func(*model.SignedProposal, uint64) *model.Vote); ok {
		r0 = returnFunc(proposal, curView)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Vote)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*model.SignedProposal, uint64) error); ok {
		r1 = returnFunc(proposal, curView)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// SafetyRules_ProduceVote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ProduceVote'
type SafetyRules_ProduceVote_Call struct {
	*mock.Call
}

// ProduceVote is a helper method to define mock.On call
//   - proposal *model.SignedProposal
//   - curView uint64
func (_e *SafetyRules_Expecter) ProduceVote(proposal interface{}, curView interface{}) *SafetyRules_ProduceVote_Call {
	return &SafetyRules_ProduceVote_Call{Call: _e.mock.On("ProduceVote", proposal, curView)}
}

func (_c *SafetyRules_ProduceVote_Call) Run(run func(proposal *model.SignedProposal, curView uint64)) *SafetyRules_ProduceVote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.SignedProposal
		if args[0] != nil {
			arg0 = args[0].(*model.SignedProposal)
		}
		var arg1 uint64
		if args[1] != nil {
			arg1 = args[1].(uint64)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *SafetyRules_ProduceVote_Call) Return(vote *model.Vote, err error) *SafetyRules_ProduceVote_Call {
	_c.Call.Return(vote, err)
	return _c
}

func (_c *SafetyRules_ProduceVote_Call) RunAndReturn(run func(proposal *model.SignedProposal, curView uint64) (*model.Vote, error)) *SafetyRules_ProduceVote_Call {
	_c.Call.Return(run)
	return _c
}

// SignOwnProposal provides a mock function for the type SafetyRules
func (_mock *SafetyRules) SignOwnProposal(unsignedProposal *model.Proposal) (*model.Vote, error) {
	ret := _mock.Called(unsignedProposal)

	if len(ret) == 0 {
		panic("no return value specified for SignOwnProposal")
	}

	var r0 *model.Vote
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*model.Proposal) (*model.Vote, error)); ok {
		return returnFunc(unsignedProposal)
	}
	if returnFunc, ok := ret.Get(0).(func(*model.Proposal) *model.Vote); ok {
		r0 = returnFunc(unsignedProposal)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Vote)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*model.Proposal) error); ok {
		r1 = returnFunc(unsignedProposal)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// SafetyRules_SignOwnProposal_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SignOwnProposal'
type SafetyRules_SignOwnProposal_Call struct {
	*mock.Call
}

// SignOwnProposal is a helper method to define mock.On call
//   - unsignedProposal *model.Proposal
func (_e *SafetyRules_Expecter) SignOwnProposal(unsignedProposal interface{}) *SafetyRules_SignOwnProposal_Call {
	return &SafetyRules_SignOwnProposal_Call{Call: _e.mock.On("SignOwnProposal", unsignedProposal)}
}

func (_c *SafetyRules_SignOwnProposal_Call) Run(run func(unsignedProposal *model.Proposal)) *SafetyRules_SignOwnProposal_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Proposal
		if args[0] != nil {
			arg0 = args[0].(*model.Proposal)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *SafetyRules_SignOwnProposal_Call) Return(vote *model.Vote, err error) *SafetyRules_SignOwnProposal_Call {
	_c.Call.Return(vote, err)
	return _c
}

func (_c *SafetyRules_SignOwnProposal_Call) RunAndReturn(run func(unsignedProposal *model.Proposal) (*model.Vote, error)) *SafetyRules_SignOwnProposal_Call {
	_c.Call.Return(run)
	return _c
}

// NewRandomBeaconReconstructor creates a new instance of RandomBeaconReconstructor. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewRandomBeaconReconstructor(t interface {
	mock.TestingT
	Cleanup(func())
}) *RandomBeaconReconstructor {
	mock := &RandomBeaconReconstructor{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// RandomBeaconReconstructor is an autogenerated mock type for the RandomBeaconReconstructor type
type RandomBeaconReconstructor struct {
	mock.Mock
}

type RandomBeaconReconstructor_Expecter struct {
	mock *mock.Mock
}

func (_m *RandomBeaconReconstructor) EXPECT() *RandomBeaconReconstructor_Expecter {
	return &RandomBeaconReconstructor_Expecter{mock: &_m.Mock}
}

// EnoughShares provides a mock function for the type RandomBeaconReconstructor
func (_mock *RandomBeaconReconstructor) EnoughShares() bool {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for EnoughShares")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func() bool); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// RandomBeaconReconstructor_EnoughShares_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnoughShares'
type RandomBeaconReconstructor_EnoughShares_Call struct {
	*mock.Call
}

// EnoughShares is a helper method to define mock.On call
func (_e *RandomBeaconReconstructor_Expecter) EnoughShares() *RandomBeaconReconstructor_EnoughShares_Call {
	return &RandomBeaconReconstructor_EnoughShares_Call{Call: _e.mock.On("EnoughShares")}
}

func (_c *RandomBeaconReconstructor_EnoughShares_Call) Run(run func()) *RandomBeaconReconstructor_EnoughShares_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *RandomBeaconReconstructor_EnoughShares_Call) Return(b bool) *RandomBeaconReconstructor_EnoughShares_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *RandomBeaconReconstructor_EnoughShares_Call) RunAndReturn(run func() bool) *RandomBeaconReconstructor_EnoughShares_Call {
	_c.Call.Return(run)
	return _c
}

// Reconstruct provides a mock function for the type RandomBeaconReconstructor
func (_mock *RandomBeaconReconstructor) Reconstruct() (crypto.Signature, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Reconstruct")
	}

	var r0 crypto.Signature
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (crypto.Signature, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() crypto.Signature); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(crypto.Signature)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// RandomBeaconReconstructor_Reconstruct_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Reconstruct'
type RandomBeaconReconstructor_Reconstruct_Call struct {
	*mock.Call
}

// Reconstruct is a helper method to define mock.On call
func (_e *RandomBeaconReconstructor_Expecter) Reconstruct() *RandomBeaconReconstructor_Reconstruct_Call {
	return &RandomBeaconReconstructor_Reconstruct_Call{Call: _e.mock.On("Reconstruct")}
}

func (_c *RandomBeaconReconstructor_Reconstruct_Call) Run(run func()) *RandomBeaconReconstructor_Reconstruct_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *RandomBeaconReconstructor_Reconstruct_Call) Return(signature crypto.Signature, err error) *RandomBeaconReconstructor_Reconstruct_Call {
	_c.Call.Return(signature, err)
	return _c
}

func (_c *RandomBeaconReconstructor_Reconstruct_Call) RunAndReturn(run func() (crypto.Signature, error)) *RandomBeaconReconstructor_Reconstruct_Call {
	_c.Call.Return(run)
	return _c
}

// TrustedAdd provides a mock function for the type RandomBeaconReconstructor
func (_mock *RandomBeaconReconstructor) TrustedAdd(signerID flow.Identifier, sig crypto.Signature) (bool, error) {
	ret := _mock.Called(signerID, sig)

	if len(ret) == 0 {
		panic("no return value specified for TrustedAdd")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, crypto.Signature) (bool, error)); ok {
		return returnFunc(signerID, sig)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, crypto.Signature) bool); ok {
		r0 = returnFunc(signerID, sig)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier, crypto.Signature) error); ok {
		r1 = returnFunc(signerID, sig)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// RandomBeaconReconstructor_TrustedAdd_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TrustedAdd'
type RandomBeaconReconstructor_TrustedAdd_Call struct {
	*mock.Call
}

// TrustedAdd is a helper method to define mock.On call
//   - signerID flow.Identifier
//   - sig crypto.Signature
func (_e *RandomBeaconReconstructor_Expecter) TrustedAdd(signerID interface{}, sig interface{}) *RandomBeaconReconstructor_TrustedAdd_Call {
	return &RandomBeaconReconstructor_TrustedAdd_Call{Call: _e.mock.On("TrustedAdd", signerID, sig)}
}

func (_c *RandomBeaconReconstructor_TrustedAdd_Call) Run(run func(signerID flow.Identifier, sig crypto.Signature)) *RandomBeaconReconstructor_TrustedAdd_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		var arg1 crypto.Signature
		if args[1] != nil {
			arg1 = args[1].(crypto.Signature)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *RandomBeaconReconstructor_TrustedAdd_Call) Return(EnoughShares bool, err error) *RandomBeaconReconstructor_TrustedAdd_Call {
	_c.Call.Return(EnoughShares, err)
	return _c
}

func (_c *RandomBeaconReconstructor_TrustedAdd_Call) RunAndReturn(run func(signerID flow.Identifier, sig crypto.Signature) (bool, error)) *RandomBeaconReconstructor_TrustedAdd_Call {
	_c.Call.Return(run)
	return _c
}

// Verify provides a mock function for the type RandomBeaconReconstructor
func (_mock *RandomBeaconReconstructor) Verify(signerID flow.Identifier, sig crypto.Signature) error {
	ret := _mock.Called(signerID, sig)

	if len(ret) == 0 {
		panic("no return value specified for Verify")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, crypto.Signature) error); ok {
		r0 = returnFunc(signerID, sig)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// RandomBeaconReconstructor_Verify_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Verify'
type RandomBeaconReconstructor_Verify_Call struct {
	*mock.Call
}

// Verify is a helper method to define mock.On call
//   - signerID flow.Identifier
//   - sig crypto.Signature
func (_e *RandomBeaconReconstructor_Expecter) Verify(signerID interface{}, sig interface{}) *RandomBeaconReconstructor_Verify_Call {
	return &RandomBeaconReconstructor_Verify_Call{Call: _e.mock.On("Verify", signerID, sig)}
}

func (_c *RandomBeaconReconstructor_Verify_Call) Run(run func(signerID flow.Identifier, sig crypto.Signature)) *RandomBeaconReconstructor_Verify_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		var arg1 crypto.Signature
		if args[1] != nil {
			arg1 = args[1].(crypto.Signature)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *RandomBeaconReconstructor_Verify_Call) Return(err error) *RandomBeaconReconstructor_Verify_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *RandomBeaconReconstructor_Verify_Call) RunAndReturn(run func(signerID flow.Identifier, sig crypto.Signature) error) *RandomBeaconReconstructor_Verify_Call {
	_c.Call.Return(run)
	return _c
}

// NewWeightedSignatureAggregator creates a new instance of WeightedSignatureAggregator. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewWeightedSignatureAggregator(t interface {
	mock.TestingT
	Cleanup(func())
}) *WeightedSignatureAggregator {
	mock := &WeightedSignatureAggregator{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// WeightedSignatureAggregator is an autogenerated mock type for the WeightedSignatureAggregator type
type WeightedSignatureAggregator struct {
	mock.Mock
}

type WeightedSignatureAggregator_Expecter struct {
	mock *mock.Mock
}

func (_m *WeightedSignatureAggregator) EXPECT() *WeightedSignatureAggregator_Expecter {
	return &WeightedSignatureAggregator_Expecter{mock: &_m.Mock}
}

// Aggregate provides a mock function for the type WeightedSignatureAggregator
func (_mock *WeightedSignatureAggregator) Aggregate() (flow.IdentifierList, []byte, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Aggregate")
	}

	var r0 flow.IdentifierList
	var r1 []byte
	var r2 error
	if returnFunc, ok := ret.Get(0).(func() (flow.IdentifierList, []byte, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() flow.IdentifierList); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.IdentifierList)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() []byte); ok {
		r1 = returnFunc()
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]byte)
		}
	}
	if returnFunc, ok := ret.Get(2).(func() error); ok {
		r2 = returnFunc()
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// WeightedSignatureAggregator_Aggregate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Aggregate'
type WeightedSignatureAggregator_Aggregate_Call struct {
	*mock.Call
}

// Aggregate is a helper method to define mock.On call
func (_e *WeightedSignatureAggregator_Expecter) Aggregate() *WeightedSignatureAggregator_Aggregate_Call {
	return &WeightedSignatureAggregator_Aggregate_Call{Call: _e.mock.On("Aggregate")}
}

func (_c *WeightedSignatureAggregator_Aggregate_Call) Run(run func()) *WeightedSignatureAggregator_Aggregate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *WeightedSignatureAggregator_Aggregate_Call) Return(identifierList flow.IdentifierList, bytes []byte, err error) *WeightedSignatureAggregator_Aggregate_Call {
	_c.Call.Return(identifierList, bytes, err)
	return _c
}

func (_c *WeightedSignatureAggregator_Aggregate_Call) RunAndReturn(run func() (flow.IdentifierList, []byte, error)) *WeightedSignatureAggregator_Aggregate_Call {
	_c.Call.Return(run)
	return _c
}

// TotalWeight provides a mock function for the type WeightedSignatureAggregator
func (_mock *WeightedSignatureAggregator) TotalWeight() uint64 {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for TotalWeight")
	}

	var r0 uint64
	if returnFunc, ok := ret.Get(0).(func() uint64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint64)
	}
	return r0
}

// WeightedSignatureAggregator_TotalWeight_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TotalWeight'
type WeightedSignatureAggregator_TotalWeight_Call struct {
	*mock.Call
}

// TotalWeight is a helper method to define mock.On call
func (_e *WeightedSignatureAggregator_Expecter) TotalWeight() *WeightedSignatureAggregator_TotalWeight_Call {
	return &WeightedSignatureAggregator_TotalWeight_Call{Call: _e.mock.On("TotalWeight")}
}

func (_c *WeightedSignatureAggregator_TotalWeight_Call) Run(run func()) *WeightedSignatureAggregator_TotalWeight_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *WeightedSignatureAggregator_TotalWeight_Call) Return(v uint64) *WeightedSignatureAggregator_TotalWeight_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *WeightedSignatureAggregator_TotalWeight_Call) RunAndReturn(run func() uint64) *WeightedSignatureAggregator_TotalWeight_Call {
	_c.Call.Return(run)
	return _c
}

// TrustedAdd provides a mock function for the type WeightedSignatureAggregator
func (_mock *WeightedSignatureAggregator) TrustedAdd(signerID flow.Identifier, sig crypto.Signature) (uint64, error) {
	ret := _mock.Called(signerID, sig)

	if len(ret) == 0 {
		panic("no return value specified for TrustedAdd")
	}

	var r0 uint64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, crypto.Signature) (uint64, error)); ok {
		return returnFunc(signerID, sig)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, crypto.Signature) uint64); ok {
		r0 = returnFunc(signerID, sig)
	} else {
		r0 = ret.Get(0).(uint64)
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier, crypto.Signature) error); ok {
		r1 = returnFunc(signerID, sig)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// WeightedSignatureAggregator_TrustedAdd_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TrustedAdd'
type WeightedSignatureAggregator_TrustedAdd_Call struct {
	*mock.Call
}

// TrustedAdd is a helper method to define mock.On call
//   - signerID flow.Identifier
//   - sig crypto.Signature
func (_e *WeightedSignatureAggregator_Expecter) TrustedAdd(signerID interface{}, sig interface{}) *WeightedSignatureAggregator_TrustedAdd_Call {
	return &WeightedSignatureAggregator_TrustedAdd_Call{Call: _e.mock.On("TrustedAdd", signerID, sig)}
}

func (_c *WeightedSignatureAggregator_TrustedAdd_Call) Run(run func(signerID flow.Identifier, sig crypto.Signature)) *WeightedSignatureAggregator_TrustedAdd_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		var arg1 crypto.Signature
		if args[1] != nil {
			arg1 = args[1].(crypto.Signature)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *WeightedSignatureAggregator_TrustedAdd_Call) Return(totalWeight uint64, exception error) *WeightedSignatureAggregator_TrustedAdd_Call {
	_c.Call.Return(totalWeight, exception)
	return _c
}

func (_c *WeightedSignatureAggregator_TrustedAdd_Call) RunAndReturn(run func(signerID flow.Identifier, sig crypto.Signature) (uint64, error)) *WeightedSignatureAggregator_TrustedAdd_Call {
	_c.Call.Return(run)
	return _c
}

// Verify provides a mock function for the type WeightedSignatureAggregator
func (_mock *WeightedSignatureAggregator) Verify(signerID flow.Identifier, sig crypto.Signature) error {
	ret := _mock.Called(signerID, sig)

	if len(ret) == 0 {
		panic("no return value specified for Verify")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, crypto.Signature) error); ok {
		r0 = returnFunc(signerID, sig)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// WeightedSignatureAggregator_Verify_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Verify'
type WeightedSignatureAggregator_Verify_Call struct {
	*mock.Call
}

// Verify is a helper method to define mock.On call
//   - signerID flow.Identifier
//   - sig crypto.Signature
func (_e *WeightedSignatureAggregator_Expecter) Verify(signerID interface{}, sig interface{}) *WeightedSignatureAggregator_Verify_Call {
	return &WeightedSignatureAggregator_Verify_Call{Call: _e.mock.On("Verify", signerID, sig)}
}

func (_c *WeightedSignatureAggregator_Verify_Call) Run(run func(signerID flow.Identifier, sig crypto.Signature)) *WeightedSignatureAggregator_Verify_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		var arg1 crypto.Signature
		if args[1] != nil {
			arg1 = args[1].(crypto.Signature)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *WeightedSignatureAggregator_Verify_Call) Return(err error) *WeightedSignatureAggregator_Verify_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *WeightedSignatureAggregator_Verify_Call) RunAndReturn(run func(signerID flow.Identifier, sig crypto.Signature) error) *WeightedSignatureAggregator_Verify_Call {
	_c.Call.Return(run)
	return _c
}

// NewTimeoutSignatureAggregator creates a new instance of TimeoutSignatureAggregator. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewTimeoutSignatureAggregator(t interface {
	mock.TestingT
	Cleanup(func())
}) *TimeoutSignatureAggregator {
	mock := &TimeoutSignatureAggregator{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// TimeoutSignatureAggregator is an autogenerated mock type for the TimeoutSignatureAggregator type
type TimeoutSignatureAggregator struct {
	mock.Mock
}

type TimeoutSignatureAggregator_Expecter struct {
	mock *mock.Mock
}

func (_m *TimeoutSignatureAggregator) EXPECT() *TimeoutSignatureAggregator_Expecter {
	return &TimeoutSignatureAggregator_Expecter{mock: &_m.Mock}
}

// Aggregate provides a mock function for the type TimeoutSignatureAggregator
func (_mock *TimeoutSignatureAggregator) Aggregate() ([]hotstuff.TimeoutSignerInfo, crypto.Signature, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Aggregate")
	}

	var r0 []hotstuff.TimeoutSignerInfo
	var r1 crypto.Signature
	var r2 error
	if returnFunc, ok := ret.Get(0).(func() ([]hotstuff.TimeoutSignerInfo, crypto.Signature, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() []hotstuff.TimeoutSignerInfo); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]hotstuff.TimeoutSignerInfo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() crypto.Signature); ok {
		r1 = returnFunc()
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(crypto.Signature)
		}
	}
	if returnFunc, ok := ret.Get(2).(func() error); ok {
		r2 = returnFunc()
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// TimeoutSignatureAggregator_Aggregate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Aggregate'
type TimeoutSignatureAggregator_Aggregate_Call struct {
	*mock.Call
}

// Aggregate is a helper method to define mock.On call
func (_e *TimeoutSignatureAggregator_Expecter) Aggregate() *TimeoutSignatureAggregator_Aggregate_Call {
	return &TimeoutSignatureAggregator_Aggregate_Call{Call: _e.mock.On("Aggregate")}
}

func (_c *TimeoutSignatureAggregator_Aggregate_Call) Run(run func()) *TimeoutSignatureAggregator_Aggregate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *TimeoutSignatureAggregator_Aggregate_Call) Return(signersInfo []hotstuff.TimeoutSignerInfo, aggregatedSig crypto.Signature, exception error) *TimeoutSignatureAggregator_Aggregate_Call {
	_c.Call.Return(signersInfo, aggregatedSig, exception)
	return _c
}

func (_c *TimeoutSignatureAggregator_Aggregate_Call) RunAndReturn(run func() ([]hotstuff.TimeoutSignerInfo, crypto.Signature, error)) *TimeoutSignatureAggregator_Aggregate_Call {
	_c.Call.Return(run)
	return _c
}

// TotalWeight provides a mock function for the type TimeoutSignatureAggregator
func (_mock *TimeoutSignatureAggregator) TotalWeight() uint64 {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for TotalWeight")
	}

	var r0 uint64
	if returnFunc, ok := ret.Get(0).(func() uint64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint64)
	}
	return r0
}

// TimeoutSignatureAggregator_TotalWeight_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TotalWeight'
type TimeoutSignatureAggregator_TotalWeight_Call struct {
	*mock.Call
}

// TotalWeight is a helper method to define mock.On call
func (_e *TimeoutSignatureAggregator_Expecter) TotalWeight() *TimeoutSignatureAggregator_TotalWeight_Call {
	return &TimeoutSignatureAggregator_TotalWeight_Call{Call: _e.mock.On("TotalWeight")}
}

func (_c *TimeoutSignatureAggregator_TotalWeight_Call) Run(run func()) *TimeoutSignatureAggregator_TotalWeight_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *TimeoutSignatureAggregator_TotalWeight_Call) Return(v uint64) *TimeoutSignatureAggregator_TotalWeight_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *TimeoutSignatureAggregator_TotalWeight_Call) RunAndReturn(run func() uint64) *TimeoutSignatureAggregator_TotalWeight_Call {
	_c.Call.Return(run)
	return _c
}

// VerifyAndAdd provides a mock function for the type TimeoutSignatureAggregator
func (_mock *TimeoutSignatureAggregator) VerifyAndAdd(signerID flow.Identifier, sig crypto.Signature, newestQCView uint64) (uint64, error) {
	ret := _mock.Called(signerID, sig, newestQCView)

	if len(ret) == 0 {
		panic("no return value specified for VerifyAndAdd")
	}

	var r0 uint64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, crypto.Signature, uint64) (uint64, error)); ok {
		return returnFunc(signerID, sig, newestQCView)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, crypto.Signature, uint64) uint64); ok {
		r0 = returnFunc(signerID, sig, newestQCView)
	} else {
		r0 = ret.Get(0).(uint64)
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier, crypto.Signature, uint64) error); ok {
		r1 = returnFunc(signerID, sig, newestQCView)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// TimeoutSignatureAggregator_VerifyAndAdd_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'VerifyAndAdd'
type TimeoutSignatureAggregator_VerifyAndAdd_Call struct {
	*mock.Call
}

// VerifyAndAdd is a helper method to define mock.On call
//   - signerID flow.Identifier
//   - sig crypto.Signature
//   - newestQCView uint64
func (_e *TimeoutSignatureAggregator_Expecter) VerifyAndAdd(signerID interface{}, sig interface{}, newestQCView interface{}) *TimeoutSignatureAggregator_VerifyAndAdd_Call {
	return &TimeoutSignatureAggregator_VerifyAndAdd_Call{Call: _e.mock.On("VerifyAndAdd", signerID, sig, newestQCView)}
}

func (_c *TimeoutSignatureAggregator_VerifyAndAdd_Call) Run(run func(signerID flow.Identifier, sig crypto.Signature, newestQCView uint64)) *TimeoutSignatureAggregator_VerifyAndAdd_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		var arg1 crypto.Signature
		if args[1] != nil {
			arg1 = args[1].(crypto.Signature)
		}
		var arg2 uint64
		if args[2] != nil {
			arg2 = args[2].(uint64)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *TimeoutSignatureAggregator_VerifyAndAdd_Call) Return(totalWeight uint64, exception error) *TimeoutSignatureAggregator_VerifyAndAdd_Call {
	_c.Call.Return(totalWeight, exception)
	return _c
}

func (_c *TimeoutSignatureAggregator_VerifyAndAdd_Call) RunAndReturn(run func(signerID flow.Identifier, sig crypto.Signature, newestQCView uint64) (uint64, error)) *TimeoutSignatureAggregator_VerifyAndAdd_Call {
	_c.Call.Return(run)
	return _c
}

// View provides a mock function for the type TimeoutSignatureAggregator
func (_mock *TimeoutSignatureAggregator) View() uint64 {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for View")
	}

	var r0 uint64
	if returnFunc, ok := ret.Get(0).(func() uint64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint64)
	}
	return r0
}

// TimeoutSignatureAggregator_View_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'View'
type TimeoutSignatureAggregator_View_Call struct {
	*mock.Call
}

// View is a helper method to define mock.On call
func (_e *TimeoutSignatureAggregator_Expecter) View() *TimeoutSignatureAggregator_View_Call {
	return &TimeoutSignatureAggregator_View_Call{Call: _e.mock.On("View")}
}

func (_c *TimeoutSignatureAggregator_View_Call) Run(run func()) *TimeoutSignatureAggregator_View_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *TimeoutSignatureAggregator_View_Call) Return(v uint64) *TimeoutSignatureAggregator_View_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *TimeoutSignatureAggregator_View_Call) RunAndReturn(run func() uint64) *TimeoutSignatureAggregator_View_Call {
	_c.Call.Return(run)
	return _c
}

// NewPacker creates a new instance of Packer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewPacker(t interface {
	mock.TestingT
	Cleanup(func())
}) *Packer {
	mock := &Packer{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Packer is an autogenerated mock type for the Packer type
type Packer struct {
	mock.Mock
}

type Packer_Expecter struct {
	mock *mock.Mock
}

func (_m *Packer) EXPECT() *Packer_Expecter {
	return &Packer_Expecter{mock: &_m.Mock}
}

// Pack provides a mock function for the type Packer
func (_mock *Packer) Pack(view uint64, sig *hotstuff.BlockSignatureData) ([]byte, []byte, error) {
	ret := _mock.Called(view, sig)

	if len(ret) == 0 {
		panic("no return value specified for Pack")
	}

	var r0 []byte
	var r1 []byte
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(uint64, *hotstuff.BlockSignatureData) ([]byte, []byte, error)); ok {
		return returnFunc(view, sig)
	}
	if returnFunc, ok := ret.Get(0).(func(uint64, *hotstuff.BlockSignatureData) []byte); ok {
		r0 = returnFunc(view, sig)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(uint64, *hotstuff.BlockSignatureData) []byte); ok {
		r1 = returnFunc(view, sig)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]byte)
		}
	}
	if returnFunc, ok := ret.Get(2).(func(uint64, *hotstuff.BlockSignatureData) error); ok {
		r2 = returnFunc(view, sig)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// Packer_Pack_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Pack'
type Packer_Pack_Call struct {
	*mock.Call
}

// Pack is a helper method to define mock.On call
//   - view uint64
//   - sig *hotstuff.BlockSignatureData
func (_e *Packer_Expecter) Pack(view interface{}, sig interface{}) *Packer_Pack_Call {
	return &Packer_Pack_Call{Call: _e.mock.On("Pack", view, sig)}
}

func (_c *Packer_Pack_Call) Run(run func(view uint64, sig *hotstuff.BlockSignatureData)) *Packer_Pack_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		var arg1 *hotstuff.BlockSignatureData
		if args[1] != nil {
			arg1 = args[1].(*hotstuff.BlockSignatureData)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Packer_Pack_Call) Return(signerIndices []byte, sigData []byte, err error) *Packer_Pack_Call {
	_c.Call.Return(signerIndices, sigData, err)
	return _c
}

func (_c *Packer_Pack_Call) RunAndReturn(run func(view uint64, sig *hotstuff.BlockSignatureData) ([]byte, []byte, error)) *Packer_Pack_Call {
	_c.Call.Return(run)
	return _c
}

// Unpack provides a mock function for the type Packer
func (_mock *Packer) Unpack(signerIdentities flow.IdentitySkeletonList, sigData []byte) (*hotstuff.BlockSignatureData, error) {
	ret := _mock.Called(signerIdentities, sigData)

	if len(ret) == 0 {
		panic("no return value specified for Unpack")
	}

	var r0 *hotstuff.BlockSignatureData
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.IdentitySkeletonList, []byte) (*hotstuff.BlockSignatureData, error)); ok {
		return returnFunc(signerIdentities, sigData)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.IdentitySkeletonList, []byte) *hotstuff.BlockSignatureData); ok {
		r0 = returnFunc(signerIdentities, sigData)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*hotstuff.BlockSignatureData)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.IdentitySkeletonList, []byte) error); ok {
		r1 = returnFunc(signerIdentities, sigData)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Packer_Unpack_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Unpack'
type Packer_Unpack_Call struct {
	*mock.Call
}

// Unpack is a helper method to define mock.On call
//   - signerIdentities flow.IdentitySkeletonList
//   - sigData []byte
func (_e *Packer_Expecter) Unpack(signerIdentities interface{}, sigData interface{}) *Packer_Unpack_Call {
	return &Packer_Unpack_Call{Call: _e.mock.On("Unpack", signerIdentities, sigData)}
}

func (_c *Packer_Unpack_Call) Run(run func(signerIdentities flow.IdentitySkeletonList, sigData []byte)) *Packer_Unpack_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.IdentitySkeletonList
		if args[0] != nil {
			arg0 = args[0].(flow.IdentitySkeletonList)
		}
		var arg1 []byte
		if args[1] != nil {
			arg1 = args[1].([]byte)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Packer_Unpack_Call) Return(blockSignatureData *hotstuff.BlockSignatureData, err error) *Packer_Unpack_Call {
	_c.Call.Return(blockSignatureData, err)
	return _c
}

func (_c *Packer_Unpack_Call) RunAndReturn(run func(signerIdentities flow.IdentitySkeletonList, sigData []byte) (*hotstuff.BlockSignatureData, error)) *Packer_Unpack_Call {
	_c.Call.Return(run)
	return _c
}

// NewSigner creates a new instance of Signer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewSigner(t interface {
	mock.TestingT
	Cleanup(func())
}) *Signer {
	mock := &Signer{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Signer is an autogenerated mock type for the Signer type
type Signer struct {
	mock.Mock
}

type Signer_Expecter struct {
	mock *mock.Mock
}

func (_m *Signer) EXPECT() *Signer_Expecter {
	return &Signer_Expecter{mock: &_m.Mock}
}

// CreateTimeout provides a mock function for the type Signer
func (_mock *Signer) CreateTimeout(curView uint64, newestQC *flow.QuorumCertificate, lastViewTC *flow.TimeoutCertificate) (*model.TimeoutObject, error) {
	ret := _mock.Called(curView, newestQC, lastViewTC)

	if len(ret) == 0 {
		panic("no return value specified for CreateTimeout")
	}

	var r0 *model.TimeoutObject
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(uint64, *flow.QuorumCertificate, *flow.TimeoutCertificate) (*model.TimeoutObject, error)); ok {
		return returnFunc(curView, newestQC, lastViewTC)
	}
	if returnFunc, ok := ret.Get(0).(func(uint64, *flow.QuorumCertificate, *flow.TimeoutCertificate) *model.TimeoutObject); ok {
		r0 = returnFunc(curView, newestQC, lastViewTC)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.TimeoutObject)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(uint64, *flow.QuorumCertificate, *flow.TimeoutCertificate) error); ok {
		r1 = returnFunc(curView, newestQC, lastViewTC)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Signer_CreateTimeout_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateTimeout'
type Signer_CreateTimeout_Call struct {
	*mock.Call
}

// CreateTimeout is a helper method to define mock.On call
//   - curView uint64
//   - newestQC *flow.QuorumCertificate
//   - lastViewTC *flow.TimeoutCertificate
func (_e *Signer_Expecter) CreateTimeout(curView interface{}, newestQC interface{}, lastViewTC interface{}) *Signer_CreateTimeout_Call {
	return &Signer_CreateTimeout_Call{Call: _e.mock.On("CreateTimeout", curView, newestQC, lastViewTC)}
}

func (_c *Signer_CreateTimeout_Call) Run(run func(curView uint64, newestQC *flow.QuorumCertificate, lastViewTC *flow.TimeoutCertificate)) *Signer_CreateTimeout_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		var arg1 *flow.QuorumCertificate
		if args[1] != nil {
			arg1 = args[1].(*flow.QuorumCertificate)
		}
		var arg2 *flow.TimeoutCertificate
		if args[2] != nil {
			arg2 = args[2].(*flow.TimeoutCertificate)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Signer_CreateTimeout_Call) Return(timeoutObject *model.TimeoutObject, err error) *Signer_CreateTimeout_Call {
	_c.Call.Return(timeoutObject, err)
	return _c
}

func (_c *Signer_CreateTimeout_Call) RunAndReturn(run func(curView uint64, newestQC *flow.QuorumCertificate, lastViewTC *flow.TimeoutCertificate) (*model.TimeoutObject, error)) *Signer_CreateTimeout_Call {
	_c.Call.Return(run)
	return _c
}

// CreateVote provides a mock function for the type Signer
func (_mock *Signer) CreateVote(block *model.Block) (*model.Vote, error) {
	ret := _mock.Called(block)

	if len(ret) == 0 {
		panic("no return value specified for CreateVote")
	}

	var r0 *model.Vote
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*model.Block) (*model.Vote, error)); ok {
		return returnFunc(block)
	}
	if returnFunc, ok := ret.Get(0).(func(*model.Block) *model.Vote); ok {
		r0 = returnFunc(block)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Vote)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*model.Block) error); ok {
		r1 = returnFunc(block)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Signer_CreateVote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateVote'
type Signer_CreateVote_Call struct {
	*mock.Call
}

// CreateVote is a helper method to define mock.On call
//   - block *model.Block
func (_e *Signer_Expecter) CreateVote(block interface{}) *Signer_CreateVote_Call {
	return &Signer_CreateVote_Call{Call: _e.mock.On("CreateVote", block)}
}

func (_c *Signer_CreateVote_Call) Run(run func(block *model.Block)) *Signer_CreateVote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Block
		if args[0] != nil {
			arg0 = args[0].(*model.Block)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Signer_CreateVote_Call) Return(vote *model.Vote, err error) *Signer_CreateVote_Call {
	_c.Call.Return(vote, err)
	return _c
}

func (_c *Signer_CreateVote_Call) RunAndReturn(run func(block *model.Block) (*model.Vote, error)) *Signer_CreateVote_Call {
	_c.Call.Return(run)
	return _c
}

// NewTimeoutAggregator creates a new instance of TimeoutAggregator. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewTimeoutAggregator(t interface {
	mock.TestingT
	Cleanup(func())
}) *TimeoutAggregator {
	mock := &TimeoutAggregator{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// TimeoutAggregator is an autogenerated mock type for the TimeoutAggregator type
type TimeoutAggregator struct {
	mock.Mock
}

type TimeoutAggregator_Expecter struct {
	mock *mock.Mock
}

func (_m *TimeoutAggregator) EXPECT() *TimeoutAggregator_Expecter {
	return &TimeoutAggregator_Expecter{mock: &_m.Mock}
}

// AddTimeout provides a mock function for the type TimeoutAggregator
func (_mock *TimeoutAggregator) AddTimeout(timeoutObject *model.TimeoutObject) {
	_mock.Called(timeoutObject)
	return
}

// TimeoutAggregator_AddTimeout_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddTimeout'
type TimeoutAggregator_AddTimeout_Call struct {
	*mock.Call
}

// AddTimeout is a helper method to define mock.On call
//   - timeoutObject *model.TimeoutObject
func (_e *TimeoutAggregator_Expecter) AddTimeout(timeoutObject interface{}) *TimeoutAggregator_AddTimeout_Call {
	return &TimeoutAggregator_AddTimeout_Call{Call: _e.mock.On("AddTimeout", timeoutObject)}
}

func (_c *TimeoutAggregator_AddTimeout_Call) Run(run func(timeoutObject *model.TimeoutObject)) *TimeoutAggregator_AddTimeout_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.TimeoutObject
		if args[0] != nil {
			arg0 = args[0].(*model.TimeoutObject)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *TimeoutAggregator_AddTimeout_Call) Return() *TimeoutAggregator_AddTimeout_Call {
	_c.Call.Return()
	return _c
}

func (_c *TimeoutAggregator_AddTimeout_Call) RunAndReturn(run func(timeoutObject *model.TimeoutObject)) *TimeoutAggregator_AddTimeout_Call {
	_c.Run(run)
	return _c
}

// Done provides a mock function for the type TimeoutAggregator
func (_mock *TimeoutAggregator) Done() <-chan struct{} {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Done")
	}

	var r0 <-chan struct{}
	if returnFunc, ok := ret.Get(0).(func() <-chan struct{}); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan struct{})
		}
	}
	return r0
}

// TimeoutAggregator_Done_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Done'
type TimeoutAggregator_Done_Call struct {
	*mock.Call
}

// Done is a helper method to define mock.On call
func (_e *TimeoutAggregator_Expecter) Done() *TimeoutAggregator_Done_Call {
	return &TimeoutAggregator_Done_Call{Call: _e.mock.On("Done")}
}

func (_c *TimeoutAggregator_Done_Call) Run(run func()) *TimeoutAggregator_Done_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *TimeoutAggregator_Done_Call) Return(valCh <-chan struct{}) *TimeoutAggregator_Done_Call {
	_c.Call.Return(valCh)
	return _c
}

func (_c *TimeoutAggregator_Done_Call) RunAndReturn(run func() <-chan struct{}) *TimeoutAggregator_Done_Call {
	_c.Call.Return(run)
	return _c
}

// PruneUpToView provides a mock function for the type TimeoutAggregator
func (_mock *TimeoutAggregator) PruneUpToView(lowestRetainedView uint64) {
	_mock.Called(lowestRetainedView)
	return
}

// TimeoutAggregator_PruneUpToView_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PruneUpToView'
type TimeoutAggregator_PruneUpToView_Call struct {
	*mock.Call
}

// PruneUpToView is a helper method to define mock.On call
//   - lowestRetainedView uint64
func (_e *TimeoutAggregator_Expecter) PruneUpToView(lowestRetainedView interface{}) *TimeoutAggregator_PruneUpToView_Call {
	return &TimeoutAggregator_PruneUpToView_Call{Call: _e.mock.On("PruneUpToView", lowestRetainedView)}
}

func (_c *TimeoutAggregator_PruneUpToView_Call) Run(run func(lowestRetainedView uint64)) *TimeoutAggregator_PruneUpToView_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *TimeoutAggregator_PruneUpToView_Call) Return() *TimeoutAggregator_PruneUpToView_Call {
	_c.Call.Return()
	return _c
}

func (_c *TimeoutAggregator_PruneUpToView_Call) RunAndReturn(run func(lowestRetainedView uint64)) *TimeoutAggregator_PruneUpToView_Call {
	_c.Run(run)
	return _c
}

// Ready provides a mock function for the type TimeoutAggregator
func (_mock *TimeoutAggregator) Ready() <-chan struct{} {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Ready")
	}

	var r0 <-chan struct{}
	if returnFunc, ok := ret.Get(0).(func() <-chan struct{}); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan struct{})
		}
	}
	return r0
}

// TimeoutAggregator_Ready_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Ready'
type TimeoutAggregator_Ready_Call struct {
	*mock.Call
}

// Ready is a helper method to define mock.On call
func (_e *TimeoutAggregator_Expecter) Ready() *TimeoutAggregator_Ready_Call {
	return &TimeoutAggregator_Ready_Call{Call: _e.mock.On("Ready")}
}

func (_c *TimeoutAggregator_Ready_Call) Run(run func()) *TimeoutAggregator_Ready_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *TimeoutAggregator_Ready_Call) Return(valCh <-chan struct{}) *TimeoutAggregator_Ready_Call {
	_c.Call.Return(valCh)
	return _c
}

func (_c *TimeoutAggregator_Ready_Call) RunAndReturn(run func() <-chan struct{}) *TimeoutAggregator_Ready_Call {
	_c.Call.Return(run)
	return _c
}

// Start provides a mock function for the type TimeoutAggregator
func (_mock *TimeoutAggregator) Start(signalerContext irrecoverable.SignalerContext) {
	_mock.Called(signalerContext)
	return
}

// TimeoutAggregator_Start_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Start'
type TimeoutAggregator_Start_Call struct {
	*mock.Call
}

// Start is a helper method to define mock.On call
//   - signalerContext irrecoverable.SignalerContext
func (_e *TimeoutAggregator_Expecter) Start(signalerContext interface{}) *TimeoutAggregator_Start_Call {
	return &TimeoutAggregator_Start_Call{Call: _e.mock.On("Start", signalerContext)}
}

func (_c *TimeoutAggregator_Start_Call) Run(run func(signalerContext irrecoverable.SignalerContext)) *TimeoutAggregator_Start_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 irrecoverable.SignalerContext
		if args[0] != nil {
			arg0 = args[0].(irrecoverable.SignalerContext)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *TimeoutAggregator_Start_Call) Return() *TimeoutAggregator_Start_Call {
	_c.Call.Return()
	return _c
}

func (_c *TimeoutAggregator_Start_Call) RunAndReturn(run func(signalerContext irrecoverable.SignalerContext)) *TimeoutAggregator_Start_Call {
	_c.Run(run)
	return _c
}

// NewTimeoutCollector creates a new instance of TimeoutCollector. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewTimeoutCollector(t interface {
	mock.TestingT
	Cleanup(func())
}) *TimeoutCollector {
	mock := &TimeoutCollector{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// TimeoutCollector is an autogenerated mock type for the TimeoutCollector type
type TimeoutCollector struct {
	mock.Mock
}

type TimeoutCollector_Expecter struct {
	mock *mock.Mock
}

func (_m *TimeoutCollector) EXPECT() *TimeoutCollector_Expecter {
	return &TimeoutCollector_Expecter{mock: &_m.Mock}
}

// AddTimeout provides a mock function for the type TimeoutCollector
func (_mock *TimeoutCollector) AddTimeout(timeoutObject *model.TimeoutObject) error {
	ret := _mock.Called(timeoutObject)

	if len(ret) == 0 {
		panic("no return value specified for AddTimeout")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*model.TimeoutObject) error); ok {
		r0 = returnFunc(timeoutObject)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// TimeoutCollector_AddTimeout_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddTimeout'
type TimeoutCollector_AddTimeout_Call struct {
	*mock.Call
}

// AddTimeout is a helper method to define mock.On call
//   - timeoutObject *model.TimeoutObject
func (_e *TimeoutCollector_Expecter) AddTimeout(timeoutObject interface{}) *TimeoutCollector_AddTimeout_Call {
	return &TimeoutCollector_AddTimeout_Call{Call: _e.mock.On("AddTimeout", timeoutObject)}
}

func (_c *TimeoutCollector_AddTimeout_Call) Run(run func(timeoutObject *model.TimeoutObject)) *TimeoutCollector_AddTimeout_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.TimeoutObject
		if args[0] != nil {
			arg0 = args[0].(*model.TimeoutObject)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *TimeoutCollector_AddTimeout_Call) Return(err error) *TimeoutCollector_AddTimeout_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *TimeoutCollector_AddTimeout_Call) RunAndReturn(run func(timeoutObject *model.TimeoutObject) error) *TimeoutCollector_AddTimeout_Call {
	_c.Call.Return(run)
	return _c
}

// View provides a mock function for the type TimeoutCollector
func (_mock *TimeoutCollector) View() uint64 {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for View")
	}

	var r0 uint64
	if returnFunc, ok := ret.Get(0).(func() uint64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint64)
	}
	return r0
}

// TimeoutCollector_View_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'View'
type TimeoutCollector_View_Call struct {
	*mock.Call
}

// View is a helper method to define mock.On call
func (_e *TimeoutCollector_Expecter) View() *TimeoutCollector_View_Call {
	return &TimeoutCollector_View_Call{Call: _e.mock.On("View")}
}

func (_c *TimeoutCollector_View_Call) Run(run func()) *TimeoutCollector_View_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *TimeoutCollector_View_Call) Return(v uint64) *TimeoutCollector_View_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *TimeoutCollector_View_Call) RunAndReturn(run func() uint64) *TimeoutCollector_View_Call {
	_c.Call.Return(run)
	return _c
}

// NewTimeoutProcessor creates a new instance of TimeoutProcessor. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewTimeoutProcessor(t interface {
	mock.TestingT
	Cleanup(func())
}) *TimeoutProcessor {
	mock := &TimeoutProcessor{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// TimeoutProcessor is an autogenerated mock type for the TimeoutProcessor type
type TimeoutProcessor struct {
	mock.Mock
}

type TimeoutProcessor_Expecter struct {
	mock *mock.Mock
}

func (_m *TimeoutProcessor) EXPECT() *TimeoutProcessor_Expecter {
	return &TimeoutProcessor_Expecter{mock: &_m.Mock}
}

// Process provides a mock function for the type TimeoutProcessor
func (_mock *TimeoutProcessor) Process(timeout *model.TimeoutObject) error {
	ret := _mock.Called(timeout)

	if len(ret) == 0 {
		panic("no return value specified for Process")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*model.TimeoutObject) error); ok {
		r0 = returnFunc(timeout)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// TimeoutProcessor_Process_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Process'
type TimeoutProcessor_Process_Call struct {
	*mock.Call
}

// Process is a helper method to define mock.On call
//   - timeout *model.TimeoutObject
func (_e *TimeoutProcessor_Expecter) Process(timeout interface{}) *TimeoutProcessor_Process_Call {
	return &TimeoutProcessor_Process_Call{Call: _e.mock.On("Process", timeout)}
}

func (_c *TimeoutProcessor_Process_Call) Run(run func(timeout *model.TimeoutObject)) *TimeoutProcessor_Process_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.TimeoutObject
		if args[0] != nil {
			arg0 = args[0].(*model.TimeoutObject)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *TimeoutProcessor_Process_Call) Return(err error) *TimeoutProcessor_Process_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *TimeoutProcessor_Process_Call) RunAndReturn(run func(timeout *model.TimeoutObject) error) *TimeoutProcessor_Process_Call {
	_c.Call.Return(run)
	return _c
}

// NewTimeoutCollectorFactory creates a new instance of TimeoutCollectorFactory. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewTimeoutCollectorFactory(t interface {
	mock.TestingT
	Cleanup(func())
}) *TimeoutCollectorFactory {
	mock := &TimeoutCollectorFactory{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// TimeoutCollectorFactory is an autogenerated mock type for the TimeoutCollectorFactory type
type TimeoutCollectorFactory struct {
	mock.Mock
}

type TimeoutCollectorFactory_Expecter struct {
	mock *mock.Mock
}

func (_m *TimeoutCollectorFactory) EXPECT() *TimeoutCollectorFactory_Expecter {
	return &TimeoutCollectorFactory_Expecter{mock: &_m.Mock}
}

// Create provides a mock function for the type TimeoutCollectorFactory
func (_mock *TimeoutCollectorFactory) Create(view uint64) (hotstuff.TimeoutCollector, error) {
	ret := _mock.Called(view)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 hotstuff.TimeoutCollector
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(uint64) (hotstuff.TimeoutCollector, error)); ok {
		return returnFunc(view)
	}
	if returnFunc, ok := ret.Get(0).(func(uint64) hotstuff.TimeoutCollector); ok {
		r0 = returnFunc(view)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(hotstuff.TimeoutCollector)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(uint64) error); ok {
		r1 = returnFunc(view)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// TimeoutCollectorFactory_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type TimeoutCollectorFactory_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - view uint64
func (_e *TimeoutCollectorFactory_Expecter) Create(view interface{}) *TimeoutCollectorFactory_Create_Call {
	return &TimeoutCollectorFactory_Create_Call{Call: _e.mock.On("Create", view)}
}

func (_c *TimeoutCollectorFactory_Create_Call) Run(run func(view uint64)) *TimeoutCollectorFactory_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *TimeoutCollectorFactory_Create_Call) Return(timeoutCollector hotstuff.TimeoutCollector, err error) *TimeoutCollectorFactory_Create_Call {
	_c.Call.Return(timeoutCollector, err)
	return _c
}

func (_c *TimeoutCollectorFactory_Create_Call) RunAndReturn(run func(view uint64) (hotstuff.TimeoutCollector, error)) *TimeoutCollectorFactory_Create_Call {
	_c.Call.Return(run)
	return _c
}

// NewTimeoutProcessorFactory creates a new instance of TimeoutProcessorFactory. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewTimeoutProcessorFactory(t interface {
	mock.TestingT
	Cleanup(func())
}) *TimeoutProcessorFactory {
	mock := &TimeoutProcessorFactory{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// TimeoutProcessorFactory is an autogenerated mock type for the TimeoutProcessorFactory type
type TimeoutProcessorFactory struct {
	mock.Mock
}

type TimeoutProcessorFactory_Expecter struct {
	mock *mock.Mock
}

func (_m *TimeoutProcessorFactory) EXPECT() *TimeoutProcessorFactory_Expecter {
	return &TimeoutProcessorFactory_Expecter{mock: &_m.Mock}
}

// Create provides a mock function for the type TimeoutProcessorFactory
func (_mock *TimeoutProcessorFactory) Create(view uint64) (hotstuff.TimeoutProcessor, error) {
	ret := _mock.Called(view)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 hotstuff.TimeoutProcessor
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(uint64) (hotstuff.TimeoutProcessor, error)); ok {
		return returnFunc(view)
	}
	if returnFunc, ok := ret.Get(0).(func(uint64) hotstuff.TimeoutProcessor); ok {
		r0 = returnFunc(view)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(hotstuff.TimeoutProcessor)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(uint64) error); ok {
		r1 = returnFunc(view)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// TimeoutProcessorFactory_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type TimeoutProcessorFactory_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - view uint64
func (_e *TimeoutProcessorFactory_Expecter) Create(view interface{}) *TimeoutProcessorFactory_Create_Call {
	return &TimeoutProcessorFactory_Create_Call{Call: _e.mock.On("Create", view)}
}

func (_c *TimeoutProcessorFactory_Create_Call) Run(run func(view uint64)) *TimeoutProcessorFactory_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *TimeoutProcessorFactory_Create_Call) Return(timeoutProcessor hotstuff.TimeoutProcessor, err error) *TimeoutProcessorFactory_Create_Call {
	_c.Call.Return(timeoutProcessor, err)
	return _c
}

func (_c *TimeoutProcessorFactory_Create_Call) RunAndReturn(run func(view uint64) (hotstuff.TimeoutProcessor, error)) *TimeoutProcessorFactory_Create_Call {
	_c.Call.Return(run)
	return _c
}

// NewTimeoutCollectors creates a new instance of TimeoutCollectors. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewTimeoutCollectors(t interface {
	mock.TestingT
	Cleanup(func())
}) *TimeoutCollectors {
	mock := &TimeoutCollectors{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// TimeoutCollectors is an autogenerated mock type for the TimeoutCollectors type
type TimeoutCollectors struct {
	mock.Mock
}

type TimeoutCollectors_Expecter struct {
	mock *mock.Mock
}

func (_m *TimeoutCollectors) EXPECT() *TimeoutCollectors_Expecter {
	return &TimeoutCollectors_Expecter{mock: &_m.Mock}
}

// GetOrCreateCollector provides a mock function for the type TimeoutCollectors
func (_mock *TimeoutCollectors) GetOrCreateCollector(view uint64) (hotstuff.TimeoutCollector, bool, error) {
	ret := _mock.Called(view)

	if len(ret) == 0 {
		panic("no return value specified for GetOrCreateCollector")
	}

	var r0 hotstuff.TimeoutCollector
	var r1 bool
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(uint64) (hotstuff.TimeoutCollector, bool, error)); ok {
		return returnFunc(view)
	}
	if returnFunc, ok := ret.Get(0).(func(uint64) hotstuff.TimeoutCollector); ok {
		r0 = returnFunc(view)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(hotstuff.TimeoutCollector)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(uint64) bool); ok {
		r1 = returnFunc(view)
	} else {
		r1 = ret.Get(1).(bool)
	}
	if returnFunc, ok := ret.Get(2).(func(uint64) error); ok {
		r2 = returnFunc(view)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// TimeoutCollectors_GetOrCreateCollector_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetOrCreateCollector'
type TimeoutCollectors_GetOrCreateCollector_Call struct {
	*mock.Call
}

// GetOrCreateCollector is a helper method to define mock.On call
//   - view uint64
func (_e *TimeoutCollectors_Expecter) GetOrCreateCollector(view interface{}) *TimeoutCollectors_GetOrCreateCollector_Call {
	return &TimeoutCollectors_GetOrCreateCollector_Call{Call: _e.mock.On("GetOrCreateCollector", view)}
}

func (_c *TimeoutCollectors_GetOrCreateCollector_Call) Run(run func(view uint64)) *TimeoutCollectors_GetOrCreateCollector_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *TimeoutCollectors_GetOrCreateCollector_Call) Return(collector hotstuff.TimeoutCollector, created bool, err error) *TimeoutCollectors_GetOrCreateCollector_Call {
	_c.Call.Return(collector, created, err)
	return _c
}

func (_c *TimeoutCollectors_GetOrCreateCollector_Call) RunAndReturn(run func(view uint64) (hotstuff.TimeoutCollector, bool, error)) *TimeoutCollectors_GetOrCreateCollector_Call {
	_c.Call.Return(run)
	return _c
}

// PruneUpToView provides a mock function for the type TimeoutCollectors
func (_mock *TimeoutCollectors) PruneUpToView(lowestRetainedView uint64) {
	_mock.Called(lowestRetainedView)
	return
}

// TimeoutCollectors_PruneUpToView_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PruneUpToView'
type TimeoutCollectors_PruneUpToView_Call struct {
	*mock.Call
}

// PruneUpToView is a helper method to define mock.On call
//   - lowestRetainedView uint64
func (_e *TimeoutCollectors_Expecter) PruneUpToView(lowestRetainedView interface{}) *TimeoutCollectors_PruneUpToView_Call {
	return &TimeoutCollectors_PruneUpToView_Call{Call: _e.mock.On("PruneUpToView", lowestRetainedView)}
}

func (_c *TimeoutCollectors_PruneUpToView_Call) Run(run func(lowestRetainedView uint64)) *TimeoutCollectors_PruneUpToView_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *TimeoutCollectors_PruneUpToView_Call) Return() *TimeoutCollectors_PruneUpToView_Call {
	_c.Call.Return()
	return _c
}

func (_c *TimeoutCollectors_PruneUpToView_Call) RunAndReturn(run func(lowestRetainedView uint64)) *TimeoutCollectors_PruneUpToView_Call {
	_c.Run(run)
	return _c
}

// NewValidator creates a new instance of Validator. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewValidator(t interface {
	mock.TestingT
	Cleanup(func())
}) *Validator {
	mock := &Validator{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Validator is an autogenerated mock type for the Validator type
type Validator struct {
	mock.Mock
}

type Validator_Expecter struct {
	mock *mock.Mock
}

func (_m *Validator) EXPECT() *Validator_Expecter {
	return &Validator_Expecter{mock: &_m.Mock}
}

// ValidateProposal provides a mock function for the type Validator
func (_mock *Validator) ValidateProposal(proposal *model.SignedProposal) error {
	ret := _mock.Called(proposal)

	if len(ret) == 0 {
		panic("no return value specified for ValidateProposal")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*model.SignedProposal) error); ok {
		r0 = returnFunc(proposal)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Validator_ValidateProposal_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ValidateProposal'
type Validator_ValidateProposal_Call struct {
	*mock.Call
}

// ValidateProposal is a helper method to define mock.On call
//   - proposal *model.SignedProposal
func (_e *Validator_Expecter) ValidateProposal(proposal interface{}) *Validator_ValidateProposal_Call {
	return &Validator_ValidateProposal_Call{Call: _e.mock.On("ValidateProposal", proposal)}
}

func (_c *Validator_ValidateProposal_Call) Run(run func(proposal *model.SignedProposal)) *Validator_ValidateProposal_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.SignedProposal
		if args[0] != nil {
			arg0 = args[0].(*model.SignedProposal)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Validator_ValidateProposal_Call) Return(err error) *Validator_ValidateProposal_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Validator_ValidateProposal_Call) RunAndReturn(run func(proposal *model.SignedProposal) error) *Validator_ValidateProposal_Call {
	_c.Call.Return(run)
	return _c
}

// ValidateQC provides a mock function for the type Validator
func (_mock *Validator) ValidateQC(qc *flow.QuorumCertificate) error {
	ret := _mock.Called(qc)

	if len(ret) == 0 {
		panic("no return value specified for ValidateQC")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*flow.QuorumCertificate) error); ok {
		r0 = returnFunc(qc)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Validator_ValidateQC_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ValidateQC'
type Validator_ValidateQC_Call struct {
	*mock.Call
}

// ValidateQC is a helper method to define mock.On call
//   - qc *flow.QuorumCertificate
func (_e *Validator_Expecter) ValidateQC(qc interface{}) *Validator_ValidateQC_Call {
	return &Validator_ValidateQC_Call{Call: _e.mock.On("ValidateQC", qc)}
}

func (_c *Validator_ValidateQC_Call) Run(run func(qc *flow.QuorumCertificate)) *Validator_ValidateQC_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *flow.QuorumCertificate
		if args[0] != nil {
			arg0 = args[0].(*flow.QuorumCertificate)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Validator_ValidateQC_Call) Return(err error) *Validator_ValidateQC_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Validator_ValidateQC_Call) RunAndReturn(run func(qc *flow.QuorumCertificate) error) *Validator_ValidateQC_Call {
	_c.Call.Return(run)
	return _c
}

// ValidateTC provides a mock function for the type Validator
func (_mock *Validator) ValidateTC(tc *flow.TimeoutCertificate) error {
	ret := _mock.Called(tc)

	if len(ret) == 0 {
		panic("no return value specified for ValidateTC")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*flow.TimeoutCertificate) error); ok {
		r0 = returnFunc(tc)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Validator_ValidateTC_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ValidateTC'
type Validator_ValidateTC_Call struct {
	*mock.Call
}

// ValidateTC is a helper method to define mock.On call
//   - tc *flow.TimeoutCertificate
func (_e *Validator_Expecter) ValidateTC(tc interface{}) *Validator_ValidateTC_Call {
	return &Validator_ValidateTC_Call{Call: _e.mock.On("ValidateTC", tc)}
}

func (_c *Validator_ValidateTC_Call) Run(run func(tc *flow.TimeoutCertificate)) *Validator_ValidateTC_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *flow.TimeoutCertificate
		if args[0] != nil {
			arg0 = args[0].(*flow.TimeoutCertificate)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Validator_ValidateTC_Call) Return(err error) *Validator_ValidateTC_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Validator_ValidateTC_Call) RunAndReturn(run func(tc *flow.TimeoutCertificate) error) *Validator_ValidateTC_Call {
	_c.Call.Return(run)
	return _c
}

// ValidateVote provides a mock function for the type Validator
func (_mock *Validator) ValidateVote(vote *model.Vote) (*flow.IdentitySkeleton, error) {
	ret := _mock.Called(vote)

	if len(ret) == 0 {
		panic("no return value specified for ValidateVote")
	}

	var r0 *flow.IdentitySkeleton
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*model.Vote) (*flow.IdentitySkeleton, error)); ok {
		return returnFunc(vote)
	}
	if returnFunc, ok := ret.Get(0).(func(*model.Vote) *flow.IdentitySkeleton); ok {
		r0 = returnFunc(vote)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.IdentitySkeleton)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*model.Vote) error); ok {
		r1 = returnFunc(vote)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Validator_ValidateVote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ValidateVote'
type Validator_ValidateVote_Call struct {
	*mock.Call
}

// ValidateVote is a helper method to define mock.On call
//   - vote *model.Vote
func (_e *Validator_Expecter) ValidateVote(vote interface{}) *Validator_ValidateVote_Call {
	return &Validator_ValidateVote_Call{Call: _e.mock.On("ValidateVote", vote)}
}

func (_c *Validator_ValidateVote_Call) Run(run func(vote *model.Vote)) *Validator_ValidateVote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Vote
		if args[0] != nil {
			arg0 = args[0].(*model.Vote)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Validator_ValidateVote_Call) Return(identitySkeleton *flow.IdentitySkeleton, err error) *Validator_ValidateVote_Call {
	_c.Call.Return(identitySkeleton, err)
	return _c
}

func (_c *Validator_ValidateVote_Call) RunAndReturn(run func(vote *model.Vote) (*flow.IdentitySkeleton, error)) *Validator_ValidateVote_Call {
	_c.Call.Return(run)
	return _c
}

// NewVerifier creates a new instance of Verifier. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewVerifier(t interface {
	mock.TestingT
	Cleanup(func())
}) *Verifier {
	mock := &Verifier{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Verifier is an autogenerated mock type for the Verifier type
type Verifier struct {
	mock.Mock
}

type Verifier_Expecter struct {
	mock *mock.Mock
}

func (_m *Verifier) EXPECT() *Verifier_Expecter {
	return &Verifier_Expecter{mock: &_m.Mock}
}

// VerifyQC provides a mock function for the type Verifier
func (_mock *Verifier) VerifyQC(signers flow.IdentitySkeletonList, sigData []byte, view uint64, blockID flow.Identifier) error {
	ret := _mock.Called(signers, sigData, view, blockID)

	if len(ret) == 0 {
		panic("no return value specified for VerifyQC")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(flow.IdentitySkeletonList, []byte, uint64, flow.Identifier) error); ok {
		r0 = returnFunc(signers, sigData, view, blockID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Verifier_VerifyQC_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'VerifyQC'
type Verifier_VerifyQC_Call struct {
	*mock.Call
}

// VerifyQC is a helper method to define mock.On call
//   - signers flow.IdentitySkeletonList
//   - sigData []byte
//   - view uint64
//   - blockID flow.Identifier
func (_e *Verifier_Expecter) VerifyQC(signers interface{}, sigData interface{}, view interface{}, blockID interface{}) *Verifier_VerifyQC_Call {
	return &Verifier_VerifyQC_Call{Call: _e.mock.On("VerifyQC", signers, sigData, view, blockID)}
}

func (_c *Verifier_VerifyQC_Call) Run(run func(signers flow.IdentitySkeletonList, sigData []byte, view uint64, blockID flow.Identifier)) *Verifier_VerifyQC_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.IdentitySkeletonList
		if args[0] != nil {
			arg0 = args[0].(flow.IdentitySkeletonList)
		}
		var arg1 []byte
		if args[1] != nil {
			arg1 = args[1].([]byte)
		}
		var arg2 uint64
		if args[2] != nil {
			arg2 = args[2].(uint64)
		}
		var arg3 flow.Identifier
		if args[3] != nil {
			arg3 = args[3].(flow.Identifier)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *Verifier_VerifyQC_Call) Return(err error) *Verifier_VerifyQC_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Verifier_VerifyQC_Call) RunAndReturn(run func(signers flow.IdentitySkeletonList, sigData []byte, view uint64, blockID flow.Identifier) error) *Verifier_VerifyQC_Call {
	_c.Call.Return(run)
	return _c
}

// VerifyTC provides a mock function for the type Verifier
func (_mock *Verifier) VerifyTC(signers flow.IdentitySkeletonList, sigData []byte, view uint64, highQCViews []uint64) error {
	ret := _mock.Called(signers, sigData, view, highQCViews)

	if len(ret) == 0 {
		panic("no return value specified for VerifyTC")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(flow.IdentitySkeletonList, []byte, uint64, []uint64) error); ok {
		r0 = returnFunc(signers, sigData, view, highQCViews)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Verifier_VerifyTC_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'VerifyTC'
type Verifier_VerifyTC_Call struct {
	*mock.Call
}

// VerifyTC is a helper method to define mock.On call
//   - signers flow.IdentitySkeletonList
//   - sigData []byte
//   - view uint64
//   - highQCViews []uint64
func (_e *Verifier_Expecter) VerifyTC(signers interface{}, sigData interface{}, view interface{}, highQCViews interface{}) *Verifier_VerifyTC_Call {
	return &Verifier_VerifyTC_Call{Call: _e.mock.On("VerifyTC", signers, sigData, view, highQCViews)}
}

func (_c *Verifier_VerifyTC_Call) Run(run func(signers flow.IdentitySkeletonList, sigData []byte, view uint64, highQCViews []uint64)) *Verifier_VerifyTC_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.IdentitySkeletonList
		if args[0] != nil {
			arg0 = args[0].(flow.IdentitySkeletonList)
		}
		var arg1 []byte
		if args[1] != nil {
			arg1 = args[1].([]byte)
		}
		var arg2 uint64
		if args[2] != nil {
			arg2 = args[2].(uint64)
		}
		var arg3 []uint64
		if args[3] != nil {
			arg3 = args[3].([]uint64)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *Verifier_VerifyTC_Call) Return(err error) *Verifier_VerifyTC_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Verifier_VerifyTC_Call) RunAndReturn(run func(signers flow.IdentitySkeletonList, sigData []byte, view uint64, highQCViews []uint64) error) *Verifier_VerifyTC_Call {
	_c.Call.Return(run)
	return _c
}

// VerifyVote provides a mock function for the type Verifier
func (_mock *Verifier) VerifyVote(voter *flow.IdentitySkeleton, sigData []byte, view uint64, blockID flow.Identifier) error {
	ret := _mock.Called(voter, sigData, view, blockID)

	if len(ret) == 0 {
		panic("no return value specified for VerifyVote")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*flow.IdentitySkeleton, []byte, uint64, flow.Identifier) error); ok {
		r0 = returnFunc(voter, sigData, view, blockID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Verifier_VerifyVote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'VerifyVote'
type Verifier_VerifyVote_Call struct {
	*mock.Call
}

// VerifyVote is a helper method to define mock.On call
//   - voter *flow.IdentitySkeleton
//   - sigData []byte
//   - view uint64
//   - blockID flow.Identifier
func (_e *Verifier_Expecter) VerifyVote(voter interface{}, sigData interface{}, view interface{}, blockID interface{}) *Verifier_VerifyVote_Call {
	return &Verifier_VerifyVote_Call{Call: _e.mock.On("VerifyVote", voter, sigData, view, blockID)}
}

func (_c *Verifier_VerifyVote_Call) Run(run func(voter *flow.IdentitySkeleton, sigData []byte, view uint64, blockID flow.Identifier)) *Verifier_VerifyVote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *flow.IdentitySkeleton
		if args[0] != nil {
			arg0 = args[0].(*flow.IdentitySkeleton)
		}
		var arg1 []byte
		if args[1] != nil {
			arg1 = args[1].([]byte)
		}
		var arg2 uint64
		if args[2] != nil {
			arg2 = args[2].(uint64)
		}
		var arg3 flow.Identifier
		if args[3] != nil {
			arg3 = args[3].(flow.Identifier)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *Verifier_VerifyVote_Call) Return(err error) *Verifier_VerifyVote_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Verifier_VerifyVote_Call) RunAndReturn(run func(voter *flow.IdentitySkeleton, sigData []byte, view uint64, blockID flow.Identifier) error) *Verifier_VerifyVote_Call {
	_c.Call.Return(run)
	return _c
}

// NewVoteAggregator creates a new instance of VoteAggregator. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewVoteAggregator(t interface {
	mock.TestingT
	Cleanup(func())
}) *VoteAggregator {
	mock := &VoteAggregator{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// VoteAggregator is an autogenerated mock type for the VoteAggregator type
type VoteAggregator struct {
	mock.Mock
}

type VoteAggregator_Expecter struct {
	mock *mock.Mock
}

func (_m *VoteAggregator) EXPECT() *VoteAggregator_Expecter {
	return &VoteAggregator_Expecter{mock: &_m.Mock}
}

// AddBlock provides a mock function for the type VoteAggregator
func (_mock *VoteAggregator) AddBlock(block *model.SignedProposal) {
	_mock.Called(block)
	return
}

// VoteAggregator_AddBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddBlock'
type VoteAggregator_AddBlock_Call struct {
	*mock.Call
}

// AddBlock is a helper method to define mock.On call
//   - block *model.SignedProposal
func (_e *VoteAggregator_Expecter) AddBlock(block interface{}) *VoteAggregator_AddBlock_Call {
	return &VoteAggregator_AddBlock_Call{Call: _e.mock.On("AddBlock", block)}
}

func (_c *VoteAggregator_AddBlock_Call) Run(run func(block *model.SignedProposal)) *VoteAggregator_AddBlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.SignedProposal
		if args[0] != nil {
			arg0 = args[0].(*model.SignedProposal)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *VoteAggregator_AddBlock_Call) Return() *VoteAggregator_AddBlock_Call {
	_c.Call.Return()
	return _c
}

func (_c *VoteAggregator_AddBlock_Call) RunAndReturn(run func(block *model.SignedProposal)) *VoteAggregator_AddBlock_Call {
	_c.Run(run)
	return _c
}

// AddVote provides a mock function for the type VoteAggregator
func (_mock *VoteAggregator) AddVote(vote *model.Vote) {
	_mock.Called(vote)
	return
}

// VoteAggregator_AddVote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddVote'
type VoteAggregator_AddVote_Call struct {
	*mock.Call
}

// AddVote is a helper method to define mock.On call
//   - vote *model.Vote
func (_e *VoteAggregator_Expecter) AddVote(vote interface{}) *VoteAggregator_AddVote_Call {
	return &VoteAggregator_AddVote_Call{Call: _e.mock.On("AddVote", vote)}
}

func (_c *VoteAggregator_AddVote_Call) Run(run func(vote *model.Vote)) *VoteAggregator_AddVote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Vote
		if args[0] != nil {
			arg0 = args[0].(*model.Vote)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *VoteAggregator_AddVote_Call) Return() *VoteAggregator_AddVote_Call {
	_c.Call.Return()
	return _c
}

func (_c *VoteAggregator_AddVote_Call) RunAndReturn(run func(vote *model.Vote)) *VoteAggregator_AddVote_Call {
	_c.Run(run)
	return _c
}

// Done provides a mock function for the type VoteAggregator
func (_mock *VoteAggregator) Done() <-chan struct{} {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Done")
	}

	var r0 <-chan struct{}
	if returnFunc, ok := ret.Get(0).(func() <-chan struct{}); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan struct{})
		}
	}
	return r0
}

// VoteAggregator_Done_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Done'
type VoteAggregator_Done_Call struct {
	*mock.Call
}

// Done is a helper method to define mock.On call
func (_e *VoteAggregator_Expecter) Done() *VoteAggregator_Done_Call {
	return &VoteAggregator_Done_Call{Call: _e.mock.On("Done")}
}

func (_c *VoteAggregator_Done_Call) Run(run func()) *VoteAggregator_Done_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *VoteAggregator_Done_Call) Return(valCh <-chan struct{}) *VoteAggregator_Done_Call {
	_c.Call.Return(valCh)
	return _c
}

func (_c *VoteAggregator_Done_Call) RunAndReturn(run func() <-chan struct{}) *VoteAggregator_Done_Call {
	_c.Call.Return(run)
	return _c
}

// InvalidBlock provides a mock function for the type VoteAggregator
func (_mock *VoteAggregator) InvalidBlock(block *model.SignedProposal) error {
	ret := _mock.Called(block)

	if len(ret) == 0 {
		panic("no return value specified for InvalidBlock")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*model.SignedProposal) error); ok {
		r0 = returnFunc(block)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// VoteAggregator_InvalidBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InvalidBlock'
type VoteAggregator_InvalidBlock_Call struct {
	*mock.Call
}

// InvalidBlock is a helper method to define mock.On call
//   - block *model.SignedProposal
func (_e *VoteAggregator_Expecter) InvalidBlock(block interface{}) *VoteAggregator_InvalidBlock_Call {
	return &VoteAggregator_InvalidBlock_Call{Call: _e.mock.On("InvalidBlock", block)}
}

func (_c *VoteAggregator_InvalidBlock_Call) Run(run func(block *model.SignedProposal)) *VoteAggregator_InvalidBlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.SignedProposal
		if args[0] != nil {
			arg0 = args[0].(*model.SignedProposal)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *VoteAggregator_InvalidBlock_Call) Return(err error) *VoteAggregator_InvalidBlock_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *VoteAggregator_InvalidBlock_Call) RunAndReturn(run func(block *model.SignedProposal) error) *VoteAggregator_InvalidBlock_Call {
	_c.Call.Return(run)
	return _c
}

// PruneUpToView provides a mock function for the type VoteAggregator
func (_mock *VoteAggregator) PruneUpToView(view uint64) {
	_mock.Called(view)
	return
}

// VoteAggregator_PruneUpToView_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PruneUpToView'
type VoteAggregator_PruneUpToView_Call struct {
	*mock.Call
}

// PruneUpToView is a helper method to define mock.On call
//   - view uint64
func (_e *VoteAggregator_Expecter) PruneUpToView(view interface{}) *VoteAggregator_PruneUpToView_Call {
	return &VoteAggregator_PruneUpToView_Call{Call: _e.mock.On("PruneUpToView", view)}
}

func (_c *VoteAggregator_PruneUpToView_Call) Run(run func(view uint64)) *VoteAggregator_PruneUpToView_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *VoteAggregator_PruneUpToView_Call) Return() *VoteAggregator_PruneUpToView_Call {
	_c.Call.Return()
	return _c
}

func (_c *VoteAggregator_PruneUpToView_Call) RunAndReturn(run func(view uint64)) *VoteAggregator_PruneUpToView_Call {
	_c.Run(run)
	return _c
}

// Ready provides a mock function for the type VoteAggregator
func (_mock *VoteAggregator) Ready() <-chan struct{} {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Ready")
	}

	var r0 <-chan struct{}
	if returnFunc, ok := ret.Get(0).(func() <-chan struct{}); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan struct{})
		}
	}
	return r0
}

// VoteAggregator_Ready_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Ready'
type VoteAggregator_Ready_Call struct {
	*mock.Call
}

// Ready is a helper method to define mock.On call
func (_e *VoteAggregator_Expecter) Ready() *VoteAggregator_Ready_Call {
	return &VoteAggregator_Ready_Call{Call: _e.mock.On("Ready")}
}

func (_c *VoteAggregator_Ready_Call) Run(run func()) *VoteAggregator_Ready_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *VoteAggregator_Ready_Call) Return(valCh <-chan struct{}) *VoteAggregator_Ready_Call {
	_c.Call.Return(valCh)
	return _c
}

func (_c *VoteAggregator_Ready_Call) RunAndReturn(run func() <-chan struct{}) *VoteAggregator_Ready_Call {
	_c.Call.Return(run)
	return _c
}

// Start provides a mock function for the type VoteAggregator
func (_mock *VoteAggregator) Start(signalerContext irrecoverable.SignalerContext) {
	_mock.Called(signalerContext)
	return
}

// VoteAggregator_Start_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Start'
type VoteAggregator_Start_Call struct {
	*mock.Call
}

// Start is a helper method to define mock.On call
//   - signalerContext irrecoverable.SignalerContext
func (_e *VoteAggregator_Expecter) Start(signalerContext interface{}) *VoteAggregator_Start_Call {
	return &VoteAggregator_Start_Call{Call: _e.mock.On("Start", signalerContext)}
}

func (_c *VoteAggregator_Start_Call) Run(run func(signalerContext irrecoverable.SignalerContext)) *VoteAggregator_Start_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 irrecoverable.SignalerContext
		if args[0] != nil {
			arg0 = args[0].(irrecoverable.SignalerContext)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *VoteAggregator_Start_Call) Return() *VoteAggregator_Start_Call {
	_c.Call.Return()
	return _c
}

func (_c *VoteAggregator_Start_Call) RunAndReturn(run func(signalerContext irrecoverable.SignalerContext)) *VoteAggregator_Start_Call {
	_c.Run(run)
	return _c
}

// NewVoteCollector creates a new instance of VoteCollector. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewVoteCollector(t interface {
	mock.TestingT
	Cleanup(func())
}) *VoteCollector {
	mock := &VoteCollector{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// VoteCollector is an autogenerated mock type for the VoteCollector type
type VoteCollector struct {
	mock.Mock
}

type VoteCollector_Expecter struct {
	mock *mock.Mock
}

func (_m *VoteCollector) EXPECT() *VoteCollector_Expecter {
	return &VoteCollector_Expecter{mock: &_m.Mock}
}

// AddVote provides a mock function for the type VoteCollector
func (_mock *VoteCollector) AddVote(vote *model.Vote) error {
	ret := _mock.Called(vote)

	if len(ret) == 0 {
		panic("no return value specified for AddVote")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*model.Vote) error); ok {
		r0 = returnFunc(vote)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// VoteCollector_AddVote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddVote'
type VoteCollector_AddVote_Call struct {
	*mock.Call
}

// AddVote is a helper method to define mock.On call
//   - vote *model.Vote
func (_e *VoteCollector_Expecter) AddVote(vote interface{}) *VoteCollector_AddVote_Call {
	return &VoteCollector_AddVote_Call{Call: _e.mock.On("AddVote", vote)}
}

func (_c *VoteCollector_AddVote_Call) Run(run func(vote *model.Vote)) *VoteCollector_AddVote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Vote
		if args[0] != nil {
			arg0 = args[0].(*model.Vote)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *VoteCollector_AddVote_Call) Return(err error) *VoteCollector_AddVote_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *VoteCollector_AddVote_Call) RunAndReturn(run func(vote *model.Vote) error) *VoteCollector_AddVote_Call {
	_c.Call.Return(run)
	return _c
}

// ProcessBlock provides a mock function for the type VoteCollector
func (_mock *VoteCollector) ProcessBlock(block *model.SignedProposal) error {
	ret := _mock.Called(block)

	if len(ret) == 0 {
		panic("no return value specified for ProcessBlock")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*model.SignedProposal) error); ok {
		r0 = returnFunc(block)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// VoteCollector_ProcessBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ProcessBlock'
type VoteCollector_ProcessBlock_Call struct {
	*mock.Call
}

// ProcessBlock is a helper method to define mock.On call
//   - block *model.SignedProposal
func (_e *VoteCollector_Expecter) ProcessBlock(block interface{}) *VoteCollector_ProcessBlock_Call {
	return &VoteCollector_ProcessBlock_Call{Call: _e.mock.On("ProcessBlock", block)}
}

func (_c *VoteCollector_ProcessBlock_Call) Run(run func(block *model.SignedProposal)) *VoteCollector_ProcessBlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.SignedProposal
		if args[0] != nil {
			arg0 = args[0].(*model.SignedProposal)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *VoteCollector_ProcessBlock_Call) Return(err error) *VoteCollector_ProcessBlock_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *VoteCollector_ProcessBlock_Call) RunAndReturn(run func(block *model.SignedProposal) error) *VoteCollector_ProcessBlock_Call {
	_c.Call.Return(run)
	return _c
}

// RegisterVoteConsumer provides a mock function for the type VoteCollector
func (_mock *VoteCollector) RegisterVoteConsumer(consumer hotstuff.VoteConsumer) {
	_mock.Called(consumer)
	return
}

// VoteCollector_RegisterVoteConsumer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RegisterVoteConsumer'
type VoteCollector_RegisterVoteConsumer_Call struct {
	*mock.Call
}

// RegisterVoteConsumer is a helper method to define mock.On call
//   - consumer hotstuff.VoteConsumer
func (_e *VoteCollector_Expecter) RegisterVoteConsumer(consumer interface{}) *VoteCollector_RegisterVoteConsumer_Call {
	return &VoteCollector_RegisterVoteConsumer_Call{Call: _e.mock.On("RegisterVoteConsumer", consumer)}
}

func (_c *VoteCollector_RegisterVoteConsumer_Call) Run(run func(consumer hotstuff.VoteConsumer)) *VoteCollector_RegisterVoteConsumer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 hotstuff.VoteConsumer
		if args[0] != nil {
			arg0 = args[0].(hotstuff.VoteConsumer)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *VoteCollector_RegisterVoteConsumer_Call) Return() *VoteCollector_RegisterVoteConsumer_Call {
	_c.Call.Return()
	return _c
}

func (_c *VoteCollector_RegisterVoteConsumer_Call) RunAndReturn(run func(consumer hotstuff.VoteConsumer)) *VoteCollector_RegisterVoteConsumer_Call {
	_c.Run(run)
	return _c
}

// Status provides a mock function for the type VoteCollector
func (_mock *VoteCollector) Status() hotstuff.VoteCollectorStatus {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Status")
	}

	var r0 hotstuff.VoteCollectorStatus
	if returnFunc, ok := ret.Get(0).(func() hotstuff.VoteCollectorStatus); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(hotstuff.VoteCollectorStatus)
	}
	return r0
}

// VoteCollector_Status_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Status'
type VoteCollector_Status_Call struct {
	*mock.Call
}

// Status is a helper method to define mock.On call
func (_e *VoteCollector_Expecter) Status() *VoteCollector_Status_Call {
	return &VoteCollector_Status_Call{Call: _e.mock.On("Status")}
}

func (_c *VoteCollector_Status_Call) Run(run func()) *VoteCollector_Status_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *VoteCollector_Status_Call) Return(voteCollectorStatus hotstuff.VoteCollectorStatus) *VoteCollector_Status_Call {
	_c.Call.Return(voteCollectorStatus)
	return _c
}

func (_c *VoteCollector_Status_Call) RunAndReturn(run func() hotstuff.VoteCollectorStatus) *VoteCollector_Status_Call {
	_c.Call.Return(run)
	return _c
}

// View provides a mock function for the type VoteCollector
func (_mock *VoteCollector) View() uint64 {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for View")
	}

	var r0 uint64
	if returnFunc, ok := ret.Get(0).(func() uint64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint64)
	}
	return r0
}

// VoteCollector_View_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'View'
type VoteCollector_View_Call struct {
	*mock.Call
}

// View is a helper method to define mock.On call
func (_e *VoteCollector_Expecter) View() *VoteCollector_View_Call {
	return &VoteCollector_View_Call{Call: _e.mock.On("View")}
}

func (_c *VoteCollector_View_Call) Run(run func()) *VoteCollector_View_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *VoteCollector_View_Call) Return(v uint64) *VoteCollector_View_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *VoteCollector_View_Call) RunAndReturn(run func() uint64) *VoteCollector_View_Call {
	_c.Call.Return(run)
	return _c
}

// NewVoteProcessor creates a new instance of VoteProcessor. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewVoteProcessor(t interface {
	mock.TestingT
	Cleanup(func())
}) *VoteProcessor {
	mock := &VoteProcessor{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// VoteProcessor is an autogenerated mock type for the VoteProcessor type
type VoteProcessor struct {
	mock.Mock
}

type VoteProcessor_Expecter struct {
	mock *mock.Mock
}

func (_m *VoteProcessor) EXPECT() *VoteProcessor_Expecter {
	return &VoteProcessor_Expecter{mock: &_m.Mock}
}

// Process provides a mock function for the type VoteProcessor
func (_mock *VoteProcessor) Process(vote *model.Vote) error {
	ret := _mock.Called(vote)

	if len(ret) == 0 {
		panic("no return value specified for Process")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*model.Vote) error); ok {
		r0 = returnFunc(vote)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// VoteProcessor_Process_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Process'
type VoteProcessor_Process_Call struct {
	*mock.Call
}

// Process is a helper method to define mock.On call
//   - vote *model.Vote
func (_e *VoteProcessor_Expecter) Process(vote interface{}) *VoteProcessor_Process_Call {
	return &VoteProcessor_Process_Call{Call: _e.mock.On("Process", vote)}
}

func (_c *VoteProcessor_Process_Call) Run(run func(vote *model.Vote)) *VoteProcessor_Process_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Vote
		if args[0] != nil {
			arg0 = args[0].(*model.Vote)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *VoteProcessor_Process_Call) Return(err error) *VoteProcessor_Process_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *VoteProcessor_Process_Call) RunAndReturn(run func(vote *model.Vote) error) *VoteProcessor_Process_Call {
	_c.Call.Return(run)
	return _c
}

// Status provides a mock function for the type VoteProcessor
func (_mock *VoteProcessor) Status() hotstuff.VoteCollectorStatus {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Status")
	}

	var r0 hotstuff.VoteCollectorStatus
	if returnFunc, ok := ret.Get(0).(func() hotstuff.VoteCollectorStatus); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(hotstuff.VoteCollectorStatus)
	}
	return r0
}

// VoteProcessor_Status_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Status'
type VoteProcessor_Status_Call struct {
	*mock.Call
}

// Status is a helper method to define mock.On call
func (_e *VoteProcessor_Expecter) Status() *VoteProcessor_Status_Call {
	return &VoteProcessor_Status_Call{Call: _e.mock.On("Status")}
}

func (_c *VoteProcessor_Status_Call) Run(run func()) *VoteProcessor_Status_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *VoteProcessor_Status_Call) Return(voteCollectorStatus hotstuff.VoteCollectorStatus) *VoteProcessor_Status_Call {
	_c.Call.Return(voteCollectorStatus)
	return _c
}

func (_c *VoteProcessor_Status_Call) RunAndReturn(run func() hotstuff.VoteCollectorStatus) *VoteProcessor_Status_Call {
	_c.Call.Return(run)
	return _c
}

// NewVerifyingVoteProcessor creates a new instance of VerifyingVoteProcessor. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewVerifyingVoteProcessor(t interface {
	mock.TestingT
	Cleanup(func())
}) *VerifyingVoteProcessor {
	mock := &VerifyingVoteProcessor{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// VerifyingVoteProcessor is an autogenerated mock type for the VerifyingVoteProcessor type
type VerifyingVoteProcessor struct {
	mock.Mock
}

type VerifyingVoteProcessor_Expecter struct {
	mock *mock.Mock
}

func (_m *VerifyingVoteProcessor) EXPECT() *VerifyingVoteProcessor_Expecter {
	return &VerifyingVoteProcessor_Expecter{mock: &_m.Mock}
}

// Block provides a mock function for the type VerifyingVoteProcessor
func (_mock *VerifyingVoteProcessor) Block() *model.Block {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Block")
	}

	var r0 *model.Block
	if returnFunc, ok := ret.Get(0).(func() *model.Block); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Block)
		}
	}
	return r0
}

// VerifyingVoteProcessor_Block_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Block'
type VerifyingVoteProcessor_Block_Call struct {
	*mock.Call
}

// Block is a helper method to define mock.On call
func (_e *VerifyingVoteProcessor_Expecter) Block() *VerifyingVoteProcessor_Block_Call {
	return &VerifyingVoteProcessor_Block_Call{Call: _e.mock.On("Block")}
}

func (_c *VerifyingVoteProcessor_Block_Call) Run(run func()) *VerifyingVoteProcessor_Block_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *VerifyingVoteProcessor_Block_Call) Return(block *model.Block) *VerifyingVoteProcessor_Block_Call {
	_c.Call.Return(block)
	return _c
}

func (_c *VerifyingVoteProcessor_Block_Call) RunAndReturn(run func() *model.Block) *VerifyingVoteProcessor_Block_Call {
	_c.Call.Return(run)
	return _c
}

// Process provides a mock function for the type VerifyingVoteProcessor
func (_mock *VerifyingVoteProcessor) Process(vote *model.Vote) error {
	ret := _mock.Called(vote)

	if len(ret) == 0 {
		panic("no return value specified for Process")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*model.Vote) error); ok {
		r0 = returnFunc(vote)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// VerifyingVoteProcessor_Process_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Process'
type VerifyingVoteProcessor_Process_Call struct {
	*mock.Call
}

// Process is a helper method to define mock.On call
//   - vote *model.Vote
func (_e *VerifyingVoteProcessor_Expecter) Process(vote interface{}) *VerifyingVoteProcessor_Process_Call {
	return &VerifyingVoteProcessor_Process_Call{Call: _e.mock.On("Process", vote)}
}

func (_c *VerifyingVoteProcessor_Process_Call) Run(run func(vote *model.Vote)) *VerifyingVoteProcessor_Process_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *model.Vote
		if args[0] != nil {
			arg0 = args[0].(*model.Vote)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *VerifyingVoteProcessor_Process_Call) Return(err error) *VerifyingVoteProcessor_Process_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *VerifyingVoteProcessor_Process_Call) RunAndReturn(run func(vote *model.Vote) error) *VerifyingVoteProcessor_Process_Call {
	_c.Call.Return(run)
	return _c
}

// Status provides a mock function for the type VerifyingVoteProcessor
func (_mock *VerifyingVoteProcessor) Status() hotstuff.VoteCollectorStatus {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Status")
	}

	var r0 hotstuff.VoteCollectorStatus
	if returnFunc, ok := ret.Get(0).(func() hotstuff.VoteCollectorStatus); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(hotstuff.VoteCollectorStatus)
	}
	return r0
}

// VerifyingVoteProcessor_Status_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Status'
type VerifyingVoteProcessor_Status_Call struct {
	*mock.Call
}

// Status is a helper method to define mock.On call
func (_e *VerifyingVoteProcessor_Expecter) Status() *VerifyingVoteProcessor_Status_Call {
	return &VerifyingVoteProcessor_Status_Call{Call: _e.mock.On("Status")}
}

func (_c *VerifyingVoteProcessor_Status_Call) Run(run func()) *VerifyingVoteProcessor_Status_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *VerifyingVoteProcessor_Status_Call) Return(voteCollectorStatus hotstuff.VoteCollectorStatus) *VerifyingVoteProcessor_Status_Call {
	_c.Call.Return(voteCollectorStatus)
	return _c
}

func (_c *VerifyingVoteProcessor_Status_Call) RunAndReturn(run func() hotstuff.VoteCollectorStatus) *VerifyingVoteProcessor_Status_Call {
	_c.Call.Return(run)
	return _c
}

// NewVoteProcessorFactory creates a new instance of VoteProcessorFactory. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewVoteProcessorFactory(t interface {
	mock.TestingT
	Cleanup(func())
}) *VoteProcessorFactory {
	mock := &VoteProcessorFactory{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// VoteProcessorFactory is an autogenerated mock type for the VoteProcessorFactory type
type VoteProcessorFactory struct {
	mock.Mock
}

type VoteProcessorFactory_Expecter struct {
	mock *mock.Mock
}

func (_m *VoteProcessorFactory) EXPECT() *VoteProcessorFactory_Expecter {
	return &VoteProcessorFactory_Expecter{mock: &_m.Mock}
}

// Create provides a mock function for the type VoteProcessorFactory
func (_mock *VoteProcessorFactory) Create(log zerolog.Logger, proposal *model.SignedProposal) (hotstuff.VerifyingVoteProcessor, error) {
	ret := _mock.Called(log, proposal)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 hotstuff.VerifyingVoteProcessor
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(zerolog.Logger, *model.SignedProposal) (hotstuff.VerifyingVoteProcessor, error)); ok {
		return returnFunc(log, proposal)
	}
	if returnFunc, ok := ret.Get(0).(func(zerolog.Logger, *model.SignedProposal) hotstuff.VerifyingVoteProcessor); ok {
		r0 = returnFunc(log, proposal)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(hotstuff.VerifyingVoteProcessor)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(zerolog.Logger, *model.SignedProposal) error); ok {
		r1 = returnFunc(log, proposal)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// VoteProcessorFactory_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type VoteProcessorFactory_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - log zerolog.Logger
//   - proposal *model.SignedProposal
func (_e *VoteProcessorFactory_Expecter) Create(log interface{}, proposal interface{}) *VoteProcessorFactory_Create_Call {
	return &VoteProcessorFactory_Create_Call{Call: _e.mock.On("Create", log, proposal)}
}

func (_c *VoteProcessorFactory_Create_Call) Run(run func(log zerolog.Logger, proposal *model.SignedProposal)) *VoteProcessorFactory_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 zerolog.Logger
		if args[0] != nil {
			arg0 = args[0].(zerolog.Logger)
		}
		var arg1 *model.SignedProposal
		if args[1] != nil {
			arg1 = args[1].(*model.SignedProposal)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *VoteProcessorFactory_Create_Call) Return(verifyingVoteProcessor hotstuff.VerifyingVoteProcessor, err error) *VoteProcessorFactory_Create_Call {
	_c.Call.Return(verifyingVoteProcessor, err)
	return _c
}

func (_c *VoteProcessorFactory_Create_Call) RunAndReturn(run func(log zerolog.Logger, proposal *model.SignedProposal) (hotstuff.VerifyingVoteProcessor, error)) *VoteProcessorFactory_Create_Call {
	_c.Call.Return(run)
	return _c
}

// NewVoteCollectors creates a new instance of VoteCollectors. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewVoteCollectors(t interface {
	mock.TestingT
	Cleanup(func())
}) *VoteCollectors {
	mock := &VoteCollectors{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// VoteCollectors is an autogenerated mock type for the VoteCollectors type
type VoteCollectors struct {
	mock.Mock
}

type VoteCollectors_Expecter struct {
	mock *mock.Mock
}

func (_m *VoteCollectors) EXPECT() *VoteCollectors_Expecter {
	return &VoteCollectors_Expecter{mock: &_m.Mock}
}

// Done provides a mock function for the type VoteCollectors
func (_mock *VoteCollectors) Done() <-chan struct{} {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Done")
	}

	var r0 <-chan struct{}
	if returnFunc, ok := ret.Get(0).(func() <-chan struct{}); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan struct{})
		}
	}
	return r0
}

// VoteCollectors_Done_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Done'
type VoteCollectors_Done_Call struct {
	*mock.Call
}

// Done is a helper method to define mock.On call
func (_e *VoteCollectors_Expecter) Done() *VoteCollectors_Done_Call {
	return &VoteCollectors_Done_Call{Call: _e.mock.On("Done")}
}

func (_c *VoteCollectors_Done_Call) Run(run func()) *VoteCollectors_Done_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *VoteCollectors_Done_Call) Return(valCh <-chan struct{}) *VoteCollectors_Done_Call {
	_c.Call.Return(valCh)
	return _c
}

func (_c *VoteCollectors_Done_Call) RunAndReturn(run func() <-chan struct{}) *VoteCollectors_Done_Call {
	_c.Call.Return(run)
	return _c
}

// GetOrCreateCollector provides a mock function for the type VoteCollectors
func (_mock *VoteCollectors) GetOrCreateCollector(view uint64) (hotstuff.VoteCollector, bool, error) {
	ret := _mock.Called(view)

	if len(ret) == 0 {
		panic("no return value specified for GetOrCreateCollector")
	}

	var r0 hotstuff.VoteCollector
	var r1 bool
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(uint64) (hotstuff.VoteCollector, bool, error)); ok {
		return returnFunc(view)
	}
	if returnFunc, ok := ret.Get(0).(func(uint64) hotstuff.VoteCollector); ok {
		r0 = returnFunc(view)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(hotstuff.VoteCollector)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(uint64) bool); ok {
		r1 = returnFunc(view)
	} else {
		r1 = ret.Get(1).(bool)
	}
	if returnFunc, ok := ret.Get(2).(func(uint64) error); ok {
		r2 = returnFunc(view)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// VoteCollectors_GetOrCreateCollector_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetOrCreateCollector'
type VoteCollectors_GetOrCreateCollector_Call struct {
	*mock.Call
}

// GetOrCreateCollector is a helper method to define mock.On call
//   - view uint64
func (_e *VoteCollectors_Expecter) GetOrCreateCollector(view interface{}) *VoteCollectors_GetOrCreateCollector_Call {
	return &VoteCollectors_GetOrCreateCollector_Call{Call: _e.mock.On("GetOrCreateCollector", view)}
}

func (_c *VoteCollectors_GetOrCreateCollector_Call) Run(run func(view uint64)) *VoteCollectors_GetOrCreateCollector_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *VoteCollectors_GetOrCreateCollector_Call) Return(collector hotstuff.VoteCollector, created bool, err error) *VoteCollectors_GetOrCreateCollector_Call {
	_c.Call.Return(collector, created, err)
	return _c
}

func (_c *VoteCollectors_GetOrCreateCollector_Call) RunAndReturn(run func(view uint64) (hotstuff.VoteCollector, bool, error)) *VoteCollectors_GetOrCreateCollector_Call {
	_c.Call.Return(run)
	return _c
}

// PruneUpToView provides a mock function for the type VoteCollectors
func (_mock *VoteCollectors) PruneUpToView(lowestRetainedView uint64) {
	_mock.Called(lowestRetainedView)
	return
}

// VoteCollectors_PruneUpToView_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PruneUpToView'
type VoteCollectors_PruneUpToView_Call struct {
	*mock.Call
}

// PruneUpToView is a helper method to define mock.On call
//   - lowestRetainedView uint64
func (_e *VoteCollectors_Expecter) PruneUpToView(lowestRetainedView interface{}) *VoteCollectors_PruneUpToView_Call {
	return &VoteCollectors_PruneUpToView_Call{Call: _e.mock.On("PruneUpToView", lowestRetainedView)}
}

func (_c *VoteCollectors_PruneUpToView_Call) Run(run func(lowestRetainedView uint64)) *VoteCollectors_PruneUpToView_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *VoteCollectors_PruneUpToView_Call) Return() *VoteCollectors_PruneUpToView_Call {
	_c.Call.Return()
	return _c
}

func (_c *VoteCollectors_PruneUpToView_Call) RunAndReturn(run func(lowestRetainedView uint64)) *VoteCollectors_PruneUpToView_Call {
	_c.Run(run)
	return _c
}

// Ready provides a mock function for the type VoteCollectors
func (_mock *VoteCollectors) Ready() <-chan struct{} {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Ready")
	}

	var r0 <-chan struct{}
	if returnFunc, ok := ret.Get(0).(func() <-chan struct{}); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan struct{})
		}
	}
	return r0
}

// VoteCollectors_Ready_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Ready'
type VoteCollectors_Ready_Call struct {
	*mock.Call
}

// Ready is a helper method to define mock.On call
func (_e *VoteCollectors_Expecter) Ready() *VoteCollectors_Ready_Call {
	return &VoteCollectors_Ready_Call{Call: _e.mock.On("Ready")}
}

func (_c *VoteCollectors_Ready_Call) Run(run func()) *VoteCollectors_Ready_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *VoteCollectors_Ready_Call) Return(valCh <-chan struct{}) *VoteCollectors_Ready_Call {
	_c.Call.Return(valCh)
	return _c
}

func (_c *VoteCollectors_Ready_Call) RunAndReturn(run func() <-chan struct{}) *VoteCollectors_Ready_Call {
	_c.Call.Return(run)
	return _c
}

// Start provides a mock function for the type VoteCollectors
func (_mock *VoteCollectors) Start(signalerContext irrecoverable.SignalerContext) {
	_mock.Called(signalerContext)
	return
}

// VoteCollectors_Start_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Start'
type VoteCollectors_Start_Call struct {
	*mock.Call
}

// Start is a helper method to define mock.On call
//   - signalerContext irrecoverable.SignalerContext
func (_e *VoteCollectors_Expecter) Start(signalerContext interface{}) *VoteCollectors_Start_Call {
	return &VoteCollectors_Start_Call{Call: _e.mock.On("Start", signalerContext)}
}

func (_c *VoteCollectors_Start_Call) Run(run func(signalerContext irrecoverable.SignalerContext)) *VoteCollectors_Start_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 irrecoverable.SignalerContext
		if args[0] != nil {
			arg0 = args[0].(irrecoverable.SignalerContext)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *VoteCollectors_Start_Call) Return() *VoteCollectors_Start_Call {
	_c.Call.Return()
	return _c
}

func (_c *VoteCollectors_Start_Call) RunAndReturn(run func(signalerContext irrecoverable.SignalerContext)) *VoteCollectors_Start_Call {
	_c.Run(run)
	return _c
}

// NewWorkers creates a new instance of Workers. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewWorkers(t interface {
	mock.TestingT
	Cleanup(func())
}) *Workers {
	mock := &Workers{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Workers is an autogenerated mock type for the Workers type
type Workers struct {
	mock.Mock
}

type Workers_Expecter struct {
	mock *mock.Mock
}

func (_m *Workers) EXPECT() *Workers_Expecter {
	return &Workers_Expecter{mock: &_m.Mock}
}

// Submit provides a mock function for the type Workers
func (_mock *Workers) Submit(task func()) {
	_mock.Called(task)
	return
}

// Workers_Submit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Submit'
type Workers_Submit_Call struct {
	*mock.Call
}

// Submit is a helper method to define mock.On call
//   - task func()
func (_e *Workers_Expecter) Submit(task interface{}) *Workers_Submit_Call {
	return &Workers_Submit_Call{Call: _e.mock.On("Submit", task)}
}

func (_c *Workers_Submit_Call) Run(run func(task func())) *Workers_Submit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 func()
		if args[0] != nil {
			arg0 = args[0].(func())
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Workers_Submit_Call) Return() *Workers_Submit_Call {
	_c.Call.Return()
	return _c
}

func (_c *Workers_Submit_Call) RunAndReturn(run func(task func())) *Workers_Submit_Call {
	_c.Run(run)
	return _c
}

// NewWorkerpool creates a new instance of Workerpool. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewWorkerpool(t interface {
	mock.TestingT
	Cleanup(func())
}) *Workerpool {
	mock := &Workerpool{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Workerpool is an autogenerated mock type for the Workerpool type
type Workerpool struct {
	mock.Mock
}

type Workerpool_Expecter struct {
	mock *mock.Mock
}

func (_m *Workerpool) EXPECT() *Workerpool_Expecter {
	return &Workerpool_Expecter{mock: &_m.Mock}
}

// StopWait provides a mock function for the type Workerpool
func (_mock *Workerpool) StopWait() {
	_mock.Called()
	return
}

// Workerpool_StopWait_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StopWait'
type Workerpool_StopWait_Call struct {
	*mock.Call
}

// StopWait is a helper method to define mock.On call
func (_e *Workerpool_Expecter) StopWait() *Workerpool_StopWait_Call {
	return &Workerpool_StopWait_Call{Call: _e.mock.On("StopWait")}
}

func (_c *Workerpool_StopWait_Call) Run(run func()) *Workerpool_StopWait_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Workerpool_StopWait_Call) Return() *Workerpool_StopWait_Call {
	_c.Call.Return()
	return _c
}

func (_c *Workerpool_StopWait_Call) RunAndReturn(run func()) *Workerpool_StopWait_Call {
	_c.Run(run)
	return _c
}

// Submit provides a mock function for the type Workerpool
func (_mock *Workerpool) Submit(task func()) {
	_mock.Called(task)
	return
}

// Workerpool_Submit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Submit'
type Workerpool_Submit_Call struct {
	*mock.Call
}

// Submit is a helper method to define mock.On call
//   - task func()
func (_e *Workerpool_Expecter) Submit(task interface{}) *Workerpool_Submit_Call {
	return &Workerpool_Submit_Call{Call: _e.mock.On("Submit", task)}
}

func (_c *Workerpool_Submit_Call) Run(run func(task func())) *Workerpool_Submit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 func()
		if args[0] != nil {
			arg0 = args[0].(func())
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Workerpool_Submit_Call) Return() *Workerpool_Submit_Call {
	_c.Call.Return()
	return _c
}

func (_c *Workerpool_Submit_Call) RunAndReturn(run func(task func())) *Workerpool_Submit_Call {
	_c.Run(run)
	return _c
}
