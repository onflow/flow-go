package cluster

import (
	"fmt"
	"regexp"

	"github.com/onflow/flow-go/model/cluster"
	"github.com/onflow/flow-go/model/flow"
)

// ClusterChainPrefix is the prefix used for all Collection Cluster chains.
// Clusters change every epoch, resulting in a new ChainID every epoch.
// Cluster ChainIDs are generated by [CanonicalClusterID] and verified by [ChainID.IsCanonicalClusterID].
const ClusterChainPrefix string = "cluster"

// CanonicalClusterID returns the canonical chain ID for the given cluster in
// the given epoch.
func CanonicalClusterID(epoch uint64, participants flow.IdentifierList) flow.ChainID {
	return flow.ChainID(fmt.Sprintf(ClusterChainPrefix+"-%d-%s", epoch, participants.ID()))
}

var clusterChainFormat = regexp.MustCompile("^" + ClusterChainPrefix + `-\d+-[0-9a-f]{64}$`)

// IsCanonicalClusterID returns true if the chain ID matches the standard format
// for a collection cluster during an epoch, rather than a full network.
func IsCanonicalClusterID(c flow.ChainID) bool {
	return clusterChainFormat.MatchString(string(c))
}

// CanonicalRootBlock returns the canonical root block for the given
// cluster in the given epoch. It contains an empty collection referencing
func CanonicalRootBlock(epoch uint64, participants flow.IdentifierList) (*cluster.Block, error) {
	chainID := CanonicalClusterID(epoch, participants)
	rootHeaderBody, err := flow.NewRootHeaderBody(flow.UntrustedHeaderBody{
		ChainID:            chainID,
		ParentID:           flow.ZeroID,
		Height:             0,
		Timestamp:          uint64(flow.GenesisTime.UnixMilli()),
		View:               0,
		ParentView:         0,
		ParentVoterIndices: nil,
		ParentVoterSigData: nil,
		ProposerID:         flow.ZeroID,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to create root header body: %w", err)
	}

	rootBlockPayload, err := cluster.NewRootPayload(
		cluster.UntrustedPayload(*cluster.NewEmptyPayload(flow.ZeroID)),
	)
	if err != nil {
		return nil, fmt.Errorf("failed to create root cluster payload: %w", err)
	}

	block, err := cluster.NewRootBlock(
		cluster.UntrustedBlock{
			HeaderBody: *rootHeaderBody,
			Payload:    *rootBlockPayload,
		},
	)
	if err != nil {
		return nil, fmt.Errorf("failed to create root cluster block: %w", err)
	}

	return block, nil
}
