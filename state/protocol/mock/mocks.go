// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mock

import (
	"context"

	"github.com/onflow/crypto"
	"github.com/onflow/flow-go/model/cluster"
	"github.com/onflow/flow-go/model/flow"
	"github.com/onflow/flow-go/state/protocol"
	"github.com/onflow/flow-go/storage/deferred"
	mock "github.com/stretchr/testify/mock"
)

// NewBlockTimer creates a new instance of BlockTimer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewBlockTimer(t interface {
	mock.TestingT
	Cleanup(func())
}) *BlockTimer {
	mock := &BlockTimer{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// BlockTimer is an autogenerated mock type for the BlockTimer type
type BlockTimer struct {
	mock.Mock
}

type BlockTimer_Expecter struct {
	mock *mock.Mock
}

func (_m *BlockTimer) EXPECT() *BlockTimer_Expecter {
	return &BlockTimer_Expecter{mock: &_m.Mock}
}

// Build provides a mock function for the type BlockTimer
func (_mock *BlockTimer) Build(parentTimestamp uint64) uint64 {
	ret := _mock.Called(parentTimestamp)

	if len(ret) == 0 {
		panic("no return value specified for Build")
	}

	var r0 uint64
	if returnFunc, ok := ret.Get(0).(func(uint64) uint64); ok {
		r0 = returnFunc(parentTimestamp)
	} else {
		r0 = ret.Get(0).(uint64)
	}
	return r0
}

// BlockTimer_Build_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Build'
type BlockTimer_Build_Call struct {
	*mock.Call
}

// Build is a helper method to define mock.On call
//   - parentTimestamp uint64
func (_e *BlockTimer_Expecter) Build(parentTimestamp interface{}) *BlockTimer_Build_Call {
	return &BlockTimer_Build_Call{Call: _e.mock.On("Build", parentTimestamp)}
}

func (_c *BlockTimer_Build_Call) Run(run func(parentTimestamp uint64)) *BlockTimer_Build_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *BlockTimer_Build_Call) Return(v uint64) *BlockTimer_Build_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *BlockTimer_Build_Call) RunAndReturn(run func(parentTimestamp uint64) uint64) *BlockTimer_Build_Call {
	_c.Call.Return(run)
	return _c
}

// Validate provides a mock function for the type BlockTimer
func (_mock *BlockTimer) Validate(parentTimestamp uint64, currentTimestamp uint64) error {
	ret := _mock.Called(parentTimestamp, currentTimestamp)

	if len(ret) == 0 {
		panic("no return value specified for Validate")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(uint64, uint64) error); ok {
		r0 = returnFunc(parentTimestamp, currentTimestamp)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// BlockTimer_Validate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Validate'
type BlockTimer_Validate_Call struct {
	*mock.Call
}

// Validate is a helper method to define mock.On call
//   - parentTimestamp uint64
//   - currentTimestamp uint64
func (_e *BlockTimer_Expecter) Validate(parentTimestamp interface{}, currentTimestamp interface{}) *BlockTimer_Validate_Call {
	return &BlockTimer_Validate_Call{Call: _e.mock.On("Validate", parentTimestamp, currentTimestamp)}
}

func (_c *BlockTimer_Validate_Call) Run(run func(parentTimestamp uint64, currentTimestamp uint64)) *BlockTimer_Validate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		var arg1 uint64
		if args[1] != nil {
			arg1 = args[1].(uint64)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *BlockTimer_Validate_Call) Return(err error) *BlockTimer_Validate_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *BlockTimer_Validate_Call) RunAndReturn(run func(parentTimestamp uint64, currentTimestamp uint64) error) *BlockTimer_Validate_Call {
	_c.Call.Return(run)
	return _c
}

// NewState creates a new instance of State. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewState(t interface {
	mock.TestingT
	Cleanup(func())
}) *State {
	mock := &State{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// State is an autogenerated mock type for the State type
type State struct {
	mock.Mock
}

type State_Expecter struct {
	mock *mock.Mock
}

func (_m *State) EXPECT() *State_Expecter {
	return &State_Expecter{mock: &_m.Mock}
}

// AtBlockID provides a mock function for the type State
func (_mock *State) AtBlockID(blockID flow.Identifier) protocol.Snapshot {
	ret := _mock.Called(blockID)

	if len(ret) == 0 {
		panic("no return value specified for AtBlockID")
	}

	var r0 protocol.Snapshot
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) protocol.Snapshot); ok {
		r0 = returnFunc(blockID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(protocol.Snapshot)
		}
	}
	return r0
}

// State_AtBlockID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AtBlockID'
type State_AtBlockID_Call struct {
	*mock.Call
}

// AtBlockID is a helper method to define mock.On call
//   - blockID flow.Identifier
func (_e *State_Expecter) AtBlockID(blockID interface{}) *State_AtBlockID_Call {
	return &State_AtBlockID_Call{Call: _e.mock.On("AtBlockID", blockID)}
}

func (_c *State_AtBlockID_Call) Run(run func(blockID flow.Identifier)) *State_AtBlockID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *State_AtBlockID_Call) Return(snapshot protocol.Snapshot) *State_AtBlockID_Call {
	_c.Call.Return(snapshot)
	return _c
}

func (_c *State_AtBlockID_Call) RunAndReturn(run func(blockID flow.Identifier) protocol.Snapshot) *State_AtBlockID_Call {
	_c.Call.Return(run)
	return _c
}

// AtHeight provides a mock function for the type State
func (_mock *State) AtHeight(height uint64) protocol.Snapshot {
	ret := _mock.Called(height)

	if len(ret) == 0 {
		panic("no return value specified for AtHeight")
	}

	var r0 protocol.Snapshot
	if returnFunc, ok := ret.Get(0).(func(uint64) protocol.Snapshot); ok {
		r0 = returnFunc(height)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(protocol.Snapshot)
		}
	}
	return r0
}

// State_AtHeight_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AtHeight'
type State_AtHeight_Call struct {
	*mock.Call
}

// AtHeight is a helper method to define mock.On call
//   - height uint64
func (_e *State_Expecter) AtHeight(height interface{}) *State_AtHeight_Call {
	return &State_AtHeight_Call{Call: _e.mock.On("AtHeight", height)}
}

func (_c *State_AtHeight_Call) Run(run func(height uint64)) *State_AtHeight_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *State_AtHeight_Call) Return(snapshot protocol.Snapshot) *State_AtHeight_Call {
	_c.Call.Return(snapshot)
	return _c
}

func (_c *State_AtHeight_Call) RunAndReturn(run func(height uint64) protocol.Snapshot) *State_AtHeight_Call {
	_c.Call.Return(run)
	return _c
}

// Final provides a mock function for the type State
func (_mock *State) Final() protocol.Snapshot {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Final")
	}

	var r0 protocol.Snapshot
	if returnFunc, ok := ret.Get(0).(func() protocol.Snapshot); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(protocol.Snapshot)
		}
	}
	return r0
}

// State_Final_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Final'
type State_Final_Call struct {
	*mock.Call
}

// Final is a helper method to define mock.On call
func (_e *State_Expecter) Final() *State_Final_Call {
	return &State_Final_Call{Call: _e.mock.On("Final")}
}

func (_c *State_Final_Call) Run(run func()) *State_Final_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *State_Final_Call) Return(snapshot protocol.Snapshot) *State_Final_Call {
	_c.Call.Return(snapshot)
	return _c
}

func (_c *State_Final_Call) RunAndReturn(run func() protocol.Snapshot) *State_Final_Call {
	_c.Call.Return(run)
	return _c
}

// Params provides a mock function for the type State
func (_mock *State) Params() protocol.Params {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Params")
	}

	var r0 protocol.Params
	if returnFunc, ok := ret.Get(0).(func() protocol.Params); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(protocol.Params)
		}
	}
	return r0
}

// State_Params_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Params'
type State_Params_Call struct {
	*mock.Call
}

// Params is a helper method to define mock.On call
func (_e *State_Expecter) Params() *State_Params_Call {
	return &State_Params_Call{Call: _e.mock.On("Params")}
}

func (_c *State_Params_Call) Run(run func()) *State_Params_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *State_Params_Call) Return(params protocol.Params) *State_Params_Call {
	_c.Call.Return(params)
	return _c
}

func (_c *State_Params_Call) RunAndReturn(run func() protocol.Params) *State_Params_Call {
	_c.Call.Return(run)
	return _c
}

// Sealed provides a mock function for the type State
func (_mock *State) Sealed() protocol.Snapshot {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Sealed")
	}

	var r0 protocol.Snapshot
	if returnFunc, ok := ret.Get(0).(func() protocol.Snapshot); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(protocol.Snapshot)
		}
	}
	return r0
}

// State_Sealed_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Sealed'
type State_Sealed_Call struct {
	*mock.Call
}

// Sealed is a helper method to define mock.On call
func (_e *State_Expecter) Sealed() *State_Sealed_Call {
	return &State_Sealed_Call{Call: _e.mock.On("Sealed")}
}

func (_c *State_Sealed_Call) Run(run func()) *State_Sealed_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *State_Sealed_Call) Return(snapshot protocol.Snapshot) *State_Sealed_Call {
	_c.Call.Return(snapshot)
	return _c
}

func (_c *State_Sealed_Call) RunAndReturn(run func() protocol.Snapshot) *State_Sealed_Call {
	_c.Call.Return(run)
	return _c
}

// NewFollowerState creates a new instance of FollowerState. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewFollowerState(t interface {
	mock.TestingT
	Cleanup(func())
}) *FollowerState {
	mock := &FollowerState{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// FollowerState is an autogenerated mock type for the FollowerState type
type FollowerState struct {
	mock.Mock
}

type FollowerState_Expecter struct {
	mock *mock.Mock
}

func (_m *FollowerState) EXPECT() *FollowerState_Expecter {
	return &FollowerState_Expecter{mock: &_m.Mock}
}

// AtBlockID provides a mock function for the type FollowerState
func (_mock *FollowerState) AtBlockID(blockID flow.Identifier) protocol.Snapshot {
	ret := _mock.Called(blockID)

	if len(ret) == 0 {
		panic("no return value specified for AtBlockID")
	}

	var r0 protocol.Snapshot
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) protocol.Snapshot); ok {
		r0 = returnFunc(blockID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(protocol.Snapshot)
		}
	}
	return r0
}

// FollowerState_AtBlockID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AtBlockID'
type FollowerState_AtBlockID_Call struct {
	*mock.Call
}

// AtBlockID is a helper method to define mock.On call
//   - blockID flow.Identifier
func (_e *FollowerState_Expecter) AtBlockID(blockID interface{}) *FollowerState_AtBlockID_Call {
	return &FollowerState_AtBlockID_Call{Call: _e.mock.On("AtBlockID", blockID)}
}

func (_c *FollowerState_AtBlockID_Call) Run(run func(blockID flow.Identifier)) *FollowerState_AtBlockID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *FollowerState_AtBlockID_Call) Return(snapshot protocol.Snapshot) *FollowerState_AtBlockID_Call {
	_c.Call.Return(snapshot)
	return _c
}

func (_c *FollowerState_AtBlockID_Call) RunAndReturn(run func(blockID flow.Identifier) protocol.Snapshot) *FollowerState_AtBlockID_Call {
	_c.Call.Return(run)
	return _c
}

// AtHeight provides a mock function for the type FollowerState
func (_mock *FollowerState) AtHeight(height uint64) protocol.Snapshot {
	ret := _mock.Called(height)

	if len(ret) == 0 {
		panic("no return value specified for AtHeight")
	}

	var r0 protocol.Snapshot
	if returnFunc, ok := ret.Get(0).(func(uint64) protocol.Snapshot); ok {
		r0 = returnFunc(height)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(protocol.Snapshot)
		}
	}
	return r0
}

// FollowerState_AtHeight_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AtHeight'
type FollowerState_AtHeight_Call struct {
	*mock.Call
}

// AtHeight is a helper method to define mock.On call
//   - height uint64
func (_e *FollowerState_Expecter) AtHeight(height interface{}) *FollowerState_AtHeight_Call {
	return &FollowerState_AtHeight_Call{Call: _e.mock.On("AtHeight", height)}
}

func (_c *FollowerState_AtHeight_Call) Run(run func(height uint64)) *FollowerState_AtHeight_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *FollowerState_AtHeight_Call) Return(snapshot protocol.Snapshot) *FollowerState_AtHeight_Call {
	_c.Call.Return(snapshot)
	return _c
}

func (_c *FollowerState_AtHeight_Call) RunAndReturn(run func(height uint64) protocol.Snapshot) *FollowerState_AtHeight_Call {
	_c.Call.Return(run)
	return _c
}

// ExtendCertified provides a mock function for the type FollowerState
func (_mock *FollowerState) ExtendCertified(ctx context.Context, certified *flow.CertifiedBlock) error {
	ret := _mock.Called(ctx, certified)

	if len(ret) == 0 {
		panic("no return value specified for ExtendCertified")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *flow.CertifiedBlock) error); ok {
		r0 = returnFunc(ctx, certified)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// FollowerState_ExtendCertified_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExtendCertified'
type FollowerState_ExtendCertified_Call struct {
	*mock.Call
}

// ExtendCertified is a helper method to define mock.On call
//   - ctx context.Context
//   - certified *flow.CertifiedBlock
func (_e *FollowerState_Expecter) ExtendCertified(ctx interface{}, certified interface{}) *FollowerState_ExtendCertified_Call {
	return &FollowerState_ExtendCertified_Call{Call: _e.mock.On("ExtendCertified", ctx, certified)}
}

func (_c *FollowerState_ExtendCertified_Call) Run(run func(ctx context.Context, certified *flow.CertifiedBlock)) *FollowerState_ExtendCertified_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *flow.CertifiedBlock
		if args[1] != nil {
			arg1 = args[1].(*flow.CertifiedBlock)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *FollowerState_ExtendCertified_Call) Return(err error) *FollowerState_ExtendCertified_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *FollowerState_ExtendCertified_Call) RunAndReturn(run func(ctx context.Context, certified *flow.CertifiedBlock) error) *FollowerState_ExtendCertified_Call {
	_c.Call.Return(run)
	return _c
}

// Final provides a mock function for the type FollowerState
func (_mock *FollowerState) Final() protocol.Snapshot {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Final")
	}

	var r0 protocol.Snapshot
	if returnFunc, ok := ret.Get(0).(func() protocol.Snapshot); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(protocol.Snapshot)
		}
	}
	return r0
}

// FollowerState_Final_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Final'
type FollowerState_Final_Call struct {
	*mock.Call
}

// Final is a helper method to define mock.On call
func (_e *FollowerState_Expecter) Final() *FollowerState_Final_Call {
	return &FollowerState_Final_Call{Call: _e.mock.On("Final")}
}

func (_c *FollowerState_Final_Call) Run(run func()) *FollowerState_Final_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *FollowerState_Final_Call) Return(snapshot protocol.Snapshot) *FollowerState_Final_Call {
	_c.Call.Return(snapshot)
	return _c
}

func (_c *FollowerState_Final_Call) RunAndReturn(run func() protocol.Snapshot) *FollowerState_Final_Call {
	_c.Call.Return(run)
	return _c
}

// Finalize provides a mock function for the type FollowerState
func (_mock *FollowerState) Finalize(ctx context.Context, blockID flow.Identifier) error {
	ret := _mock.Called(ctx, blockID)

	if len(ret) == 0 {
		panic("no return value specified for Finalize")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, flow.Identifier) error); ok {
		r0 = returnFunc(ctx, blockID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// FollowerState_Finalize_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Finalize'
type FollowerState_Finalize_Call struct {
	*mock.Call
}

// Finalize is a helper method to define mock.On call
//   - ctx context.Context
//   - blockID flow.Identifier
func (_e *FollowerState_Expecter) Finalize(ctx interface{}, blockID interface{}) *FollowerState_Finalize_Call {
	return &FollowerState_Finalize_Call{Call: _e.mock.On("Finalize", ctx, blockID)}
}

func (_c *FollowerState_Finalize_Call) Run(run func(ctx context.Context, blockID flow.Identifier)) *FollowerState_Finalize_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 flow.Identifier
		if args[1] != nil {
			arg1 = args[1].(flow.Identifier)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *FollowerState_Finalize_Call) Return(err error) *FollowerState_Finalize_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *FollowerState_Finalize_Call) RunAndReturn(run func(ctx context.Context, blockID flow.Identifier) error) *FollowerState_Finalize_Call {
	_c.Call.Return(run)
	return _c
}

// Params provides a mock function for the type FollowerState
func (_mock *FollowerState) Params() protocol.Params {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Params")
	}

	var r0 protocol.Params
	if returnFunc, ok := ret.Get(0).(func() protocol.Params); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(protocol.Params)
		}
	}
	return r0
}

// FollowerState_Params_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Params'
type FollowerState_Params_Call struct {
	*mock.Call
}

// Params is a helper method to define mock.On call
func (_e *FollowerState_Expecter) Params() *FollowerState_Params_Call {
	return &FollowerState_Params_Call{Call: _e.mock.On("Params")}
}

func (_c *FollowerState_Params_Call) Run(run func()) *FollowerState_Params_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *FollowerState_Params_Call) Return(params protocol.Params) *FollowerState_Params_Call {
	_c.Call.Return(params)
	return _c
}

func (_c *FollowerState_Params_Call) RunAndReturn(run func() protocol.Params) *FollowerState_Params_Call {
	_c.Call.Return(run)
	return _c
}

// Sealed provides a mock function for the type FollowerState
func (_mock *FollowerState) Sealed() protocol.Snapshot {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Sealed")
	}

	var r0 protocol.Snapshot
	if returnFunc, ok := ret.Get(0).(func() protocol.Snapshot); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(protocol.Snapshot)
		}
	}
	return r0
}

// FollowerState_Sealed_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Sealed'
type FollowerState_Sealed_Call struct {
	*mock.Call
}

// Sealed is a helper method to define mock.On call
func (_e *FollowerState_Expecter) Sealed() *FollowerState_Sealed_Call {
	return &FollowerState_Sealed_Call{Call: _e.mock.On("Sealed")}
}

func (_c *FollowerState_Sealed_Call) Run(run func()) *FollowerState_Sealed_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *FollowerState_Sealed_Call) Return(snapshot protocol.Snapshot) *FollowerState_Sealed_Call {
	_c.Call.Return(snapshot)
	return _c
}

func (_c *FollowerState_Sealed_Call) RunAndReturn(run func() protocol.Snapshot) *FollowerState_Sealed_Call {
	_c.Call.Return(run)
	return _c
}

// NewParticipantState creates a new instance of ParticipantState. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewParticipantState(t interface {
	mock.TestingT
	Cleanup(func())
}) *ParticipantState {
	mock := &ParticipantState{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// ParticipantState is an autogenerated mock type for the ParticipantState type
type ParticipantState struct {
	mock.Mock
}

type ParticipantState_Expecter struct {
	mock *mock.Mock
}

func (_m *ParticipantState) EXPECT() *ParticipantState_Expecter {
	return &ParticipantState_Expecter{mock: &_m.Mock}
}

// AtBlockID provides a mock function for the type ParticipantState
func (_mock *ParticipantState) AtBlockID(blockID flow.Identifier) protocol.Snapshot {
	ret := _mock.Called(blockID)

	if len(ret) == 0 {
		panic("no return value specified for AtBlockID")
	}

	var r0 protocol.Snapshot
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) protocol.Snapshot); ok {
		r0 = returnFunc(blockID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(protocol.Snapshot)
		}
	}
	return r0
}

// ParticipantState_AtBlockID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AtBlockID'
type ParticipantState_AtBlockID_Call struct {
	*mock.Call
}

// AtBlockID is a helper method to define mock.On call
//   - blockID flow.Identifier
func (_e *ParticipantState_Expecter) AtBlockID(blockID interface{}) *ParticipantState_AtBlockID_Call {
	return &ParticipantState_AtBlockID_Call{Call: _e.mock.On("AtBlockID", blockID)}
}

func (_c *ParticipantState_AtBlockID_Call) Run(run func(blockID flow.Identifier)) *ParticipantState_AtBlockID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ParticipantState_AtBlockID_Call) Return(snapshot protocol.Snapshot) *ParticipantState_AtBlockID_Call {
	_c.Call.Return(snapshot)
	return _c
}

func (_c *ParticipantState_AtBlockID_Call) RunAndReturn(run func(blockID flow.Identifier) protocol.Snapshot) *ParticipantState_AtBlockID_Call {
	_c.Call.Return(run)
	return _c
}

// AtHeight provides a mock function for the type ParticipantState
func (_mock *ParticipantState) AtHeight(height uint64) protocol.Snapshot {
	ret := _mock.Called(height)

	if len(ret) == 0 {
		panic("no return value specified for AtHeight")
	}

	var r0 protocol.Snapshot
	if returnFunc, ok := ret.Get(0).(func(uint64) protocol.Snapshot); ok {
		r0 = returnFunc(height)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(protocol.Snapshot)
		}
	}
	return r0
}

// ParticipantState_AtHeight_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AtHeight'
type ParticipantState_AtHeight_Call struct {
	*mock.Call
}

// AtHeight is a helper method to define mock.On call
//   - height uint64
func (_e *ParticipantState_Expecter) AtHeight(height interface{}) *ParticipantState_AtHeight_Call {
	return &ParticipantState_AtHeight_Call{Call: _e.mock.On("AtHeight", height)}
}

func (_c *ParticipantState_AtHeight_Call) Run(run func(height uint64)) *ParticipantState_AtHeight_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ParticipantState_AtHeight_Call) Return(snapshot protocol.Snapshot) *ParticipantState_AtHeight_Call {
	_c.Call.Return(snapshot)
	return _c
}

func (_c *ParticipantState_AtHeight_Call) RunAndReturn(run func(height uint64) protocol.Snapshot) *ParticipantState_AtHeight_Call {
	_c.Call.Return(run)
	return _c
}

// Extend provides a mock function for the type ParticipantState
func (_mock *ParticipantState) Extend(ctx context.Context, candidate *flow.Proposal) error {
	ret := _mock.Called(ctx, candidate)

	if len(ret) == 0 {
		panic("no return value specified for Extend")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *flow.Proposal) error); ok {
		r0 = returnFunc(ctx, candidate)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ParticipantState_Extend_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Extend'
type ParticipantState_Extend_Call struct {
	*mock.Call
}

// Extend is a helper method to define mock.On call
//   - ctx context.Context
//   - candidate *flow.Proposal
func (_e *ParticipantState_Expecter) Extend(ctx interface{}, candidate interface{}) *ParticipantState_Extend_Call {
	return &ParticipantState_Extend_Call{Call: _e.mock.On("Extend", ctx, candidate)}
}

func (_c *ParticipantState_Extend_Call) Run(run func(ctx context.Context, candidate *flow.Proposal)) *ParticipantState_Extend_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *flow.Proposal
		if args[1] != nil {
			arg1 = args[1].(*flow.Proposal)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ParticipantState_Extend_Call) Return(err error) *ParticipantState_Extend_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ParticipantState_Extend_Call) RunAndReturn(run func(ctx context.Context, candidate *flow.Proposal) error) *ParticipantState_Extend_Call {
	_c.Call.Return(run)
	return _c
}

// ExtendCertified provides a mock function for the type ParticipantState
func (_mock *ParticipantState) ExtendCertified(ctx context.Context, certified *flow.CertifiedBlock) error {
	ret := _mock.Called(ctx, certified)

	if len(ret) == 0 {
		panic("no return value specified for ExtendCertified")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *flow.CertifiedBlock) error); ok {
		r0 = returnFunc(ctx, certified)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ParticipantState_ExtendCertified_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExtendCertified'
type ParticipantState_ExtendCertified_Call struct {
	*mock.Call
}

// ExtendCertified is a helper method to define mock.On call
//   - ctx context.Context
//   - certified *flow.CertifiedBlock
func (_e *ParticipantState_Expecter) ExtendCertified(ctx interface{}, certified interface{}) *ParticipantState_ExtendCertified_Call {
	return &ParticipantState_ExtendCertified_Call{Call: _e.mock.On("ExtendCertified", ctx, certified)}
}

func (_c *ParticipantState_ExtendCertified_Call) Run(run func(ctx context.Context, certified *flow.CertifiedBlock)) *ParticipantState_ExtendCertified_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *flow.CertifiedBlock
		if args[1] != nil {
			arg1 = args[1].(*flow.CertifiedBlock)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ParticipantState_ExtendCertified_Call) Return(err error) *ParticipantState_ExtendCertified_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ParticipantState_ExtendCertified_Call) RunAndReturn(run func(ctx context.Context, certified *flow.CertifiedBlock) error) *ParticipantState_ExtendCertified_Call {
	_c.Call.Return(run)
	return _c
}

// Final provides a mock function for the type ParticipantState
func (_mock *ParticipantState) Final() protocol.Snapshot {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Final")
	}

	var r0 protocol.Snapshot
	if returnFunc, ok := ret.Get(0).(func() protocol.Snapshot); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(protocol.Snapshot)
		}
	}
	return r0
}

// ParticipantState_Final_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Final'
type ParticipantState_Final_Call struct {
	*mock.Call
}

// Final is a helper method to define mock.On call
func (_e *ParticipantState_Expecter) Final() *ParticipantState_Final_Call {
	return &ParticipantState_Final_Call{Call: _e.mock.On("Final")}
}

func (_c *ParticipantState_Final_Call) Run(run func()) *ParticipantState_Final_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ParticipantState_Final_Call) Return(snapshot protocol.Snapshot) *ParticipantState_Final_Call {
	_c.Call.Return(snapshot)
	return _c
}

func (_c *ParticipantState_Final_Call) RunAndReturn(run func() protocol.Snapshot) *ParticipantState_Final_Call {
	_c.Call.Return(run)
	return _c
}

// Finalize provides a mock function for the type ParticipantState
func (_mock *ParticipantState) Finalize(ctx context.Context, blockID flow.Identifier) error {
	ret := _mock.Called(ctx, blockID)

	if len(ret) == 0 {
		panic("no return value specified for Finalize")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, flow.Identifier) error); ok {
		r0 = returnFunc(ctx, blockID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ParticipantState_Finalize_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Finalize'
type ParticipantState_Finalize_Call struct {
	*mock.Call
}

// Finalize is a helper method to define mock.On call
//   - ctx context.Context
//   - blockID flow.Identifier
func (_e *ParticipantState_Expecter) Finalize(ctx interface{}, blockID interface{}) *ParticipantState_Finalize_Call {
	return &ParticipantState_Finalize_Call{Call: _e.mock.On("Finalize", ctx, blockID)}
}

func (_c *ParticipantState_Finalize_Call) Run(run func(ctx context.Context, blockID flow.Identifier)) *ParticipantState_Finalize_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 flow.Identifier
		if args[1] != nil {
			arg1 = args[1].(flow.Identifier)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ParticipantState_Finalize_Call) Return(err error) *ParticipantState_Finalize_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ParticipantState_Finalize_Call) RunAndReturn(run func(ctx context.Context, blockID flow.Identifier) error) *ParticipantState_Finalize_Call {
	_c.Call.Return(run)
	return _c
}

// Params provides a mock function for the type ParticipantState
func (_mock *ParticipantState) Params() protocol.Params {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Params")
	}

	var r0 protocol.Params
	if returnFunc, ok := ret.Get(0).(func() protocol.Params); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(protocol.Params)
		}
	}
	return r0
}

// ParticipantState_Params_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Params'
type ParticipantState_Params_Call struct {
	*mock.Call
}

// Params is a helper method to define mock.On call
func (_e *ParticipantState_Expecter) Params() *ParticipantState_Params_Call {
	return &ParticipantState_Params_Call{Call: _e.mock.On("Params")}
}

func (_c *ParticipantState_Params_Call) Run(run func()) *ParticipantState_Params_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ParticipantState_Params_Call) Return(params protocol.Params) *ParticipantState_Params_Call {
	_c.Call.Return(params)
	return _c
}

func (_c *ParticipantState_Params_Call) RunAndReturn(run func() protocol.Params) *ParticipantState_Params_Call {
	_c.Call.Return(run)
	return _c
}

// Sealed provides a mock function for the type ParticipantState
func (_mock *ParticipantState) Sealed() protocol.Snapshot {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Sealed")
	}

	var r0 protocol.Snapshot
	if returnFunc, ok := ret.Get(0).(func() protocol.Snapshot); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(protocol.Snapshot)
		}
	}
	return r0
}

// ParticipantState_Sealed_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Sealed'
type ParticipantState_Sealed_Call struct {
	*mock.Call
}

// Sealed is a helper method to define mock.On call
func (_e *ParticipantState_Expecter) Sealed() *ParticipantState_Sealed_Call {
	return &ParticipantState_Sealed_Call{Call: _e.mock.On("Sealed")}
}

func (_c *ParticipantState_Sealed_Call) Run(run func()) *ParticipantState_Sealed_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ParticipantState_Sealed_Call) Return(snapshot protocol.Snapshot) *ParticipantState_Sealed_Call {
	_c.Call.Return(snapshot)
	return _c
}

func (_c *ParticipantState_Sealed_Call) RunAndReturn(run func() protocol.Snapshot) *ParticipantState_Sealed_Call {
	_c.Call.Return(run)
	return _c
}

// NewCluster creates a new instance of Cluster. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewCluster(t interface {
	mock.TestingT
	Cleanup(func())
}) *Cluster {
	mock := &Cluster{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Cluster is an autogenerated mock type for the Cluster type
type Cluster struct {
	mock.Mock
}

type Cluster_Expecter struct {
	mock *mock.Mock
}

func (_m *Cluster) EXPECT() *Cluster_Expecter {
	return &Cluster_Expecter{mock: &_m.Mock}
}

// ChainID provides a mock function for the type Cluster
func (_mock *Cluster) ChainID() flow.ChainID {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for ChainID")
	}

	var r0 flow.ChainID
	if returnFunc, ok := ret.Get(0).(func() flow.ChainID); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(flow.ChainID)
	}
	return r0
}

// Cluster_ChainID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChainID'
type Cluster_ChainID_Call struct {
	*mock.Call
}

// ChainID is a helper method to define mock.On call
func (_e *Cluster_Expecter) ChainID() *Cluster_ChainID_Call {
	return &Cluster_ChainID_Call{Call: _e.mock.On("ChainID")}
}

func (_c *Cluster_ChainID_Call) Run(run func()) *Cluster_ChainID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Cluster_ChainID_Call) Return(chainID flow.ChainID) *Cluster_ChainID_Call {
	_c.Call.Return(chainID)
	return _c
}

func (_c *Cluster_ChainID_Call) RunAndReturn(run func() flow.ChainID) *Cluster_ChainID_Call {
	_c.Call.Return(run)
	return _c
}

// EpochCounter provides a mock function for the type Cluster
func (_mock *Cluster) EpochCounter() uint64 {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for EpochCounter")
	}

	var r0 uint64
	if returnFunc, ok := ret.Get(0).(func() uint64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint64)
	}
	return r0
}

// Cluster_EpochCounter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EpochCounter'
type Cluster_EpochCounter_Call struct {
	*mock.Call
}

// EpochCounter is a helper method to define mock.On call
func (_e *Cluster_Expecter) EpochCounter() *Cluster_EpochCounter_Call {
	return &Cluster_EpochCounter_Call{Call: _e.mock.On("EpochCounter")}
}

func (_c *Cluster_EpochCounter_Call) Run(run func()) *Cluster_EpochCounter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Cluster_EpochCounter_Call) Return(v uint64) *Cluster_EpochCounter_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *Cluster_EpochCounter_Call) RunAndReturn(run func() uint64) *Cluster_EpochCounter_Call {
	_c.Call.Return(run)
	return _c
}

// Index provides a mock function for the type Cluster
func (_mock *Cluster) Index() uint {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Index")
	}

	var r0 uint
	if returnFunc, ok := ret.Get(0).(func() uint); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint)
	}
	return r0
}

// Cluster_Index_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Index'
type Cluster_Index_Call struct {
	*mock.Call
}

// Index is a helper method to define mock.On call
func (_e *Cluster_Expecter) Index() *Cluster_Index_Call {
	return &Cluster_Index_Call{Call: _e.mock.On("Index")}
}

func (_c *Cluster_Index_Call) Run(run func()) *Cluster_Index_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Cluster_Index_Call) Return(v uint) *Cluster_Index_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *Cluster_Index_Call) RunAndReturn(run func() uint) *Cluster_Index_Call {
	_c.Call.Return(run)
	return _c
}

// Members provides a mock function for the type Cluster
func (_mock *Cluster) Members() flow.IdentitySkeletonList {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Members")
	}

	var r0 flow.IdentitySkeletonList
	if returnFunc, ok := ret.Get(0).(func() flow.IdentitySkeletonList); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.IdentitySkeletonList)
		}
	}
	return r0
}

// Cluster_Members_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Members'
type Cluster_Members_Call struct {
	*mock.Call
}

// Members is a helper method to define mock.On call
func (_e *Cluster_Expecter) Members() *Cluster_Members_Call {
	return &Cluster_Members_Call{Call: _e.mock.On("Members")}
}

func (_c *Cluster_Members_Call) Run(run func()) *Cluster_Members_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Cluster_Members_Call) Return(v flow.IdentitySkeletonList) *Cluster_Members_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *Cluster_Members_Call) RunAndReturn(run func() flow.IdentitySkeletonList) *Cluster_Members_Call {
	_c.Call.Return(run)
	return _c
}

// RootBlock provides a mock function for the type Cluster
func (_mock *Cluster) RootBlock() *cluster.Block {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for RootBlock")
	}

	var r0 *cluster.Block
	if returnFunc, ok := ret.Get(0).(func() *cluster.Block); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cluster.Block)
		}
	}
	return r0
}

// Cluster_RootBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RootBlock'
type Cluster_RootBlock_Call struct {
	*mock.Call
}

// RootBlock is a helper method to define mock.On call
func (_e *Cluster_Expecter) RootBlock() *Cluster_RootBlock_Call {
	return &Cluster_RootBlock_Call{Call: _e.mock.On("RootBlock")}
}

func (_c *Cluster_RootBlock_Call) Run(run func()) *Cluster_RootBlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Cluster_RootBlock_Call) Return(v *cluster.Block) *Cluster_RootBlock_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *Cluster_RootBlock_Call) RunAndReturn(run func() *cluster.Block) *Cluster_RootBlock_Call {
	_c.Call.Return(run)
	return _c
}

// RootQC provides a mock function for the type Cluster
func (_mock *Cluster) RootQC() *flow.QuorumCertificate {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for RootQC")
	}

	var r0 *flow.QuorumCertificate
	if returnFunc, ok := ret.Get(0).(func() *flow.QuorumCertificate); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.QuorumCertificate)
		}
	}
	return r0
}

// Cluster_RootQC_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RootQC'
type Cluster_RootQC_Call struct {
	*mock.Call
}

// RootQC is a helper method to define mock.On call
func (_e *Cluster_Expecter) RootQC() *Cluster_RootQC_Call {
	return &Cluster_RootQC_Call{Call: _e.mock.On("RootQC")}
}

func (_c *Cluster_RootQC_Call) Run(run func()) *Cluster_RootQC_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Cluster_RootQC_Call) Return(quorumCertificate *flow.QuorumCertificate) *Cluster_RootQC_Call {
	_c.Call.Return(quorumCertificate)
	return _c
}

func (_c *Cluster_RootQC_Call) RunAndReturn(run func() *flow.QuorumCertificate) *Cluster_RootQC_Call {
	_c.Call.Return(run)
	return _c
}

// NewDKG creates a new instance of DKG. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewDKG(t interface {
	mock.TestingT
	Cleanup(func())
}) *DKG {
	mock := &DKG{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// DKG is an autogenerated mock type for the DKG type
type DKG struct {
	mock.Mock
}

type DKG_Expecter struct {
	mock *mock.Mock
}

func (_m *DKG) EXPECT() *DKG_Expecter {
	return &DKG_Expecter{mock: &_m.Mock}
}

// GroupKey provides a mock function for the type DKG
func (_mock *DKG) GroupKey() crypto.PublicKey {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GroupKey")
	}

	var r0 crypto.PublicKey
	if returnFunc, ok := ret.Get(0).(func() crypto.PublicKey); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(crypto.PublicKey)
		}
	}
	return r0
}

// DKG_GroupKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GroupKey'
type DKG_GroupKey_Call struct {
	*mock.Call
}

// GroupKey is a helper method to define mock.On call
func (_e *DKG_Expecter) GroupKey() *DKG_GroupKey_Call {
	return &DKG_GroupKey_Call{Call: _e.mock.On("GroupKey")}
}

func (_c *DKG_GroupKey_Call) Run(run func()) *DKG_GroupKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *DKG_GroupKey_Call) Return(publicKey crypto.PublicKey) *DKG_GroupKey_Call {
	_c.Call.Return(publicKey)
	return _c
}

func (_c *DKG_GroupKey_Call) RunAndReturn(run func() crypto.PublicKey) *DKG_GroupKey_Call {
	_c.Call.Return(run)
	return _c
}

// Index provides a mock function for the type DKG
func (_mock *DKG) Index(nodeID flow.Identifier) (uint, error) {
	ret := _mock.Called(nodeID)

	if len(ret) == 0 {
		panic("no return value specified for Index")
	}

	var r0 uint
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (uint, error)); ok {
		return returnFunc(nodeID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) uint); ok {
		r0 = returnFunc(nodeID)
	} else {
		r0 = ret.Get(0).(uint)
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(nodeID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// DKG_Index_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Index'
type DKG_Index_Call struct {
	*mock.Call
}

// Index is a helper method to define mock.On call
//   - nodeID flow.Identifier
func (_e *DKG_Expecter) Index(nodeID interface{}) *DKG_Index_Call {
	return &DKG_Index_Call{Call: _e.mock.On("Index", nodeID)}
}

func (_c *DKG_Index_Call) Run(run func(nodeID flow.Identifier)) *DKG_Index_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *DKG_Index_Call) Return(v uint, err error) *DKG_Index_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *DKG_Index_Call) RunAndReturn(run func(nodeID flow.Identifier) (uint, error)) *DKG_Index_Call {
	_c.Call.Return(run)
	return _c
}

// KeyShare provides a mock function for the type DKG
func (_mock *DKG) KeyShare(nodeID flow.Identifier) (crypto.PublicKey, error) {
	ret := _mock.Called(nodeID)

	if len(ret) == 0 {
		panic("no return value specified for KeyShare")
	}

	var r0 crypto.PublicKey
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (crypto.PublicKey, error)); ok {
		return returnFunc(nodeID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) crypto.PublicKey); ok {
		r0 = returnFunc(nodeID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(crypto.PublicKey)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(nodeID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// DKG_KeyShare_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'KeyShare'
type DKG_KeyShare_Call struct {
	*mock.Call
}

// KeyShare is a helper method to define mock.On call
//   - nodeID flow.Identifier
func (_e *DKG_Expecter) KeyShare(nodeID interface{}) *DKG_KeyShare_Call {
	return &DKG_KeyShare_Call{Call: _e.mock.On("KeyShare", nodeID)}
}

func (_c *DKG_KeyShare_Call) Run(run func(nodeID flow.Identifier)) *DKG_KeyShare_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *DKG_KeyShare_Call) Return(publicKey crypto.PublicKey, err error) *DKG_KeyShare_Call {
	_c.Call.Return(publicKey, err)
	return _c
}

func (_c *DKG_KeyShare_Call) RunAndReturn(run func(nodeID flow.Identifier) (crypto.PublicKey, error)) *DKG_KeyShare_Call {
	_c.Call.Return(run)
	return _c
}

// KeyShares provides a mock function for the type DKG
func (_mock *DKG) KeyShares() []crypto.PublicKey {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for KeyShares")
	}

	var r0 []crypto.PublicKey
	if returnFunc, ok := ret.Get(0).(func() []crypto.PublicKey); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]crypto.PublicKey)
		}
	}
	return r0
}

// DKG_KeyShares_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'KeyShares'
type DKG_KeyShares_Call struct {
	*mock.Call
}

// KeyShares is a helper method to define mock.On call
func (_e *DKG_Expecter) KeyShares() *DKG_KeyShares_Call {
	return &DKG_KeyShares_Call{Call: _e.mock.On("KeyShares")}
}

func (_c *DKG_KeyShares_Call) Run(run func()) *DKG_KeyShares_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *DKG_KeyShares_Call) Return(publicKeys []crypto.PublicKey) *DKG_KeyShares_Call {
	_c.Call.Return(publicKeys)
	return _c
}

func (_c *DKG_KeyShares_Call) RunAndReturn(run func() []crypto.PublicKey) *DKG_KeyShares_Call {
	_c.Call.Return(run)
	return _c
}

// NodeID provides a mock function for the type DKG
func (_mock *DKG) NodeID(index uint) (flow.Identifier, error) {
	ret := _mock.Called(index)

	if len(ret) == 0 {
		panic("no return value specified for NodeID")
	}

	var r0 flow.Identifier
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(uint) (flow.Identifier, error)); ok {
		return returnFunc(index)
	}
	if returnFunc, ok := ret.Get(0).(func(uint) flow.Identifier); ok {
		r0 = returnFunc(index)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.Identifier)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(uint) error); ok {
		r1 = returnFunc(index)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// DKG_NodeID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NodeID'
type DKG_NodeID_Call struct {
	*mock.Call
}

// NodeID is a helper method to define mock.On call
//   - index uint
func (_e *DKG_Expecter) NodeID(index interface{}) *DKG_NodeID_Call {
	return &DKG_NodeID_Call{Call: _e.mock.On("NodeID", index)}
}

func (_c *DKG_NodeID_Call) Run(run func(index uint)) *DKG_NodeID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint
		if args[0] != nil {
			arg0 = args[0].(uint)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *DKG_NodeID_Call) Return(identifier flow.Identifier, err error) *DKG_NodeID_Call {
	_c.Call.Return(identifier, err)
	return _c
}

func (_c *DKG_NodeID_Call) RunAndReturn(run func(index uint) (flow.Identifier, error)) *DKG_NodeID_Call {
	_c.Call.Return(run)
	return _c
}

// Size provides a mock function for the type DKG
func (_mock *DKG) Size() uint {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Size")
	}

	var r0 uint
	if returnFunc, ok := ret.Get(0).(func() uint); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint)
	}
	return r0
}

// DKG_Size_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Size'
type DKG_Size_Call struct {
	*mock.Call
}

// Size is a helper method to define mock.On call
func (_e *DKG_Expecter) Size() *DKG_Size_Call {
	return &DKG_Size_Call{Call: _e.mock.On("Size")}
}

func (_c *DKG_Size_Call) Run(run func()) *DKG_Size_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *DKG_Size_Call) Return(v uint) *DKG_Size_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *DKG_Size_Call) RunAndReturn(run func() uint) *DKG_Size_Call {
	_c.Call.Return(run)
	return _c
}

// NewEpochQuery creates a new instance of EpochQuery. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewEpochQuery(t interface {
	mock.TestingT
	Cleanup(func())
}) *EpochQuery {
	mock := &EpochQuery{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// EpochQuery is an autogenerated mock type for the EpochQuery type
type EpochQuery struct {
	mock.Mock
}

type EpochQuery_Expecter struct {
	mock *mock.Mock
}

func (_m *EpochQuery) EXPECT() *EpochQuery_Expecter {
	return &EpochQuery_Expecter{mock: &_m.Mock}
}

// Current provides a mock function for the type EpochQuery
func (_mock *EpochQuery) Current() (protocol.CommittedEpoch, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Current")
	}

	var r0 protocol.CommittedEpoch
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (protocol.CommittedEpoch, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() protocol.CommittedEpoch); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(protocol.CommittedEpoch)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// EpochQuery_Current_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Current'
type EpochQuery_Current_Call struct {
	*mock.Call
}

// Current is a helper method to define mock.On call
func (_e *EpochQuery_Expecter) Current() *EpochQuery_Current_Call {
	return &EpochQuery_Current_Call{Call: _e.mock.On("Current")}
}

func (_c *EpochQuery_Current_Call) Run(run func()) *EpochQuery_Current_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *EpochQuery_Current_Call) Return(committedEpoch protocol.CommittedEpoch, err error) *EpochQuery_Current_Call {
	_c.Call.Return(committedEpoch, err)
	return _c
}

func (_c *EpochQuery_Current_Call) RunAndReturn(run func() (protocol.CommittedEpoch, error)) *EpochQuery_Current_Call {
	_c.Call.Return(run)
	return _c
}

// NextCommitted provides a mock function for the type EpochQuery
func (_mock *EpochQuery) NextCommitted() (protocol.CommittedEpoch, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for NextCommitted")
	}

	var r0 protocol.CommittedEpoch
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (protocol.CommittedEpoch, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() protocol.CommittedEpoch); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(protocol.CommittedEpoch)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// EpochQuery_NextCommitted_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NextCommitted'
type EpochQuery_NextCommitted_Call struct {
	*mock.Call
}

// NextCommitted is a helper method to define mock.On call
func (_e *EpochQuery_Expecter) NextCommitted() *EpochQuery_NextCommitted_Call {
	return &EpochQuery_NextCommitted_Call{Call: _e.mock.On("NextCommitted")}
}

func (_c *EpochQuery_NextCommitted_Call) Run(run func()) *EpochQuery_NextCommitted_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *EpochQuery_NextCommitted_Call) Return(committedEpoch protocol.CommittedEpoch, err error) *EpochQuery_NextCommitted_Call {
	_c.Call.Return(committedEpoch, err)
	return _c
}

func (_c *EpochQuery_NextCommitted_Call) RunAndReturn(run func() (protocol.CommittedEpoch, error)) *EpochQuery_NextCommitted_Call {
	_c.Call.Return(run)
	return _c
}

// NextUnsafe provides a mock function for the type EpochQuery
func (_mock *EpochQuery) NextUnsafe() (protocol.TentativeEpoch, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for NextUnsafe")
	}

	var r0 protocol.TentativeEpoch
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (protocol.TentativeEpoch, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() protocol.TentativeEpoch); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(protocol.TentativeEpoch)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// EpochQuery_NextUnsafe_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NextUnsafe'
type EpochQuery_NextUnsafe_Call struct {
	*mock.Call
}

// NextUnsafe is a helper method to define mock.On call
func (_e *EpochQuery_Expecter) NextUnsafe() *EpochQuery_NextUnsafe_Call {
	return &EpochQuery_NextUnsafe_Call{Call: _e.mock.On("NextUnsafe")}
}

func (_c *EpochQuery_NextUnsafe_Call) Run(run func()) *EpochQuery_NextUnsafe_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *EpochQuery_NextUnsafe_Call) Return(tentativeEpoch protocol.TentativeEpoch, err error) *EpochQuery_NextUnsafe_Call {
	_c.Call.Return(tentativeEpoch, err)
	return _c
}

func (_c *EpochQuery_NextUnsafe_Call) RunAndReturn(run func() (protocol.TentativeEpoch, error)) *EpochQuery_NextUnsafe_Call {
	_c.Call.Return(run)
	return _c
}

// Previous provides a mock function for the type EpochQuery
func (_mock *EpochQuery) Previous() (protocol.CommittedEpoch, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Previous")
	}

	var r0 protocol.CommittedEpoch
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (protocol.CommittedEpoch, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() protocol.CommittedEpoch); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(protocol.CommittedEpoch)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// EpochQuery_Previous_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Previous'
type EpochQuery_Previous_Call struct {
	*mock.Call
}

// Previous is a helper method to define mock.On call
func (_e *EpochQuery_Expecter) Previous() *EpochQuery_Previous_Call {
	return &EpochQuery_Previous_Call{Call: _e.mock.On("Previous")}
}

func (_c *EpochQuery_Previous_Call) Run(run func()) *EpochQuery_Previous_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *EpochQuery_Previous_Call) Return(committedEpoch protocol.CommittedEpoch, err error) *EpochQuery_Previous_Call {
	_c.Call.Return(committedEpoch, err)
	return _c
}

func (_c *EpochQuery_Previous_Call) RunAndReturn(run func() (protocol.CommittedEpoch, error)) *EpochQuery_Previous_Call {
	_c.Call.Return(run)
	return _c
}

// NewCommittedEpoch creates a new instance of CommittedEpoch. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewCommittedEpoch(t interface {
	mock.TestingT
	Cleanup(func())
}) *CommittedEpoch {
	mock := &CommittedEpoch{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// CommittedEpoch is an autogenerated mock type for the CommittedEpoch type
type CommittedEpoch struct {
	mock.Mock
}

type CommittedEpoch_Expecter struct {
	mock *mock.Mock
}

func (_m *CommittedEpoch) EXPECT() *CommittedEpoch_Expecter {
	return &CommittedEpoch_Expecter{mock: &_m.Mock}
}

// Cluster provides a mock function for the type CommittedEpoch
func (_mock *CommittedEpoch) Cluster(index uint) (protocol.Cluster, error) {
	ret := _mock.Called(index)

	if len(ret) == 0 {
		panic("no return value specified for Cluster")
	}

	var r0 protocol.Cluster
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(uint) (protocol.Cluster, error)); ok {
		return returnFunc(index)
	}
	if returnFunc, ok := ret.Get(0).(func(uint) protocol.Cluster); ok {
		r0 = returnFunc(index)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(protocol.Cluster)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(uint) error); ok {
		r1 = returnFunc(index)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// CommittedEpoch_Cluster_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Cluster'
type CommittedEpoch_Cluster_Call struct {
	*mock.Call
}

// Cluster is a helper method to define mock.On call
//   - index uint
func (_e *CommittedEpoch_Expecter) Cluster(index interface{}) *CommittedEpoch_Cluster_Call {
	return &CommittedEpoch_Cluster_Call{Call: _e.mock.On("Cluster", index)}
}

func (_c *CommittedEpoch_Cluster_Call) Run(run func(index uint)) *CommittedEpoch_Cluster_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint
		if args[0] != nil {
			arg0 = args[0].(uint)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *CommittedEpoch_Cluster_Call) Return(cluster1 protocol.Cluster, err error) *CommittedEpoch_Cluster_Call {
	_c.Call.Return(cluster1, err)
	return _c
}

func (_c *CommittedEpoch_Cluster_Call) RunAndReturn(run func(index uint) (protocol.Cluster, error)) *CommittedEpoch_Cluster_Call {
	_c.Call.Return(run)
	return _c
}

// ClusterByChainID provides a mock function for the type CommittedEpoch
func (_mock *CommittedEpoch) ClusterByChainID(chainID flow.ChainID) (protocol.Cluster, error) {
	ret := _mock.Called(chainID)

	if len(ret) == 0 {
		panic("no return value specified for ClusterByChainID")
	}

	var r0 protocol.Cluster
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.ChainID) (protocol.Cluster, error)); ok {
		return returnFunc(chainID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.ChainID) protocol.Cluster); ok {
		r0 = returnFunc(chainID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(protocol.Cluster)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.ChainID) error); ok {
		r1 = returnFunc(chainID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// CommittedEpoch_ClusterByChainID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClusterByChainID'
type CommittedEpoch_ClusterByChainID_Call struct {
	*mock.Call
}

// ClusterByChainID is a helper method to define mock.On call
//   - chainID flow.ChainID
func (_e *CommittedEpoch_Expecter) ClusterByChainID(chainID interface{}) *CommittedEpoch_ClusterByChainID_Call {
	return &CommittedEpoch_ClusterByChainID_Call{Call: _e.mock.On("ClusterByChainID", chainID)}
}

func (_c *CommittedEpoch_ClusterByChainID_Call) Run(run func(chainID flow.ChainID)) *CommittedEpoch_ClusterByChainID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.ChainID
		if args[0] != nil {
			arg0 = args[0].(flow.ChainID)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *CommittedEpoch_ClusterByChainID_Call) Return(cluster1 protocol.Cluster, err error) *CommittedEpoch_ClusterByChainID_Call {
	_c.Call.Return(cluster1, err)
	return _c
}

func (_c *CommittedEpoch_ClusterByChainID_Call) RunAndReturn(run func(chainID flow.ChainID) (protocol.Cluster, error)) *CommittedEpoch_ClusterByChainID_Call {
	_c.Call.Return(run)
	return _c
}

// Clustering provides a mock function for the type CommittedEpoch
func (_mock *CommittedEpoch) Clustering() (flow.ClusterList, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Clustering")
	}

	var r0 flow.ClusterList
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (flow.ClusterList, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() flow.ClusterList); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.ClusterList)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// CommittedEpoch_Clustering_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Clustering'
type CommittedEpoch_Clustering_Call struct {
	*mock.Call
}

// Clustering is a helper method to define mock.On call
func (_e *CommittedEpoch_Expecter) Clustering() *CommittedEpoch_Clustering_Call {
	return &CommittedEpoch_Clustering_Call{Call: _e.mock.On("Clustering")}
}

func (_c *CommittedEpoch_Clustering_Call) Run(run func()) *CommittedEpoch_Clustering_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *CommittedEpoch_Clustering_Call) Return(clusterList flow.ClusterList, err error) *CommittedEpoch_Clustering_Call {
	_c.Call.Return(clusterList, err)
	return _c
}

func (_c *CommittedEpoch_Clustering_Call) RunAndReturn(run func() (flow.ClusterList, error)) *CommittedEpoch_Clustering_Call {
	_c.Call.Return(run)
	return _c
}

// Counter provides a mock function for the type CommittedEpoch
func (_mock *CommittedEpoch) Counter() uint64 {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Counter")
	}

	var r0 uint64
	if returnFunc, ok := ret.Get(0).(func() uint64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint64)
	}
	return r0
}

// CommittedEpoch_Counter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Counter'
type CommittedEpoch_Counter_Call struct {
	*mock.Call
}

// Counter is a helper method to define mock.On call
func (_e *CommittedEpoch_Expecter) Counter() *CommittedEpoch_Counter_Call {
	return &CommittedEpoch_Counter_Call{Call: _e.mock.On("Counter")}
}

func (_c *CommittedEpoch_Counter_Call) Run(run func()) *CommittedEpoch_Counter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *CommittedEpoch_Counter_Call) Return(v uint64) *CommittedEpoch_Counter_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *CommittedEpoch_Counter_Call) RunAndReturn(run func() uint64) *CommittedEpoch_Counter_Call {
	_c.Call.Return(run)
	return _c
}

// DKG provides a mock function for the type CommittedEpoch
func (_mock *CommittedEpoch) DKG() (protocol.DKG, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for DKG")
	}

	var r0 protocol.DKG
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (protocol.DKG, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() protocol.DKG); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(protocol.DKG)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// CommittedEpoch_DKG_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DKG'
type CommittedEpoch_DKG_Call struct {
	*mock.Call
}

// DKG is a helper method to define mock.On call
func (_e *CommittedEpoch_Expecter) DKG() *CommittedEpoch_DKG_Call {
	return &CommittedEpoch_DKG_Call{Call: _e.mock.On("DKG")}
}

func (_c *CommittedEpoch_DKG_Call) Run(run func()) *CommittedEpoch_DKG_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *CommittedEpoch_DKG_Call) Return(dKG protocol.DKG, err error) *CommittedEpoch_DKG_Call {
	_c.Call.Return(dKG, err)
	return _c
}

func (_c *CommittedEpoch_DKG_Call) RunAndReturn(run func() (protocol.DKG, error)) *CommittedEpoch_DKG_Call {
	_c.Call.Return(run)
	return _c
}

// DKGPhase1FinalView provides a mock function for the type CommittedEpoch
func (_mock *CommittedEpoch) DKGPhase1FinalView() uint64 {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for DKGPhase1FinalView")
	}

	var r0 uint64
	if returnFunc, ok := ret.Get(0).(func() uint64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint64)
	}
	return r0
}

// CommittedEpoch_DKGPhase1FinalView_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DKGPhase1FinalView'
type CommittedEpoch_DKGPhase1FinalView_Call struct {
	*mock.Call
}

// DKGPhase1FinalView is a helper method to define mock.On call
func (_e *CommittedEpoch_Expecter) DKGPhase1FinalView() *CommittedEpoch_DKGPhase1FinalView_Call {
	return &CommittedEpoch_DKGPhase1FinalView_Call{Call: _e.mock.On("DKGPhase1FinalView")}
}

func (_c *CommittedEpoch_DKGPhase1FinalView_Call) Run(run func()) *CommittedEpoch_DKGPhase1FinalView_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *CommittedEpoch_DKGPhase1FinalView_Call) Return(v uint64) *CommittedEpoch_DKGPhase1FinalView_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *CommittedEpoch_DKGPhase1FinalView_Call) RunAndReturn(run func() uint64) *CommittedEpoch_DKGPhase1FinalView_Call {
	_c.Call.Return(run)
	return _c
}

// DKGPhase2FinalView provides a mock function for the type CommittedEpoch
func (_mock *CommittedEpoch) DKGPhase2FinalView() uint64 {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for DKGPhase2FinalView")
	}

	var r0 uint64
	if returnFunc, ok := ret.Get(0).(func() uint64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint64)
	}
	return r0
}

// CommittedEpoch_DKGPhase2FinalView_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DKGPhase2FinalView'
type CommittedEpoch_DKGPhase2FinalView_Call struct {
	*mock.Call
}

// DKGPhase2FinalView is a helper method to define mock.On call
func (_e *CommittedEpoch_Expecter) DKGPhase2FinalView() *CommittedEpoch_DKGPhase2FinalView_Call {
	return &CommittedEpoch_DKGPhase2FinalView_Call{Call: _e.mock.On("DKGPhase2FinalView")}
}

func (_c *CommittedEpoch_DKGPhase2FinalView_Call) Run(run func()) *CommittedEpoch_DKGPhase2FinalView_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *CommittedEpoch_DKGPhase2FinalView_Call) Return(v uint64) *CommittedEpoch_DKGPhase2FinalView_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *CommittedEpoch_DKGPhase2FinalView_Call) RunAndReturn(run func() uint64) *CommittedEpoch_DKGPhase2FinalView_Call {
	_c.Call.Return(run)
	return _c
}

// DKGPhase3FinalView provides a mock function for the type CommittedEpoch
func (_mock *CommittedEpoch) DKGPhase3FinalView() uint64 {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for DKGPhase3FinalView")
	}

	var r0 uint64
	if returnFunc, ok := ret.Get(0).(func() uint64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint64)
	}
	return r0
}

// CommittedEpoch_DKGPhase3FinalView_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DKGPhase3FinalView'
type CommittedEpoch_DKGPhase3FinalView_Call struct {
	*mock.Call
}

// DKGPhase3FinalView is a helper method to define mock.On call
func (_e *CommittedEpoch_Expecter) DKGPhase3FinalView() *CommittedEpoch_DKGPhase3FinalView_Call {
	return &CommittedEpoch_DKGPhase3FinalView_Call{Call: _e.mock.On("DKGPhase3FinalView")}
}

func (_c *CommittedEpoch_DKGPhase3FinalView_Call) Run(run func()) *CommittedEpoch_DKGPhase3FinalView_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *CommittedEpoch_DKGPhase3FinalView_Call) Return(v uint64) *CommittedEpoch_DKGPhase3FinalView_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *CommittedEpoch_DKGPhase3FinalView_Call) RunAndReturn(run func() uint64) *CommittedEpoch_DKGPhase3FinalView_Call {
	_c.Call.Return(run)
	return _c
}

// FinalHeight provides a mock function for the type CommittedEpoch
func (_mock *CommittedEpoch) FinalHeight() (uint64, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for FinalHeight")
	}

	var r0 uint64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (uint64, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() uint64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint64)
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// CommittedEpoch_FinalHeight_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FinalHeight'
type CommittedEpoch_FinalHeight_Call struct {
	*mock.Call
}

// FinalHeight is a helper method to define mock.On call
func (_e *CommittedEpoch_Expecter) FinalHeight() *CommittedEpoch_FinalHeight_Call {
	return &CommittedEpoch_FinalHeight_Call{Call: _e.mock.On("FinalHeight")}
}

func (_c *CommittedEpoch_FinalHeight_Call) Run(run func()) *CommittedEpoch_FinalHeight_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *CommittedEpoch_FinalHeight_Call) Return(v uint64, err error) *CommittedEpoch_FinalHeight_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *CommittedEpoch_FinalHeight_Call) RunAndReturn(run func() (uint64, error)) *CommittedEpoch_FinalHeight_Call {
	_c.Call.Return(run)
	return _c
}

// FinalView provides a mock function for the type CommittedEpoch
func (_mock *CommittedEpoch) FinalView() uint64 {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for FinalView")
	}

	var r0 uint64
	if returnFunc, ok := ret.Get(0).(func() uint64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint64)
	}
	return r0
}

// CommittedEpoch_FinalView_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FinalView'
type CommittedEpoch_FinalView_Call struct {
	*mock.Call
}

// FinalView is a helper method to define mock.On call
func (_e *CommittedEpoch_Expecter) FinalView() *CommittedEpoch_FinalView_Call {
	return &CommittedEpoch_FinalView_Call{Call: _e.mock.On("FinalView")}
}

func (_c *CommittedEpoch_FinalView_Call) Run(run func()) *CommittedEpoch_FinalView_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *CommittedEpoch_FinalView_Call) Return(v uint64) *CommittedEpoch_FinalView_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *CommittedEpoch_FinalView_Call) RunAndReturn(run func() uint64) *CommittedEpoch_FinalView_Call {
	_c.Call.Return(run)
	return _c
}

// FirstHeight provides a mock function for the type CommittedEpoch
func (_mock *CommittedEpoch) FirstHeight() (uint64, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for FirstHeight")
	}

	var r0 uint64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (uint64, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() uint64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint64)
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// CommittedEpoch_FirstHeight_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FirstHeight'
type CommittedEpoch_FirstHeight_Call struct {
	*mock.Call
}

// FirstHeight is a helper method to define mock.On call
func (_e *CommittedEpoch_Expecter) FirstHeight() *CommittedEpoch_FirstHeight_Call {
	return &CommittedEpoch_FirstHeight_Call{Call: _e.mock.On("FirstHeight")}
}

func (_c *CommittedEpoch_FirstHeight_Call) Run(run func()) *CommittedEpoch_FirstHeight_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *CommittedEpoch_FirstHeight_Call) Return(v uint64, err error) *CommittedEpoch_FirstHeight_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *CommittedEpoch_FirstHeight_Call) RunAndReturn(run func() (uint64, error)) *CommittedEpoch_FirstHeight_Call {
	_c.Call.Return(run)
	return _c
}

// FirstView provides a mock function for the type CommittedEpoch
func (_mock *CommittedEpoch) FirstView() uint64 {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for FirstView")
	}

	var r0 uint64
	if returnFunc, ok := ret.Get(0).(func() uint64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint64)
	}
	return r0
}

// CommittedEpoch_FirstView_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FirstView'
type CommittedEpoch_FirstView_Call struct {
	*mock.Call
}

// FirstView is a helper method to define mock.On call
func (_e *CommittedEpoch_Expecter) FirstView() *CommittedEpoch_FirstView_Call {
	return &CommittedEpoch_FirstView_Call{Call: _e.mock.On("FirstView")}
}

func (_c *CommittedEpoch_FirstView_Call) Run(run func()) *CommittedEpoch_FirstView_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *CommittedEpoch_FirstView_Call) Return(v uint64) *CommittedEpoch_FirstView_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *CommittedEpoch_FirstView_Call) RunAndReturn(run func() uint64) *CommittedEpoch_FirstView_Call {
	_c.Call.Return(run)
	return _c
}

// InitialIdentities provides a mock function for the type CommittedEpoch
func (_mock *CommittedEpoch) InitialIdentities() flow.IdentitySkeletonList {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for InitialIdentities")
	}

	var r0 flow.IdentitySkeletonList
	if returnFunc, ok := ret.Get(0).(func() flow.IdentitySkeletonList); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.IdentitySkeletonList)
		}
	}
	return r0
}

// CommittedEpoch_InitialIdentities_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InitialIdentities'
type CommittedEpoch_InitialIdentities_Call struct {
	*mock.Call
}

// InitialIdentities is a helper method to define mock.On call
func (_e *CommittedEpoch_Expecter) InitialIdentities() *CommittedEpoch_InitialIdentities_Call {
	return &CommittedEpoch_InitialIdentities_Call{Call: _e.mock.On("InitialIdentities")}
}

func (_c *CommittedEpoch_InitialIdentities_Call) Run(run func()) *CommittedEpoch_InitialIdentities_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *CommittedEpoch_InitialIdentities_Call) Return(v flow.IdentitySkeletonList) *CommittedEpoch_InitialIdentities_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *CommittedEpoch_InitialIdentities_Call) RunAndReturn(run func() flow.IdentitySkeletonList) *CommittedEpoch_InitialIdentities_Call {
	_c.Call.Return(run)
	return _c
}

// RandomSource provides a mock function for the type CommittedEpoch
func (_mock *CommittedEpoch) RandomSource() []byte {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for RandomSource")
	}

	var r0 []byte
	if returnFunc, ok := ret.Get(0).(func() []byte); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}
	return r0
}

// CommittedEpoch_RandomSource_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RandomSource'
type CommittedEpoch_RandomSource_Call struct {
	*mock.Call
}

// RandomSource is a helper method to define mock.On call
func (_e *CommittedEpoch_Expecter) RandomSource() *CommittedEpoch_RandomSource_Call {
	return &CommittedEpoch_RandomSource_Call{Call: _e.mock.On("RandomSource")}
}

func (_c *CommittedEpoch_RandomSource_Call) Run(run func()) *CommittedEpoch_RandomSource_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *CommittedEpoch_RandomSource_Call) Return(bytes []byte) *CommittedEpoch_RandomSource_Call {
	_c.Call.Return(bytes)
	return _c
}

func (_c *CommittedEpoch_RandomSource_Call) RunAndReturn(run func() []byte) *CommittedEpoch_RandomSource_Call {
	_c.Call.Return(run)
	return _c
}

// TargetDuration provides a mock function for the type CommittedEpoch
func (_mock *CommittedEpoch) TargetDuration() uint64 {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for TargetDuration")
	}

	var r0 uint64
	if returnFunc, ok := ret.Get(0).(func() uint64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint64)
	}
	return r0
}

// CommittedEpoch_TargetDuration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TargetDuration'
type CommittedEpoch_TargetDuration_Call struct {
	*mock.Call
}

// TargetDuration is a helper method to define mock.On call
func (_e *CommittedEpoch_Expecter) TargetDuration() *CommittedEpoch_TargetDuration_Call {
	return &CommittedEpoch_TargetDuration_Call{Call: _e.mock.On("TargetDuration")}
}

func (_c *CommittedEpoch_TargetDuration_Call) Run(run func()) *CommittedEpoch_TargetDuration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *CommittedEpoch_TargetDuration_Call) Return(v uint64) *CommittedEpoch_TargetDuration_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *CommittedEpoch_TargetDuration_Call) RunAndReturn(run func() uint64) *CommittedEpoch_TargetDuration_Call {
	_c.Call.Return(run)
	return _c
}

// TargetEndTime provides a mock function for the type CommittedEpoch
func (_mock *CommittedEpoch) TargetEndTime() uint64 {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for TargetEndTime")
	}

	var r0 uint64
	if returnFunc, ok := ret.Get(0).(func() uint64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint64)
	}
	return r0
}

// CommittedEpoch_TargetEndTime_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TargetEndTime'
type CommittedEpoch_TargetEndTime_Call struct {
	*mock.Call
}

// TargetEndTime is a helper method to define mock.On call
func (_e *CommittedEpoch_Expecter) TargetEndTime() *CommittedEpoch_TargetEndTime_Call {
	return &CommittedEpoch_TargetEndTime_Call{Call: _e.mock.On("TargetEndTime")}
}

func (_c *CommittedEpoch_TargetEndTime_Call) Run(run func()) *CommittedEpoch_TargetEndTime_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *CommittedEpoch_TargetEndTime_Call) Return(v uint64) *CommittedEpoch_TargetEndTime_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *CommittedEpoch_TargetEndTime_Call) RunAndReturn(run func() uint64) *CommittedEpoch_TargetEndTime_Call {
	_c.Call.Return(run)
	return _c
}

// NewTentativeEpoch creates a new instance of TentativeEpoch. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewTentativeEpoch(t interface {
	mock.TestingT
	Cleanup(func())
}) *TentativeEpoch {
	mock := &TentativeEpoch{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// TentativeEpoch is an autogenerated mock type for the TentativeEpoch type
type TentativeEpoch struct {
	mock.Mock
}

type TentativeEpoch_Expecter struct {
	mock *mock.Mock
}

func (_m *TentativeEpoch) EXPECT() *TentativeEpoch_Expecter {
	return &TentativeEpoch_Expecter{mock: &_m.Mock}
}

// Clustering provides a mock function for the type TentativeEpoch
func (_mock *TentativeEpoch) Clustering() (flow.ClusterList, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Clustering")
	}

	var r0 flow.ClusterList
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (flow.ClusterList, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() flow.ClusterList); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.ClusterList)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// TentativeEpoch_Clustering_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Clustering'
type TentativeEpoch_Clustering_Call struct {
	*mock.Call
}

// Clustering is a helper method to define mock.On call
func (_e *TentativeEpoch_Expecter) Clustering() *TentativeEpoch_Clustering_Call {
	return &TentativeEpoch_Clustering_Call{Call: _e.mock.On("Clustering")}
}

func (_c *TentativeEpoch_Clustering_Call) Run(run func()) *TentativeEpoch_Clustering_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *TentativeEpoch_Clustering_Call) Return(clusterList flow.ClusterList, err error) *TentativeEpoch_Clustering_Call {
	_c.Call.Return(clusterList, err)
	return _c
}

func (_c *TentativeEpoch_Clustering_Call) RunAndReturn(run func() (flow.ClusterList, error)) *TentativeEpoch_Clustering_Call {
	_c.Call.Return(run)
	return _c
}

// Counter provides a mock function for the type TentativeEpoch
func (_mock *TentativeEpoch) Counter() uint64 {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Counter")
	}

	var r0 uint64
	if returnFunc, ok := ret.Get(0).(func() uint64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint64)
	}
	return r0
}

// TentativeEpoch_Counter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Counter'
type TentativeEpoch_Counter_Call struct {
	*mock.Call
}

// Counter is a helper method to define mock.On call
func (_e *TentativeEpoch_Expecter) Counter() *TentativeEpoch_Counter_Call {
	return &TentativeEpoch_Counter_Call{Call: _e.mock.On("Counter")}
}

func (_c *TentativeEpoch_Counter_Call) Run(run func()) *TentativeEpoch_Counter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *TentativeEpoch_Counter_Call) Return(v uint64) *TentativeEpoch_Counter_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *TentativeEpoch_Counter_Call) RunAndReturn(run func() uint64) *TentativeEpoch_Counter_Call {
	_c.Call.Return(run)
	return _c
}

// InitialIdentities provides a mock function for the type TentativeEpoch
func (_mock *TentativeEpoch) InitialIdentities() flow.IdentitySkeletonList {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for InitialIdentities")
	}

	var r0 flow.IdentitySkeletonList
	if returnFunc, ok := ret.Get(0).(func() flow.IdentitySkeletonList); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.IdentitySkeletonList)
		}
	}
	return r0
}

// TentativeEpoch_InitialIdentities_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InitialIdentities'
type TentativeEpoch_InitialIdentities_Call struct {
	*mock.Call
}

// InitialIdentities is a helper method to define mock.On call
func (_e *TentativeEpoch_Expecter) InitialIdentities() *TentativeEpoch_InitialIdentities_Call {
	return &TentativeEpoch_InitialIdentities_Call{Call: _e.mock.On("InitialIdentities")}
}

func (_c *TentativeEpoch_InitialIdentities_Call) Run(run func()) *TentativeEpoch_InitialIdentities_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *TentativeEpoch_InitialIdentities_Call) Return(v flow.IdentitySkeletonList) *TentativeEpoch_InitialIdentities_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *TentativeEpoch_InitialIdentities_Call) RunAndReturn(run func() flow.IdentitySkeletonList) *TentativeEpoch_InitialIdentities_Call {
	_c.Call.Return(run)
	return _c
}

// NewConsumer creates a new instance of Consumer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewConsumer(t interface {
	mock.TestingT
	Cleanup(func())
}) *Consumer {
	mock := &Consumer{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Consumer is an autogenerated mock type for the Consumer type
type Consumer struct {
	mock.Mock
}

type Consumer_Expecter struct {
	mock *mock.Mock
}

func (_m *Consumer) EXPECT() *Consumer_Expecter {
	return &Consumer_Expecter{mock: &_m.Mock}
}

// BlockFinalized provides a mock function for the type Consumer
func (_mock *Consumer) BlockFinalized(block *flow.Header) {
	_mock.Called(block)
	return
}

// Consumer_BlockFinalized_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BlockFinalized'
type Consumer_BlockFinalized_Call struct {
	*mock.Call
}

// BlockFinalized is a helper method to define mock.On call
//   - block *flow.Header
func (_e *Consumer_Expecter) BlockFinalized(block interface{}) *Consumer_BlockFinalized_Call {
	return &Consumer_BlockFinalized_Call{Call: _e.mock.On("BlockFinalized", block)}
}

func (_c *Consumer_BlockFinalized_Call) Run(run func(block *flow.Header)) *Consumer_BlockFinalized_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *flow.Header
		if args[0] != nil {
			arg0 = args[0].(*flow.Header)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Consumer_BlockFinalized_Call) Return() *Consumer_BlockFinalized_Call {
	_c.Call.Return()
	return _c
}

func (_c *Consumer_BlockFinalized_Call) RunAndReturn(run func(block *flow.Header)) *Consumer_BlockFinalized_Call {
	_c.Run(run)
	return _c
}

// BlockProcessable provides a mock function for the type Consumer
func (_mock *Consumer) BlockProcessable(block *flow.Header, certifyingQC *flow.QuorumCertificate) {
	_mock.Called(block, certifyingQC)
	return
}

// Consumer_BlockProcessable_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BlockProcessable'
type Consumer_BlockProcessable_Call struct {
	*mock.Call
}

// BlockProcessable is a helper method to define mock.On call
//   - block *flow.Header
//   - certifyingQC *flow.QuorumCertificate
func (_e *Consumer_Expecter) BlockProcessable(block interface{}, certifyingQC interface{}) *Consumer_BlockProcessable_Call {
	return &Consumer_BlockProcessable_Call{Call: _e.mock.On("BlockProcessable", block, certifyingQC)}
}

func (_c *Consumer_BlockProcessable_Call) Run(run func(block *flow.Header, certifyingQC *flow.QuorumCertificate)) *Consumer_BlockProcessable_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *flow.Header
		if args[0] != nil {
			arg0 = args[0].(*flow.Header)
		}
		var arg1 *flow.QuorumCertificate
		if args[1] != nil {
			arg1 = args[1].(*flow.QuorumCertificate)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Consumer_BlockProcessable_Call) Return() *Consumer_BlockProcessable_Call {
	_c.Call.Return()
	return _c
}

func (_c *Consumer_BlockProcessable_Call) RunAndReturn(run func(block *flow.Header, certifyingQC *flow.QuorumCertificate)) *Consumer_BlockProcessable_Call {
	_c.Run(run)
	return _c
}

// EpochCommittedPhaseStarted provides a mock function for the type Consumer
func (_mock *Consumer) EpochCommittedPhaseStarted(currentEpochCounter uint64, first *flow.Header) {
	_mock.Called(currentEpochCounter, first)
	return
}

// Consumer_EpochCommittedPhaseStarted_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EpochCommittedPhaseStarted'
type Consumer_EpochCommittedPhaseStarted_Call struct {
	*mock.Call
}

// EpochCommittedPhaseStarted is a helper method to define mock.On call
//   - currentEpochCounter uint64
//   - first *flow.Header
func (_e *Consumer_Expecter) EpochCommittedPhaseStarted(currentEpochCounter interface{}, first interface{}) *Consumer_EpochCommittedPhaseStarted_Call {
	return &Consumer_EpochCommittedPhaseStarted_Call{Call: _e.mock.On("EpochCommittedPhaseStarted", currentEpochCounter, first)}
}

func (_c *Consumer_EpochCommittedPhaseStarted_Call) Run(run func(currentEpochCounter uint64, first *flow.Header)) *Consumer_EpochCommittedPhaseStarted_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		var arg1 *flow.Header
		if args[1] != nil {
			arg1 = args[1].(*flow.Header)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Consumer_EpochCommittedPhaseStarted_Call) Return() *Consumer_EpochCommittedPhaseStarted_Call {
	_c.Call.Return()
	return _c
}

func (_c *Consumer_EpochCommittedPhaseStarted_Call) RunAndReturn(run func(currentEpochCounter uint64, first *flow.Header)) *Consumer_EpochCommittedPhaseStarted_Call {
	_c.Run(run)
	return _c
}

// EpochExtended provides a mock function for the type Consumer
func (_mock *Consumer) EpochExtended(epochCounter uint64, header *flow.Header, extension flow.EpochExtension) {
	_mock.Called(epochCounter, header, extension)
	return
}

// Consumer_EpochExtended_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EpochExtended'
type Consumer_EpochExtended_Call struct {
	*mock.Call
}

// EpochExtended is a helper method to define mock.On call
//   - epochCounter uint64
//   - header *flow.Header
//   - extension flow.EpochExtension
func (_e *Consumer_Expecter) EpochExtended(epochCounter interface{}, header interface{}, extension interface{}) *Consumer_EpochExtended_Call {
	return &Consumer_EpochExtended_Call{Call: _e.mock.On("EpochExtended", epochCounter, header, extension)}
}

func (_c *Consumer_EpochExtended_Call) Run(run func(epochCounter uint64, header *flow.Header, extension flow.EpochExtension)) *Consumer_EpochExtended_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		var arg1 *flow.Header
		if args[1] != nil {
			arg1 = args[1].(*flow.Header)
		}
		var arg2 flow.EpochExtension
		if args[2] != nil {
			arg2 = args[2].(flow.EpochExtension)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Consumer_EpochExtended_Call) Return() *Consumer_EpochExtended_Call {
	_c.Call.Return()
	return _c
}

func (_c *Consumer_EpochExtended_Call) RunAndReturn(run func(epochCounter uint64, header *flow.Header, extension flow.EpochExtension)) *Consumer_EpochExtended_Call {
	_c.Run(run)
	return _c
}

// EpochFallbackModeExited provides a mock function for the type Consumer
func (_mock *Consumer) EpochFallbackModeExited(epochCounter uint64, header *flow.Header) {
	_mock.Called(epochCounter, header)
	return
}

// Consumer_EpochFallbackModeExited_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EpochFallbackModeExited'
type Consumer_EpochFallbackModeExited_Call struct {
	*mock.Call
}

// EpochFallbackModeExited is a helper method to define mock.On call
//   - epochCounter uint64
//   - header *flow.Header
func (_e *Consumer_Expecter) EpochFallbackModeExited(epochCounter interface{}, header interface{}) *Consumer_EpochFallbackModeExited_Call {
	return &Consumer_EpochFallbackModeExited_Call{Call: _e.mock.On("EpochFallbackModeExited", epochCounter, header)}
}

func (_c *Consumer_EpochFallbackModeExited_Call) Run(run func(epochCounter uint64, header *flow.Header)) *Consumer_EpochFallbackModeExited_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		var arg1 *flow.Header
		if args[1] != nil {
			arg1 = args[1].(*flow.Header)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Consumer_EpochFallbackModeExited_Call) Return() *Consumer_EpochFallbackModeExited_Call {
	_c.Call.Return()
	return _c
}

func (_c *Consumer_EpochFallbackModeExited_Call) RunAndReturn(run func(epochCounter uint64, header *flow.Header)) *Consumer_EpochFallbackModeExited_Call {
	_c.Run(run)
	return _c
}

// EpochFallbackModeTriggered provides a mock function for the type Consumer
func (_mock *Consumer) EpochFallbackModeTriggered(epochCounter uint64, header *flow.Header) {
	_mock.Called(epochCounter, header)
	return
}

// Consumer_EpochFallbackModeTriggered_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EpochFallbackModeTriggered'
type Consumer_EpochFallbackModeTriggered_Call struct {
	*mock.Call
}

// EpochFallbackModeTriggered is a helper method to define mock.On call
//   - epochCounter uint64
//   - header *flow.Header
func (_e *Consumer_Expecter) EpochFallbackModeTriggered(epochCounter interface{}, header interface{}) *Consumer_EpochFallbackModeTriggered_Call {
	return &Consumer_EpochFallbackModeTriggered_Call{Call: _e.mock.On("EpochFallbackModeTriggered", epochCounter, header)}
}

func (_c *Consumer_EpochFallbackModeTriggered_Call) Run(run func(epochCounter uint64, header *flow.Header)) *Consumer_EpochFallbackModeTriggered_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		var arg1 *flow.Header
		if args[1] != nil {
			arg1 = args[1].(*flow.Header)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Consumer_EpochFallbackModeTriggered_Call) Return() *Consumer_EpochFallbackModeTriggered_Call {
	_c.Call.Return()
	return _c
}

func (_c *Consumer_EpochFallbackModeTriggered_Call) RunAndReturn(run func(epochCounter uint64, header *flow.Header)) *Consumer_EpochFallbackModeTriggered_Call {
	_c.Run(run)
	return _c
}

// EpochSetupPhaseStarted provides a mock function for the type Consumer
func (_mock *Consumer) EpochSetupPhaseStarted(currentEpochCounter uint64, first *flow.Header) {
	_mock.Called(currentEpochCounter, first)
	return
}

// Consumer_EpochSetupPhaseStarted_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EpochSetupPhaseStarted'
type Consumer_EpochSetupPhaseStarted_Call struct {
	*mock.Call
}

// EpochSetupPhaseStarted is a helper method to define mock.On call
//   - currentEpochCounter uint64
//   - first *flow.Header
func (_e *Consumer_Expecter) EpochSetupPhaseStarted(currentEpochCounter interface{}, first interface{}) *Consumer_EpochSetupPhaseStarted_Call {
	return &Consumer_EpochSetupPhaseStarted_Call{Call: _e.mock.On("EpochSetupPhaseStarted", currentEpochCounter, first)}
}

func (_c *Consumer_EpochSetupPhaseStarted_Call) Run(run func(currentEpochCounter uint64, first *flow.Header)) *Consumer_EpochSetupPhaseStarted_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		var arg1 *flow.Header
		if args[1] != nil {
			arg1 = args[1].(*flow.Header)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Consumer_EpochSetupPhaseStarted_Call) Return() *Consumer_EpochSetupPhaseStarted_Call {
	_c.Call.Return()
	return _c
}

func (_c *Consumer_EpochSetupPhaseStarted_Call) RunAndReturn(run func(currentEpochCounter uint64, first *flow.Header)) *Consumer_EpochSetupPhaseStarted_Call {
	_c.Run(run)
	return _c
}

// EpochTransition provides a mock function for the type Consumer
func (_mock *Consumer) EpochTransition(newEpochCounter uint64, first *flow.Header) {
	_mock.Called(newEpochCounter, first)
	return
}

// Consumer_EpochTransition_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EpochTransition'
type Consumer_EpochTransition_Call struct {
	*mock.Call
}

// EpochTransition is a helper method to define mock.On call
//   - newEpochCounter uint64
//   - first *flow.Header
func (_e *Consumer_Expecter) EpochTransition(newEpochCounter interface{}, first interface{}) *Consumer_EpochTransition_Call {
	return &Consumer_EpochTransition_Call{Call: _e.mock.On("EpochTransition", newEpochCounter, first)}
}

func (_c *Consumer_EpochTransition_Call) Run(run func(newEpochCounter uint64, first *flow.Header)) *Consumer_EpochTransition_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		var arg1 *flow.Header
		if args[1] != nil {
			arg1 = args[1].(*flow.Header)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Consumer_EpochTransition_Call) Return() *Consumer_EpochTransition_Call {
	_c.Call.Return()
	return _c
}

func (_c *Consumer_EpochTransition_Call) RunAndReturn(run func(newEpochCounter uint64, first *flow.Header)) *Consumer_EpochTransition_Call {
	_c.Run(run)
	return _c
}

// NewSnapshotExecutionSubset creates a new instance of SnapshotExecutionSubset. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewSnapshotExecutionSubset(t interface {
	mock.TestingT
	Cleanup(func())
}) *SnapshotExecutionSubset {
	mock := &SnapshotExecutionSubset{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// SnapshotExecutionSubset is an autogenerated mock type for the SnapshotExecutionSubset type
type SnapshotExecutionSubset struct {
	mock.Mock
}

type SnapshotExecutionSubset_Expecter struct {
	mock *mock.Mock
}

func (_m *SnapshotExecutionSubset) EXPECT() *SnapshotExecutionSubset_Expecter {
	return &SnapshotExecutionSubset_Expecter{mock: &_m.Mock}
}

// RandomSource provides a mock function for the type SnapshotExecutionSubset
func (_mock *SnapshotExecutionSubset) RandomSource() ([]byte, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for RandomSource")
	}

	var r0 []byte
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() ([]byte, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() []byte); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// SnapshotExecutionSubset_RandomSource_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RandomSource'
type SnapshotExecutionSubset_RandomSource_Call struct {
	*mock.Call
}

// RandomSource is a helper method to define mock.On call
func (_e *SnapshotExecutionSubset_Expecter) RandomSource() *SnapshotExecutionSubset_RandomSource_Call {
	return &SnapshotExecutionSubset_RandomSource_Call{Call: _e.mock.On("RandomSource")}
}

func (_c *SnapshotExecutionSubset_RandomSource_Call) Run(run func()) *SnapshotExecutionSubset_RandomSource_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *SnapshotExecutionSubset_RandomSource_Call) Return(bytes []byte, err error) *SnapshotExecutionSubset_RandomSource_Call {
	_c.Call.Return(bytes, err)
	return _c
}

func (_c *SnapshotExecutionSubset_RandomSource_Call) RunAndReturn(run func() ([]byte, error)) *SnapshotExecutionSubset_RandomSource_Call {
	_c.Call.Return(run)
	return _c
}

// VersionBeacon provides a mock function for the type SnapshotExecutionSubset
func (_mock *SnapshotExecutionSubset) VersionBeacon() (*flow.SealedVersionBeacon, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for VersionBeacon")
	}

	var r0 *flow.SealedVersionBeacon
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (*flow.SealedVersionBeacon, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() *flow.SealedVersionBeacon); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.SealedVersionBeacon)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// SnapshotExecutionSubset_VersionBeacon_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'VersionBeacon'
type SnapshotExecutionSubset_VersionBeacon_Call struct {
	*mock.Call
}

// VersionBeacon is a helper method to define mock.On call
func (_e *SnapshotExecutionSubset_Expecter) VersionBeacon() *SnapshotExecutionSubset_VersionBeacon_Call {
	return &SnapshotExecutionSubset_VersionBeacon_Call{Call: _e.mock.On("VersionBeacon")}
}

func (_c *SnapshotExecutionSubset_VersionBeacon_Call) Run(run func()) *SnapshotExecutionSubset_VersionBeacon_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *SnapshotExecutionSubset_VersionBeacon_Call) Return(sealedVersionBeacon *flow.SealedVersionBeacon, err error) *SnapshotExecutionSubset_VersionBeacon_Call {
	_c.Call.Return(sealedVersionBeacon, err)
	return _c
}

func (_c *SnapshotExecutionSubset_VersionBeacon_Call) RunAndReturn(run func() (*flow.SealedVersionBeacon, error)) *SnapshotExecutionSubset_VersionBeacon_Call {
	_c.Call.Return(run)
	return _c
}

// NewSnapshotExecutionSubsetProvider creates a new instance of SnapshotExecutionSubsetProvider. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewSnapshotExecutionSubsetProvider(t interface {
	mock.TestingT
	Cleanup(func())
}) *SnapshotExecutionSubsetProvider {
	mock := &SnapshotExecutionSubsetProvider{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// SnapshotExecutionSubsetProvider is an autogenerated mock type for the SnapshotExecutionSubsetProvider type
type SnapshotExecutionSubsetProvider struct {
	mock.Mock
}

type SnapshotExecutionSubsetProvider_Expecter struct {
	mock *mock.Mock
}

func (_m *SnapshotExecutionSubsetProvider) EXPECT() *SnapshotExecutionSubsetProvider_Expecter {
	return &SnapshotExecutionSubsetProvider_Expecter{mock: &_m.Mock}
}

// AtBlockID provides a mock function for the type SnapshotExecutionSubsetProvider
func (_mock *SnapshotExecutionSubsetProvider) AtBlockID(blockID flow.Identifier) protocol.SnapshotExecutionSubset {
	ret := _mock.Called(blockID)

	if len(ret) == 0 {
		panic("no return value specified for AtBlockID")
	}

	var r0 protocol.SnapshotExecutionSubset
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) protocol.SnapshotExecutionSubset); ok {
		r0 = returnFunc(blockID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(protocol.SnapshotExecutionSubset)
		}
	}
	return r0
}

// SnapshotExecutionSubsetProvider_AtBlockID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AtBlockID'
type SnapshotExecutionSubsetProvider_AtBlockID_Call struct {
	*mock.Call
}

// AtBlockID is a helper method to define mock.On call
//   - blockID flow.Identifier
func (_e *SnapshotExecutionSubsetProvider_Expecter) AtBlockID(blockID interface{}) *SnapshotExecutionSubsetProvider_AtBlockID_Call {
	return &SnapshotExecutionSubsetProvider_AtBlockID_Call{Call: _e.mock.On("AtBlockID", blockID)}
}

func (_c *SnapshotExecutionSubsetProvider_AtBlockID_Call) Run(run func(blockID flow.Identifier)) *SnapshotExecutionSubsetProvider_AtBlockID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *SnapshotExecutionSubsetProvider_AtBlockID_Call) Return(snapshotExecutionSubset protocol.SnapshotExecutionSubset) *SnapshotExecutionSubsetProvider_AtBlockID_Call {
	_c.Call.Return(snapshotExecutionSubset)
	return _c
}

func (_c *SnapshotExecutionSubsetProvider_AtBlockID_Call) RunAndReturn(run func(blockID flow.Identifier) protocol.SnapshotExecutionSubset) *SnapshotExecutionSubsetProvider_AtBlockID_Call {
	_c.Call.Return(run)
	return _c
}

// NewKVStoreReader creates a new instance of KVStoreReader. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewKVStoreReader(t interface {
	mock.TestingT
	Cleanup(func())
}) *KVStoreReader {
	mock := &KVStoreReader{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// KVStoreReader is an autogenerated mock type for the KVStoreReader type
type KVStoreReader struct {
	mock.Mock
}

type KVStoreReader_Expecter struct {
	mock *mock.Mock
}

func (_m *KVStoreReader) EXPECT() *KVStoreReader_Expecter {
	return &KVStoreReader_Expecter{mock: &_m.Mock}
}

// GetCadenceComponentVersion provides a mock function for the type KVStoreReader
func (_mock *KVStoreReader) GetCadenceComponentVersion() (protocol.MagnitudeVersion, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetCadenceComponentVersion")
	}

	var r0 protocol.MagnitudeVersion
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (protocol.MagnitudeVersion, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() protocol.MagnitudeVersion); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(protocol.MagnitudeVersion)
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// KVStoreReader_GetCadenceComponentVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCadenceComponentVersion'
type KVStoreReader_GetCadenceComponentVersion_Call struct {
	*mock.Call
}

// GetCadenceComponentVersion is a helper method to define mock.On call
func (_e *KVStoreReader_Expecter) GetCadenceComponentVersion() *KVStoreReader_GetCadenceComponentVersion_Call {
	return &KVStoreReader_GetCadenceComponentVersion_Call{Call: _e.mock.On("GetCadenceComponentVersion")}
}

func (_c *KVStoreReader_GetCadenceComponentVersion_Call) Run(run func()) *KVStoreReader_GetCadenceComponentVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *KVStoreReader_GetCadenceComponentVersion_Call) Return(magnitudeVersion protocol.MagnitudeVersion, err error) *KVStoreReader_GetCadenceComponentVersion_Call {
	_c.Call.Return(magnitudeVersion, err)
	return _c
}

func (_c *KVStoreReader_GetCadenceComponentVersion_Call) RunAndReturn(run func() (protocol.MagnitudeVersion, error)) *KVStoreReader_GetCadenceComponentVersion_Call {
	_c.Call.Return(run)
	return _c
}

// GetCadenceComponentVersionUpgrade provides a mock function for the type KVStoreReader
func (_mock *KVStoreReader) GetCadenceComponentVersionUpgrade() *protocol.ViewBasedActivator[protocol.MagnitudeVersion] {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetCadenceComponentVersionUpgrade")
	}

	var r0 *protocol.ViewBasedActivator[protocol.MagnitudeVersion]
	if returnFunc, ok := ret.Get(0).(func() *protocol.ViewBasedActivator[protocol.MagnitudeVersion]); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*protocol.ViewBasedActivator[protocol.MagnitudeVersion])
		}
	}
	return r0
}

// KVStoreReader_GetCadenceComponentVersionUpgrade_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCadenceComponentVersionUpgrade'
type KVStoreReader_GetCadenceComponentVersionUpgrade_Call struct {
	*mock.Call
}

// GetCadenceComponentVersionUpgrade is a helper method to define mock.On call
func (_e *KVStoreReader_Expecter) GetCadenceComponentVersionUpgrade() *KVStoreReader_GetCadenceComponentVersionUpgrade_Call {
	return &KVStoreReader_GetCadenceComponentVersionUpgrade_Call{Call: _e.mock.On("GetCadenceComponentVersionUpgrade")}
}

func (_c *KVStoreReader_GetCadenceComponentVersionUpgrade_Call) Run(run func()) *KVStoreReader_GetCadenceComponentVersionUpgrade_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *KVStoreReader_GetCadenceComponentVersionUpgrade_Call) Return(viewBasedActivator *protocol.ViewBasedActivator[protocol.MagnitudeVersion]) *KVStoreReader_GetCadenceComponentVersionUpgrade_Call {
	_c.Call.Return(viewBasedActivator)
	return _c
}

func (_c *KVStoreReader_GetCadenceComponentVersionUpgrade_Call) RunAndReturn(run func() *protocol.ViewBasedActivator[protocol.MagnitudeVersion]) *KVStoreReader_GetCadenceComponentVersionUpgrade_Call {
	_c.Call.Return(run)
	return _c
}

// GetEpochExtensionViewCount provides a mock function for the type KVStoreReader
func (_mock *KVStoreReader) GetEpochExtensionViewCount() uint64 {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetEpochExtensionViewCount")
	}

	var r0 uint64
	if returnFunc, ok := ret.Get(0).(func() uint64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint64)
	}
	return r0
}

// KVStoreReader_GetEpochExtensionViewCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEpochExtensionViewCount'
type KVStoreReader_GetEpochExtensionViewCount_Call struct {
	*mock.Call
}

// GetEpochExtensionViewCount is a helper method to define mock.On call
func (_e *KVStoreReader_Expecter) GetEpochExtensionViewCount() *KVStoreReader_GetEpochExtensionViewCount_Call {
	return &KVStoreReader_GetEpochExtensionViewCount_Call{Call: _e.mock.On("GetEpochExtensionViewCount")}
}

func (_c *KVStoreReader_GetEpochExtensionViewCount_Call) Run(run func()) *KVStoreReader_GetEpochExtensionViewCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *KVStoreReader_GetEpochExtensionViewCount_Call) Return(v uint64) *KVStoreReader_GetEpochExtensionViewCount_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *KVStoreReader_GetEpochExtensionViewCount_Call) RunAndReturn(run func() uint64) *KVStoreReader_GetEpochExtensionViewCount_Call {
	_c.Call.Return(run)
	return _c
}

// GetEpochStateID provides a mock function for the type KVStoreReader
func (_mock *KVStoreReader) GetEpochStateID() flow.Identifier {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetEpochStateID")
	}

	var r0 flow.Identifier
	if returnFunc, ok := ret.Get(0).(func() flow.Identifier); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.Identifier)
		}
	}
	return r0
}

// KVStoreReader_GetEpochStateID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEpochStateID'
type KVStoreReader_GetEpochStateID_Call struct {
	*mock.Call
}

// GetEpochStateID is a helper method to define mock.On call
func (_e *KVStoreReader_Expecter) GetEpochStateID() *KVStoreReader_GetEpochStateID_Call {
	return &KVStoreReader_GetEpochStateID_Call{Call: _e.mock.On("GetEpochStateID")}
}

func (_c *KVStoreReader_GetEpochStateID_Call) Run(run func()) *KVStoreReader_GetEpochStateID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *KVStoreReader_GetEpochStateID_Call) Return(identifier flow.Identifier) *KVStoreReader_GetEpochStateID_Call {
	_c.Call.Return(identifier)
	return _c
}

func (_c *KVStoreReader_GetEpochStateID_Call) RunAndReturn(run func() flow.Identifier) *KVStoreReader_GetEpochStateID_Call {
	_c.Call.Return(run)
	return _c
}

// GetExecutionComponentVersion provides a mock function for the type KVStoreReader
func (_mock *KVStoreReader) GetExecutionComponentVersion() (protocol.MagnitudeVersion, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetExecutionComponentVersion")
	}

	var r0 protocol.MagnitudeVersion
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (protocol.MagnitudeVersion, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() protocol.MagnitudeVersion); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(protocol.MagnitudeVersion)
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// KVStoreReader_GetExecutionComponentVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetExecutionComponentVersion'
type KVStoreReader_GetExecutionComponentVersion_Call struct {
	*mock.Call
}

// GetExecutionComponentVersion is a helper method to define mock.On call
func (_e *KVStoreReader_Expecter) GetExecutionComponentVersion() *KVStoreReader_GetExecutionComponentVersion_Call {
	return &KVStoreReader_GetExecutionComponentVersion_Call{Call: _e.mock.On("GetExecutionComponentVersion")}
}

func (_c *KVStoreReader_GetExecutionComponentVersion_Call) Run(run func()) *KVStoreReader_GetExecutionComponentVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *KVStoreReader_GetExecutionComponentVersion_Call) Return(magnitudeVersion protocol.MagnitudeVersion, err error) *KVStoreReader_GetExecutionComponentVersion_Call {
	_c.Call.Return(magnitudeVersion, err)
	return _c
}

func (_c *KVStoreReader_GetExecutionComponentVersion_Call) RunAndReturn(run func() (protocol.MagnitudeVersion, error)) *KVStoreReader_GetExecutionComponentVersion_Call {
	_c.Call.Return(run)
	return _c
}

// GetExecutionComponentVersionUpgrade provides a mock function for the type KVStoreReader
func (_mock *KVStoreReader) GetExecutionComponentVersionUpgrade() *protocol.ViewBasedActivator[protocol.MagnitudeVersion] {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetExecutionComponentVersionUpgrade")
	}

	var r0 *protocol.ViewBasedActivator[protocol.MagnitudeVersion]
	if returnFunc, ok := ret.Get(0).(func() *protocol.ViewBasedActivator[protocol.MagnitudeVersion]); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*protocol.ViewBasedActivator[protocol.MagnitudeVersion])
		}
	}
	return r0
}

// KVStoreReader_GetExecutionComponentVersionUpgrade_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetExecutionComponentVersionUpgrade'
type KVStoreReader_GetExecutionComponentVersionUpgrade_Call struct {
	*mock.Call
}

// GetExecutionComponentVersionUpgrade is a helper method to define mock.On call
func (_e *KVStoreReader_Expecter) GetExecutionComponentVersionUpgrade() *KVStoreReader_GetExecutionComponentVersionUpgrade_Call {
	return &KVStoreReader_GetExecutionComponentVersionUpgrade_Call{Call: _e.mock.On("GetExecutionComponentVersionUpgrade")}
}

func (_c *KVStoreReader_GetExecutionComponentVersionUpgrade_Call) Run(run func()) *KVStoreReader_GetExecutionComponentVersionUpgrade_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *KVStoreReader_GetExecutionComponentVersionUpgrade_Call) Return(viewBasedActivator *protocol.ViewBasedActivator[protocol.MagnitudeVersion]) *KVStoreReader_GetExecutionComponentVersionUpgrade_Call {
	_c.Call.Return(viewBasedActivator)
	return _c
}

func (_c *KVStoreReader_GetExecutionComponentVersionUpgrade_Call) RunAndReturn(run func() *protocol.ViewBasedActivator[protocol.MagnitudeVersion]) *KVStoreReader_GetExecutionComponentVersionUpgrade_Call {
	_c.Call.Return(run)
	return _c
}

// GetExecutionMeteringParameters provides a mock function for the type KVStoreReader
func (_mock *KVStoreReader) GetExecutionMeteringParameters() (protocol.ExecutionMeteringParameters, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetExecutionMeteringParameters")
	}

	var r0 protocol.ExecutionMeteringParameters
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (protocol.ExecutionMeteringParameters, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() protocol.ExecutionMeteringParameters); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(protocol.ExecutionMeteringParameters)
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// KVStoreReader_GetExecutionMeteringParameters_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetExecutionMeteringParameters'
type KVStoreReader_GetExecutionMeteringParameters_Call struct {
	*mock.Call
}

// GetExecutionMeteringParameters is a helper method to define mock.On call
func (_e *KVStoreReader_Expecter) GetExecutionMeteringParameters() *KVStoreReader_GetExecutionMeteringParameters_Call {
	return &KVStoreReader_GetExecutionMeteringParameters_Call{Call: _e.mock.On("GetExecutionMeteringParameters")}
}

func (_c *KVStoreReader_GetExecutionMeteringParameters_Call) Run(run func()) *KVStoreReader_GetExecutionMeteringParameters_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *KVStoreReader_GetExecutionMeteringParameters_Call) Return(executionMeteringParameters protocol.ExecutionMeteringParameters, err error) *KVStoreReader_GetExecutionMeteringParameters_Call {
	_c.Call.Return(executionMeteringParameters, err)
	return _c
}

func (_c *KVStoreReader_GetExecutionMeteringParameters_Call) RunAndReturn(run func() (protocol.ExecutionMeteringParameters, error)) *KVStoreReader_GetExecutionMeteringParameters_Call {
	_c.Call.Return(run)
	return _c
}

// GetExecutionMeteringParametersUpgrade provides a mock function for the type KVStoreReader
func (_mock *KVStoreReader) GetExecutionMeteringParametersUpgrade() *protocol.ViewBasedActivator[protocol.ExecutionMeteringParameters] {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetExecutionMeteringParametersUpgrade")
	}

	var r0 *protocol.ViewBasedActivator[protocol.ExecutionMeteringParameters]
	if returnFunc, ok := ret.Get(0).(func() *protocol.ViewBasedActivator[protocol.ExecutionMeteringParameters]); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*protocol.ViewBasedActivator[protocol.ExecutionMeteringParameters])
		}
	}
	return r0
}

// KVStoreReader_GetExecutionMeteringParametersUpgrade_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetExecutionMeteringParametersUpgrade'
type KVStoreReader_GetExecutionMeteringParametersUpgrade_Call struct {
	*mock.Call
}

// GetExecutionMeteringParametersUpgrade is a helper method to define mock.On call
func (_e *KVStoreReader_Expecter) GetExecutionMeteringParametersUpgrade() *KVStoreReader_GetExecutionMeteringParametersUpgrade_Call {
	return &KVStoreReader_GetExecutionMeteringParametersUpgrade_Call{Call: _e.mock.On("GetExecutionMeteringParametersUpgrade")}
}

func (_c *KVStoreReader_GetExecutionMeteringParametersUpgrade_Call) Run(run func()) *KVStoreReader_GetExecutionMeteringParametersUpgrade_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *KVStoreReader_GetExecutionMeteringParametersUpgrade_Call) Return(viewBasedActivator *protocol.ViewBasedActivator[protocol.ExecutionMeteringParameters]) *KVStoreReader_GetExecutionMeteringParametersUpgrade_Call {
	_c.Call.Return(viewBasedActivator)
	return _c
}

func (_c *KVStoreReader_GetExecutionMeteringParametersUpgrade_Call) RunAndReturn(run func() *protocol.ViewBasedActivator[protocol.ExecutionMeteringParameters]) *KVStoreReader_GetExecutionMeteringParametersUpgrade_Call {
	_c.Call.Return(run)
	return _c
}

// GetFinalizationSafetyThreshold provides a mock function for the type KVStoreReader
func (_mock *KVStoreReader) GetFinalizationSafetyThreshold() uint64 {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetFinalizationSafetyThreshold")
	}

	var r0 uint64
	if returnFunc, ok := ret.Get(0).(func() uint64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint64)
	}
	return r0
}

// KVStoreReader_GetFinalizationSafetyThreshold_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFinalizationSafetyThreshold'
type KVStoreReader_GetFinalizationSafetyThreshold_Call struct {
	*mock.Call
}

// GetFinalizationSafetyThreshold is a helper method to define mock.On call
func (_e *KVStoreReader_Expecter) GetFinalizationSafetyThreshold() *KVStoreReader_GetFinalizationSafetyThreshold_Call {
	return &KVStoreReader_GetFinalizationSafetyThreshold_Call{Call: _e.mock.On("GetFinalizationSafetyThreshold")}
}

func (_c *KVStoreReader_GetFinalizationSafetyThreshold_Call) Run(run func()) *KVStoreReader_GetFinalizationSafetyThreshold_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *KVStoreReader_GetFinalizationSafetyThreshold_Call) Return(v uint64) *KVStoreReader_GetFinalizationSafetyThreshold_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *KVStoreReader_GetFinalizationSafetyThreshold_Call) RunAndReturn(run func() uint64) *KVStoreReader_GetFinalizationSafetyThreshold_Call {
	_c.Call.Return(run)
	return _c
}

// GetProtocolStateVersion provides a mock function for the type KVStoreReader
func (_mock *KVStoreReader) GetProtocolStateVersion() uint64 {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetProtocolStateVersion")
	}

	var r0 uint64
	if returnFunc, ok := ret.Get(0).(func() uint64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint64)
	}
	return r0
}

// KVStoreReader_GetProtocolStateVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetProtocolStateVersion'
type KVStoreReader_GetProtocolStateVersion_Call struct {
	*mock.Call
}

// GetProtocolStateVersion is a helper method to define mock.On call
func (_e *KVStoreReader_Expecter) GetProtocolStateVersion() *KVStoreReader_GetProtocolStateVersion_Call {
	return &KVStoreReader_GetProtocolStateVersion_Call{Call: _e.mock.On("GetProtocolStateVersion")}
}

func (_c *KVStoreReader_GetProtocolStateVersion_Call) Run(run func()) *KVStoreReader_GetProtocolStateVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *KVStoreReader_GetProtocolStateVersion_Call) Return(v uint64) *KVStoreReader_GetProtocolStateVersion_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *KVStoreReader_GetProtocolStateVersion_Call) RunAndReturn(run func() uint64) *KVStoreReader_GetProtocolStateVersion_Call {
	_c.Call.Return(run)
	return _c
}

// GetVersionUpgrade provides a mock function for the type KVStoreReader
func (_mock *KVStoreReader) GetVersionUpgrade() *protocol.ViewBasedActivator[uint64] {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetVersionUpgrade")
	}

	var r0 *protocol.ViewBasedActivator[uint64]
	if returnFunc, ok := ret.Get(0).(func() *protocol.ViewBasedActivator[uint64]); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*protocol.ViewBasedActivator[uint64])
		}
	}
	return r0
}

// KVStoreReader_GetVersionUpgrade_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetVersionUpgrade'
type KVStoreReader_GetVersionUpgrade_Call struct {
	*mock.Call
}

// GetVersionUpgrade is a helper method to define mock.On call
func (_e *KVStoreReader_Expecter) GetVersionUpgrade() *KVStoreReader_GetVersionUpgrade_Call {
	return &KVStoreReader_GetVersionUpgrade_Call{Call: _e.mock.On("GetVersionUpgrade")}
}

func (_c *KVStoreReader_GetVersionUpgrade_Call) Run(run func()) *KVStoreReader_GetVersionUpgrade_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *KVStoreReader_GetVersionUpgrade_Call) Return(viewBasedActivator *protocol.ViewBasedActivator[uint64]) *KVStoreReader_GetVersionUpgrade_Call {
	_c.Call.Return(viewBasedActivator)
	return _c
}

func (_c *KVStoreReader_GetVersionUpgrade_Call) RunAndReturn(run func() *protocol.ViewBasedActivator[uint64]) *KVStoreReader_GetVersionUpgrade_Call {
	_c.Call.Return(run)
	return _c
}

// ID provides a mock function for the type KVStoreReader
func (_mock *KVStoreReader) ID() flow.Identifier {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for ID")
	}

	var r0 flow.Identifier
	if returnFunc, ok := ret.Get(0).(func() flow.Identifier); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.Identifier)
		}
	}
	return r0
}

// KVStoreReader_ID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ID'
type KVStoreReader_ID_Call struct {
	*mock.Call
}

// ID is a helper method to define mock.On call
func (_e *KVStoreReader_Expecter) ID() *KVStoreReader_ID_Call {
	return &KVStoreReader_ID_Call{Call: _e.mock.On("ID")}
}

func (_c *KVStoreReader_ID_Call) Run(run func()) *KVStoreReader_ID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *KVStoreReader_ID_Call) Return(identifier flow.Identifier) *KVStoreReader_ID_Call {
	_c.Call.Return(identifier)
	return _c
}

func (_c *KVStoreReader_ID_Call) RunAndReturn(run func() flow.Identifier) *KVStoreReader_ID_Call {
	_c.Call.Return(run)
	return _c
}

// VersionedEncode provides a mock function for the type KVStoreReader
func (_mock *KVStoreReader) VersionedEncode() (uint64, []byte, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for VersionedEncode")
	}

	var r0 uint64
	var r1 []byte
	var r2 error
	if returnFunc, ok := ret.Get(0).(func() (uint64, []byte, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() uint64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint64)
	}
	if returnFunc, ok := ret.Get(1).(func() []byte); ok {
		r1 = returnFunc()
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]byte)
		}
	}
	if returnFunc, ok := ret.Get(2).(func() error); ok {
		r2 = returnFunc()
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// KVStoreReader_VersionedEncode_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'VersionedEncode'
type KVStoreReader_VersionedEncode_Call struct {
	*mock.Call
}

// VersionedEncode is a helper method to define mock.On call
func (_e *KVStoreReader_Expecter) VersionedEncode() *KVStoreReader_VersionedEncode_Call {
	return &KVStoreReader_VersionedEncode_Call{Call: _e.mock.On("VersionedEncode")}
}

func (_c *KVStoreReader_VersionedEncode_Call) Run(run func()) *KVStoreReader_VersionedEncode_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *KVStoreReader_VersionedEncode_Call) Return(v uint64, bytes []byte, err error) *KVStoreReader_VersionedEncode_Call {
	_c.Call.Return(v, bytes, err)
	return _c
}

func (_c *KVStoreReader_VersionedEncode_Call) RunAndReturn(run func() (uint64, []byte, error)) *KVStoreReader_VersionedEncode_Call {
	_c.Call.Return(run)
	return _c
}

// NewVersionedEncodable creates a new instance of VersionedEncodable. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewVersionedEncodable(t interface {
	mock.TestingT
	Cleanup(func())
}) *VersionedEncodable {
	mock := &VersionedEncodable{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// VersionedEncodable is an autogenerated mock type for the VersionedEncodable type
type VersionedEncodable struct {
	mock.Mock
}

type VersionedEncodable_Expecter struct {
	mock *mock.Mock
}

func (_m *VersionedEncodable) EXPECT() *VersionedEncodable_Expecter {
	return &VersionedEncodable_Expecter{mock: &_m.Mock}
}

// VersionedEncode provides a mock function for the type VersionedEncodable
func (_mock *VersionedEncodable) VersionedEncode() (uint64, []byte, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for VersionedEncode")
	}

	var r0 uint64
	var r1 []byte
	var r2 error
	if returnFunc, ok := ret.Get(0).(func() (uint64, []byte, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() uint64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint64)
	}
	if returnFunc, ok := ret.Get(1).(func() []byte); ok {
		r1 = returnFunc()
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]byte)
		}
	}
	if returnFunc, ok := ret.Get(2).(func() error); ok {
		r2 = returnFunc()
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// VersionedEncodable_VersionedEncode_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'VersionedEncode'
type VersionedEncodable_VersionedEncode_Call struct {
	*mock.Call
}

// VersionedEncode is a helper method to define mock.On call
func (_e *VersionedEncodable_Expecter) VersionedEncode() *VersionedEncodable_VersionedEncode_Call {
	return &VersionedEncodable_VersionedEncode_Call{Call: _e.mock.On("VersionedEncode")}
}

func (_c *VersionedEncodable_VersionedEncode_Call) Run(run func()) *VersionedEncodable_VersionedEncode_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *VersionedEncodable_VersionedEncode_Call) Return(v uint64, bytes []byte, err error) *VersionedEncodable_VersionedEncode_Call {
	_c.Call.Return(v, bytes, err)
	return _c
}

func (_c *VersionedEncodable_VersionedEncode_Call) RunAndReturn(run func() (uint64, []byte, error)) *VersionedEncodable_VersionedEncode_Call {
	_c.Call.Return(run)
	return _c
}

// NewParams creates a new instance of Params. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewParams(t interface {
	mock.TestingT
	Cleanup(func())
}) *Params {
	mock := &Params{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Params is an autogenerated mock type for the Params type
type Params struct {
	mock.Mock
}

type Params_Expecter struct {
	mock *mock.Mock
}

func (_m *Params) EXPECT() *Params_Expecter {
	return &Params_Expecter{mock: &_m.Mock}
}

// ChainID provides a mock function for the type Params
func (_mock *Params) ChainID() flow.ChainID {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for ChainID")
	}

	var r0 flow.ChainID
	if returnFunc, ok := ret.Get(0).(func() flow.ChainID); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(flow.ChainID)
	}
	return r0
}

// Params_ChainID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChainID'
type Params_ChainID_Call struct {
	*mock.Call
}

// ChainID is a helper method to define mock.On call
func (_e *Params_Expecter) ChainID() *Params_ChainID_Call {
	return &Params_ChainID_Call{Call: _e.mock.On("ChainID")}
}

func (_c *Params_ChainID_Call) Run(run func()) *Params_ChainID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Params_ChainID_Call) Return(chainID flow.ChainID) *Params_ChainID_Call {
	_c.Call.Return(chainID)
	return _c
}

func (_c *Params_ChainID_Call) RunAndReturn(run func() flow.ChainID) *Params_ChainID_Call {
	_c.Call.Return(run)
	return _c
}

// FinalizedRoot provides a mock function for the type Params
func (_mock *Params) FinalizedRoot() *flow.Header {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for FinalizedRoot")
	}

	var r0 *flow.Header
	if returnFunc, ok := ret.Get(0).(func() *flow.Header); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.Header)
		}
	}
	return r0
}

// Params_FinalizedRoot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FinalizedRoot'
type Params_FinalizedRoot_Call struct {
	*mock.Call
}

// FinalizedRoot is a helper method to define mock.On call
func (_e *Params_Expecter) FinalizedRoot() *Params_FinalizedRoot_Call {
	return &Params_FinalizedRoot_Call{Call: _e.mock.On("FinalizedRoot")}
}

func (_c *Params_FinalizedRoot_Call) Run(run func()) *Params_FinalizedRoot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Params_FinalizedRoot_Call) Return(header *flow.Header) *Params_FinalizedRoot_Call {
	_c.Call.Return(header)
	return _c
}

func (_c *Params_FinalizedRoot_Call) RunAndReturn(run func() *flow.Header) *Params_FinalizedRoot_Call {
	_c.Call.Return(run)
	return _c
}

// Seal provides a mock function for the type Params
func (_mock *Params) Seal() *flow.Seal {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Seal")
	}

	var r0 *flow.Seal
	if returnFunc, ok := ret.Get(0).(func() *flow.Seal); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.Seal)
		}
	}
	return r0
}

// Params_Seal_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Seal'
type Params_Seal_Call struct {
	*mock.Call
}

// Seal is a helper method to define mock.On call
func (_e *Params_Expecter) Seal() *Params_Seal_Call {
	return &Params_Seal_Call{Call: _e.mock.On("Seal")}
}

func (_c *Params_Seal_Call) Run(run func()) *Params_Seal_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Params_Seal_Call) Return(seal *flow.Seal) *Params_Seal_Call {
	_c.Call.Return(seal)
	return _c
}

func (_c *Params_Seal_Call) RunAndReturn(run func() *flow.Seal) *Params_Seal_Call {
	_c.Call.Return(run)
	return _c
}

// SealedRoot provides a mock function for the type Params
func (_mock *Params) SealedRoot() *flow.Header {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for SealedRoot")
	}

	var r0 *flow.Header
	if returnFunc, ok := ret.Get(0).(func() *flow.Header); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.Header)
		}
	}
	return r0
}

// Params_SealedRoot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SealedRoot'
type Params_SealedRoot_Call struct {
	*mock.Call
}

// SealedRoot is a helper method to define mock.On call
func (_e *Params_Expecter) SealedRoot() *Params_SealedRoot_Call {
	return &Params_SealedRoot_Call{Call: _e.mock.On("SealedRoot")}
}

func (_c *Params_SealedRoot_Call) Run(run func()) *Params_SealedRoot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Params_SealedRoot_Call) Return(header *flow.Header) *Params_SealedRoot_Call {
	_c.Call.Return(header)
	return _c
}

func (_c *Params_SealedRoot_Call) RunAndReturn(run func() *flow.Header) *Params_SealedRoot_Call {
	_c.Call.Return(run)
	return _c
}

// SporkID provides a mock function for the type Params
func (_mock *Params) SporkID() flow.Identifier {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for SporkID")
	}

	var r0 flow.Identifier
	if returnFunc, ok := ret.Get(0).(func() flow.Identifier); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.Identifier)
		}
	}
	return r0
}

// Params_SporkID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SporkID'
type Params_SporkID_Call struct {
	*mock.Call
}

// SporkID is a helper method to define mock.On call
func (_e *Params_Expecter) SporkID() *Params_SporkID_Call {
	return &Params_SporkID_Call{Call: _e.mock.On("SporkID")}
}

func (_c *Params_SporkID_Call) Run(run func()) *Params_SporkID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Params_SporkID_Call) Return(identifier flow.Identifier) *Params_SporkID_Call {
	_c.Call.Return(identifier)
	return _c
}

func (_c *Params_SporkID_Call) RunAndReturn(run func() flow.Identifier) *Params_SporkID_Call {
	_c.Call.Return(run)
	return _c
}

// SporkRootBlock provides a mock function for the type Params
func (_mock *Params) SporkRootBlock() *flow.Block {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for SporkRootBlock")
	}

	var r0 *flow.Block
	if returnFunc, ok := ret.Get(0).(func() *flow.Block); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.Block)
		}
	}
	return r0
}

// Params_SporkRootBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SporkRootBlock'
type Params_SporkRootBlock_Call struct {
	*mock.Call
}

// SporkRootBlock is a helper method to define mock.On call
func (_e *Params_Expecter) SporkRootBlock() *Params_SporkRootBlock_Call {
	return &Params_SporkRootBlock_Call{Call: _e.mock.On("SporkRootBlock")}
}

func (_c *Params_SporkRootBlock_Call) Run(run func()) *Params_SporkRootBlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Params_SporkRootBlock_Call) Return(v *flow.Block) *Params_SporkRootBlock_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *Params_SporkRootBlock_Call) RunAndReturn(run func() *flow.Block) *Params_SporkRootBlock_Call {
	_c.Call.Return(run)
	return _c
}

// SporkRootBlockHeight provides a mock function for the type Params
func (_mock *Params) SporkRootBlockHeight() uint64 {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for SporkRootBlockHeight")
	}

	var r0 uint64
	if returnFunc, ok := ret.Get(0).(func() uint64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint64)
	}
	return r0
}

// Params_SporkRootBlockHeight_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SporkRootBlockHeight'
type Params_SporkRootBlockHeight_Call struct {
	*mock.Call
}

// SporkRootBlockHeight is a helper method to define mock.On call
func (_e *Params_Expecter) SporkRootBlockHeight() *Params_SporkRootBlockHeight_Call {
	return &Params_SporkRootBlockHeight_Call{Call: _e.mock.On("SporkRootBlockHeight")}
}

func (_c *Params_SporkRootBlockHeight_Call) Run(run func()) *Params_SporkRootBlockHeight_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Params_SporkRootBlockHeight_Call) Return(v uint64) *Params_SporkRootBlockHeight_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *Params_SporkRootBlockHeight_Call) RunAndReturn(run func() uint64) *Params_SporkRootBlockHeight_Call {
	_c.Call.Return(run)
	return _c
}

// SporkRootBlockView provides a mock function for the type Params
func (_mock *Params) SporkRootBlockView() uint64 {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for SporkRootBlockView")
	}

	var r0 uint64
	if returnFunc, ok := ret.Get(0).(func() uint64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint64)
	}
	return r0
}

// Params_SporkRootBlockView_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SporkRootBlockView'
type Params_SporkRootBlockView_Call struct {
	*mock.Call
}

// SporkRootBlockView is a helper method to define mock.On call
func (_e *Params_Expecter) SporkRootBlockView() *Params_SporkRootBlockView_Call {
	return &Params_SporkRootBlockView_Call{Call: _e.mock.On("SporkRootBlockView")}
}

func (_c *Params_SporkRootBlockView_Call) Run(run func()) *Params_SporkRootBlockView_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Params_SporkRootBlockView_Call) Return(v uint64) *Params_SporkRootBlockView_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *Params_SporkRootBlockView_Call) RunAndReturn(run func() uint64) *Params_SporkRootBlockView_Call {
	_c.Call.Return(run)
	return _c
}

// NewInstanceParams creates a new instance of InstanceParams. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewInstanceParams(t interface {
	mock.TestingT
	Cleanup(func())
}) *InstanceParams {
	mock := &InstanceParams{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// InstanceParams is an autogenerated mock type for the InstanceParams type
type InstanceParams struct {
	mock.Mock
}

type InstanceParams_Expecter struct {
	mock *mock.Mock
}

func (_m *InstanceParams) EXPECT() *InstanceParams_Expecter {
	return &InstanceParams_Expecter{mock: &_m.Mock}
}

// FinalizedRoot provides a mock function for the type InstanceParams
func (_mock *InstanceParams) FinalizedRoot() *flow.Header {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for FinalizedRoot")
	}

	var r0 *flow.Header
	if returnFunc, ok := ret.Get(0).(func() *flow.Header); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.Header)
		}
	}
	return r0
}

// InstanceParams_FinalizedRoot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FinalizedRoot'
type InstanceParams_FinalizedRoot_Call struct {
	*mock.Call
}

// FinalizedRoot is a helper method to define mock.On call
func (_e *InstanceParams_Expecter) FinalizedRoot() *InstanceParams_FinalizedRoot_Call {
	return &InstanceParams_FinalizedRoot_Call{Call: _e.mock.On("FinalizedRoot")}
}

func (_c *InstanceParams_FinalizedRoot_Call) Run(run func()) *InstanceParams_FinalizedRoot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *InstanceParams_FinalizedRoot_Call) Return(header *flow.Header) *InstanceParams_FinalizedRoot_Call {
	_c.Call.Return(header)
	return _c
}

func (_c *InstanceParams_FinalizedRoot_Call) RunAndReturn(run func() *flow.Header) *InstanceParams_FinalizedRoot_Call {
	_c.Call.Return(run)
	return _c
}

// Seal provides a mock function for the type InstanceParams
func (_mock *InstanceParams) Seal() *flow.Seal {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Seal")
	}

	var r0 *flow.Seal
	if returnFunc, ok := ret.Get(0).(func() *flow.Seal); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.Seal)
		}
	}
	return r0
}

// InstanceParams_Seal_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Seal'
type InstanceParams_Seal_Call struct {
	*mock.Call
}

// Seal is a helper method to define mock.On call
func (_e *InstanceParams_Expecter) Seal() *InstanceParams_Seal_Call {
	return &InstanceParams_Seal_Call{Call: _e.mock.On("Seal")}
}

func (_c *InstanceParams_Seal_Call) Run(run func()) *InstanceParams_Seal_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *InstanceParams_Seal_Call) Return(seal *flow.Seal) *InstanceParams_Seal_Call {
	_c.Call.Return(seal)
	return _c
}

func (_c *InstanceParams_Seal_Call) RunAndReturn(run func() *flow.Seal) *InstanceParams_Seal_Call {
	_c.Call.Return(run)
	return _c
}

// SealedRoot provides a mock function for the type InstanceParams
func (_mock *InstanceParams) SealedRoot() *flow.Header {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for SealedRoot")
	}

	var r0 *flow.Header
	if returnFunc, ok := ret.Get(0).(func() *flow.Header); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.Header)
		}
	}
	return r0
}

// InstanceParams_SealedRoot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SealedRoot'
type InstanceParams_SealedRoot_Call struct {
	*mock.Call
}

// SealedRoot is a helper method to define mock.On call
func (_e *InstanceParams_Expecter) SealedRoot() *InstanceParams_SealedRoot_Call {
	return &InstanceParams_SealedRoot_Call{Call: _e.mock.On("SealedRoot")}
}

func (_c *InstanceParams_SealedRoot_Call) Run(run func()) *InstanceParams_SealedRoot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *InstanceParams_SealedRoot_Call) Return(header *flow.Header) *InstanceParams_SealedRoot_Call {
	_c.Call.Return(header)
	return _c
}

func (_c *InstanceParams_SealedRoot_Call) RunAndReturn(run func() *flow.Header) *InstanceParams_SealedRoot_Call {
	_c.Call.Return(run)
	return _c
}

// SporkRootBlock provides a mock function for the type InstanceParams
func (_mock *InstanceParams) SporkRootBlock() *flow.Block {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for SporkRootBlock")
	}

	var r0 *flow.Block
	if returnFunc, ok := ret.Get(0).(func() *flow.Block); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.Block)
		}
	}
	return r0
}

// InstanceParams_SporkRootBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SporkRootBlock'
type InstanceParams_SporkRootBlock_Call struct {
	*mock.Call
}

// SporkRootBlock is a helper method to define mock.On call
func (_e *InstanceParams_Expecter) SporkRootBlock() *InstanceParams_SporkRootBlock_Call {
	return &InstanceParams_SporkRootBlock_Call{Call: _e.mock.On("SporkRootBlock")}
}

func (_c *InstanceParams_SporkRootBlock_Call) Run(run func()) *InstanceParams_SporkRootBlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *InstanceParams_SporkRootBlock_Call) Return(v *flow.Block) *InstanceParams_SporkRootBlock_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *InstanceParams_SporkRootBlock_Call) RunAndReturn(run func() *flow.Block) *InstanceParams_SporkRootBlock_Call {
	_c.Call.Return(run)
	return _c
}

// NewGlobalParams creates a new instance of GlobalParams. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewGlobalParams(t interface {
	mock.TestingT
	Cleanup(func())
}) *GlobalParams {
	mock := &GlobalParams{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// GlobalParams is an autogenerated mock type for the GlobalParams type
type GlobalParams struct {
	mock.Mock
}

type GlobalParams_Expecter struct {
	mock *mock.Mock
}

func (_m *GlobalParams) EXPECT() *GlobalParams_Expecter {
	return &GlobalParams_Expecter{mock: &_m.Mock}
}

// ChainID provides a mock function for the type GlobalParams
func (_mock *GlobalParams) ChainID() flow.ChainID {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for ChainID")
	}

	var r0 flow.ChainID
	if returnFunc, ok := ret.Get(0).(func() flow.ChainID); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(flow.ChainID)
	}
	return r0
}

// GlobalParams_ChainID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChainID'
type GlobalParams_ChainID_Call struct {
	*mock.Call
}

// ChainID is a helper method to define mock.On call
func (_e *GlobalParams_Expecter) ChainID() *GlobalParams_ChainID_Call {
	return &GlobalParams_ChainID_Call{Call: _e.mock.On("ChainID")}
}

func (_c *GlobalParams_ChainID_Call) Run(run func()) *GlobalParams_ChainID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *GlobalParams_ChainID_Call) Return(chainID flow.ChainID) *GlobalParams_ChainID_Call {
	_c.Call.Return(chainID)
	return _c
}

func (_c *GlobalParams_ChainID_Call) RunAndReturn(run func() flow.ChainID) *GlobalParams_ChainID_Call {
	_c.Call.Return(run)
	return _c
}

// SporkID provides a mock function for the type GlobalParams
func (_mock *GlobalParams) SporkID() flow.Identifier {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for SporkID")
	}

	var r0 flow.Identifier
	if returnFunc, ok := ret.Get(0).(func() flow.Identifier); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.Identifier)
		}
	}
	return r0
}

// GlobalParams_SporkID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SporkID'
type GlobalParams_SporkID_Call struct {
	*mock.Call
}

// SporkID is a helper method to define mock.On call
func (_e *GlobalParams_Expecter) SporkID() *GlobalParams_SporkID_Call {
	return &GlobalParams_SporkID_Call{Call: _e.mock.On("SporkID")}
}

func (_c *GlobalParams_SporkID_Call) Run(run func()) *GlobalParams_SporkID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *GlobalParams_SporkID_Call) Return(identifier flow.Identifier) *GlobalParams_SporkID_Call {
	_c.Call.Return(identifier)
	return _c
}

func (_c *GlobalParams_SporkID_Call) RunAndReturn(run func() flow.Identifier) *GlobalParams_SporkID_Call {
	_c.Call.Return(run)
	return _c
}

// SporkRootBlockHeight provides a mock function for the type GlobalParams
func (_mock *GlobalParams) SporkRootBlockHeight() uint64 {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for SporkRootBlockHeight")
	}

	var r0 uint64
	if returnFunc, ok := ret.Get(0).(func() uint64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint64)
	}
	return r0
}

// GlobalParams_SporkRootBlockHeight_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SporkRootBlockHeight'
type GlobalParams_SporkRootBlockHeight_Call struct {
	*mock.Call
}

// SporkRootBlockHeight is a helper method to define mock.On call
func (_e *GlobalParams_Expecter) SporkRootBlockHeight() *GlobalParams_SporkRootBlockHeight_Call {
	return &GlobalParams_SporkRootBlockHeight_Call{Call: _e.mock.On("SporkRootBlockHeight")}
}

func (_c *GlobalParams_SporkRootBlockHeight_Call) Run(run func()) *GlobalParams_SporkRootBlockHeight_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *GlobalParams_SporkRootBlockHeight_Call) Return(v uint64) *GlobalParams_SporkRootBlockHeight_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *GlobalParams_SporkRootBlockHeight_Call) RunAndReturn(run func() uint64) *GlobalParams_SporkRootBlockHeight_Call {
	_c.Call.Return(run)
	return _c
}

// SporkRootBlockView provides a mock function for the type GlobalParams
func (_mock *GlobalParams) SporkRootBlockView() uint64 {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for SporkRootBlockView")
	}

	var r0 uint64
	if returnFunc, ok := ret.Get(0).(func() uint64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint64)
	}
	return r0
}

// GlobalParams_SporkRootBlockView_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SporkRootBlockView'
type GlobalParams_SporkRootBlockView_Call struct {
	*mock.Call
}

// SporkRootBlockView is a helper method to define mock.On call
func (_e *GlobalParams_Expecter) SporkRootBlockView() *GlobalParams_SporkRootBlockView_Call {
	return &GlobalParams_SporkRootBlockView_Call{Call: _e.mock.On("SporkRootBlockView")}
}

func (_c *GlobalParams_SporkRootBlockView_Call) Run(run func()) *GlobalParams_SporkRootBlockView_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *GlobalParams_SporkRootBlockView_Call) Return(v uint64) *GlobalParams_SporkRootBlockView_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *GlobalParams_SporkRootBlockView_Call) RunAndReturn(run func() uint64) *GlobalParams_SporkRootBlockView_Call {
	_c.Call.Return(run)
	return _c
}

// NewEpochProtocolState creates a new instance of EpochProtocolState. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewEpochProtocolState(t interface {
	mock.TestingT
	Cleanup(func())
}) *EpochProtocolState {
	mock := &EpochProtocolState{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// EpochProtocolState is an autogenerated mock type for the EpochProtocolState type
type EpochProtocolState struct {
	mock.Mock
}

type EpochProtocolState_Expecter struct {
	mock *mock.Mock
}

func (_m *EpochProtocolState) EXPECT() *EpochProtocolState_Expecter {
	return &EpochProtocolState_Expecter{mock: &_m.Mock}
}

// Clustering provides a mock function for the type EpochProtocolState
func (_mock *EpochProtocolState) Clustering() (flow.ClusterList, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Clustering")
	}

	var r0 flow.ClusterList
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (flow.ClusterList, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() flow.ClusterList); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.ClusterList)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// EpochProtocolState_Clustering_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Clustering'
type EpochProtocolState_Clustering_Call struct {
	*mock.Call
}

// Clustering is a helper method to define mock.On call
func (_e *EpochProtocolState_Expecter) Clustering() *EpochProtocolState_Clustering_Call {
	return &EpochProtocolState_Clustering_Call{Call: _e.mock.On("Clustering")}
}

func (_c *EpochProtocolState_Clustering_Call) Run(run func()) *EpochProtocolState_Clustering_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *EpochProtocolState_Clustering_Call) Return(clusterList flow.ClusterList, err error) *EpochProtocolState_Clustering_Call {
	_c.Call.Return(clusterList, err)
	return _c
}

func (_c *EpochProtocolState_Clustering_Call) RunAndReturn(run func() (flow.ClusterList, error)) *EpochProtocolState_Clustering_Call {
	_c.Call.Return(run)
	return _c
}

// DKG provides a mock function for the type EpochProtocolState
func (_mock *EpochProtocolState) DKG() (protocol.DKG, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for DKG")
	}

	var r0 protocol.DKG
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (protocol.DKG, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() protocol.DKG); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(protocol.DKG)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// EpochProtocolState_DKG_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DKG'
type EpochProtocolState_DKG_Call struct {
	*mock.Call
}

// DKG is a helper method to define mock.On call
func (_e *EpochProtocolState_Expecter) DKG() *EpochProtocolState_DKG_Call {
	return &EpochProtocolState_DKG_Call{Call: _e.mock.On("DKG")}
}

func (_c *EpochProtocolState_DKG_Call) Run(run func()) *EpochProtocolState_DKG_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *EpochProtocolState_DKG_Call) Return(dKG protocol.DKG, err error) *EpochProtocolState_DKG_Call {
	_c.Call.Return(dKG, err)
	return _c
}

func (_c *EpochProtocolState_DKG_Call) RunAndReturn(run func() (protocol.DKG, error)) *EpochProtocolState_DKG_Call {
	_c.Call.Return(run)
	return _c
}

// Entry provides a mock function for the type EpochProtocolState
func (_mock *EpochProtocolState) Entry() *flow.RichEpochStateEntry {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Entry")
	}

	var r0 *flow.RichEpochStateEntry
	if returnFunc, ok := ret.Get(0).(func() *flow.RichEpochStateEntry); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.RichEpochStateEntry)
		}
	}
	return r0
}

// EpochProtocolState_Entry_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Entry'
type EpochProtocolState_Entry_Call struct {
	*mock.Call
}

// Entry is a helper method to define mock.On call
func (_e *EpochProtocolState_Expecter) Entry() *EpochProtocolState_Entry_Call {
	return &EpochProtocolState_Entry_Call{Call: _e.mock.On("Entry")}
}

func (_c *EpochProtocolState_Entry_Call) Run(run func()) *EpochProtocolState_Entry_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *EpochProtocolState_Entry_Call) Return(richEpochStateEntry *flow.RichEpochStateEntry) *EpochProtocolState_Entry_Call {
	_c.Call.Return(richEpochStateEntry)
	return _c
}

func (_c *EpochProtocolState_Entry_Call) RunAndReturn(run func() *flow.RichEpochStateEntry) *EpochProtocolState_Entry_Call {
	_c.Call.Return(run)
	return _c
}

// Epoch provides a mock function for the type EpochProtocolState
func (_mock *EpochProtocolState) Epoch() uint64 {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Epoch")
	}

	var r0 uint64
	if returnFunc, ok := ret.Get(0).(func() uint64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint64)
	}
	return r0
}

// EpochProtocolState_Epoch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Epoch'
type EpochProtocolState_Epoch_Call struct {
	*mock.Call
}

// Epoch is a helper method to define mock.On call
func (_e *EpochProtocolState_Expecter) Epoch() *EpochProtocolState_Epoch_Call {
	return &EpochProtocolState_Epoch_Call{Call: _e.mock.On("Epoch")}
}

func (_c *EpochProtocolState_Epoch_Call) Run(run func()) *EpochProtocolState_Epoch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *EpochProtocolState_Epoch_Call) Return(v uint64) *EpochProtocolState_Epoch_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *EpochProtocolState_Epoch_Call) RunAndReturn(run func() uint64) *EpochProtocolState_Epoch_Call {
	_c.Call.Return(run)
	return _c
}

// EpochCommit provides a mock function for the type EpochProtocolState
func (_mock *EpochProtocolState) EpochCommit() *flow.EpochCommit {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for EpochCommit")
	}

	var r0 *flow.EpochCommit
	if returnFunc, ok := ret.Get(0).(func() *flow.EpochCommit); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.EpochCommit)
		}
	}
	return r0
}

// EpochProtocolState_EpochCommit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EpochCommit'
type EpochProtocolState_EpochCommit_Call struct {
	*mock.Call
}

// EpochCommit is a helper method to define mock.On call
func (_e *EpochProtocolState_Expecter) EpochCommit() *EpochProtocolState_EpochCommit_Call {
	return &EpochProtocolState_EpochCommit_Call{Call: _e.mock.On("EpochCommit")}
}

func (_c *EpochProtocolState_EpochCommit_Call) Run(run func()) *EpochProtocolState_EpochCommit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *EpochProtocolState_EpochCommit_Call) Return(epochCommit *flow.EpochCommit) *EpochProtocolState_EpochCommit_Call {
	_c.Call.Return(epochCommit)
	return _c
}

func (_c *EpochProtocolState_EpochCommit_Call) RunAndReturn(run func() *flow.EpochCommit) *EpochProtocolState_EpochCommit_Call {
	_c.Call.Return(run)
	return _c
}

// EpochExtensions provides a mock function for the type EpochProtocolState
func (_mock *EpochProtocolState) EpochExtensions() []flow.EpochExtension {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for EpochExtensions")
	}

	var r0 []flow.EpochExtension
	if returnFunc, ok := ret.Get(0).(func() []flow.EpochExtension); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]flow.EpochExtension)
		}
	}
	return r0
}

// EpochProtocolState_EpochExtensions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EpochExtensions'
type EpochProtocolState_EpochExtensions_Call struct {
	*mock.Call
}

// EpochExtensions is a helper method to define mock.On call
func (_e *EpochProtocolState_Expecter) EpochExtensions() *EpochProtocolState_EpochExtensions_Call {
	return &EpochProtocolState_EpochExtensions_Call{Call: _e.mock.On("EpochExtensions")}
}

func (_c *EpochProtocolState_EpochExtensions_Call) Run(run func()) *EpochProtocolState_EpochExtensions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *EpochProtocolState_EpochExtensions_Call) Return(epochExtensions []flow.EpochExtension) *EpochProtocolState_EpochExtensions_Call {
	_c.Call.Return(epochExtensions)
	return _c
}

func (_c *EpochProtocolState_EpochExtensions_Call) RunAndReturn(run func() []flow.EpochExtension) *EpochProtocolState_EpochExtensions_Call {
	_c.Call.Return(run)
	return _c
}

// EpochFallbackTriggered provides a mock function for the type EpochProtocolState
func (_mock *EpochProtocolState) EpochFallbackTriggered() bool {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for EpochFallbackTriggered")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func() bool); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// EpochProtocolState_EpochFallbackTriggered_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EpochFallbackTriggered'
type EpochProtocolState_EpochFallbackTriggered_Call struct {
	*mock.Call
}

// EpochFallbackTriggered is a helper method to define mock.On call
func (_e *EpochProtocolState_Expecter) EpochFallbackTriggered() *EpochProtocolState_EpochFallbackTriggered_Call {
	return &EpochProtocolState_EpochFallbackTriggered_Call{Call: _e.mock.On("EpochFallbackTriggered")}
}

func (_c *EpochProtocolState_EpochFallbackTriggered_Call) Run(run func()) *EpochProtocolState_EpochFallbackTriggered_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *EpochProtocolState_EpochFallbackTriggered_Call) Return(b bool) *EpochProtocolState_EpochFallbackTriggered_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *EpochProtocolState_EpochFallbackTriggered_Call) RunAndReturn(run func() bool) *EpochProtocolState_EpochFallbackTriggered_Call {
	_c.Call.Return(run)
	return _c
}

// EpochPhase provides a mock function for the type EpochProtocolState
func (_mock *EpochProtocolState) EpochPhase() flow.EpochPhase {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for EpochPhase")
	}

	var r0 flow.EpochPhase
	if returnFunc, ok := ret.Get(0).(func() flow.EpochPhase); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(flow.EpochPhase)
	}
	return r0
}

// EpochProtocolState_EpochPhase_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EpochPhase'
type EpochProtocolState_EpochPhase_Call struct {
	*mock.Call
}

// EpochPhase is a helper method to define mock.On call
func (_e *EpochProtocolState_Expecter) EpochPhase() *EpochProtocolState_EpochPhase_Call {
	return &EpochProtocolState_EpochPhase_Call{Call: _e.mock.On("EpochPhase")}
}

func (_c *EpochProtocolState_EpochPhase_Call) Run(run func()) *EpochProtocolState_EpochPhase_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *EpochProtocolState_EpochPhase_Call) Return(epochPhase flow.EpochPhase) *EpochProtocolState_EpochPhase_Call {
	_c.Call.Return(epochPhase)
	return _c
}

func (_c *EpochProtocolState_EpochPhase_Call) RunAndReturn(run func() flow.EpochPhase) *EpochProtocolState_EpochPhase_Call {
	_c.Call.Return(run)
	return _c
}

// EpochSetup provides a mock function for the type EpochProtocolState
func (_mock *EpochProtocolState) EpochSetup() *flow.EpochSetup {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for EpochSetup")
	}

	var r0 *flow.EpochSetup
	if returnFunc, ok := ret.Get(0).(func() *flow.EpochSetup); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.EpochSetup)
		}
	}
	return r0
}

// EpochProtocolState_EpochSetup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EpochSetup'
type EpochProtocolState_EpochSetup_Call struct {
	*mock.Call
}

// EpochSetup is a helper method to define mock.On call
func (_e *EpochProtocolState_Expecter) EpochSetup() *EpochProtocolState_EpochSetup_Call {
	return &EpochProtocolState_EpochSetup_Call{Call: _e.mock.On("EpochSetup")}
}

func (_c *EpochProtocolState_EpochSetup_Call) Run(run func()) *EpochProtocolState_EpochSetup_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *EpochProtocolState_EpochSetup_Call) Return(epochSetup *flow.EpochSetup) *EpochProtocolState_EpochSetup_Call {
	_c.Call.Return(epochSetup)
	return _c
}

func (_c *EpochProtocolState_EpochSetup_Call) RunAndReturn(run func() *flow.EpochSetup) *EpochProtocolState_EpochSetup_Call {
	_c.Call.Return(run)
	return _c
}

// GlobalParams provides a mock function for the type EpochProtocolState
func (_mock *EpochProtocolState) GlobalParams() protocol.GlobalParams {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GlobalParams")
	}

	var r0 protocol.GlobalParams
	if returnFunc, ok := ret.Get(0).(func() protocol.GlobalParams); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(protocol.GlobalParams)
		}
	}
	return r0
}

// EpochProtocolState_GlobalParams_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GlobalParams'
type EpochProtocolState_GlobalParams_Call struct {
	*mock.Call
}

// GlobalParams is a helper method to define mock.On call
func (_e *EpochProtocolState_Expecter) GlobalParams() *EpochProtocolState_GlobalParams_Call {
	return &EpochProtocolState_GlobalParams_Call{Call: _e.mock.On("GlobalParams")}
}

func (_c *EpochProtocolState_GlobalParams_Call) Run(run func()) *EpochProtocolState_GlobalParams_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *EpochProtocolState_GlobalParams_Call) Return(globalParams protocol.GlobalParams) *EpochProtocolState_GlobalParams_Call {
	_c.Call.Return(globalParams)
	return _c
}

func (_c *EpochProtocolState_GlobalParams_Call) RunAndReturn(run func() protocol.GlobalParams) *EpochProtocolState_GlobalParams_Call {
	_c.Call.Return(run)
	return _c
}

// Identities provides a mock function for the type EpochProtocolState
func (_mock *EpochProtocolState) Identities() flow.IdentityList {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Identities")
	}

	var r0 flow.IdentityList
	if returnFunc, ok := ret.Get(0).(func() flow.IdentityList); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.IdentityList)
		}
	}
	return r0
}

// EpochProtocolState_Identities_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Identities'
type EpochProtocolState_Identities_Call struct {
	*mock.Call
}

// Identities is a helper method to define mock.On call
func (_e *EpochProtocolState_Expecter) Identities() *EpochProtocolState_Identities_Call {
	return &EpochProtocolState_Identities_Call{Call: _e.mock.On("Identities")}
}

func (_c *EpochProtocolState_Identities_Call) Run(run func()) *EpochProtocolState_Identities_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *EpochProtocolState_Identities_Call) Return(v flow.IdentityList) *EpochProtocolState_Identities_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *EpochProtocolState_Identities_Call) RunAndReturn(run func() flow.IdentityList) *EpochProtocolState_Identities_Call {
	_c.Call.Return(run)
	return _c
}

// PreviousEpochExists provides a mock function for the type EpochProtocolState
func (_mock *EpochProtocolState) PreviousEpochExists() bool {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for PreviousEpochExists")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func() bool); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// EpochProtocolState_PreviousEpochExists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PreviousEpochExists'
type EpochProtocolState_PreviousEpochExists_Call struct {
	*mock.Call
}

// PreviousEpochExists is a helper method to define mock.On call
func (_e *EpochProtocolState_Expecter) PreviousEpochExists() *EpochProtocolState_PreviousEpochExists_Call {
	return &EpochProtocolState_PreviousEpochExists_Call{Call: _e.mock.On("PreviousEpochExists")}
}

func (_c *EpochProtocolState_PreviousEpochExists_Call) Run(run func()) *EpochProtocolState_PreviousEpochExists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *EpochProtocolState_PreviousEpochExists_Call) Return(b bool) *EpochProtocolState_PreviousEpochExists_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *EpochProtocolState_PreviousEpochExists_Call) RunAndReturn(run func() bool) *EpochProtocolState_PreviousEpochExists_Call {
	_c.Call.Return(run)
	return _c
}

// NewProtocolState creates a new instance of ProtocolState. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewProtocolState(t interface {
	mock.TestingT
	Cleanup(func())
}) *ProtocolState {
	mock := &ProtocolState{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// ProtocolState is an autogenerated mock type for the ProtocolState type
type ProtocolState struct {
	mock.Mock
}

type ProtocolState_Expecter struct {
	mock *mock.Mock
}

func (_m *ProtocolState) EXPECT() *ProtocolState_Expecter {
	return &ProtocolState_Expecter{mock: &_m.Mock}
}

// EpochStateAtBlockID provides a mock function for the type ProtocolState
func (_mock *ProtocolState) EpochStateAtBlockID(blockID flow.Identifier) (protocol.EpochProtocolState, error) {
	ret := _mock.Called(blockID)

	if len(ret) == 0 {
		panic("no return value specified for EpochStateAtBlockID")
	}

	var r0 protocol.EpochProtocolState
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (protocol.EpochProtocolState, error)); ok {
		return returnFunc(blockID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) protocol.EpochProtocolState); ok {
		r0 = returnFunc(blockID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(protocol.EpochProtocolState)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(blockID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ProtocolState_EpochStateAtBlockID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EpochStateAtBlockID'
type ProtocolState_EpochStateAtBlockID_Call struct {
	*mock.Call
}

// EpochStateAtBlockID is a helper method to define mock.On call
//   - blockID flow.Identifier
func (_e *ProtocolState_Expecter) EpochStateAtBlockID(blockID interface{}) *ProtocolState_EpochStateAtBlockID_Call {
	return &ProtocolState_EpochStateAtBlockID_Call{Call: _e.mock.On("EpochStateAtBlockID", blockID)}
}

func (_c *ProtocolState_EpochStateAtBlockID_Call) Run(run func(blockID flow.Identifier)) *ProtocolState_EpochStateAtBlockID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ProtocolState_EpochStateAtBlockID_Call) Return(epochProtocolState protocol.EpochProtocolState, err error) *ProtocolState_EpochStateAtBlockID_Call {
	_c.Call.Return(epochProtocolState, err)
	return _c
}

func (_c *ProtocolState_EpochStateAtBlockID_Call) RunAndReturn(run func(blockID flow.Identifier) (protocol.EpochProtocolState, error)) *ProtocolState_EpochStateAtBlockID_Call {
	_c.Call.Return(run)
	return _c
}

// GlobalParams provides a mock function for the type ProtocolState
func (_mock *ProtocolState) GlobalParams() protocol.GlobalParams {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GlobalParams")
	}

	var r0 protocol.GlobalParams
	if returnFunc, ok := ret.Get(0).(func() protocol.GlobalParams); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(protocol.GlobalParams)
		}
	}
	return r0
}

// ProtocolState_GlobalParams_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GlobalParams'
type ProtocolState_GlobalParams_Call struct {
	*mock.Call
}

// GlobalParams is a helper method to define mock.On call
func (_e *ProtocolState_Expecter) GlobalParams() *ProtocolState_GlobalParams_Call {
	return &ProtocolState_GlobalParams_Call{Call: _e.mock.On("GlobalParams")}
}

func (_c *ProtocolState_GlobalParams_Call) Run(run func()) *ProtocolState_GlobalParams_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ProtocolState_GlobalParams_Call) Return(globalParams protocol.GlobalParams) *ProtocolState_GlobalParams_Call {
	_c.Call.Return(globalParams)
	return _c
}

func (_c *ProtocolState_GlobalParams_Call) RunAndReturn(run func() protocol.GlobalParams) *ProtocolState_GlobalParams_Call {
	_c.Call.Return(run)
	return _c
}

// KVStoreAtBlockID provides a mock function for the type ProtocolState
func (_mock *ProtocolState) KVStoreAtBlockID(blockID flow.Identifier) (protocol.KVStoreReader, error) {
	ret := _mock.Called(blockID)

	if len(ret) == 0 {
		panic("no return value specified for KVStoreAtBlockID")
	}

	var r0 protocol.KVStoreReader
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (protocol.KVStoreReader, error)); ok {
		return returnFunc(blockID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) protocol.KVStoreReader); ok {
		r0 = returnFunc(blockID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(protocol.KVStoreReader)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(blockID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ProtocolState_KVStoreAtBlockID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'KVStoreAtBlockID'
type ProtocolState_KVStoreAtBlockID_Call struct {
	*mock.Call
}

// KVStoreAtBlockID is a helper method to define mock.On call
//   - blockID flow.Identifier
func (_e *ProtocolState_Expecter) KVStoreAtBlockID(blockID interface{}) *ProtocolState_KVStoreAtBlockID_Call {
	return &ProtocolState_KVStoreAtBlockID_Call{Call: _e.mock.On("KVStoreAtBlockID", blockID)}
}

func (_c *ProtocolState_KVStoreAtBlockID_Call) Run(run func(blockID flow.Identifier)) *ProtocolState_KVStoreAtBlockID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ProtocolState_KVStoreAtBlockID_Call) Return(kVStoreReader protocol.KVStoreReader, err error) *ProtocolState_KVStoreAtBlockID_Call {
	_c.Call.Return(kVStoreReader, err)
	return _c
}

func (_c *ProtocolState_KVStoreAtBlockID_Call) RunAndReturn(run func(blockID flow.Identifier) (protocol.KVStoreReader, error)) *ProtocolState_KVStoreAtBlockID_Call {
	_c.Call.Return(run)
	return _c
}

// NewMutableProtocolState creates a new instance of MutableProtocolState. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMutableProtocolState(t interface {
	mock.TestingT
	Cleanup(func())
}) *MutableProtocolState {
	mock := &MutableProtocolState{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MutableProtocolState is an autogenerated mock type for the MutableProtocolState type
type MutableProtocolState struct {
	mock.Mock
}

type MutableProtocolState_Expecter struct {
	mock *mock.Mock
}

func (_m *MutableProtocolState) EXPECT() *MutableProtocolState_Expecter {
	return &MutableProtocolState_Expecter{mock: &_m.Mock}
}

// EpochStateAtBlockID provides a mock function for the type MutableProtocolState
func (_mock *MutableProtocolState) EpochStateAtBlockID(blockID flow.Identifier) (protocol.EpochProtocolState, error) {
	ret := _mock.Called(blockID)

	if len(ret) == 0 {
		panic("no return value specified for EpochStateAtBlockID")
	}

	var r0 protocol.EpochProtocolState
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (protocol.EpochProtocolState, error)); ok {
		return returnFunc(blockID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) protocol.EpochProtocolState); ok {
		r0 = returnFunc(blockID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(protocol.EpochProtocolState)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(blockID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MutableProtocolState_EpochStateAtBlockID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EpochStateAtBlockID'
type MutableProtocolState_EpochStateAtBlockID_Call struct {
	*mock.Call
}

// EpochStateAtBlockID is a helper method to define mock.On call
//   - blockID flow.Identifier
func (_e *MutableProtocolState_Expecter) EpochStateAtBlockID(blockID interface{}) *MutableProtocolState_EpochStateAtBlockID_Call {
	return &MutableProtocolState_EpochStateAtBlockID_Call{Call: _e.mock.On("EpochStateAtBlockID", blockID)}
}

func (_c *MutableProtocolState_EpochStateAtBlockID_Call) Run(run func(blockID flow.Identifier)) *MutableProtocolState_EpochStateAtBlockID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MutableProtocolState_EpochStateAtBlockID_Call) Return(epochProtocolState protocol.EpochProtocolState, err error) *MutableProtocolState_EpochStateAtBlockID_Call {
	_c.Call.Return(epochProtocolState, err)
	return _c
}

func (_c *MutableProtocolState_EpochStateAtBlockID_Call) RunAndReturn(run func(blockID flow.Identifier) (protocol.EpochProtocolState, error)) *MutableProtocolState_EpochStateAtBlockID_Call {
	_c.Call.Return(run)
	return _c
}

// EvolveState provides a mock function for the type MutableProtocolState
func (_mock *MutableProtocolState) EvolveState(deferredDBOps *deferred.DeferredBlockPersist, parentBlockID flow.Identifier, candidateView uint64, candidateSeals []*flow.Seal) (flow.Identifier, error) {
	ret := _mock.Called(deferredDBOps, parentBlockID, candidateView, candidateSeals)

	if len(ret) == 0 {
		panic("no return value specified for EvolveState")
	}

	var r0 flow.Identifier
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*deferred.DeferredBlockPersist, flow.Identifier, uint64, []*flow.Seal) (flow.Identifier, error)); ok {
		return returnFunc(deferredDBOps, parentBlockID, candidateView, candidateSeals)
	}
	if returnFunc, ok := ret.Get(0).(func(*deferred.DeferredBlockPersist, flow.Identifier, uint64, []*flow.Seal) flow.Identifier); ok {
		r0 = returnFunc(deferredDBOps, parentBlockID, candidateView, candidateSeals)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.Identifier)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*deferred.DeferredBlockPersist, flow.Identifier, uint64, []*flow.Seal) error); ok {
		r1 = returnFunc(deferredDBOps, parentBlockID, candidateView, candidateSeals)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MutableProtocolState_EvolveState_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EvolveState'
type MutableProtocolState_EvolveState_Call struct {
	*mock.Call
}

// EvolveState is a helper method to define mock.On call
//   - deferredDBOps *deferred.DeferredBlockPersist
//   - parentBlockID flow.Identifier
//   - candidateView uint64
//   - candidateSeals []*flow.Seal
func (_e *MutableProtocolState_Expecter) EvolveState(deferredDBOps interface{}, parentBlockID interface{}, candidateView interface{}, candidateSeals interface{}) *MutableProtocolState_EvolveState_Call {
	return &MutableProtocolState_EvolveState_Call{Call: _e.mock.On("EvolveState", deferredDBOps, parentBlockID, candidateView, candidateSeals)}
}

func (_c *MutableProtocolState_EvolveState_Call) Run(run func(deferredDBOps *deferred.DeferredBlockPersist, parentBlockID flow.Identifier, candidateView uint64, candidateSeals []*flow.Seal)) *MutableProtocolState_EvolveState_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *deferred.DeferredBlockPersist
		if args[0] != nil {
			arg0 = args[0].(*deferred.DeferredBlockPersist)
		}
		var arg1 flow.Identifier
		if args[1] != nil {
			arg1 = args[1].(flow.Identifier)
		}
		var arg2 uint64
		if args[2] != nil {
			arg2 = args[2].(uint64)
		}
		var arg3 []*flow.Seal
		if args[3] != nil {
			arg3 = args[3].([]*flow.Seal)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MutableProtocolState_EvolveState_Call) Return(stateID flow.Identifier, err error) *MutableProtocolState_EvolveState_Call {
	_c.Call.Return(stateID, err)
	return _c
}

func (_c *MutableProtocolState_EvolveState_Call) RunAndReturn(run func(deferredDBOps *deferred.DeferredBlockPersist, parentBlockID flow.Identifier, candidateView uint64, candidateSeals []*flow.Seal) (flow.Identifier, error)) *MutableProtocolState_EvolveState_Call {
	_c.Call.Return(run)
	return _c
}

// GlobalParams provides a mock function for the type MutableProtocolState
func (_mock *MutableProtocolState) GlobalParams() protocol.GlobalParams {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GlobalParams")
	}

	var r0 protocol.GlobalParams
	if returnFunc, ok := ret.Get(0).(func() protocol.GlobalParams); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(protocol.GlobalParams)
		}
	}
	return r0
}

// MutableProtocolState_GlobalParams_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GlobalParams'
type MutableProtocolState_GlobalParams_Call struct {
	*mock.Call
}

// GlobalParams is a helper method to define mock.On call
func (_e *MutableProtocolState_Expecter) GlobalParams() *MutableProtocolState_GlobalParams_Call {
	return &MutableProtocolState_GlobalParams_Call{Call: _e.mock.On("GlobalParams")}
}

func (_c *MutableProtocolState_GlobalParams_Call) Run(run func()) *MutableProtocolState_GlobalParams_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MutableProtocolState_GlobalParams_Call) Return(globalParams protocol.GlobalParams) *MutableProtocolState_GlobalParams_Call {
	_c.Call.Return(globalParams)
	return _c
}

func (_c *MutableProtocolState_GlobalParams_Call) RunAndReturn(run func() protocol.GlobalParams) *MutableProtocolState_GlobalParams_Call {
	_c.Call.Return(run)
	return _c
}

// KVStoreAtBlockID provides a mock function for the type MutableProtocolState
func (_mock *MutableProtocolState) KVStoreAtBlockID(blockID flow.Identifier) (protocol.KVStoreReader, error) {
	ret := _mock.Called(blockID)

	if len(ret) == 0 {
		panic("no return value specified for KVStoreAtBlockID")
	}

	var r0 protocol.KVStoreReader
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (protocol.KVStoreReader, error)); ok {
		return returnFunc(blockID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) protocol.KVStoreReader); ok {
		r0 = returnFunc(blockID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(protocol.KVStoreReader)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(blockID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MutableProtocolState_KVStoreAtBlockID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'KVStoreAtBlockID'
type MutableProtocolState_KVStoreAtBlockID_Call struct {
	*mock.Call
}

// KVStoreAtBlockID is a helper method to define mock.On call
//   - blockID flow.Identifier
func (_e *MutableProtocolState_Expecter) KVStoreAtBlockID(blockID interface{}) *MutableProtocolState_KVStoreAtBlockID_Call {
	return &MutableProtocolState_KVStoreAtBlockID_Call{Call: _e.mock.On("KVStoreAtBlockID", blockID)}
}

func (_c *MutableProtocolState_KVStoreAtBlockID_Call) Run(run func(blockID flow.Identifier)) *MutableProtocolState_KVStoreAtBlockID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MutableProtocolState_KVStoreAtBlockID_Call) Return(kVStoreReader protocol.KVStoreReader, err error) *MutableProtocolState_KVStoreAtBlockID_Call {
	_c.Call.Return(kVStoreReader, err)
	return _c
}

func (_c *MutableProtocolState_KVStoreAtBlockID_Call) RunAndReturn(run func(blockID flow.Identifier) (protocol.KVStoreReader, error)) *MutableProtocolState_KVStoreAtBlockID_Call {
	_c.Call.Return(run)
	return _c
}

// NewSnapshot creates a new instance of Snapshot. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewSnapshot(t interface {
	mock.TestingT
	Cleanup(func())
}) *Snapshot {
	mock := &Snapshot{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Snapshot is an autogenerated mock type for the Snapshot type
type Snapshot struct {
	mock.Mock
}

type Snapshot_Expecter struct {
	mock *mock.Mock
}

func (_m *Snapshot) EXPECT() *Snapshot_Expecter {
	return &Snapshot_Expecter{mock: &_m.Mock}
}

// Commit provides a mock function for the type Snapshot
func (_mock *Snapshot) Commit() (flow.StateCommitment, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Commit")
	}

	var r0 flow.StateCommitment
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (flow.StateCommitment, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() flow.StateCommitment); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.StateCommitment)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Snapshot_Commit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Commit'
type Snapshot_Commit_Call struct {
	*mock.Call
}

// Commit is a helper method to define mock.On call
func (_e *Snapshot_Expecter) Commit() *Snapshot_Commit_Call {
	return &Snapshot_Commit_Call{Call: _e.mock.On("Commit")}
}

func (_c *Snapshot_Commit_Call) Run(run func()) *Snapshot_Commit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Snapshot_Commit_Call) Return(stateCommitment flow.StateCommitment, err error) *Snapshot_Commit_Call {
	_c.Call.Return(stateCommitment, err)
	return _c
}

func (_c *Snapshot_Commit_Call) RunAndReturn(run func() (flow.StateCommitment, error)) *Snapshot_Commit_Call {
	_c.Call.Return(run)
	return _c
}

// Descendants provides a mock function for the type Snapshot
func (_mock *Snapshot) Descendants() ([]flow.Identifier, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Descendants")
	}

	var r0 []flow.Identifier
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() ([]flow.Identifier, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() []flow.Identifier); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]flow.Identifier)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Snapshot_Descendants_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Descendants'
type Snapshot_Descendants_Call struct {
	*mock.Call
}

// Descendants is a helper method to define mock.On call
func (_e *Snapshot_Expecter) Descendants() *Snapshot_Descendants_Call {
	return &Snapshot_Descendants_Call{Call: _e.mock.On("Descendants")}
}

func (_c *Snapshot_Descendants_Call) Run(run func()) *Snapshot_Descendants_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Snapshot_Descendants_Call) Return(identifiers []flow.Identifier, err error) *Snapshot_Descendants_Call {
	_c.Call.Return(identifiers, err)
	return _c
}

func (_c *Snapshot_Descendants_Call) RunAndReturn(run func() ([]flow.Identifier, error)) *Snapshot_Descendants_Call {
	_c.Call.Return(run)
	return _c
}

// EpochPhase provides a mock function for the type Snapshot
func (_mock *Snapshot) EpochPhase() (flow.EpochPhase, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for EpochPhase")
	}

	var r0 flow.EpochPhase
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (flow.EpochPhase, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() flow.EpochPhase); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(flow.EpochPhase)
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Snapshot_EpochPhase_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EpochPhase'
type Snapshot_EpochPhase_Call struct {
	*mock.Call
}

// EpochPhase is a helper method to define mock.On call
func (_e *Snapshot_Expecter) EpochPhase() *Snapshot_EpochPhase_Call {
	return &Snapshot_EpochPhase_Call{Call: _e.mock.On("EpochPhase")}
}

func (_c *Snapshot_EpochPhase_Call) Run(run func()) *Snapshot_EpochPhase_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Snapshot_EpochPhase_Call) Return(epochPhase flow.EpochPhase, err error) *Snapshot_EpochPhase_Call {
	_c.Call.Return(epochPhase, err)
	return _c
}

func (_c *Snapshot_EpochPhase_Call) RunAndReturn(run func() (flow.EpochPhase, error)) *Snapshot_EpochPhase_Call {
	_c.Call.Return(run)
	return _c
}

// EpochProtocolState provides a mock function for the type Snapshot
func (_mock *Snapshot) EpochProtocolState() (protocol.EpochProtocolState, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for EpochProtocolState")
	}

	var r0 protocol.EpochProtocolState
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (protocol.EpochProtocolState, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() protocol.EpochProtocolState); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(protocol.EpochProtocolState)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Snapshot_EpochProtocolState_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EpochProtocolState'
type Snapshot_EpochProtocolState_Call struct {
	*mock.Call
}

// EpochProtocolState is a helper method to define mock.On call
func (_e *Snapshot_Expecter) EpochProtocolState() *Snapshot_EpochProtocolState_Call {
	return &Snapshot_EpochProtocolState_Call{Call: _e.mock.On("EpochProtocolState")}
}

func (_c *Snapshot_EpochProtocolState_Call) Run(run func()) *Snapshot_EpochProtocolState_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Snapshot_EpochProtocolState_Call) Return(epochProtocolState protocol.EpochProtocolState, err error) *Snapshot_EpochProtocolState_Call {
	_c.Call.Return(epochProtocolState, err)
	return _c
}

func (_c *Snapshot_EpochProtocolState_Call) RunAndReturn(run func() (protocol.EpochProtocolState, error)) *Snapshot_EpochProtocolState_Call {
	_c.Call.Return(run)
	return _c
}

// Epochs provides a mock function for the type Snapshot
func (_mock *Snapshot) Epochs() protocol.EpochQuery {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Epochs")
	}

	var r0 protocol.EpochQuery
	if returnFunc, ok := ret.Get(0).(func() protocol.EpochQuery); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(protocol.EpochQuery)
		}
	}
	return r0
}

// Snapshot_Epochs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Epochs'
type Snapshot_Epochs_Call struct {
	*mock.Call
}

// Epochs is a helper method to define mock.On call
func (_e *Snapshot_Expecter) Epochs() *Snapshot_Epochs_Call {
	return &Snapshot_Epochs_Call{Call: _e.mock.On("Epochs")}
}

func (_c *Snapshot_Epochs_Call) Run(run func()) *Snapshot_Epochs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Snapshot_Epochs_Call) Return(epochQuery protocol.EpochQuery) *Snapshot_Epochs_Call {
	_c.Call.Return(epochQuery)
	return _c
}

func (_c *Snapshot_Epochs_Call) RunAndReturn(run func() protocol.EpochQuery) *Snapshot_Epochs_Call {
	_c.Call.Return(run)
	return _c
}

// Head provides a mock function for the type Snapshot
func (_mock *Snapshot) Head() (*flow.Header, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Head")
	}

	var r0 *flow.Header
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (*flow.Header, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() *flow.Header); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.Header)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Snapshot_Head_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Head'
type Snapshot_Head_Call struct {
	*mock.Call
}

// Head is a helper method to define mock.On call
func (_e *Snapshot_Expecter) Head() *Snapshot_Head_Call {
	return &Snapshot_Head_Call{Call: _e.mock.On("Head")}
}

func (_c *Snapshot_Head_Call) Run(run func()) *Snapshot_Head_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Snapshot_Head_Call) Return(header *flow.Header, err error) *Snapshot_Head_Call {
	_c.Call.Return(header, err)
	return _c
}

func (_c *Snapshot_Head_Call) RunAndReturn(run func() (*flow.Header, error)) *Snapshot_Head_Call {
	_c.Call.Return(run)
	return _c
}

// Identities provides a mock function for the type Snapshot
func (_mock *Snapshot) Identities(selector flow.IdentityFilter[flow.Identity]) (flow.IdentityList, error) {
	ret := _mock.Called(selector)

	if len(ret) == 0 {
		panic("no return value specified for Identities")
	}

	var r0 flow.IdentityList
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.IdentityFilter[flow.Identity]) (flow.IdentityList, error)); ok {
		return returnFunc(selector)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.IdentityFilter[flow.Identity]) flow.IdentityList); ok {
		r0 = returnFunc(selector)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.IdentityList)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.IdentityFilter[flow.Identity]) error); ok {
		r1 = returnFunc(selector)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Snapshot_Identities_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Identities'
type Snapshot_Identities_Call struct {
	*mock.Call
}

// Identities is a helper method to define mock.On call
//   - selector flow.IdentityFilter[flow.Identity]
func (_e *Snapshot_Expecter) Identities(selector interface{}) *Snapshot_Identities_Call {
	return &Snapshot_Identities_Call{Call: _e.mock.On("Identities", selector)}
}

func (_c *Snapshot_Identities_Call) Run(run func(selector flow.IdentityFilter[flow.Identity])) *Snapshot_Identities_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.IdentityFilter[flow.Identity]
		if args[0] != nil {
			arg0 = args[0].(flow.IdentityFilter[flow.Identity])
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Snapshot_Identities_Call) Return(v flow.IdentityList, err error) *Snapshot_Identities_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *Snapshot_Identities_Call) RunAndReturn(run func(selector flow.IdentityFilter[flow.Identity]) (flow.IdentityList, error)) *Snapshot_Identities_Call {
	_c.Call.Return(run)
	return _c
}

// Identity provides a mock function for the type Snapshot
func (_mock *Snapshot) Identity(nodeID flow.Identifier) (*flow.Identity, error) {
	ret := _mock.Called(nodeID)

	if len(ret) == 0 {
		panic("no return value specified for Identity")
	}

	var r0 *flow.Identity
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (*flow.Identity, error)); ok {
		return returnFunc(nodeID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) *flow.Identity); ok {
		r0 = returnFunc(nodeID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.Identity)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) error); ok {
		r1 = returnFunc(nodeID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Snapshot_Identity_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Identity'
type Snapshot_Identity_Call struct {
	*mock.Call
}

// Identity is a helper method to define mock.On call
//   - nodeID flow.Identifier
func (_e *Snapshot_Expecter) Identity(nodeID interface{}) *Snapshot_Identity_Call {
	return &Snapshot_Identity_Call{Call: _e.mock.On("Identity", nodeID)}
}

func (_c *Snapshot_Identity_Call) Run(run func(nodeID flow.Identifier)) *Snapshot_Identity_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Snapshot_Identity_Call) Return(identity *flow.Identity, err error) *Snapshot_Identity_Call {
	_c.Call.Return(identity, err)
	return _c
}

func (_c *Snapshot_Identity_Call) RunAndReturn(run func(nodeID flow.Identifier) (*flow.Identity, error)) *Snapshot_Identity_Call {
	_c.Call.Return(run)
	return _c
}

// Params provides a mock function for the type Snapshot
func (_mock *Snapshot) Params() protocol.GlobalParams {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Params")
	}

	var r0 protocol.GlobalParams
	if returnFunc, ok := ret.Get(0).(func() protocol.GlobalParams); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(protocol.GlobalParams)
		}
	}
	return r0
}

// Snapshot_Params_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Params'
type Snapshot_Params_Call struct {
	*mock.Call
}

// Params is a helper method to define mock.On call
func (_e *Snapshot_Expecter) Params() *Snapshot_Params_Call {
	return &Snapshot_Params_Call{Call: _e.mock.On("Params")}
}

func (_c *Snapshot_Params_Call) Run(run func()) *Snapshot_Params_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Snapshot_Params_Call) Return(globalParams protocol.GlobalParams) *Snapshot_Params_Call {
	_c.Call.Return(globalParams)
	return _c
}

func (_c *Snapshot_Params_Call) RunAndReturn(run func() protocol.GlobalParams) *Snapshot_Params_Call {
	_c.Call.Return(run)
	return _c
}

// ProtocolState provides a mock function for the type Snapshot
func (_mock *Snapshot) ProtocolState() (protocol.KVStoreReader, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for ProtocolState")
	}

	var r0 protocol.KVStoreReader
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (protocol.KVStoreReader, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() protocol.KVStoreReader); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(protocol.KVStoreReader)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Snapshot_ProtocolState_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ProtocolState'
type Snapshot_ProtocolState_Call struct {
	*mock.Call
}

// ProtocolState is a helper method to define mock.On call
func (_e *Snapshot_Expecter) ProtocolState() *Snapshot_ProtocolState_Call {
	return &Snapshot_ProtocolState_Call{Call: _e.mock.On("ProtocolState")}
}

func (_c *Snapshot_ProtocolState_Call) Run(run func()) *Snapshot_ProtocolState_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Snapshot_ProtocolState_Call) Return(kVStoreReader protocol.KVStoreReader, err error) *Snapshot_ProtocolState_Call {
	_c.Call.Return(kVStoreReader, err)
	return _c
}

func (_c *Snapshot_ProtocolState_Call) RunAndReturn(run func() (protocol.KVStoreReader, error)) *Snapshot_ProtocolState_Call {
	_c.Call.Return(run)
	return _c
}

// QuorumCertificate provides a mock function for the type Snapshot
func (_mock *Snapshot) QuorumCertificate() (*flow.QuorumCertificate, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for QuorumCertificate")
	}

	var r0 *flow.QuorumCertificate
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (*flow.QuorumCertificate, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() *flow.QuorumCertificate); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.QuorumCertificate)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Snapshot_QuorumCertificate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'QuorumCertificate'
type Snapshot_QuorumCertificate_Call struct {
	*mock.Call
}

// QuorumCertificate is a helper method to define mock.On call
func (_e *Snapshot_Expecter) QuorumCertificate() *Snapshot_QuorumCertificate_Call {
	return &Snapshot_QuorumCertificate_Call{Call: _e.mock.On("QuorumCertificate")}
}

func (_c *Snapshot_QuorumCertificate_Call) Run(run func()) *Snapshot_QuorumCertificate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Snapshot_QuorumCertificate_Call) Return(quorumCertificate *flow.QuorumCertificate, err error) *Snapshot_QuorumCertificate_Call {
	_c.Call.Return(quorumCertificate, err)
	return _c
}

func (_c *Snapshot_QuorumCertificate_Call) RunAndReturn(run func() (*flow.QuorumCertificate, error)) *Snapshot_QuorumCertificate_Call {
	_c.Call.Return(run)
	return _c
}

// RandomSource provides a mock function for the type Snapshot
func (_mock *Snapshot) RandomSource() ([]byte, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for RandomSource")
	}

	var r0 []byte
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() ([]byte, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() []byte); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Snapshot_RandomSource_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RandomSource'
type Snapshot_RandomSource_Call struct {
	*mock.Call
}

// RandomSource is a helper method to define mock.On call
func (_e *Snapshot_Expecter) RandomSource() *Snapshot_RandomSource_Call {
	return &Snapshot_RandomSource_Call{Call: _e.mock.On("RandomSource")}
}

func (_c *Snapshot_RandomSource_Call) Run(run func()) *Snapshot_RandomSource_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Snapshot_RandomSource_Call) Return(bytes []byte, err error) *Snapshot_RandomSource_Call {
	_c.Call.Return(bytes, err)
	return _c
}

func (_c *Snapshot_RandomSource_Call) RunAndReturn(run func() ([]byte, error)) *Snapshot_RandomSource_Call {
	_c.Call.Return(run)
	return _c
}

// SealedResult provides a mock function for the type Snapshot
func (_mock *Snapshot) SealedResult() (*flow.ExecutionResult, *flow.Seal, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for SealedResult")
	}

	var r0 *flow.ExecutionResult
	var r1 *flow.Seal
	var r2 error
	if returnFunc, ok := ret.Get(0).(func() (*flow.ExecutionResult, *flow.Seal, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() *flow.ExecutionResult); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.ExecutionResult)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() *flow.Seal); ok {
		r1 = returnFunc()
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*flow.Seal)
		}
	}
	if returnFunc, ok := ret.Get(2).(func() error); ok {
		r2 = returnFunc()
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// Snapshot_SealedResult_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SealedResult'
type Snapshot_SealedResult_Call struct {
	*mock.Call
}

// SealedResult is a helper method to define mock.On call
func (_e *Snapshot_Expecter) SealedResult() *Snapshot_SealedResult_Call {
	return &Snapshot_SealedResult_Call{Call: _e.mock.On("SealedResult")}
}

func (_c *Snapshot_SealedResult_Call) Run(run func()) *Snapshot_SealedResult_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Snapshot_SealedResult_Call) Return(executionResult *flow.ExecutionResult, seal *flow.Seal, err error) *Snapshot_SealedResult_Call {
	_c.Call.Return(executionResult, seal, err)
	return _c
}

func (_c *Snapshot_SealedResult_Call) RunAndReturn(run func() (*flow.ExecutionResult, *flow.Seal, error)) *Snapshot_SealedResult_Call {
	_c.Call.Return(run)
	return _c
}

// SealingSegment provides a mock function for the type Snapshot
func (_mock *Snapshot) SealingSegment() (*flow.SealingSegment, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for SealingSegment")
	}

	var r0 *flow.SealingSegment
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (*flow.SealingSegment, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() *flow.SealingSegment); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.SealingSegment)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Snapshot_SealingSegment_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SealingSegment'
type Snapshot_SealingSegment_Call struct {
	*mock.Call
}

// SealingSegment is a helper method to define mock.On call
func (_e *Snapshot_Expecter) SealingSegment() *Snapshot_SealingSegment_Call {
	return &Snapshot_SealingSegment_Call{Call: _e.mock.On("SealingSegment")}
}

func (_c *Snapshot_SealingSegment_Call) Run(run func()) *Snapshot_SealingSegment_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Snapshot_SealingSegment_Call) Return(sealingSegment *flow.SealingSegment, err error) *Snapshot_SealingSegment_Call {
	_c.Call.Return(sealingSegment, err)
	return _c
}

func (_c *Snapshot_SealingSegment_Call) RunAndReturn(run func() (*flow.SealingSegment, error)) *Snapshot_SealingSegment_Call {
	_c.Call.Return(run)
	return _c
}

// VersionBeacon provides a mock function for the type Snapshot
func (_mock *Snapshot) VersionBeacon() (*flow.SealedVersionBeacon, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for VersionBeacon")
	}

	var r0 *flow.SealedVersionBeacon
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (*flow.SealedVersionBeacon, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() *flow.SealedVersionBeacon); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.SealedVersionBeacon)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Snapshot_VersionBeacon_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'VersionBeacon'
type Snapshot_VersionBeacon_Call struct {
	*mock.Call
}

// VersionBeacon is a helper method to define mock.On call
func (_e *Snapshot_Expecter) VersionBeacon() *Snapshot_VersionBeacon_Call {
	return &Snapshot_VersionBeacon_Call{Call: _e.mock.On("VersionBeacon")}
}

func (_c *Snapshot_VersionBeacon_Call) Run(run func()) *Snapshot_VersionBeacon_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Snapshot_VersionBeacon_Call) Return(sealedVersionBeacon *flow.SealedVersionBeacon, err error) *Snapshot_VersionBeacon_Call {
	_c.Call.Return(sealedVersionBeacon, err)
	return _c
}

func (_c *Snapshot_VersionBeacon_Call) RunAndReturn(run func() (*flow.SealedVersionBeacon, error)) *Snapshot_VersionBeacon_Call {
	_c.Call.Return(run)
	return _c
}
