// +build relic

package crypto

// #cgo CFLAGS: -g -Wall -std=c99
// #include "dkg_include.h"
import "C"

import (
	"errors"
	"fmt"
)

// Implements Feldman Verifiable Secret Sharing using
// the BLS set up on the BLS12-381 curve.

// The secret is a BLS private key generated by a single dealer/leader.
// (and hence this is a centralized generation).
// The leader generates key shares for a BLS-based
// threshold signature scheme and distributes the shares over the (n)
// partcipants including itself. The particpants validate their shares
// using a public verifiaction vector shared by the leader.

// Private keys are scalar in Zr, where r is the group order of G1/G2
// Public keys are in G2.

// feldman VSS protocol, implements DKGState
type feldmanVSSstate struct {
	// common DKG state
	*dkgCommon
	// node leader index
	leaderIndex index
	// Polynomial P = a_0 + a_1*x + .. + a_t*x^t  in Zr[X], the vector size is (t+1)
	// a_0 is the group private key
	a []scalar
	// Public vector of the group, the vector size is (t+1)
	// A_0 is the group public key
	vA         []pointG2
	vAReceived bool
	// Private share of the current node
	x         scalar
	xReceived bool
	// Public keys of the group nodes, the vector size is (n)
	y []pointG2
	// true if the private share is valid
	validKey bool
}

// NewFeldmanVSS creates a new instance of Feldman VSS protocol.
//
// An instance is run by a single node and is usable for only one protocol.
// In order to run the protocol again, a new instance needs to be created
func NewFeldmanVSS(size int, threshold int, currentIndex int,
	processor DKGProcessor, leaderIndex int) (DKGState, error) {

	common, err := newDKGCommon(size, threshold, currentIndex, processor, leaderIndex)
	if err != nil {
		return nil, err
	}

	fvss := &feldmanVSSstate{
		dkgCommon:   common,
		leaderIndex: index(leaderIndex),
	}
	fvss.init()
	return fvss, nil
}

func (s *feldmanVSSstate) init() {
	// set the bls context
	blsInstance.reInit()
	s.running = false
	s.y = nil
	s.xReceived = false
	s.vAReceived = false
}

// Start starts running the protocol in the current node
// If the current node is the leader, then the seed is used
// to generate the secret polynomial (including the group private key)
// if the current node is not the leader, the seed is ignored.
func (s *feldmanVSSstate) Start(seed []byte) error {
	if s.running {
		return errors.New("dkg is already running")
	}

	s.running = true
	// Generate shares if necessary
	if s.leaderIndex == s.currentIndex {
		return s.generateShares(seed)
	}
	return nil
}

// End ends the protocol in the current node
// It returns the finalized public data and node private key share.
// - the group public key corresponding to the group secret key
// - all the public key shares corresponding to the nodes private
// key shares.
// - the finalized private key which is the current node's own private key share
func (s *feldmanVSSstate) End() (PrivateKey, PublicKey, []PublicKey, error) {
	if !s.running {
		return nil, nil, nil, errors.New("dkg is not running")
	}
	s.running = false
	if !s.validKey {
		return nil, nil, nil, errors.New("keys are not correct")
	}
	// private key of the current node
	x := &PrKeyBLSBLS12381{
		scalar: s.x, // the private share
	}

	// Group public key
	Y := &PubKeyBLSBLS12381{
		point: s.vA[0],
	}

	// The nodes public keys
	y := make([]PublicKey, s.size)
	for i, p := range s.y {
		y[i] = &PubKeyBLSBLS12381{
			point: p,
		}
	}
	return x, Y, y, nil
}

const (
	shareSize = PrKeyLenBLSBLS12381
	// the actual verifVectorSize depends on the state and is:
	// PubKeyLenBLSBLS12381*(t+1)
	verifVectorSize = PubKeyLenBLSBLS12381
)

// HandleMsg processes a new message received by the current node
// orig is the message origin index
func (s *feldmanVSSstate) HandleMsg(orig int, msg []byte) error {
	if !s.running {
		return errors.New("dkg is not running")
	}
	if orig >= s.Size() || orig < 0 {
		return errors.New("wrong input")
	}

	if len(msg) == 0 {
		s.processor.FlagMisbehavior(orig, wrongFormat)
		return nil
	}

	// In case a broadcasted message is received by the origin node,
	// the message is just ignored
	if s.currentIndex == index(orig) {
		return nil
	}

	// msg = |tag| Data |
	switch dkgMsgTag(msg[0]) {
	case feldmanVSSShare:
		s.receiveShare(index(orig), msg[1:])
	case feldmanVSSVerifVec:
		s.receiveVerifVector(index(orig), msg[1:])
	default:
		s.processor.FlagMisbehavior(orig, wrongFormat)
	}
	return nil
}

// Disqualify forces a node to get disqualified
// for a reason outside of the DKG protocol
// The caller should make sure all honest nodes call this function,
// otherwise, the protocol can be broken
func (s *feldmanVSSstate) Disqualify(node int) error {
	if !s.running {
		return errors.New("dkg is not running")
	}
	if node >= s.Size() || node < 0 {
		return errors.New("wrong input")
	}
	if index(node) == s.leaderIndex {
		s.validKey = false
	}
	return nil
}

// generates all private and public data by the leader
func (s *feldmanVSSstate) generateShares(seed []byte) error {
	err := seedRelic(seed)
	if err != nil {
		return fmt.Errorf("generating shares failed: %w", err)
	}
	// Generate a polyomial P in Zr[X] of degree t
	s.a = make([]scalar, s.threshold+1)
	s.vA = make([]pointG2, s.threshold+1)
	s.y = make([]pointG2, s.size)
	randZrStar(&s.a[0]) // non zero a[0]
	genScalarMultG2(&s.vA[0], &s.a[0])
	for i := 1; i < s.threshold+1; i++ {
		randZr(&s.a[i])
		genScalarMultG2(&s.vA[i], &s.a[i])
	}

	// compute the shares
	for i := index(1); int(i) <= s.size; i++ {
		// the-leader-own share
		if i-1 == s.currentIndex {
			xdata := make([]byte, shareSize)
			zrPolynomialImage(xdata, s.a, i, &s.y[i-1])
			C.bn_read_bin((*C.bn_st)(&s.x),
				(*C.uchar)(&xdata[0]),
				PrKeyLenBLSBLS12381,
			)
			continue
		}
		// the-other-node shares
		data := make([]byte, shareSize+1)
		data[0] = byte(feldmanVSSShare)
		zrPolynomialImage(data[1:], s.a, i, &s.y[i-1])
		s.processor.PrivateSend(int(i-1), data)
	}
	// broadcast the vector
	vectorSize := verifVectorSize * (s.threshold + 1)
	data := make([]byte, vectorSize+1)
	data[0] = byte(feldmanVSSVerifVec)
	writeVerifVector(data[1:], s.vA)
	s.processor.Broadcast(data)

	s.vAReceived = true
	s.xReceived = true
	s.validKey = true
	return nil
}

// receives a private share from the leader
func (s *feldmanVSSstate) receiveShare(origin index, data []byte) {
	// only accept private shares from the leader.
	if origin != s.leaderIndex {
		return
	}

	if s.xReceived {
		s.processor.FlagMisbehavior(int(origin), duplicated)
		return
	}

	if (len(data)) != shareSize {
		s.processor.FlagMisbehavior(int(origin), wrongFormat)
		return
	}

	// read the node private share
	C.bn_read_bin((*C.bn_st)(&s.x),
		(*C.uchar)(&data[0]),
		PrKeyLenBLSBLS12381,
	)

	s.xReceived = true
	if s.vAReceived {
		s.validKey = s.verifyShare()
	}
}

// receives the public vector from the leader
func (s *feldmanVSSstate) receiveVerifVector(origin index, data []byte) {
	// only accept the verification vector from the leader.
	if origin != s.leaderIndex {
		return
	}
	if s.vAReceived {
		s.processor.FlagMisbehavior(int(origin), duplicated)
		return
	}
	if verifVectorSize*(s.threshold+1) != len(data) {
		s.processor.FlagMisbehavior(int(origin), wrongFormat)
		return
	}
	// read the verification vector
	s.vA = make([]pointG2, s.threshold+1)
	err := readVerifVector(s.vA, data)
	if err != nil {
		s.processor.FlagMisbehavior(int(origin), wrongFormat)
		return
	}

	s.y = make([]pointG2, s.size)
	s.computePublicKeys()

	s.vAReceived = true
	if s.xReceived {
		s.validKey = s.verifyShare()
	}
}

// zrPolynomialImage computes P(x) = a_0 + a_1*x + .. + a_n*x^n (mod r) in Z/Zr
// r being the order of G1
// P(x) is written in dest, while g2^P(x) is written in y
// x being a small integer
func zrPolynomialImage(dest []byte, a []scalar, x index, y *pointG2) {
	C.Zr_polynomialImage_export((*C.uchar)(&dest[0]),
		(*C.ep2_st)(y),
		(*C.bn_st)(&a[0]), (C.int)(len(a)),
		(C.uint8_t)(x),
	)
}

// writeVerifVector exports a vector A into an array of bytes
// assuming the array length matches the vector length
func writeVerifVector(dest []byte, A []pointG2) {
	C.ep2_vector_write_bin((*C.uchar)(&dest[0]),
		(*C.ep2_st)(&A[0]),
		(C.int)(len(A)),
	)
}

// readVerifVector imports A vector from an array of bytes,
// assuming the slice length matches the vector length
func readVerifVector(A []pointG2, src []byte) error {
	if C.ep2_vector_read_bin((*C.ep2_st)(&A[0]),
		(*C.uchar)(&src[0]),
		(C.int)(len(A)),
	) != valid {
		return errors.New("the verifcation vector does not encode public keys correctly")
	}
	return nil
}

func (s *feldmanVSSstate) verifyShare() bool {
	// check y[current] == x.G2
	return C.verifyshare((*C.bn_st)(&s.x),
		(*C.ep2_st)(&s.y[s.currentIndex])) == 1
}

// computePublicKeys extracts the nodes public keys from the verification vector
// y[i] = Q(i+1) for all nodes i, with:
//  Q(x) = A_0 + A_1*x + ... +  A_n*x^n  in G2
func (s *feldmanVSSstate) computePublicKeys() {
	C.G2_polynomialImages(
		(*C.ep2_st)(&s.y[0]), (C.int)(len(s.y)),
		(*C.ep2_st)(&s.vA[0]), (C.int)(len(s.vA)),
	)
}
