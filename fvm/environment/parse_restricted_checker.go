// AUTO-GENERATED BY generate-wrappers fvm/environment/parse_restricted_checker.go.  DO NOT MODIFY.

package environment

import (
	"github.com/onflow/flow-go/fvm/errors"
	"github.com/onflow/flow-go/fvm/state"
	"github.com/onflow/flow-go/module/trace"
)

func parseRestricted(
	txnState state.NestedTransaction,
	spanName trace.SpanName,
) error {
	if txnState.IsParseRestricted() {
		return errors.NewParseRestrictedModeInvalidAccessFailure(spanName)
	}

	return nil
}

// Utility functions used for checking unexpected operation access while
// cadence is parsing programs.
//
// The generic functions are of the form
//      parseRestrict<x>Arg<y>Ret(txnState, spanName, callback, arg1, ..., argX)
// where the callback expects <x> number of arguments, and <y> number of
// return values (not counting error). If the callback expects no argument,
// <x>Arg is omitted, and similarly for return value.

func parseRestrict1Arg[
	Arg0T any,
](
	txnState state.NestedTransaction,
	spanName trace.SpanName,
	callback func(Arg0T) error,
	arg0 Arg0T,
) error {
	err := parseRestricted(txnState, spanName)
	if err != nil {
		return err
	}

	return callback(arg0)
}

func parseRestrict2Arg[
	Arg0T any,
	Arg1T any,
](
	txnState state.NestedTransaction,
	spanName trace.SpanName,
	callback func(Arg0T, Arg1T) error,
	arg0 Arg0T,
	arg1 Arg1T,
) error {
	err := parseRestricted(txnState, spanName)
	if err != nil {
		return err
	}

	return callback(arg0, arg1)
}

func parseRestrict3Arg[
	Arg0T any,
	Arg1T any,
	Arg2T any,
](
	txnState state.NestedTransaction,
	spanName trace.SpanName,
	callback func(Arg0T, Arg1T, Arg2T) error,
	arg0 Arg0T,
	arg1 Arg1T,
	arg2 Arg2T,
) error {
	err := parseRestricted(txnState, spanName)
	if err != nil {
		return err
	}

	return callback(arg0, arg1, arg2)
}

func parseRestrict1Ret[
	Ret0T any,
](
	txnState state.NestedTransaction,
	spanName trace.SpanName,
	callback func() (Ret0T, error),
) (
	Ret0T,
	error,
) {
	err := parseRestricted(txnState, spanName)
	if err != nil {
		var value0 Ret0T
		return value0, err
	}

	return callback()
}

func parseRestrict1Arg1Ret[
	Arg0T any,
	Ret0T any,
](
	txnState state.NestedTransaction,
	spanName trace.SpanName,
	callback func(Arg0T) (Ret0T, error),
	arg0 Arg0T,
) (
	Ret0T,
	error,
) {
	err := parseRestricted(txnState, spanName)
	if err != nil {
		var value0 Ret0T
		return value0, err
	}

	return callback(arg0)
}

func parseRestrict2Arg1Ret[
	Arg0T any,
	Arg1T any,
	Ret0T any,
](
	txnState state.NestedTransaction,
	spanName trace.SpanName,
	callback func(Arg0T, Arg1T) (Ret0T, error),
	arg0 Arg0T,
	arg1 Arg1T,
) (
	Ret0T,
	error,
) {
	err := parseRestricted(txnState, spanName)
	if err != nil {
		var value0 Ret0T
		return value0, err
	}

	return callback(arg0, arg1)
}

func parseRestrict3Arg1Ret[
	Arg0T any,
	Arg1T any,
	Arg2T any,
	Ret0T any,
](
	txnState state.NestedTransaction,
	spanName trace.SpanName,
	callback func(Arg0T, Arg1T, Arg2T) (Ret0T, error),
	arg0 Arg0T,
	arg1 Arg1T,
	arg2 Arg2T,
) (
	Ret0T,
	error,
) {
	err := parseRestricted(txnState, spanName)
	if err != nil {
		var value0 Ret0T
		return value0, err
	}

	return callback(arg0, arg1, arg2)
}

func parseRestrict4Arg1Ret[
	Arg0T any,
	Arg1T any,
	Arg2T any,
	Arg3T any,
	Ret0T any,
](
	txnState state.NestedTransaction,
	spanName trace.SpanName,
	callback func(Arg0T, Arg1T, Arg2T, Arg3T) (Ret0T, error),
	arg0 Arg0T,
	arg1 Arg1T,
	arg2 Arg2T,
	arg3 Arg3T,
) (
	Ret0T,
	error,
) {
	err := parseRestricted(txnState, spanName)
	if err != nil {
		var value0 Ret0T
		return value0, err
	}

	return callback(arg0, arg1, arg2, arg3)
}

func parseRestrict6Arg1Ret[
	Arg0T any,
	Arg1T any,
	Arg2T any,
	Arg3T any,
	Arg4T any,
	Arg5T any,
	Ret0T any,
](
	txnState state.NestedTransaction,
	spanName trace.SpanName,
	callback func(Arg0T, Arg1T, Arg2T, Arg3T, Arg4T, Arg5T) (Ret0T, error),
	arg0 Arg0T,
	arg1 Arg1T,
	arg2 Arg2T,
	arg3 Arg3T,
	arg4 Arg4T,
	arg5 Arg5T,
) (
	Ret0T,
	error,
) {
	err := parseRestricted(txnState, spanName)
	if err != nil {
		var value0 Ret0T
		return value0, err
	}

	return callback(arg0, arg1, arg2, arg3, arg4, arg5)
}

func parseRestrict1Arg2Ret[
	Arg0T any,
	Ret0T any,
	Ret1T any,
](
	txnState state.NestedTransaction,
	spanName trace.SpanName,
	callback func(Arg0T) (Ret0T, Ret1T, error),
	arg0 Arg0T,
) (
	Ret0T,
	Ret1T,
	error,
) {
	err := parseRestricted(txnState, spanName)
	if err != nil {
		var value0 Ret0T
		var value1 Ret1T
		return value0, value1, err
	}

	return callback(arg0)
}
