// Code generated by mockery v2.53.4. DO NOT EDIT.

package mock

import (
	atree "github.com/onflow/atree"

	flow "github.com/onflow/flow-go/model/flow"

	mock "github.com/stretchr/testify/mock"
)

// MockAccounts is an autogenerated mock type for the Accounts type
type MockAccounts struct {
	mock.Mock
}

type MockAccounts_Expecter struct {
	mock *mock.Mock
}

func (_m *MockAccounts) EXPECT() *MockAccounts_Expecter {
	return &MockAccounts_Expecter{mock: &_m.Mock}
}

// AllocateSlabIndex provides a mock function with given fields: address
func (_m *MockAccounts) AllocateSlabIndex(address flow.Address) (atree.SlabIndex, error) {
	ret := _m.Called(address)

	if len(ret) == 0 {
		panic("no return value specified for AllocateSlabIndex")
	}

	var r0 atree.SlabIndex
	var r1 error
	if rf, ok := ret.Get(0).(func(flow.Address) (atree.SlabIndex, error)); ok {
		return rf(address)
	}
	if rf, ok := ret.Get(0).(func(flow.Address) atree.SlabIndex); ok {
		r0 = rf(address)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(atree.SlabIndex)
		}
	}

	if rf, ok := ret.Get(1).(func(flow.Address) error); ok {
		r1 = rf(address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccounts_AllocateSlabIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AllocateSlabIndex'
type MockAccounts_AllocateSlabIndex_Call struct {
	*mock.Call
}

// AllocateSlabIndex is a helper method to define mock.On call
//   - address flow.Address
func (_e *MockAccounts_Expecter) AllocateSlabIndex(address interface{}) *MockAccounts_AllocateSlabIndex_Call {
	return &MockAccounts_AllocateSlabIndex_Call{Call: _e.mock.On("AllocateSlabIndex", address)}
}

func (_c *MockAccounts_AllocateSlabIndex_Call) Run(run func(address flow.Address)) *MockAccounts_AllocateSlabIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(flow.Address))
	})
	return _c
}

func (_c *MockAccounts_AllocateSlabIndex_Call) Return(_a0 atree.SlabIndex, _a1 error) *MockAccounts_AllocateSlabIndex_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccounts_AllocateSlabIndex_Call) RunAndReturn(run func(flow.Address) (atree.SlabIndex, error)) *MockAccounts_AllocateSlabIndex_Call {
	_c.Call.Return(run)
	return _c
}

// AppendPublicKey provides a mock function with given fields: address, key
func (_m *MockAccounts) AppendPublicKey(address flow.Address, key flow.AccountPublicKey) error {
	ret := _m.Called(address, key)

	if len(ret) == 0 {
		panic("no return value specified for AppendPublicKey")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(flow.Address, flow.AccountPublicKey) error); ok {
		r0 = rf(address, key)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockAccounts_AppendPublicKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AppendPublicKey'
type MockAccounts_AppendPublicKey_Call struct {
	*mock.Call
}

// AppendPublicKey is a helper method to define mock.On call
//   - address flow.Address
//   - key flow.AccountPublicKey
func (_e *MockAccounts_Expecter) AppendPublicKey(address interface{}, key interface{}) *MockAccounts_AppendPublicKey_Call {
	return &MockAccounts_AppendPublicKey_Call{Call: _e.mock.On("AppendPublicKey", address, key)}
}

func (_c *MockAccounts_AppendPublicKey_Call) Run(run func(address flow.Address, key flow.AccountPublicKey)) *MockAccounts_AppendPublicKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(flow.Address), args[1].(flow.AccountPublicKey))
	})
	return _c
}

func (_c *MockAccounts_AppendPublicKey_Call) Return(_a0 error) *MockAccounts_AppendPublicKey_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockAccounts_AppendPublicKey_Call) RunAndReturn(run func(flow.Address, flow.AccountPublicKey) error) *MockAccounts_AppendPublicKey_Call {
	_c.Call.Return(run)
	return _c
}

// ContractExists provides a mock function with given fields: contractName, address
func (_m *MockAccounts) ContractExists(contractName string, address flow.Address) (bool, error) {
	ret := _m.Called(contractName, address)

	if len(ret) == 0 {
		panic("no return value specified for ContractExists")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, flow.Address) (bool, error)); ok {
		return rf(contractName, address)
	}
	if rf, ok := ret.Get(0).(func(string, flow.Address) bool); ok {
		r0 = rf(contractName, address)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, flow.Address) error); ok {
		r1 = rf(contractName, address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccounts_ContractExists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ContractExists'
type MockAccounts_ContractExists_Call struct {
	*mock.Call
}

// ContractExists is a helper method to define mock.On call
//   - contractName string
//   - address flow.Address
func (_e *MockAccounts_Expecter) ContractExists(contractName interface{}, address interface{}) *MockAccounts_ContractExists_Call {
	return &MockAccounts_ContractExists_Call{Call: _e.mock.On("ContractExists", contractName, address)}
}

func (_c *MockAccounts_ContractExists_Call) Run(run func(contractName string, address flow.Address)) *MockAccounts_ContractExists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(flow.Address))
	})
	return _c
}

func (_c *MockAccounts_ContractExists_Call) Return(_a0 bool, _a1 error) *MockAccounts_ContractExists_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccounts_ContractExists_Call) RunAndReturn(run func(string, flow.Address) (bool, error)) *MockAccounts_ContractExists_Call {
	_c.Call.Return(run)
	return _c
}

// Create provides a mock function with given fields: publicKeys, newAddress
func (_m *MockAccounts) Create(publicKeys []flow.AccountPublicKey, newAddress flow.Address) error {
	ret := _m.Called(publicKeys, newAddress)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func([]flow.AccountPublicKey, flow.Address) error); ok {
		r0 = rf(publicKeys, newAddress)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockAccounts_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockAccounts_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - publicKeys []flow.AccountPublicKey
//   - newAddress flow.Address
func (_e *MockAccounts_Expecter) Create(publicKeys interface{}, newAddress interface{}) *MockAccounts_Create_Call {
	return &MockAccounts_Create_Call{Call: _e.mock.On("Create", publicKeys, newAddress)}
}

func (_c *MockAccounts_Create_Call) Run(run func(publicKeys []flow.AccountPublicKey, newAddress flow.Address)) *MockAccounts_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]flow.AccountPublicKey), args[1].(flow.Address))
	})
	return _c
}

func (_c *MockAccounts_Create_Call) Return(_a0 error) *MockAccounts_Create_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockAccounts_Create_Call) RunAndReturn(run func([]flow.AccountPublicKey, flow.Address) error) *MockAccounts_Create_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteContract provides a mock function with given fields: contractName, address
func (_m *MockAccounts) DeleteContract(contractName string, address flow.Address) error {
	ret := _m.Called(contractName, address)

	if len(ret) == 0 {
		panic("no return value specified for DeleteContract")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, flow.Address) error); ok {
		r0 = rf(contractName, address)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockAccounts_DeleteContract_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteContract'
type MockAccounts_DeleteContract_Call struct {
	*mock.Call
}

// DeleteContract is a helper method to define mock.On call
//   - contractName string
//   - address flow.Address
func (_e *MockAccounts_Expecter) DeleteContract(contractName interface{}, address interface{}) *MockAccounts_DeleteContract_Call {
	return &MockAccounts_DeleteContract_Call{Call: _e.mock.On("DeleteContract", contractName, address)}
}

func (_c *MockAccounts_DeleteContract_Call) Run(run func(contractName string, address flow.Address)) *MockAccounts_DeleteContract_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(flow.Address))
	})
	return _c
}

func (_c *MockAccounts_DeleteContract_Call) Return(_a0 error) *MockAccounts_DeleteContract_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockAccounts_DeleteContract_Call) RunAndReturn(run func(string, flow.Address) error) *MockAccounts_DeleteContract_Call {
	_c.Call.Return(run)
	return _c
}

// Exists provides a mock function with given fields: address
func (_m *MockAccounts) Exists(address flow.Address) (bool, error) {
	ret := _m.Called(address)

	if len(ret) == 0 {
		panic("no return value specified for Exists")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(flow.Address) (bool, error)); ok {
		return rf(address)
	}
	if rf, ok := ret.Get(0).(func(flow.Address) bool); ok {
		r0 = rf(address)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(flow.Address) error); ok {
		r1 = rf(address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccounts_Exists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exists'
type MockAccounts_Exists_Call struct {
	*mock.Call
}

// Exists is a helper method to define mock.On call
//   - address flow.Address
func (_e *MockAccounts_Expecter) Exists(address interface{}) *MockAccounts_Exists_Call {
	return &MockAccounts_Exists_Call{Call: _e.mock.On("Exists", address)}
}

func (_c *MockAccounts_Exists_Call) Run(run func(address flow.Address)) *MockAccounts_Exists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(flow.Address))
	})
	return _c
}

func (_c *MockAccounts_Exists_Call) Return(_a0 bool, _a1 error) *MockAccounts_Exists_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccounts_Exists_Call) RunAndReturn(run func(flow.Address) (bool, error)) *MockAccounts_Exists_Call {
	_c.Call.Return(run)
	return _c
}

// GenerateAccountLocalID provides a mock function with given fields: address
func (_m *MockAccounts) GenerateAccountLocalID(address flow.Address) (uint64, error) {
	ret := _m.Called(address)

	if len(ret) == 0 {
		panic("no return value specified for GenerateAccountLocalID")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(flow.Address) (uint64, error)); ok {
		return rf(address)
	}
	if rf, ok := ret.Get(0).(func(flow.Address) uint64); ok {
		r0 = rf(address)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(flow.Address) error); ok {
		r1 = rf(address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccounts_GenerateAccountLocalID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GenerateAccountLocalID'
type MockAccounts_GenerateAccountLocalID_Call struct {
	*mock.Call
}

// GenerateAccountLocalID is a helper method to define mock.On call
//   - address flow.Address
func (_e *MockAccounts_Expecter) GenerateAccountLocalID(address interface{}) *MockAccounts_GenerateAccountLocalID_Call {
	return &MockAccounts_GenerateAccountLocalID_Call{Call: _e.mock.On("GenerateAccountLocalID", address)}
}

func (_c *MockAccounts_GenerateAccountLocalID_Call) Run(run func(address flow.Address)) *MockAccounts_GenerateAccountLocalID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(flow.Address))
	})
	return _c
}

func (_c *MockAccounts_GenerateAccountLocalID_Call) Return(_a0 uint64, _a1 error) *MockAccounts_GenerateAccountLocalID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccounts_GenerateAccountLocalID_Call) RunAndReturn(run func(flow.Address) (uint64, error)) *MockAccounts_GenerateAccountLocalID_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function with given fields: address
func (_m *MockAccounts) Get(address flow.Address) (*flow.Account, error) {
	ret := _m.Called(address)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *flow.Account
	var r1 error
	if rf, ok := ret.Get(0).(func(flow.Address) (*flow.Account, error)); ok {
		return rf(address)
	}
	if rf, ok := ret.Get(0).(func(flow.Address) *flow.Account); ok {
		r0 = rf(address)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.Account)
		}
	}

	if rf, ok := ret.Get(1).(func(flow.Address) error); ok {
		r1 = rf(address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccounts_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type MockAccounts_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - address flow.Address
func (_e *MockAccounts_Expecter) Get(address interface{}) *MockAccounts_Get_Call {
	return &MockAccounts_Get_Call{Call: _e.mock.On("Get", address)}
}

func (_c *MockAccounts_Get_Call) Run(run func(address flow.Address)) *MockAccounts_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(flow.Address))
	})
	return _c
}

func (_c *MockAccounts_Get_Call) Return(_a0 *flow.Account, _a1 error) *MockAccounts_Get_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccounts_Get_Call) RunAndReturn(run func(flow.Address) (*flow.Account, error)) *MockAccounts_Get_Call {
	_c.Call.Return(run)
	return _c
}

// GetContract provides a mock function with given fields: contractName, address
func (_m *MockAccounts) GetContract(contractName string, address flow.Address) ([]byte, error) {
	ret := _m.Called(contractName, address)

	if len(ret) == 0 {
		panic("no return value specified for GetContract")
	}

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func(string, flow.Address) ([]byte, error)); ok {
		return rf(contractName, address)
	}
	if rf, ok := ret.Get(0).(func(string, flow.Address) []byte); ok {
		r0 = rf(contractName, address)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(string, flow.Address) error); ok {
		r1 = rf(contractName, address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccounts_GetContract_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetContract'
type MockAccounts_GetContract_Call struct {
	*mock.Call
}

// GetContract is a helper method to define mock.On call
//   - contractName string
//   - address flow.Address
func (_e *MockAccounts_Expecter) GetContract(contractName interface{}, address interface{}) *MockAccounts_GetContract_Call {
	return &MockAccounts_GetContract_Call{Call: _e.mock.On("GetContract", contractName, address)}
}

func (_c *MockAccounts_GetContract_Call) Run(run func(contractName string, address flow.Address)) *MockAccounts_GetContract_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(flow.Address))
	})
	return _c
}

func (_c *MockAccounts_GetContract_Call) Return(_a0 []byte, _a1 error) *MockAccounts_GetContract_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccounts_GetContract_Call) RunAndReturn(run func(string, flow.Address) ([]byte, error)) *MockAccounts_GetContract_Call {
	_c.Call.Return(run)
	return _c
}

// GetContractNames provides a mock function with given fields: address
func (_m *MockAccounts) GetContractNames(address flow.Address) ([]string, error) {
	ret := _m.Called(address)

	if len(ret) == 0 {
		panic("no return value specified for GetContractNames")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(flow.Address) ([]string, error)); ok {
		return rf(address)
	}
	if rf, ok := ret.Get(0).(func(flow.Address) []string); ok {
		r0 = rf(address)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(flow.Address) error); ok {
		r1 = rf(address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccounts_GetContractNames_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetContractNames'
type MockAccounts_GetContractNames_Call struct {
	*mock.Call
}

// GetContractNames is a helper method to define mock.On call
//   - address flow.Address
func (_e *MockAccounts_Expecter) GetContractNames(address interface{}) *MockAccounts_GetContractNames_Call {
	return &MockAccounts_GetContractNames_Call{Call: _e.mock.On("GetContractNames", address)}
}

func (_c *MockAccounts_GetContractNames_Call) Run(run func(address flow.Address)) *MockAccounts_GetContractNames_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(flow.Address))
	})
	return _c
}

func (_c *MockAccounts_GetContractNames_Call) Return(_a0 []string, _a1 error) *MockAccounts_GetContractNames_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccounts_GetContractNames_Call) RunAndReturn(run func(flow.Address) ([]string, error)) *MockAccounts_GetContractNames_Call {
	_c.Call.Return(run)
	return _c
}

// GetPublicKey provides a mock function with given fields: address, keyIndex
func (_m *MockAccounts) GetPublicKey(address flow.Address, keyIndex uint32) (flow.AccountPublicKey, error) {
	ret := _m.Called(address, keyIndex)

	if len(ret) == 0 {
		panic("no return value specified for GetPublicKey")
	}

	var r0 flow.AccountPublicKey
	var r1 error
	if rf, ok := ret.Get(0).(func(flow.Address, uint32) (flow.AccountPublicKey, error)); ok {
		return rf(address, keyIndex)
	}
	if rf, ok := ret.Get(0).(func(flow.Address, uint32) flow.AccountPublicKey); ok {
		r0 = rf(address, keyIndex)
	} else {
		r0 = ret.Get(0).(flow.AccountPublicKey)
	}

	if rf, ok := ret.Get(1).(func(flow.Address, uint32) error); ok {
		r1 = rf(address, keyIndex)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccounts_GetPublicKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPublicKey'
type MockAccounts_GetPublicKey_Call struct {
	*mock.Call
}

// GetPublicKey is a helper method to define mock.On call
//   - address flow.Address
//   - keyIndex uint32
func (_e *MockAccounts_Expecter) GetPublicKey(address interface{}, keyIndex interface{}) *MockAccounts_GetPublicKey_Call {
	return &MockAccounts_GetPublicKey_Call{Call: _e.mock.On("GetPublicKey", address, keyIndex)}
}

func (_c *MockAccounts_GetPublicKey_Call) Run(run func(address flow.Address, keyIndex uint32)) *MockAccounts_GetPublicKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(flow.Address), args[1].(uint32))
	})
	return _c
}

func (_c *MockAccounts_GetPublicKey_Call) Return(_a0 flow.AccountPublicKey, _a1 error) *MockAccounts_GetPublicKey_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccounts_GetPublicKey_Call) RunAndReturn(run func(flow.Address, uint32) (flow.AccountPublicKey, error)) *MockAccounts_GetPublicKey_Call {
	_c.Call.Return(run)
	return _c
}

// GetPublicKeyCount provides a mock function with given fields: address
func (_m *MockAccounts) GetPublicKeyCount(address flow.Address) (uint32, error) {
	ret := _m.Called(address)

	if len(ret) == 0 {
		panic("no return value specified for GetPublicKeyCount")
	}

	var r0 uint32
	var r1 error
	if rf, ok := ret.Get(0).(func(flow.Address) (uint32, error)); ok {
		return rf(address)
	}
	if rf, ok := ret.Get(0).(func(flow.Address) uint32); ok {
		r0 = rf(address)
	} else {
		r0 = ret.Get(0).(uint32)
	}

	if rf, ok := ret.Get(1).(func(flow.Address) error); ok {
		r1 = rf(address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccounts_GetPublicKeyCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPublicKeyCount'
type MockAccounts_GetPublicKeyCount_Call struct {
	*mock.Call
}

// GetPublicKeyCount is a helper method to define mock.On call
//   - address flow.Address
func (_e *MockAccounts_Expecter) GetPublicKeyCount(address interface{}) *MockAccounts_GetPublicKeyCount_Call {
	return &MockAccounts_GetPublicKeyCount_Call{Call: _e.mock.On("GetPublicKeyCount", address)}
}

func (_c *MockAccounts_GetPublicKeyCount_Call) Run(run func(address flow.Address)) *MockAccounts_GetPublicKeyCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(flow.Address))
	})
	return _c
}

func (_c *MockAccounts_GetPublicKeyCount_Call) Return(_a0 uint32, _a1 error) *MockAccounts_GetPublicKeyCount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccounts_GetPublicKeyCount_Call) RunAndReturn(run func(flow.Address) (uint32, error)) *MockAccounts_GetPublicKeyCount_Call {
	_c.Call.Return(run)
	return _c
}

// GetPublicKeys provides a mock function with given fields: address
func (_m *MockAccounts) GetPublicKeys(address flow.Address) ([]flow.AccountPublicKey, error) {
	ret := _m.Called(address)

	if len(ret) == 0 {
		panic("no return value specified for GetPublicKeys")
	}

	var r0 []flow.AccountPublicKey
	var r1 error
	if rf, ok := ret.Get(0).(func(flow.Address) ([]flow.AccountPublicKey, error)); ok {
		return rf(address)
	}
	if rf, ok := ret.Get(0).(func(flow.Address) []flow.AccountPublicKey); ok {
		r0 = rf(address)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]flow.AccountPublicKey)
		}
	}

	if rf, ok := ret.Get(1).(func(flow.Address) error); ok {
		r1 = rf(address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccounts_GetPublicKeys_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPublicKeys'
type MockAccounts_GetPublicKeys_Call struct {
	*mock.Call
}

// GetPublicKeys is a helper method to define mock.On call
//   - address flow.Address
func (_e *MockAccounts_Expecter) GetPublicKeys(address interface{}) *MockAccounts_GetPublicKeys_Call {
	return &MockAccounts_GetPublicKeys_Call{Call: _e.mock.On("GetPublicKeys", address)}
}

func (_c *MockAccounts_GetPublicKeys_Call) Run(run func(address flow.Address)) *MockAccounts_GetPublicKeys_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(flow.Address))
	})
	return _c
}

func (_c *MockAccounts_GetPublicKeys_Call) Return(_a0 []flow.AccountPublicKey, _a1 error) *MockAccounts_GetPublicKeys_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccounts_GetPublicKeys_Call) RunAndReturn(run func(flow.Address) ([]flow.AccountPublicKey, error)) *MockAccounts_GetPublicKeys_Call {
	_c.Call.Return(run)
	return _c
}

// GetStorageUsed provides a mock function with given fields: address
func (_m *MockAccounts) GetStorageUsed(address flow.Address) (uint64, error) {
	ret := _m.Called(address)

	if len(ret) == 0 {
		panic("no return value specified for GetStorageUsed")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(flow.Address) (uint64, error)); ok {
		return rf(address)
	}
	if rf, ok := ret.Get(0).(func(flow.Address) uint64); ok {
		r0 = rf(address)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(flow.Address) error); ok {
		r1 = rf(address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccounts_GetStorageUsed_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetStorageUsed'
type MockAccounts_GetStorageUsed_Call struct {
	*mock.Call
}

// GetStorageUsed is a helper method to define mock.On call
//   - address flow.Address
func (_e *MockAccounts_Expecter) GetStorageUsed(address interface{}) *MockAccounts_GetStorageUsed_Call {
	return &MockAccounts_GetStorageUsed_Call{Call: _e.mock.On("GetStorageUsed", address)}
}

func (_c *MockAccounts_GetStorageUsed_Call) Run(run func(address flow.Address)) *MockAccounts_GetStorageUsed_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(flow.Address))
	})
	return _c
}

func (_c *MockAccounts_GetStorageUsed_Call) Return(_a0 uint64, _a1 error) *MockAccounts_GetStorageUsed_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccounts_GetStorageUsed_Call) RunAndReturn(run func(flow.Address) (uint64, error)) *MockAccounts_GetStorageUsed_Call {
	_c.Call.Return(run)
	return _c
}

// GetValue provides a mock function with given fields: id
func (_m *MockAccounts) GetValue(id flow.RegisterID) ([]byte, error) {
	ret := _m.Called(id)

	if len(ret) == 0 {
		panic("no return value specified for GetValue")
	}

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func(flow.RegisterID) ([]byte, error)); ok {
		return rf(id)
	}
	if rf, ok := ret.Get(0).(func(flow.RegisterID) []byte); ok {
		r0 = rf(id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(flow.RegisterID) error); ok {
		r1 = rf(id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccounts_GetValue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetValue'
type MockAccounts_GetValue_Call struct {
	*mock.Call
}

// GetValue is a helper method to define mock.On call
//   - id flow.RegisterID
func (_e *MockAccounts_Expecter) GetValue(id interface{}) *MockAccounts_GetValue_Call {
	return &MockAccounts_GetValue_Call{Call: _e.mock.On("GetValue", id)}
}

func (_c *MockAccounts_GetValue_Call) Run(run func(id flow.RegisterID)) *MockAccounts_GetValue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(flow.RegisterID))
	})
	return _c
}

func (_c *MockAccounts_GetValue_Call) Return(_a0 []byte, _a1 error) *MockAccounts_GetValue_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccounts_GetValue_Call) RunAndReturn(run func(flow.RegisterID) ([]byte, error)) *MockAccounts_GetValue_Call {
	_c.Call.Return(run)
	return _c
}

// SetContract provides a mock function with given fields: contractName, address, contract
func (_m *MockAccounts) SetContract(contractName string, address flow.Address, contract []byte) error {
	ret := _m.Called(contractName, address, contract)

	if len(ret) == 0 {
		panic("no return value specified for SetContract")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, flow.Address, []byte) error); ok {
		r0 = rf(contractName, address, contract)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockAccounts_SetContract_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetContract'
type MockAccounts_SetContract_Call struct {
	*mock.Call
}

// SetContract is a helper method to define mock.On call
//   - contractName string
//   - address flow.Address
//   - contract []byte
func (_e *MockAccounts_Expecter) SetContract(contractName interface{}, address interface{}, contract interface{}) *MockAccounts_SetContract_Call {
	return &MockAccounts_SetContract_Call{Call: _e.mock.On("SetContract", contractName, address, contract)}
}

func (_c *MockAccounts_SetContract_Call) Run(run func(contractName string, address flow.Address, contract []byte)) *MockAccounts_SetContract_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(flow.Address), args[2].([]byte))
	})
	return _c
}

func (_c *MockAccounts_SetContract_Call) Return(_a0 error) *MockAccounts_SetContract_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockAccounts_SetContract_Call) RunAndReturn(run func(string, flow.Address, []byte) error) *MockAccounts_SetContract_Call {
	_c.Call.Return(run)
	return _c
}

// SetPublicKey provides a mock function with given fields: address, keyIndex, publicKey
func (_m *MockAccounts) SetPublicKey(address flow.Address, keyIndex uint32, publicKey flow.AccountPublicKey) ([]byte, error) {
	ret := _m.Called(address, keyIndex, publicKey)

	if len(ret) == 0 {
		panic("no return value specified for SetPublicKey")
	}

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func(flow.Address, uint32, flow.AccountPublicKey) ([]byte, error)); ok {
		return rf(address, keyIndex, publicKey)
	}
	if rf, ok := ret.Get(0).(func(flow.Address, uint32, flow.AccountPublicKey) []byte); ok {
		r0 = rf(address, keyIndex, publicKey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(flow.Address, uint32, flow.AccountPublicKey) error); ok {
		r1 = rf(address, keyIndex, publicKey)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccounts_SetPublicKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetPublicKey'
type MockAccounts_SetPublicKey_Call struct {
	*mock.Call
}

// SetPublicKey is a helper method to define mock.On call
//   - address flow.Address
//   - keyIndex uint32
//   - publicKey flow.AccountPublicKey
func (_e *MockAccounts_Expecter) SetPublicKey(address interface{}, keyIndex interface{}, publicKey interface{}) *MockAccounts_SetPublicKey_Call {
	return &MockAccounts_SetPublicKey_Call{Call: _e.mock.On("SetPublicKey", address, keyIndex, publicKey)}
}

func (_c *MockAccounts_SetPublicKey_Call) Run(run func(address flow.Address, keyIndex uint32, publicKey flow.AccountPublicKey)) *MockAccounts_SetPublicKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(flow.Address), args[1].(uint32), args[2].(flow.AccountPublicKey))
	})
	return _c
}

func (_c *MockAccounts_SetPublicKey_Call) Return(_a0 []byte, _a1 error) *MockAccounts_SetPublicKey_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccounts_SetPublicKey_Call) RunAndReturn(run func(flow.Address, uint32, flow.AccountPublicKey) ([]byte, error)) *MockAccounts_SetPublicKey_Call {
	_c.Call.Return(run)
	return _c
}

// SetValue provides a mock function with given fields: id, value
func (_m *MockAccounts) SetValue(id flow.RegisterID, value []byte) error {
	ret := _m.Called(id, value)

	if len(ret) == 0 {
		panic("no return value specified for SetValue")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(flow.RegisterID, []byte) error); ok {
		r0 = rf(id, value)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockAccounts_SetValue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetValue'
type MockAccounts_SetValue_Call struct {
	*mock.Call
}

// SetValue is a helper method to define mock.On call
//   - id flow.RegisterID
//   - value []byte
func (_e *MockAccounts_Expecter) SetValue(id interface{}, value interface{}) *MockAccounts_SetValue_Call {
	return &MockAccounts_SetValue_Call{Call: _e.mock.On("SetValue", id, value)}
}

func (_c *MockAccounts_SetValue_Call) Run(run func(id flow.RegisterID, value []byte)) *MockAccounts_SetValue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(flow.RegisterID), args[1].([]byte))
	})
	return _c
}

func (_c *MockAccounts_SetValue_Call) Return(_a0 error) *MockAccounts_SetValue_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockAccounts_SetValue_Call) RunAndReturn(run func(flow.RegisterID, []byte) error) *MockAccounts_SetValue_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockAccounts creates a new instance of MockAccounts. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockAccounts(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockAccounts {
	mock := &MockAccounts{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
