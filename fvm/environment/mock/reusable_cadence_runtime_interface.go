// Code generated by mockery. DO NOT EDIT.

package mock

import (
	cadence "github.com/onflow/cadence"
	common "github.com/onflow/cadence/common"

	environment "github.com/onflow/flow-go/fvm/environment"

	mock "github.com/stretchr/testify/mock"

	runtime "github.com/onflow/cadence/runtime"

	sema "github.com/onflow/cadence/sema"
)

// ReusableCadenceRuntimeInterface is an autogenerated mock type for the ReusableCadenceRuntimeInterface type
type ReusableCadenceRuntimeInterface struct {
	mock.Mock
}

// CadenceScriptEnv provides a mock function with no fields
func (_m *ReusableCadenceRuntimeInterface) CadenceScriptEnv() runtime.Environment {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for CadenceScriptEnv")
	}

	var r0 runtime.Environment
	if rf, ok := ret.Get(0).(func() runtime.Environment); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(runtime.Environment)
		}
	}

	return r0
}

// CadenceTXEnv provides a mock function with no fields
func (_m *ReusableCadenceRuntimeInterface) CadenceTXEnv() runtime.Environment {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for CadenceTXEnv")
	}

	var r0 runtime.Environment
	if rf, ok := ret.Get(0).(func() runtime.Environment); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(runtime.Environment)
		}
	}

	return r0
}

// ExecuteScript provides a mock function with given fields: script, location
func (_m *ReusableCadenceRuntimeInterface) ExecuteScript(script runtime.Script, location common.Location) (cadence.Value, error) {
	ret := _m.Called(script, location)

	if len(ret) == 0 {
		panic("no return value specified for ExecuteScript")
	}

	var r0 cadence.Value
	var r1 error
	if rf, ok := ret.Get(0).(func(runtime.Script, common.Location) (cadence.Value, error)); ok {
		return rf(script, location)
	}
	if rf, ok := ret.Get(0).(func(runtime.Script, common.Location) cadence.Value); ok {
		r0 = rf(script, location)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(cadence.Value)
		}
	}

	if rf, ok := ret.Get(1).(func(runtime.Script, common.Location) error); ok {
		r1 = rf(script, location)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InvokeContractFunction provides a mock function with given fields: contractLocation, functionName, arguments, argumentTypes
func (_m *ReusableCadenceRuntimeInterface) InvokeContractFunction(contractLocation common.AddressLocation, functionName string, arguments []cadence.Value, argumentTypes []sema.Type) (cadence.Value, error) {
	ret := _m.Called(contractLocation, functionName, arguments, argumentTypes)

	if len(ret) == 0 {
		panic("no return value specified for InvokeContractFunction")
	}

	var r0 cadence.Value
	var r1 error
	if rf, ok := ret.Get(0).(func(common.AddressLocation, string, []cadence.Value, []sema.Type) (cadence.Value, error)); ok {
		return rf(contractLocation, functionName, arguments, argumentTypes)
	}
	if rf, ok := ret.Get(0).(func(common.AddressLocation, string, []cadence.Value, []sema.Type) cadence.Value); ok {
		r0 = rf(contractLocation, functionName, arguments, argumentTypes)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(cadence.Value)
		}
	}

	if rf, ok := ret.Get(1).(func(common.AddressLocation, string, []cadence.Value, []sema.Type) error); ok {
		r1 = rf(contractLocation, functionName, arguments, argumentTypes)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewTransactionExecutor provides a mock function with given fields: script, location
func (_m *ReusableCadenceRuntimeInterface) NewTransactionExecutor(script runtime.Script, location common.Location) runtime.Executor {
	ret := _m.Called(script, location)

	if len(ret) == 0 {
		panic("no return value specified for NewTransactionExecutor")
	}

	var r0 runtime.Executor
	if rf, ok := ret.Get(0).(func(runtime.Script, common.Location) runtime.Executor); ok {
		r0 = rf(script, location)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(runtime.Executor)
		}
	}

	return r0
}

// ReadStored provides a mock function with given fields: address, path
func (_m *ReusableCadenceRuntimeInterface) ReadStored(address common.Address, path cadence.Path) (cadence.Value, error) {
	ret := _m.Called(address, path)

	if len(ret) == 0 {
		panic("no return value specified for ReadStored")
	}

	var r0 cadence.Value
	var r1 error
	if rf, ok := ret.Get(0).(func(common.Address, cadence.Path) (cadence.Value, error)); ok {
		return rf(address, path)
	}
	if rf, ok := ret.Get(0).(func(common.Address, cadence.Path) cadence.Value); ok {
		r0 = rf(address, path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(cadence.Value)
		}
	}

	if rf, ok := ret.Get(1).(func(common.Address, cadence.Path) error); ok {
		r1 = rf(address, path)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetFvmEnvironment provides a mock function with given fields: fvmEnv
func (_m *ReusableCadenceRuntimeInterface) SetFvmEnvironment(fvmEnv environment.Environment) {
	_m.Called(fvmEnv)
}

// NewReusableCadenceRuntimeInterface creates a new instance of ReusableCadenceRuntimeInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewReusableCadenceRuntimeInterface(t interface {
	mock.TestingT
	Cleanup(func())
}) *ReusableCadenceRuntimeInterface {
	mock := &ReusableCadenceRuntimeInterface{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
