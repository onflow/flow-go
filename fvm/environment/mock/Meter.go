// Code generated by mockery v2.53.4. DO NOT EDIT.

package mock

import (
	common "github.com/onflow/cadence/common"

	meter "github.com/onflow/flow-go/fvm/meter"

	mock "github.com/stretchr/testify/mock"
)

// MockMeter is an autogenerated mock type for the Meter type
type MockMeter struct {
	mock.Mock
}

type MockMeter_Expecter struct {
	mock *mock.Mock
}

func (_m *MockMeter) EXPECT() *MockMeter_Expecter {
	return &MockMeter_Expecter{mock: &_m.Mock}
}

// ComputationAvailable provides a mock function with given fields: _a0
func (_m *MockMeter) ComputationAvailable(_a0 common.ComputationUsage) bool {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for ComputationAvailable")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func(common.ComputationUsage) bool); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// MockMeter_ComputationAvailable_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ComputationAvailable'
type MockMeter_ComputationAvailable_Call struct {
	*mock.Call
}

// ComputationAvailable is a helper method to define mock.On call
//   - _a0 common.ComputationUsage
func (_e *MockMeter_Expecter) ComputationAvailable(_a0 interface{}) *MockMeter_ComputationAvailable_Call {
	return &MockMeter_ComputationAvailable_Call{Call: _e.mock.On("ComputationAvailable", _a0)}
}

func (_c *MockMeter_ComputationAvailable_Call) Run(run func(_a0 common.ComputationUsage)) *MockMeter_ComputationAvailable_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(common.ComputationUsage))
	})
	return _c
}

func (_c *MockMeter_ComputationAvailable_Call) Return(_a0 bool) *MockMeter_ComputationAvailable_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockMeter_ComputationAvailable_Call) RunAndReturn(run func(common.ComputationUsage) bool) *MockMeter_ComputationAvailable_Call {
	_c.Call.Return(run)
	return _c
}

// ComputationIntensities provides a mock function with no fields
func (_m *MockMeter) ComputationIntensities() meter.MeteredComputationIntensities {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for ComputationIntensities")
	}

	var r0 meter.MeteredComputationIntensities
	if rf, ok := ret.Get(0).(func() meter.MeteredComputationIntensities); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(meter.MeteredComputationIntensities)
		}
	}

	return r0
}

// MockMeter_ComputationIntensities_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ComputationIntensities'
type MockMeter_ComputationIntensities_Call struct {
	*mock.Call
}

// ComputationIntensities is a helper method to define mock.On call
func (_e *MockMeter_Expecter) ComputationIntensities() *MockMeter_ComputationIntensities_Call {
	return &MockMeter_ComputationIntensities_Call{Call: _e.mock.On("ComputationIntensities")}
}

func (_c *MockMeter_ComputationIntensities_Call) Run(run func()) *MockMeter_ComputationIntensities_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockMeter_ComputationIntensities_Call) Return(_a0 meter.MeteredComputationIntensities) *MockMeter_ComputationIntensities_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockMeter_ComputationIntensities_Call) RunAndReturn(run func() meter.MeteredComputationIntensities) *MockMeter_ComputationIntensities_Call {
	_c.Call.Return(run)
	return _c
}

// ComputationUsed provides a mock function with no fields
func (_m *MockMeter) ComputationUsed() (uint64, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for ComputationUsed")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func() (uint64, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockMeter_ComputationUsed_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ComputationUsed'
type MockMeter_ComputationUsed_Call struct {
	*mock.Call
}

// ComputationUsed is a helper method to define mock.On call
func (_e *MockMeter_Expecter) ComputationUsed() *MockMeter_ComputationUsed_Call {
	return &MockMeter_ComputationUsed_Call{Call: _e.mock.On("ComputationUsed")}
}

func (_c *MockMeter_ComputationUsed_Call) Run(run func()) *MockMeter_ComputationUsed_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockMeter_ComputationUsed_Call) Return(_a0 uint64, _a1 error) *MockMeter_ComputationUsed_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockMeter_ComputationUsed_Call) RunAndReturn(run func() (uint64, error)) *MockMeter_ComputationUsed_Call {
	_c.Call.Return(run)
	return _c
}

// InteractionUsed provides a mock function with no fields
func (_m *MockMeter) InteractionUsed() (uint64, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for InteractionUsed")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func() (uint64, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockMeter_InteractionUsed_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InteractionUsed'
type MockMeter_InteractionUsed_Call struct {
	*mock.Call
}

// InteractionUsed is a helper method to define mock.On call
func (_e *MockMeter_Expecter) InteractionUsed() *MockMeter_InteractionUsed_Call {
	return &MockMeter_InteractionUsed_Call{Call: _e.mock.On("InteractionUsed")}
}

func (_c *MockMeter_InteractionUsed_Call) Run(run func()) *MockMeter_InteractionUsed_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockMeter_InteractionUsed_Call) Return(_a0 uint64, _a1 error) *MockMeter_InteractionUsed_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockMeter_InteractionUsed_Call) RunAndReturn(run func() (uint64, error)) *MockMeter_InteractionUsed_Call {
	_c.Call.Return(run)
	return _c
}

// MemoryUsed provides a mock function with no fields
func (_m *MockMeter) MemoryUsed() (uint64, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for MemoryUsed")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func() (uint64, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockMeter_MemoryUsed_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MemoryUsed'
type MockMeter_MemoryUsed_Call struct {
	*mock.Call
}

// MemoryUsed is a helper method to define mock.On call
func (_e *MockMeter_Expecter) MemoryUsed() *MockMeter_MemoryUsed_Call {
	return &MockMeter_MemoryUsed_Call{Call: _e.mock.On("MemoryUsed")}
}

func (_c *MockMeter_MemoryUsed_Call) Run(run func()) *MockMeter_MemoryUsed_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockMeter_MemoryUsed_Call) Return(_a0 uint64, _a1 error) *MockMeter_MemoryUsed_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockMeter_MemoryUsed_Call) RunAndReturn(run func() (uint64, error)) *MockMeter_MemoryUsed_Call {
	_c.Call.Return(run)
	return _c
}

// MeterComputation provides a mock function with given fields: usage
func (_m *MockMeter) MeterComputation(usage common.ComputationUsage) error {
	ret := _m.Called(usage)

	if len(ret) == 0 {
		panic("no return value specified for MeterComputation")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(common.ComputationUsage) error); ok {
		r0 = rf(usage)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockMeter_MeterComputation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MeterComputation'
type MockMeter_MeterComputation_Call struct {
	*mock.Call
}

// MeterComputation is a helper method to define mock.On call
//   - usage common.ComputationUsage
func (_e *MockMeter_Expecter) MeterComputation(usage interface{}) *MockMeter_MeterComputation_Call {
	return &MockMeter_MeterComputation_Call{Call: _e.mock.On("MeterComputation", usage)}
}

func (_c *MockMeter_MeterComputation_Call) Run(run func(usage common.ComputationUsage)) *MockMeter_MeterComputation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(common.ComputationUsage))
	})
	return _c
}

func (_c *MockMeter_MeterComputation_Call) Return(_a0 error) *MockMeter_MeterComputation_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockMeter_MeterComputation_Call) RunAndReturn(run func(common.ComputationUsage) error) *MockMeter_MeterComputation_Call {
	_c.Call.Return(run)
	return _c
}

// MeterEmittedEvent provides a mock function with given fields: byteSize
func (_m *MockMeter) MeterEmittedEvent(byteSize uint64) error {
	ret := _m.Called(byteSize)

	if len(ret) == 0 {
		panic("no return value specified for MeterEmittedEvent")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(uint64) error); ok {
		r0 = rf(byteSize)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockMeter_MeterEmittedEvent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MeterEmittedEvent'
type MockMeter_MeterEmittedEvent_Call struct {
	*mock.Call
}

// MeterEmittedEvent is a helper method to define mock.On call
//   - byteSize uint64
func (_e *MockMeter_Expecter) MeterEmittedEvent(byteSize interface{}) *MockMeter_MeterEmittedEvent_Call {
	return &MockMeter_MeterEmittedEvent_Call{Call: _e.mock.On("MeterEmittedEvent", byteSize)}
}

func (_c *MockMeter_MeterEmittedEvent_Call) Run(run func(byteSize uint64)) *MockMeter_MeterEmittedEvent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint64))
	})
	return _c
}

func (_c *MockMeter_MeterEmittedEvent_Call) Return(_a0 error) *MockMeter_MeterEmittedEvent_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockMeter_MeterEmittedEvent_Call) RunAndReturn(run func(uint64) error) *MockMeter_MeterEmittedEvent_Call {
	_c.Call.Return(run)
	return _c
}

// MeterMemory provides a mock function with given fields: usage
func (_m *MockMeter) MeterMemory(usage common.MemoryUsage) error {
	ret := _m.Called(usage)

	if len(ret) == 0 {
		panic("no return value specified for MeterMemory")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(common.MemoryUsage) error); ok {
		r0 = rf(usage)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockMeter_MeterMemory_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MeterMemory'
type MockMeter_MeterMemory_Call struct {
	*mock.Call
}

// MeterMemory is a helper method to define mock.On call
//   - usage common.MemoryUsage
func (_e *MockMeter_Expecter) MeterMemory(usage interface{}) *MockMeter_MeterMemory_Call {
	return &MockMeter_MeterMemory_Call{Call: _e.mock.On("MeterMemory", usage)}
}

func (_c *MockMeter_MeterMemory_Call) Run(run func(usage common.MemoryUsage)) *MockMeter_MeterMemory_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(common.MemoryUsage))
	})
	return _c
}

func (_c *MockMeter_MeterMemory_Call) Return(_a0 error) *MockMeter_MeterMemory_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockMeter_MeterMemory_Call) RunAndReturn(run func(common.MemoryUsage) error) *MockMeter_MeterMemory_Call {
	_c.Call.Return(run)
	return _c
}

// TotalEmittedEventBytes provides a mock function with no fields
func (_m *MockMeter) TotalEmittedEventBytes() uint64 {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for TotalEmittedEventBytes")
	}

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	return r0
}

// MockMeter_TotalEmittedEventBytes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TotalEmittedEventBytes'
type MockMeter_TotalEmittedEventBytes_Call struct {
	*mock.Call
}

// TotalEmittedEventBytes is a helper method to define mock.On call
func (_e *MockMeter_Expecter) TotalEmittedEventBytes() *MockMeter_TotalEmittedEventBytes_Call {
	return &MockMeter_TotalEmittedEventBytes_Call{Call: _e.mock.On("TotalEmittedEventBytes")}
}

func (_c *MockMeter_TotalEmittedEventBytes_Call) Run(run func()) *MockMeter_TotalEmittedEventBytes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockMeter_TotalEmittedEventBytes_Call) Return(_a0 uint64) *MockMeter_TotalEmittedEventBytes_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockMeter_TotalEmittedEventBytes_Call) RunAndReturn(run func() uint64) *MockMeter_TotalEmittedEventBytes_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockMeter creates a new instance of MockMeter. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockMeter(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockMeter {
	mock := &MockMeter{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
