// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mock

import (
	"time"

	"github.com/coreos/go-semver/semver"
	"github.com/onflow/atree"
	"github.com/onflow/cadence"
	"github.com/onflow/cadence/ast"
	"github.com/onflow/cadence/common"
	"github.com/onflow/cadence/interpreter"
	"github.com/onflow/cadence/runtime"
	"github.com/onflow/cadence/sema"
	"github.com/onflow/flow-go/fvm/environment"
	"github.com/onflow/flow-go/fvm/meter"
	runtime0 "github.com/onflow/flow-go/fvm/runtime"
	"github.com/onflow/flow-go/fvm/tracing"
	"github.com/onflow/flow-go/model/flow"
	"github.com/onflow/flow-go/module/trace"
	"github.com/rs/zerolog"
	mock "github.com/stretchr/testify/mock"
	"go.opentelemetry.io/otel/attribute"
	trace0 "go.opentelemetry.io/otel/trace"
)

// NewAddressGenerator creates a new instance of AddressGenerator. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewAddressGenerator(t interface {
	mock.TestingT
	Cleanup(func())
}) *AddressGenerator {
	mock := &AddressGenerator{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// AddressGenerator is an autogenerated mock type for the AddressGenerator type
type AddressGenerator struct {
	mock.Mock
}

type AddressGenerator_Expecter struct {
	mock *mock.Mock
}

func (_m *AddressGenerator) EXPECT() *AddressGenerator_Expecter {
	return &AddressGenerator_Expecter{mock: &_m.Mock}
}

// AddressCount provides a mock function for the type AddressGenerator
func (_mock *AddressGenerator) AddressCount() uint64 {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for AddressCount")
	}

	var r0 uint64
	if returnFunc, ok := ret.Get(0).(func() uint64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint64)
	}
	return r0
}

// AddressGenerator_AddressCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddressCount'
type AddressGenerator_AddressCount_Call struct {
	*mock.Call
}

// AddressCount is a helper method to define mock.On call
func (_e *AddressGenerator_Expecter) AddressCount() *AddressGenerator_AddressCount_Call {
	return &AddressGenerator_AddressCount_Call{Call: _e.mock.On("AddressCount")}
}

func (_c *AddressGenerator_AddressCount_Call) Run(run func()) *AddressGenerator_AddressCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *AddressGenerator_AddressCount_Call) Return(v uint64) *AddressGenerator_AddressCount_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *AddressGenerator_AddressCount_Call) RunAndReturn(run func() uint64) *AddressGenerator_AddressCount_Call {
	_c.Call.Return(run)
	return _c
}

// Bytes provides a mock function for the type AddressGenerator
func (_mock *AddressGenerator) Bytes() []byte {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Bytes")
	}

	var r0 []byte
	if returnFunc, ok := ret.Get(0).(func() []byte); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}
	return r0
}

// AddressGenerator_Bytes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Bytes'
type AddressGenerator_Bytes_Call struct {
	*mock.Call
}

// Bytes is a helper method to define mock.On call
func (_e *AddressGenerator_Expecter) Bytes() *AddressGenerator_Bytes_Call {
	return &AddressGenerator_Bytes_Call{Call: _e.mock.On("Bytes")}
}

func (_c *AddressGenerator_Bytes_Call) Run(run func()) *AddressGenerator_Bytes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *AddressGenerator_Bytes_Call) Return(bytes []byte) *AddressGenerator_Bytes_Call {
	_c.Call.Return(bytes)
	return _c
}

func (_c *AddressGenerator_Bytes_Call) RunAndReturn(run func() []byte) *AddressGenerator_Bytes_Call {
	_c.Call.Return(run)
	return _c
}

// CurrentAddress provides a mock function for the type AddressGenerator
func (_mock *AddressGenerator) CurrentAddress() flow.Address {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for CurrentAddress")
	}

	var r0 flow.Address
	if returnFunc, ok := ret.Get(0).(func() flow.Address); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.Address)
		}
	}
	return r0
}

// AddressGenerator_CurrentAddress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CurrentAddress'
type AddressGenerator_CurrentAddress_Call struct {
	*mock.Call
}

// CurrentAddress is a helper method to define mock.On call
func (_e *AddressGenerator_Expecter) CurrentAddress() *AddressGenerator_CurrentAddress_Call {
	return &AddressGenerator_CurrentAddress_Call{Call: _e.mock.On("CurrentAddress")}
}

func (_c *AddressGenerator_CurrentAddress_Call) Run(run func()) *AddressGenerator_CurrentAddress_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *AddressGenerator_CurrentAddress_Call) Return(address flow.Address) *AddressGenerator_CurrentAddress_Call {
	_c.Call.Return(address)
	return _c
}

func (_c *AddressGenerator_CurrentAddress_Call) RunAndReturn(run func() flow.Address) *AddressGenerator_CurrentAddress_Call {
	_c.Call.Return(run)
	return _c
}

// NextAddress provides a mock function for the type AddressGenerator
func (_mock *AddressGenerator) NextAddress() (flow.Address, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for NextAddress")
	}

	var r0 flow.Address
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (flow.Address, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() flow.Address); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.Address)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// AddressGenerator_NextAddress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NextAddress'
type AddressGenerator_NextAddress_Call struct {
	*mock.Call
}

// NextAddress is a helper method to define mock.On call
func (_e *AddressGenerator_Expecter) NextAddress() *AddressGenerator_NextAddress_Call {
	return &AddressGenerator_NextAddress_Call{Call: _e.mock.On("NextAddress")}
}

func (_c *AddressGenerator_NextAddress_Call) Run(run func()) *AddressGenerator_NextAddress_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *AddressGenerator_NextAddress_Call) Return(address flow.Address, err error) *AddressGenerator_NextAddress_Call {
	_c.Call.Return(address, err)
	return _c
}

func (_c *AddressGenerator_NextAddress_Call) RunAndReturn(run func() (flow.Address, error)) *AddressGenerator_NextAddress_Call {
	_c.Call.Return(run)
	return _c
}

// NewBootstrapAccountCreator creates a new instance of BootstrapAccountCreator. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewBootstrapAccountCreator(t interface {
	mock.TestingT
	Cleanup(func())
}) *BootstrapAccountCreator {
	mock := &BootstrapAccountCreator{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// BootstrapAccountCreator is an autogenerated mock type for the BootstrapAccountCreator type
type BootstrapAccountCreator struct {
	mock.Mock
}

type BootstrapAccountCreator_Expecter struct {
	mock *mock.Mock
}

func (_m *BootstrapAccountCreator) EXPECT() *BootstrapAccountCreator_Expecter {
	return &BootstrapAccountCreator_Expecter{mock: &_m.Mock}
}

// CreateBootstrapAccount provides a mock function for the type BootstrapAccountCreator
func (_mock *BootstrapAccountCreator) CreateBootstrapAccount(publicKeys []flow.AccountPublicKey) (flow.Address, error) {
	ret := _mock.Called(publicKeys)

	if len(ret) == 0 {
		panic("no return value specified for CreateBootstrapAccount")
	}

	var r0 flow.Address
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]flow.AccountPublicKey) (flow.Address, error)); ok {
		return returnFunc(publicKeys)
	}
	if returnFunc, ok := ret.Get(0).(func([]flow.AccountPublicKey) flow.Address); ok {
		r0 = returnFunc(publicKeys)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.Address)
		}
	}
	if returnFunc, ok := ret.Get(1).(func([]flow.AccountPublicKey) error); ok {
		r1 = returnFunc(publicKeys)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// BootstrapAccountCreator_CreateBootstrapAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateBootstrapAccount'
type BootstrapAccountCreator_CreateBootstrapAccount_Call struct {
	*mock.Call
}

// CreateBootstrapAccount is a helper method to define mock.On call
//   - publicKeys []flow.AccountPublicKey
func (_e *BootstrapAccountCreator_Expecter) CreateBootstrapAccount(publicKeys interface{}) *BootstrapAccountCreator_CreateBootstrapAccount_Call {
	return &BootstrapAccountCreator_CreateBootstrapAccount_Call{Call: _e.mock.On("CreateBootstrapAccount", publicKeys)}
}

func (_c *BootstrapAccountCreator_CreateBootstrapAccount_Call) Run(run func(publicKeys []flow.AccountPublicKey)) *BootstrapAccountCreator_CreateBootstrapAccount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []flow.AccountPublicKey
		if args[0] != nil {
			arg0 = args[0].([]flow.AccountPublicKey)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *BootstrapAccountCreator_CreateBootstrapAccount_Call) Return(address flow.Address, err error) *BootstrapAccountCreator_CreateBootstrapAccount_Call {
	_c.Call.Return(address, err)
	return _c
}

func (_c *BootstrapAccountCreator_CreateBootstrapAccount_Call) RunAndReturn(run func(publicKeys []flow.AccountPublicKey) (flow.Address, error)) *BootstrapAccountCreator_CreateBootstrapAccount_Call {
	_c.Call.Return(run)
	return _c
}

// NewAccountCreator creates a new instance of AccountCreator. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewAccountCreator(t interface {
	mock.TestingT
	Cleanup(func())
}) *AccountCreator {
	mock := &AccountCreator{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// AccountCreator is an autogenerated mock type for the AccountCreator type
type AccountCreator struct {
	mock.Mock
}

type AccountCreator_Expecter struct {
	mock *mock.Mock
}

func (_m *AccountCreator) EXPECT() *AccountCreator_Expecter {
	return &AccountCreator_Expecter{mock: &_m.Mock}
}

// CreateAccount provides a mock function for the type AccountCreator
func (_mock *AccountCreator) CreateAccount(runtimePayer common.Address) (common.Address, error) {
	ret := _mock.Called(runtimePayer)

	if len(ret) == 0 {
		panic("no return value specified for CreateAccount")
	}

	var r0 common.Address
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(common.Address) (common.Address, error)); ok {
		return returnFunc(runtimePayer)
	}
	if returnFunc, ok := ret.Get(0).(func(common.Address) common.Address); ok {
		r0 = returnFunc(runtimePayer)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(common.Address) error); ok {
		r1 = returnFunc(runtimePayer)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// AccountCreator_CreateAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateAccount'
type AccountCreator_CreateAccount_Call struct {
	*mock.Call
}

// CreateAccount is a helper method to define mock.On call
//   - runtimePayer common.Address
func (_e *AccountCreator_Expecter) CreateAccount(runtimePayer interface{}) *AccountCreator_CreateAccount_Call {
	return &AccountCreator_CreateAccount_Call{Call: _e.mock.On("CreateAccount", runtimePayer)}
}

func (_c *AccountCreator_CreateAccount_Call) Run(run func(runtimePayer common.Address)) *AccountCreator_CreateAccount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 common.Address
		if args[0] != nil {
			arg0 = args[0].(common.Address)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *AccountCreator_CreateAccount_Call) Return(address common.Address, err error) *AccountCreator_CreateAccount_Call {
	_c.Call.Return(address, err)
	return _c
}

func (_c *AccountCreator_CreateAccount_Call) RunAndReturn(run func(runtimePayer common.Address) (common.Address, error)) *AccountCreator_CreateAccount_Call {
	_c.Call.Return(run)
	return _c
}

// NewAccountInfo creates a new instance of AccountInfo. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewAccountInfo(t interface {
	mock.TestingT
	Cleanup(func())
}) *AccountInfo {
	mock := &AccountInfo{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// AccountInfo is an autogenerated mock type for the AccountInfo type
type AccountInfo struct {
	mock.Mock
}

type AccountInfo_Expecter struct {
	mock *mock.Mock
}

func (_m *AccountInfo) EXPECT() *AccountInfo_Expecter {
	return &AccountInfo_Expecter{mock: &_m.Mock}
}

// GetAccount provides a mock function for the type AccountInfo
func (_mock *AccountInfo) GetAccount(address flow.Address) (*flow.Account, error) {
	ret := _mock.Called(address)

	if len(ret) == 0 {
		panic("no return value specified for GetAccount")
	}

	var r0 *flow.Account
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Address) (*flow.Account, error)); ok {
		return returnFunc(address)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Address) *flow.Account); ok {
		r0 = returnFunc(address)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.Account)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Address) error); ok {
		r1 = returnFunc(address)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// AccountInfo_GetAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAccount'
type AccountInfo_GetAccount_Call struct {
	*mock.Call
}

// GetAccount is a helper method to define mock.On call
//   - address flow.Address
func (_e *AccountInfo_Expecter) GetAccount(address interface{}) *AccountInfo_GetAccount_Call {
	return &AccountInfo_GetAccount_Call{Call: _e.mock.On("GetAccount", address)}
}

func (_c *AccountInfo_GetAccount_Call) Run(run func(address flow.Address)) *AccountInfo_GetAccount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Address
		if args[0] != nil {
			arg0 = args[0].(flow.Address)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *AccountInfo_GetAccount_Call) Return(account *flow.Account, err error) *AccountInfo_GetAccount_Call {
	_c.Call.Return(account, err)
	return _c
}

func (_c *AccountInfo_GetAccount_Call) RunAndReturn(run func(address flow.Address) (*flow.Account, error)) *AccountInfo_GetAccount_Call {
	_c.Call.Return(run)
	return _c
}

// GetAccountAvailableBalance provides a mock function for the type AccountInfo
func (_mock *AccountInfo) GetAccountAvailableBalance(runtimeAddress common.Address) (uint64, error) {
	ret := _mock.Called(runtimeAddress)

	if len(ret) == 0 {
		panic("no return value specified for GetAccountAvailableBalance")
	}

	var r0 uint64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(common.Address) (uint64, error)); ok {
		return returnFunc(runtimeAddress)
	}
	if returnFunc, ok := ret.Get(0).(func(common.Address) uint64); ok {
		r0 = returnFunc(runtimeAddress)
	} else {
		r0 = ret.Get(0).(uint64)
	}
	if returnFunc, ok := ret.Get(1).(func(common.Address) error); ok {
		r1 = returnFunc(runtimeAddress)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// AccountInfo_GetAccountAvailableBalance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAccountAvailableBalance'
type AccountInfo_GetAccountAvailableBalance_Call struct {
	*mock.Call
}

// GetAccountAvailableBalance is a helper method to define mock.On call
//   - runtimeAddress common.Address
func (_e *AccountInfo_Expecter) GetAccountAvailableBalance(runtimeAddress interface{}) *AccountInfo_GetAccountAvailableBalance_Call {
	return &AccountInfo_GetAccountAvailableBalance_Call{Call: _e.mock.On("GetAccountAvailableBalance", runtimeAddress)}
}

func (_c *AccountInfo_GetAccountAvailableBalance_Call) Run(run func(runtimeAddress common.Address)) *AccountInfo_GetAccountAvailableBalance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 common.Address
		if args[0] != nil {
			arg0 = args[0].(common.Address)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *AccountInfo_GetAccountAvailableBalance_Call) Return(v uint64, err error) *AccountInfo_GetAccountAvailableBalance_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *AccountInfo_GetAccountAvailableBalance_Call) RunAndReturn(run func(runtimeAddress common.Address) (uint64, error)) *AccountInfo_GetAccountAvailableBalance_Call {
	_c.Call.Return(run)
	return _c
}

// GetAccountBalance provides a mock function for the type AccountInfo
func (_mock *AccountInfo) GetAccountBalance(runtimeAddress common.Address) (uint64, error) {
	ret := _mock.Called(runtimeAddress)

	if len(ret) == 0 {
		panic("no return value specified for GetAccountBalance")
	}

	var r0 uint64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(common.Address) (uint64, error)); ok {
		return returnFunc(runtimeAddress)
	}
	if returnFunc, ok := ret.Get(0).(func(common.Address) uint64); ok {
		r0 = returnFunc(runtimeAddress)
	} else {
		r0 = ret.Get(0).(uint64)
	}
	if returnFunc, ok := ret.Get(1).(func(common.Address) error); ok {
		r1 = returnFunc(runtimeAddress)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// AccountInfo_GetAccountBalance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAccountBalance'
type AccountInfo_GetAccountBalance_Call struct {
	*mock.Call
}

// GetAccountBalance is a helper method to define mock.On call
//   - runtimeAddress common.Address
func (_e *AccountInfo_Expecter) GetAccountBalance(runtimeAddress interface{}) *AccountInfo_GetAccountBalance_Call {
	return &AccountInfo_GetAccountBalance_Call{Call: _e.mock.On("GetAccountBalance", runtimeAddress)}
}

func (_c *AccountInfo_GetAccountBalance_Call) Run(run func(runtimeAddress common.Address)) *AccountInfo_GetAccountBalance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 common.Address
		if args[0] != nil {
			arg0 = args[0].(common.Address)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *AccountInfo_GetAccountBalance_Call) Return(v uint64, err error) *AccountInfo_GetAccountBalance_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *AccountInfo_GetAccountBalance_Call) RunAndReturn(run func(runtimeAddress common.Address) (uint64, error)) *AccountInfo_GetAccountBalance_Call {
	_c.Call.Return(run)
	return _c
}

// GetAccountKeyByIndex provides a mock function for the type AccountInfo
func (_mock *AccountInfo) GetAccountKeyByIndex(address flow.Address, index uint32) (*flow.AccountPublicKey, error) {
	ret := _mock.Called(address, index)

	if len(ret) == 0 {
		panic("no return value specified for GetAccountKeyByIndex")
	}

	var r0 *flow.AccountPublicKey
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Address, uint32) (*flow.AccountPublicKey, error)); ok {
		return returnFunc(address, index)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Address, uint32) *flow.AccountPublicKey); ok {
		r0 = returnFunc(address, index)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.AccountPublicKey)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Address, uint32) error); ok {
		r1 = returnFunc(address, index)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// AccountInfo_GetAccountKeyByIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAccountKeyByIndex'
type AccountInfo_GetAccountKeyByIndex_Call struct {
	*mock.Call
}

// GetAccountKeyByIndex is a helper method to define mock.On call
//   - address flow.Address
//   - index uint32
func (_e *AccountInfo_Expecter) GetAccountKeyByIndex(address interface{}, index interface{}) *AccountInfo_GetAccountKeyByIndex_Call {
	return &AccountInfo_GetAccountKeyByIndex_Call{Call: _e.mock.On("GetAccountKeyByIndex", address, index)}
}

func (_c *AccountInfo_GetAccountKeyByIndex_Call) Run(run func(address flow.Address, index uint32)) *AccountInfo_GetAccountKeyByIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Address
		if args[0] != nil {
			arg0 = args[0].(flow.Address)
		}
		var arg1 uint32
		if args[1] != nil {
			arg1 = args[1].(uint32)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *AccountInfo_GetAccountKeyByIndex_Call) Return(accountPublicKey *flow.AccountPublicKey, err error) *AccountInfo_GetAccountKeyByIndex_Call {
	_c.Call.Return(accountPublicKey, err)
	return _c
}

func (_c *AccountInfo_GetAccountKeyByIndex_Call) RunAndReturn(run func(address flow.Address, index uint32) (*flow.AccountPublicKey, error)) *AccountInfo_GetAccountKeyByIndex_Call {
	_c.Call.Return(run)
	return _c
}

// GetAccountKeys provides a mock function for the type AccountInfo
func (_mock *AccountInfo) GetAccountKeys(address flow.Address) ([]flow.AccountPublicKey, error) {
	ret := _mock.Called(address)

	if len(ret) == 0 {
		panic("no return value specified for GetAccountKeys")
	}

	var r0 []flow.AccountPublicKey
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Address) ([]flow.AccountPublicKey, error)); ok {
		return returnFunc(address)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Address) []flow.AccountPublicKey); ok {
		r0 = returnFunc(address)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]flow.AccountPublicKey)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Address) error); ok {
		r1 = returnFunc(address)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// AccountInfo_GetAccountKeys_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAccountKeys'
type AccountInfo_GetAccountKeys_Call struct {
	*mock.Call
}

// GetAccountKeys is a helper method to define mock.On call
//   - address flow.Address
func (_e *AccountInfo_Expecter) GetAccountKeys(address interface{}) *AccountInfo_GetAccountKeys_Call {
	return &AccountInfo_GetAccountKeys_Call{Call: _e.mock.On("GetAccountKeys", address)}
}

func (_c *AccountInfo_GetAccountKeys_Call) Run(run func(address flow.Address)) *AccountInfo_GetAccountKeys_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Address
		if args[0] != nil {
			arg0 = args[0].(flow.Address)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *AccountInfo_GetAccountKeys_Call) Return(accountPublicKeys []flow.AccountPublicKey, err error) *AccountInfo_GetAccountKeys_Call {
	_c.Call.Return(accountPublicKeys, err)
	return _c
}

func (_c *AccountInfo_GetAccountKeys_Call) RunAndReturn(run func(address flow.Address) ([]flow.AccountPublicKey, error)) *AccountInfo_GetAccountKeys_Call {
	_c.Call.Return(run)
	return _c
}

// GetStorageCapacity provides a mock function for the type AccountInfo
func (_mock *AccountInfo) GetStorageCapacity(runtimeAddress common.Address) (uint64, error) {
	ret := _mock.Called(runtimeAddress)

	if len(ret) == 0 {
		panic("no return value specified for GetStorageCapacity")
	}

	var r0 uint64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(common.Address) (uint64, error)); ok {
		return returnFunc(runtimeAddress)
	}
	if returnFunc, ok := ret.Get(0).(func(common.Address) uint64); ok {
		r0 = returnFunc(runtimeAddress)
	} else {
		r0 = ret.Get(0).(uint64)
	}
	if returnFunc, ok := ret.Get(1).(func(common.Address) error); ok {
		r1 = returnFunc(runtimeAddress)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// AccountInfo_GetStorageCapacity_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetStorageCapacity'
type AccountInfo_GetStorageCapacity_Call struct {
	*mock.Call
}

// GetStorageCapacity is a helper method to define mock.On call
//   - runtimeAddress common.Address
func (_e *AccountInfo_Expecter) GetStorageCapacity(runtimeAddress interface{}) *AccountInfo_GetStorageCapacity_Call {
	return &AccountInfo_GetStorageCapacity_Call{Call: _e.mock.On("GetStorageCapacity", runtimeAddress)}
}

func (_c *AccountInfo_GetStorageCapacity_Call) Run(run func(runtimeAddress common.Address)) *AccountInfo_GetStorageCapacity_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 common.Address
		if args[0] != nil {
			arg0 = args[0].(common.Address)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *AccountInfo_GetStorageCapacity_Call) Return(v uint64, err error) *AccountInfo_GetStorageCapacity_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *AccountInfo_GetStorageCapacity_Call) RunAndReturn(run func(runtimeAddress common.Address) (uint64, error)) *AccountInfo_GetStorageCapacity_Call {
	_c.Call.Return(run)
	return _c
}

// GetStorageUsed provides a mock function for the type AccountInfo
func (_mock *AccountInfo) GetStorageUsed(runtimeAddress common.Address) (uint64, error) {
	ret := _mock.Called(runtimeAddress)

	if len(ret) == 0 {
		panic("no return value specified for GetStorageUsed")
	}

	var r0 uint64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(common.Address) (uint64, error)); ok {
		return returnFunc(runtimeAddress)
	}
	if returnFunc, ok := ret.Get(0).(func(common.Address) uint64); ok {
		r0 = returnFunc(runtimeAddress)
	} else {
		r0 = ret.Get(0).(uint64)
	}
	if returnFunc, ok := ret.Get(1).(func(common.Address) error); ok {
		r1 = returnFunc(runtimeAddress)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// AccountInfo_GetStorageUsed_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetStorageUsed'
type AccountInfo_GetStorageUsed_Call struct {
	*mock.Call
}

// GetStorageUsed is a helper method to define mock.On call
//   - runtimeAddress common.Address
func (_e *AccountInfo_Expecter) GetStorageUsed(runtimeAddress interface{}) *AccountInfo_GetStorageUsed_Call {
	return &AccountInfo_GetStorageUsed_Call{Call: _e.mock.On("GetStorageUsed", runtimeAddress)}
}

func (_c *AccountInfo_GetStorageUsed_Call) Run(run func(runtimeAddress common.Address)) *AccountInfo_GetStorageUsed_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 common.Address
		if args[0] != nil {
			arg0 = args[0].(common.Address)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *AccountInfo_GetStorageUsed_Call) Return(v uint64, err error) *AccountInfo_GetStorageUsed_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *AccountInfo_GetStorageUsed_Call) RunAndReturn(run func(runtimeAddress common.Address) (uint64, error)) *AccountInfo_GetStorageUsed_Call {
	_c.Call.Return(run)
	return _c
}

// NewAccountKeyReader creates a new instance of AccountKeyReader. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewAccountKeyReader(t interface {
	mock.TestingT
	Cleanup(func())
}) *AccountKeyReader {
	mock := &AccountKeyReader{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// AccountKeyReader is an autogenerated mock type for the AccountKeyReader type
type AccountKeyReader struct {
	mock.Mock
}

type AccountKeyReader_Expecter struct {
	mock *mock.Mock
}

func (_m *AccountKeyReader) EXPECT() *AccountKeyReader_Expecter {
	return &AccountKeyReader_Expecter{mock: &_m.Mock}
}

// AccountKeysCount provides a mock function for the type AccountKeyReader
func (_mock *AccountKeyReader) AccountKeysCount(runtimeAddress common.Address) (uint32, error) {
	ret := _mock.Called(runtimeAddress)

	if len(ret) == 0 {
		panic("no return value specified for AccountKeysCount")
	}

	var r0 uint32
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(common.Address) (uint32, error)); ok {
		return returnFunc(runtimeAddress)
	}
	if returnFunc, ok := ret.Get(0).(func(common.Address) uint32); ok {
		r0 = returnFunc(runtimeAddress)
	} else {
		r0 = ret.Get(0).(uint32)
	}
	if returnFunc, ok := ret.Get(1).(func(common.Address) error); ok {
		r1 = returnFunc(runtimeAddress)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// AccountKeyReader_AccountKeysCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AccountKeysCount'
type AccountKeyReader_AccountKeysCount_Call struct {
	*mock.Call
}

// AccountKeysCount is a helper method to define mock.On call
//   - runtimeAddress common.Address
func (_e *AccountKeyReader_Expecter) AccountKeysCount(runtimeAddress interface{}) *AccountKeyReader_AccountKeysCount_Call {
	return &AccountKeyReader_AccountKeysCount_Call{Call: _e.mock.On("AccountKeysCount", runtimeAddress)}
}

func (_c *AccountKeyReader_AccountKeysCount_Call) Run(run func(runtimeAddress common.Address)) *AccountKeyReader_AccountKeysCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 common.Address
		if args[0] != nil {
			arg0 = args[0].(common.Address)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *AccountKeyReader_AccountKeysCount_Call) Return(v uint32, err error) *AccountKeyReader_AccountKeysCount_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *AccountKeyReader_AccountKeysCount_Call) RunAndReturn(run func(runtimeAddress common.Address) (uint32, error)) *AccountKeyReader_AccountKeysCount_Call {
	_c.Call.Return(run)
	return _c
}

// GetAccountKey provides a mock function for the type AccountKeyReader
func (_mock *AccountKeyReader) GetAccountKey(runtimeAddress common.Address, keyIndex uint32) (*runtime.AccountKey, error) {
	ret := _mock.Called(runtimeAddress, keyIndex)

	if len(ret) == 0 {
		panic("no return value specified for GetAccountKey")
	}

	var r0 *runtime.AccountKey
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(common.Address, uint32) (*runtime.AccountKey, error)); ok {
		return returnFunc(runtimeAddress, keyIndex)
	}
	if returnFunc, ok := ret.Get(0).(func(common.Address, uint32) *runtime.AccountKey); ok {
		r0 = returnFunc(runtimeAddress, keyIndex)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*runtime.AccountKey)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(common.Address, uint32) error); ok {
		r1 = returnFunc(runtimeAddress, keyIndex)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// AccountKeyReader_GetAccountKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAccountKey'
type AccountKeyReader_GetAccountKey_Call struct {
	*mock.Call
}

// GetAccountKey is a helper method to define mock.On call
//   - runtimeAddress common.Address
//   - keyIndex uint32
func (_e *AccountKeyReader_Expecter) GetAccountKey(runtimeAddress interface{}, keyIndex interface{}) *AccountKeyReader_GetAccountKey_Call {
	return &AccountKeyReader_GetAccountKey_Call{Call: _e.mock.On("GetAccountKey", runtimeAddress, keyIndex)}
}

func (_c *AccountKeyReader_GetAccountKey_Call) Run(run func(runtimeAddress common.Address, keyIndex uint32)) *AccountKeyReader_GetAccountKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 common.Address
		if args[0] != nil {
			arg0 = args[0].(common.Address)
		}
		var arg1 uint32
		if args[1] != nil {
			arg1 = args[1].(uint32)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *AccountKeyReader_GetAccountKey_Call) Return(v *runtime.AccountKey, err error) *AccountKeyReader_GetAccountKey_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *AccountKeyReader_GetAccountKey_Call) RunAndReturn(run func(runtimeAddress common.Address, keyIndex uint32) (*runtime.AccountKey, error)) *AccountKeyReader_GetAccountKey_Call {
	_c.Call.Return(run)
	return _c
}

// NewAccountKeyUpdater creates a new instance of AccountKeyUpdater. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewAccountKeyUpdater(t interface {
	mock.TestingT
	Cleanup(func())
}) *AccountKeyUpdater {
	mock := &AccountKeyUpdater{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// AccountKeyUpdater is an autogenerated mock type for the AccountKeyUpdater type
type AccountKeyUpdater struct {
	mock.Mock
}

type AccountKeyUpdater_Expecter struct {
	mock *mock.Mock
}

func (_m *AccountKeyUpdater) EXPECT() *AccountKeyUpdater_Expecter {
	return &AccountKeyUpdater_Expecter{mock: &_m.Mock}
}

// AddAccountKey provides a mock function for the type AccountKeyUpdater
func (_mock *AccountKeyUpdater) AddAccountKey(runtimeAddress common.Address, publicKey *runtime.PublicKey, hashAlgo runtime.HashAlgorithm, weight int) (*runtime.AccountKey, error) {
	ret := _mock.Called(runtimeAddress, publicKey, hashAlgo, weight)

	if len(ret) == 0 {
		panic("no return value specified for AddAccountKey")
	}

	var r0 *runtime.AccountKey
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(common.Address, *runtime.PublicKey, runtime.HashAlgorithm, int) (*runtime.AccountKey, error)); ok {
		return returnFunc(runtimeAddress, publicKey, hashAlgo, weight)
	}
	if returnFunc, ok := ret.Get(0).(func(common.Address, *runtime.PublicKey, runtime.HashAlgorithm, int) *runtime.AccountKey); ok {
		r0 = returnFunc(runtimeAddress, publicKey, hashAlgo, weight)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*runtime.AccountKey)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(common.Address, *runtime.PublicKey, runtime.HashAlgorithm, int) error); ok {
		r1 = returnFunc(runtimeAddress, publicKey, hashAlgo, weight)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// AccountKeyUpdater_AddAccountKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddAccountKey'
type AccountKeyUpdater_AddAccountKey_Call struct {
	*mock.Call
}

// AddAccountKey is a helper method to define mock.On call
//   - runtimeAddress common.Address
//   - publicKey *runtime.PublicKey
//   - hashAlgo runtime.HashAlgorithm
//   - weight int
func (_e *AccountKeyUpdater_Expecter) AddAccountKey(runtimeAddress interface{}, publicKey interface{}, hashAlgo interface{}, weight interface{}) *AccountKeyUpdater_AddAccountKey_Call {
	return &AccountKeyUpdater_AddAccountKey_Call{Call: _e.mock.On("AddAccountKey", runtimeAddress, publicKey, hashAlgo, weight)}
}

func (_c *AccountKeyUpdater_AddAccountKey_Call) Run(run func(runtimeAddress common.Address, publicKey *runtime.PublicKey, hashAlgo runtime.HashAlgorithm, weight int)) *AccountKeyUpdater_AddAccountKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 common.Address
		if args[0] != nil {
			arg0 = args[0].(common.Address)
		}
		var arg1 *runtime.PublicKey
		if args[1] != nil {
			arg1 = args[1].(*runtime.PublicKey)
		}
		var arg2 runtime.HashAlgorithm
		if args[2] != nil {
			arg2 = args[2].(runtime.HashAlgorithm)
		}
		var arg3 int
		if args[3] != nil {
			arg3 = args[3].(int)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *AccountKeyUpdater_AddAccountKey_Call) Return(v *runtime.AccountKey, err error) *AccountKeyUpdater_AddAccountKey_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *AccountKeyUpdater_AddAccountKey_Call) RunAndReturn(run func(runtimeAddress common.Address, publicKey *runtime.PublicKey, hashAlgo runtime.HashAlgorithm, weight int) (*runtime.AccountKey, error)) *AccountKeyUpdater_AddAccountKey_Call {
	_c.Call.Return(run)
	return _c
}

// RevokeAccountKey provides a mock function for the type AccountKeyUpdater
func (_mock *AccountKeyUpdater) RevokeAccountKey(runtimeAddress common.Address, keyIndex uint32) (*runtime.AccountKey, error) {
	ret := _mock.Called(runtimeAddress, keyIndex)

	if len(ret) == 0 {
		panic("no return value specified for RevokeAccountKey")
	}

	var r0 *runtime.AccountKey
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(common.Address, uint32) (*runtime.AccountKey, error)); ok {
		return returnFunc(runtimeAddress, keyIndex)
	}
	if returnFunc, ok := ret.Get(0).(func(common.Address, uint32) *runtime.AccountKey); ok {
		r0 = returnFunc(runtimeAddress, keyIndex)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*runtime.AccountKey)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(common.Address, uint32) error); ok {
		r1 = returnFunc(runtimeAddress, keyIndex)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// AccountKeyUpdater_RevokeAccountKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RevokeAccountKey'
type AccountKeyUpdater_RevokeAccountKey_Call struct {
	*mock.Call
}

// RevokeAccountKey is a helper method to define mock.On call
//   - runtimeAddress common.Address
//   - keyIndex uint32
func (_e *AccountKeyUpdater_Expecter) RevokeAccountKey(runtimeAddress interface{}, keyIndex interface{}) *AccountKeyUpdater_RevokeAccountKey_Call {
	return &AccountKeyUpdater_RevokeAccountKey_Call{Call: _e.mock.On("RevokeAccountKey", runtimeAddress, keyIndex)}
}

func (_c *AccountKeyUpdater_RevokeAccountKey_Call) Run(run func(runtimeAddress common.Address, keyIndex uint32)) *AccountKeyUpdater_RevokeAccountKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 common.Address
		if args[0] != nil {
			arg0 = args[0].(common.Address)
		}
		var arg1 uint32
		if args[1] != nil {
			arg1 = args[1].(uint32)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *AccountKeyUpdater_RevokeAccountKey_Call) Return(v *runtime.AccountKey, err error) *AccountKeyUpdater_RevokeAccountKey_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *AccountKeyUpdater_RevokeAccountKey_Call) RunAndReturn(run func(runtimeAddress common.Address, keyIndex uint32) (*runtime.AccountKey, error)) *AccountKeyUpdater_RevokeAccountKey_Call {
	_c.Call.Return(run)
	return _c
}

// NewAccountLocalIDGenerator creates a new instance of AccountLocalIDGenerator. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewAccountLocalIDGenerator(t interface {
	mock.TestingT
	Cleanup(func())
}) *AccountLocalIDGenerator {
	mock := &AccountLocalIDGenerator{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// AccountLocalIDGenerator is an autogenerated mock type for the AccountLocalIDGenerator type
type AccountLocalIDGenerator struct {
	mock.Mock
}

type AccountLocalIDGenerator_Expecter struct {
	mock *mock.Mock
}

func (_m *AccountLocalIDGenerator) EXPECT() *AccountLocalIDGenerator_Expecter {
	return &AccountLocalIDGenerator_Expecter{mock: &_m.Mock}
}

// GenerateAccountID provides a mock function for the type AccountLocalIDGenerator
func (_mock *AccountLocalIDGenerator) GenerateAccountID(address common.Address) (uint64, error) {
	ret := _mock.Called(address)

	if len(ret) == 0 {
		panic("no return value specified for GenerateAccountID")
	}

	var r0 uint64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(common.Address) (uint64, error)); ok {
		return returnFunc(address)
	}
	if returnFunc, ok := ret.Get(0).(func(common.Address) uint64); ok {
		r0 = returnFunc(address)
	} else {
		r0 = ret.Get(0).(uint64)
	}
	if returnFunc, ok := ret.Get(1).(func(common.Address) error); ok {
		r1 = returnFunc(address)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// AccountLocalIDGenerator_GenerateAccountID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GenerateAccountID'
type AccountLocalIDGenerator_GenerateAccountID_Call struct {
	*mock.Call
}

// GenerateAccountID is a helper method to define mock.On call
//   - address common.Address
func (_e *AccountLocalIDGenerator_Expecter) GenerateAccountID(address interface{}) *AccountLocalIDGenerator_GenerateAccountID_Call {
	return &AccountLocalIDGenerator_GenerateAccountID_Call{Call: _e.mock.On("GenerateAccountID", address)}
}

func (_c *AccountLocalIDGenerator_GenerateAccountID_Call) Run(run func(address common.Address)) *AccountLocalIDGenerator_GenerateAccountID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 common.Address
		if args[0] != nil {
			arg0 = args[0].(common.Address)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *AccountLocalIDGenerator_GenerateAccountID_Call) Return(v uint64, err error) *AccountLocalIDGenerator_GenerateAccountID_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *AccountLocalIDGenerator_GenerateAccountID_Call) RunAndReturn(run func(address common.Address) (uint64, error)) *AccountLocalIDGenerator_GenerateAccountID_Call {
	_c.Call.Return(run)
	return _c
}

// NewAccounts creates a new instance of Accounts. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewAccounts(t interface {
	mock.TestingT
	Cleanup(func())
}) *Accounts {
	mock := &Accounts{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Accounts is an autogenerated mock type for the Accounts type
type Accounts struct {
	mock.Mock
}

type Accounts_Expecter struct {
	mock *mock.Mock
}

func (_m *Accounts) EXPECT() *Accounts_Expecter {
	return &Accounts_Expecter{mock: &_m.Mock}
}

// AllocateSlabIndex provides a mock function for the type Accounts
func (_mock *Accounts) AllocateSlabIndex(address flow.Address) (atree.SlabIndex, error) {
	ret := _mock.Called(address)

	if len(ret) == 0 {
		panic("no return value specified for AllocateSlabIndex")
	}

	var r0 atree.SlabIndex
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Address) (atree.SlabIndex, error)); ok {
		return returnFunc(address)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Address) atree.SlabIndex); ok {
		r0 = returnFunc(address)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(atree.SlabIndex)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Address) error); ok {
		r1 = returnFunc(address)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Accounts_AllocateSlabIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AllocateSlabIndex'
type Accounts_AllocateSlabIndex_Call struct {
	*mock.Call
}

// AllocateSlabIndex is a helper method to define mock.On call
//   - address flow.Address
func (_e *Accounts_Expecter) AllocateSlabIndex(address interface{}) *Accounts_AllocateSlabIndex_Call {
	return &Accounts_AllocateSlabIndex_Call{Call: _e.mock.On("AllocateSlabIndex", address)}
}

func (_c *Accounts_AllocateSlabIndex_Call) Run(run func(address flow.Address)) *Accounts_AllocateSlabIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Address
		if args[0] != nil {
			arg0 = args[0].(flow.Address)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Accounts_AllocateSlabIndex_Call) Return(slabIndex atree.SlabIndex, err error) *Accounts_AllocateSlabIndex_Call {
	_c.Call.Return(slabIndex, err)
	return _c
}

func (_c *Accounts_AllocateSlabIndex_Call) RunAndReturn(run func(address flow.Address) (atree.SlabIndex, error)) *Accounts_AllocateSlabIndex_Call {
	_c.Call.Return(run)
	return _c
}

// AppendAccountPublicKey provides a mock function for the type Accounts
func (_mock *Accounts) AppendAccountPublicKey(address flow.Address, key flow.AccountPublicKey) error {
	ret := _mock.Called(address, key)

	if len(ret) == 0 {
		panic("no return value specified for AppendAccountPublicKey")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(flow.Address, flow.AccountPublicKey) error); ok {
		r0 = returnFunc(address, key)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Accounts_AppendAccountPublicKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AppendAccountPublicKey'
type Accounts_AppendAccountPublicKey_Call struct {
	*mock.Call
}

// AppendAccountPublicKey is a helper method to define mock.On call
//   - address flow.Address
//   - key flow.AccountPublicKey
func (_e *Accounts_Expecter) AppendAccountPublicKey(address interface{}, key interface{}) *Accounts_AppendAccountPublicKey_Call {
	return &Accounts_AppendAccountPublicKey_Call{Call: _e.mock.On("AppendAccountPublicKey", address, key)}
}

func (_c *Accounts_AppendAccountPublicKey_Call) Run(run func(address flow.Address, key flow.AccountPublicKey)) *Accounts_AppendAccountPublicKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Address
		if args[0] != nil {
			arg0 = args[0].(flow.Address)
		}
		var arg1 flow.AccountPublicKey
		if args[1] != nil {
			arg1 = args[1].(flow.AccountPublicKey)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Accounts_AppendAccountPublicKey_Call) Return(err error) *Accounts_AppendAccountPublicKey_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Accounts_AppendAccountPublicKey_Call) RunAndReturn(run func(address flow.Address, key flow.AccountPublicKey) error) *Accounts_AppendAccountPublicKey_Call {
	_c.Call.Return(run)
	return _c
}

// ContractExists provides a mock function for the type Accounts
func (_mock *Accounts) ContractExists(contractName string, address flow.Address) (bool, error) {
	ret := _mock.Called(contractName, address)

	if len(ret) == 0 {
		panic("no return value specified for ContractExists")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string, flow.Address) (bool, error)); ok {
		return returnFunc(contractName, address)
	}
	if returnFunc, ok := ret.Get(0).(func(string, flow.Address) bool); ok {
		r0 = returnFunc(contractName, address)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(string, flow.Address) error); ok {
		r1 = returnFunc(contractName, address)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Accounts_ContractExists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ContractExists'
type Accounts_ContractExists_Call struct {
	*mock.Call
}

// ContractExists is a helper method to define mock.On call
//   - contractName string
//   - address flow.Address
func (_e *Accounts_Expecter) ContractExists(contractName interface{}, address interface{}) *Accounts_ContractExists_Call {
	return &Accounts_ContractExists_Call{Call: _e.mock.On("ContractExists", contractName, address)}
}

func (_c *Accounts_ContractExists_Call) Run(run func(contractName string, address flow.Address)) *Accounts_ContractExists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 flow.Address
		if args[1] != nil {
			arg1 = args[1].(flow.Address)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Accounts_ContractExists_Call) Return(b bool, err error) *Accounts_ContractExists_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *Accounts_ContractExists_Call) RunAndReturn(run func(contractName string, address flow.Address) (bool, error)) *Accounts_ContractExists_Call {
	_c.Call.Return(run)
	return _c
}

// Create provides a mock function for the type Accounts
func (_mock *Accounts) Create(publicKeys []flow.AccountPublicKey, newAddress flow.Address) error {
	ret := _mock.Called(publicKeys, newAddress)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func([]flow.AccountPublicKey, flow.Address) error); ok {
		r0 = returnFunc(publicKeys, newAddress)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Accounts_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type Accounts_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - publicKeys []flow.AccountPublicKey
//   - newAddress flow.Address
func (_e *Accounts_Expecter) Create(publicKeys interface{}, newAddress interface{}) *Accounts_Create_Call {
	return &Accounts_Create_Call{Call: _e.mock.On("Create", publicKeys, newAddress)}
}

func (_c *Accounts_Create_Call) Run(run func(publicKeys []flow.AccountPublicKey, newAddress flow.Address)) *Accounts_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []flow.AccountPublicKey
		if args[0] != nil {
			arg0 = args[0].([]flow.AccountPublicKey)
		}
		var arg1 flow.Address
		if args[1] != nil {
			arg1 = args[1].(flow.Address)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Accounts_Create_Call) Return(err error) *Accounts_Create_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Accounts_Create_Call) RunAndReturn(run func(publicKeys []flow.AccountPublicKey, newAddress flow.Address) error) *Accounts_Create_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteContract provides a mock function for the type Accounts
func (_mock *Accounts) DeleteContract(contractName string, address flow.Address) error {
	ret := _mock.Called(contractName, address)

	if len(ret) == 0 {
		panic("no return value specified for DeleteContract")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string, flow.Address) error); ok {
		r0 = returnFunc(contractName, address)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Accounts_DeleteContract_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteContract'
type Accounts_DeleteContract_Call struct {
	*mock.Call
}

// DeleteContract is a helper method to define mock.On call
//   - contractName string
//   - address flow.Address
func (_e *Accounts_Expecter) DeleteContract(contractName interface{}, address interface{}) *Accounts_DeleteContract_Call {
	return &Accounts_DeleteContract_Call{Call: _e.mock.On("DeleteContract", contractName, address)}
}

func (_c *Accounts_DeleteContract_Call) Run(run func(contractName string, address flow.Address)) *Accounts_DeleteContract_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 flow.Address
		if args[1] != nil {
			arg1 = args[1].(flow.Address)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Accounts_DeleteContract_Call) Return(err error) *Accounts_DeleteContract_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Accounts_DeleteContract_Call) RunAndReturn(run func(contractName string, address flow.Address) error) *Accounts_DeleteContract_Call {
	_c.Call.Return(run)
	return _c
}

// Exists provides a mock function for the type Accounts
func (_mock *Accounts) Exists(address flow.Address) (bool, error) {
	ret := _mock.Called(address)

	if len(ret) == 0 {
		panic("no return value specified for Exists")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Address) (bool, error)); ok {
		return returnFunc(address)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Address) bool); ok {
		r0 = returnFunc(address)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Address) error); ok {
		r1 = returnFunc(address)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Accounts_Exists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exists'
type Accounts_Exists_Call struct {
	*mock.Call
}

// Exists is a helper method to define mock.On call
//   - address flow.Address
func (_e *Accounts_Expecter) Exists(address interface{}) *Accounts_Exists_Call {
	return &Accounts_Exists_Call{Call: _e.mock.On("Exists", address)}
}

func (_c *Accounts_Exists_Call) Run(run func(address flow.Address)) *Accounts_Exists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Address
		if args[0] != nil {
			arg0 = args[0].(flow.Address)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Accounts_Exists_Call) Return(b bool, err error) *Accounts_Exists_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *Accounts_Exists_Call) RunAndReturn(run func(address flow.Address) (bool, error)) *Accounts_Exists_Call {
	_c.Call.Return(run)
	return _c
}

// GenerateAccountLocalID provides a mock function for the type Accounts
func (_mock *Accounts) GenerateAccountLocalID(address flow.Address) (uint64, error) {
	ret := _mock.Called(address)

	if len(ret) == 0 {
		panic("no return value specified for GenerateAccountLocalID")
	}

	var r0 uint64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Address) (uint64, error)); ok {
		return returnFunc(address)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Address) uint64); ok {
		r0 = returnFunc(address)
	} else {
		r0 = ret.Get(0).(uint64)
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Address) error); ok {
		r1 = returnFunc(address)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Accounts_GenerateAccountLocalID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GenerateAccountLocalID'
type Accounts_GenerateAccountLocalID_Call struct {
	*mock.Call
}

// GenerateAccountLocalID is a helper method to define mock.On call
//   - address flow.Address
func (_e *Accounts_Expecter) GenerateAccountLocalID(address interface{}) *Accounts_GenerateAccountLocalID_Call {
	return &Accounts_GenerateAccountLocalID_Call{Call: _e.mock.On("GenerateAccountLocalID", address)}
}

func (_c *Accounts_GenerateAccountLocalID_Call) Run(run func(address flow.Address)) *Accounts_GenerateAccountLocalID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Address
		if args[0] != nil {
			arg0 = args[0].(flow.Address)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Accounts_GenerateAccountLocalID_Call) Return(v uint64, err error) *Accounts_GenerateAccountLocalID_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *Accounts_GenerateAccountLocalID_Call) RunAndReturn(run func(address flow.Address) (uint64, error)) *Accounts_GenerateAccountLocalID_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function for the type Accounts
func (_mock *Accounts) Get(address flow.Address) (*flow.Account, error) {
	ret := _mock.Called(address)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *flow.Account
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Address) (*flow.Account, error)); ok {
		return returnFunc(address)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Address) *flow.Account); ok {
		r0 = returnFunc(address)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.Account)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Address) error); ok {
		r1 = returnFunc(address)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Accounts_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type Accounts_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - address flow.Address
func (_e *Accounts_Expecter) Get(address interface{}) *Accounts_Get_Call {
	return &Accounts_Get_Call{Call: _e.mock.On("Get", address)}
}

func (_c *Accounts_Get_Call) Run(run func(address flow.Address)) *Accounts_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Address
		if args[0] != nil {
			arg0 = args[0].(flow.Address)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Accounts_Get_Call) Return(account *flow.Account, err error) *Accounts_Get_Call {
	_c.Call.Return(account, err)
	return _c
}

func (_c *Accounts_Get_Call) RunAndReturn(run func(address flow.Address) (*flow.Account, error)) *Accounts_Get_Call {
	_c.Call.Return(run)
	return _c
}

// GetAccountPublicKey provides a mock function for the type Accounts
func (_mock *Accounts) GetAccountPublicKey(address flow.Address, keyIndex uint32) (flow.AccountPublicKey, error) {
	ret := _mock.Called(address, keyIndex)

	if len(ret) == 0 {
		panic("no return value specified for GetAccountPublicKey")
	}

	var r0 flow.AccountPublicKey
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Address, uint32) (flow.AccountPublicKey, error)); ok {
		return returnFunc(address, keyIndex)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Address, uint32) flow.AccountPublicKey); ok {
		r0 = returnFunc(address, keyIndex)
	} else {
		r0 = ret.Get(0).(flow.AccountPublicKey)
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Address, uint32) error); ok {
		r1 = returnFunc(address, keyIndex)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Accounts_GetAccountPublicKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAccountPublicKey'
type Accounts_GetAccountPublicKey_Call struct {
	*mock.Call
}

// GetAccountPublicKey is a helper method to define mock.On call
//   - address flow.Address
//   - keyIndex uint32
func (_e *Accounts_Expecter) GetAccountPublicKey(address interface{}, keyIndex interface{}) *Accounts_GetAccountPublicKey_Call {
	return &Accounts_GetAccountPublicKey_Call{Call: _e.mock.On("GetAccountPublicKey", address, keyIndex)}
}

func (_c *Accounts_GetAccountPublicKey_Call) Run(run func(address flow.Address, keyIndex uint32)) *Accounts_GetAccountPublicKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Address
		if args[0] != nil {
			arg0 = args[0].(flow.Address)
		}
		var arg1 uint32
		if args[1] != nil {
			arg1 = args[1].(uint32)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Accounts_GetAccountPublicKey_Call) Return(accountPublicKey flow.AccountPublicKey, err error) *Accounts_GetAccountPublicKey_Call {
	_c.Call.Return(accountPublicKey, err)
	return _c
}

func (_c *Accounts_GetAccountPublicKey_Call) RunAndReturn(run func(address flow.Address, keyIndex uint32) (flow.AccountPublicKey, error)) *Accounts_GetAccountPublicKey_Call {
	_c.Call.Return(run)
	return _c
}

// GetAccountPublicKeyCount provides a mock function for the type Accounts
func (_mock *Accounts) GetAccountPublicKeyCount(address flow.Address) (uint32, error) {
	ret := _mock.Called(address)

	if len(ret) == 0 {
		panic("no return value specified for GetAccountPublicKeyCount")
	}

	var r0 uint32
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Address) (uint32, error)); ok {
		return returnFunc(address)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Address) uint32); ok {
		r0 = returnFunc(address)
	} else {
		r0 = ret.Get(0).(uint32)
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Address) error); ok {
		r1 = returnFunc(address)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Accounts_GetAccountPublicKeyCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAccountPublicKeyCount'
type Accounts_GetAccountPublicKeyCount_Call struct {
	*mock.Call
}

// GetAccountPublicKeyCount is a helper method to define mock.On call
//   - address flow.Address
func (_e *Accounts_Expecter) GetAccountPublicKeyCount(address interface{}) *Accounts_GetAccountPublicKeyCount_Call {
	return &Accounts_GetAccountPublicKeyCount_Call{Call: _e.mock.On("GetAccountPublicKeyCount", address)}
}

func (_c *Accounts_GetAccountPublicKeyCount_Call) Run(run func(address flow.Address)) *Accounts_GetAccountPublicKeyCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Address
		if args[0] != nil {
			arg0 = args[0].(flow.Address)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Accounts_GetAccountPublicKeyCount_Call) Return(v uint32, err error) *Accounts_GetAccountPublicKeyCount_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *Accounts_GetAccountPublicKeyCount_Call) RunAndReturn(run func(address flow.Address) (uint32, error)) *Accounts_GetAccountPublicKeyCount_Call {
	_c.Call.Return(run)
	return _c
}

// GetAccountPublicKeyRevokedStatus provides a mock function for the type Accounts
func (_mock *Accounts) GetAccountPublicKeyRevokedStatus(address flow.Address, keyIndex uint32) (bool, error) {
	ret := _mock.Called(address, keyIndex)

	if len(ret) == 0 {
		panic("no return value specified for GetAccountPublicKeyRevokedStatus")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Address, uint32) (bool, error)); ok {
		return returnFunc(address, keyIndex)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Address, uint32) bool); ok {
		r0 = returnFunc(address, keyIndex)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Address, uint32) error); ok {
		r1 = returnFunc(address, keyIndex)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Accounts_GetAccountPublicKeyRevokedStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAccountPublicKeyRevokedStatus'
type Accounts_GetAccountPublicKeyRevokedStatus_Call struct {
	*mock.Call
}

// GetAccountPublicKeyRevokedStatus is a helper method to define mock.On call
//   - address flow.Address
//   - keyIndex uint32
func (_e *Accounts_Expecter) GetAccountPublicKeyRevokedStatus(address interface{}, keyIndex interface{}) *Accounts_GetAccountPublicKeyRevokedStatus_Call {
	return &Accounts_GetAccountPublicKeyRevokedStatus_Call{Call: _e.mock.On("GetAccountPublicKeyRevokedStatus", address, keyIndex)}
}

func (_c *Accounts_GetAccountPublicKeyRevokedStatus_Call) Run(run func(address flow.Address, keyIndex uint32)) *Accounts_GetAccountPublicKeyRevokedStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Address
		if args[0] != nil {
			arg0 = args[0].(flow.Address)
		}
		var arg1 uint32
		if args[1] != nil {
			arg1 = args[1].(uint32)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Accounts_GetAccountPublicKeyRevokedStatus_Call) Return(b bool, err error) *Accounts_GetAccountPublicKeyRevokedStatus_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *Accounts_GetAccountPublicKeyRevokedStatus_Call) RunAndReturn(run func(address flow.Address, keyIndex uint32) (bool, error)) *Accounts_GetAccountPublicKeyRevokedStatus_Call {
	_c.Call.Return(run)
	return _c
}

// GetAccountPublicKeySequenceNumber provides a mock function for the type Accounts
func (_mock *Accounts) GetAccountPublicKeySequenceNumber(address flow.Address, keyIndex uint32) (uint64, error) {
	ret := _mock.Called(address, keyIndex)

	if len(ret) == 0 {
		panic("no return value specified for GetAccountPublicKeySequenceNumber")
	}

	var r0 uint64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Address, uint32) (uint64, error)); ok {
		return returnFunc(address, keyIndex)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Address, uint32) uint64); ok {
		r0 = returnFunc(address, keyIndex)
	} else {
		r0 = ret.Get(0).(uint64)
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Address, uint32) error); ok {
		r1 = returnFunc(address, keyIndex)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Accounts_GetAccountPublicKeySequenceNumber_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAccountPublicKeySequenceNumber'
type Accounts_GetAccountPublicKeySequenceNumber_Call struct {
	*mock.Call
}

// GetAccountPublicKeySequenceNumber is a helper method to define mock.On call
//   - address flow.Address
//   - keyIndex uint32
func (_e *Accounts_Expecter) GetAccountPublicKeySequenceNumber(address interface{}, keyIndex interface{}) *Accounts_GetAccountPublicKeySequenceNumber_Call {
	return &Accounts_GetAccountPublicKeySequenceNumber_Call{Call: _e.mock.On("GetAccountPublicKeySequenceNumber", address, keyIndex)}
}

func (_c *Accounts_GetAccountPublicKeySequenceNumber_Call) Run(run func(address flow.Address, keyIndex uint32)) *Accounts_GetAccountPublicKeySequenceNumber_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Address
		if args[0] != nil {
			arg0 = args[0].(flow.Address)
		}
		var arg1 uint32
		if args[1] != nil {
			arg1 = args[1].(uint32)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Accounts_GetAccountPublicKeySequenceNumber_Call) Return(v uint64, err error) *Accounts_GetAccountPublicKeySequenceNumber_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *Accounts_GetAccountPublicKeySequenceNumber_Call) RunAndReturn(run func(address flow.Address, keyIndex uint32) (uint64, error)) *Accounts_GetAccountPublicKeySequenceNumber_Call {
	_c.Call.Return(run)
	return _c
}

// GetAccountPublicKeys provides a mock function for the type Accounts
func (_mock *Accounts) GetAccountPublicKeys(address flow.Address) ([]flow.AccountPublicKey, error) {
	ret := _mock.Called(address)

	if len(ret) == 0 {
		panic("no return value specified for GetAccountPublicKeys")
	}

	var r0 []flow.AccountPublicKey
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Address) ([]flow.AccountPublicKey, error)); ok {
		return returnFunc(address)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Address) []flow.AccountPublicKey); ok {
		r0 = returnFunc(address)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]flow.AccountPublicKey)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Address) error); ok {
		r1 = returnFunc(address)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Accounts_GetAccountPublicKeys_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAccountPublicKeys'
type Accounts_GetAccountPublicKeys_Call struct {
	*mock.Call
}

// GetAccountPublicKeys is a helper method to define mock.On call
//   - address flow.Address
func (_e *Accounts_Expecter) GetAccountPublicKeys(address interface{}) *Accounts_GetAccountPublicKeys_Call {
	return &Accounts_GetAccountPublicKeys_Call{Call: _e.mock.On("GetAccountPublicKeys", address)}
}

func (_c *Accounts_GetAccountPublicKeys_Call) Run(run func(address flow.Address)) *Accounts_GetAccountPublicKeys_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Address
		if args[0] != nil {
			arg0 = args[0].(flow.Address)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Accounts_GetAccountPublicKeys_Call) Return(accountPublicKeys []flow.AccountPublicKey, err error) *Accounts_GetAccountPublicKeys_Call {
	_c.Call.Return(accountPublicKeys, err)
	return _c
}

func (_c *Accounts_GetAccountPublicKeys_Call) RunAndReturn(run func(address flow.Address) ([]flow.AccountPublicKey, error)) *Accounts_GetAccountPublicKeys_Call {
	_c.Call.Return(run)
	return _c
}

// GetContract provides a mock function for the type Accounts
func (_mock *Accounts) GetContract(contractName string, address flow.Address) ([]byte, error) {
	ret := _mock.Called(contractName, address)

	if len(ret) == 0 {
		panic("no return value specified for GetContract")
	}

	var r0 []byte
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string, flow.Address) ([]byte, error)); ok {
		return returnFunc(contractName, address)
	}
	if returnFunc, ok := ret.Get(0).(func(string, flow.Address) []byte); ok {
		r0 = returnFunc(contractName, address)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string, flow.Address) error); ok {
		r1 = returnFunc(contractName, address)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Accounts_GetContract_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetContract'
type Accounts_GetContract_Call struct {
	*mock.Call
}

// GetContract is a helper method to define mock.On call
//   - contractName string
//   - address flow.Address
func (_e *Accounts_Expecter) GetContract(contractName interface{}, address interface{}) *Accounts_GetContract_Call {
	return &Accounts_GetContract_Call{Call: _e.mock.On("GetContract", contractName, address)}
}

func (_c *Accounts_GetContract_Call) Run(run func(contractName string, address flow.Address)) *Accounts_GetContract_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 flow.Address
		if args[1] != nil {
			arg1 = args[1].(flow.Address)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Accounts_GetContract_Call) Return(bytes []byte, err error) *Accounts_GetContract_Call {
	_c.Call.Return(bytes, err)
	return _c
}

func (_c *Accounts_GetContract_Call) RunAndReturn(run func(contractName string, address flow.Address) ([]byte, error)) *Accounts_GetContract_Call {
	_c.Call.Return(run)
	return _c
}

// GetContractNames provides a mock function for the type Accounts
func (_mock *Accounts) GetContractNames(address flow.Address) ([]string, error) {
	ret := _mock.Called(address)

	if len(ret) == 0 {
		panic("no return value specified for GetContractNames")
	}

	var r0 []string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Address) ([]string, error)); ok {
		return returnFunc(address)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Address) []string); ok {
		r0 = returnFunc(address)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Address) error); ok {
		r1 = returnFunc(address)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Accounts_GetContractNames_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetContractNames'
type Accounts_GetContractNames_Call struct {
	*mock.Call
}

// GetContractNames is a helper method to define mock.On call
//   - address flow.Address
func (_e *Accounts_Expecter) GetContractNames(address interface{}) *Accounts_GetContractNames_Call {
	return &Accounts_GetContractNames_Call{Call: _e.mock.On("GetContractNames", address)}
}

func (_c *Accounts_GetContractNames_Call) Run(run func(address flow.Address)) *Accounts_GetContractNames_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Address
		if args[0] != nil {
			arg0 = args[0].(flow.Address)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Accounts_GetContractNames_Call) Return(strings []string, err error) *Accounts_GetContractNames_Call {
	_c.Call.Return(strings, err)
	return _c
}

func (_c *Accounts_GetContractNames_Call) RunAndReturn(run func(address flow.Address) ([]string, error)) *Accounts_GetContractNames_Call {
	_c.Call.Return(run)
	return _c
}

// GetRuntimeAccountPublicKey provides a mock function for the type Accounts
func (_mock *Accounts) GetRuntimeAccountPublicKey(address flow.Address, keyIndex uint32) (flow.RuntimeAccountPublicKey, error) {
	ret := _mock.Called(address, keyIndex)

	if len(ret) == 0 {
		panic("no return value specified for GetRuntimeAccountPublicKey")
	}

	var r0 flow.RuntimeAccountPublicKey
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Address, uint32) (flow.RuntimeAccountPublicKey, error)); ok {
		return returnFunc(address, keyIndex)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Address, uint32) flow.RuntimeAccountPublicKey); ok {
		r0 = returnFunc(address, keyIndex)
	} else {
		r0 = ret.Get(0).(flow.RuntimeAccountPublicKey)
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Address, uint32) error); ok {
		r1 = returnFunc(address, keyIndex)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Accounts_GetRuntimeAccountPublicKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRuntimeAccountPublicKey'
type Accounts_GetRuntimeAccountPublicKey_Call struct {
	*mock.Call
}

// GetRuntimeAccountPublicKey is a helper method to define mock.On call
//   - address flow.Address
//   - keyIndex uint32
func (_e *Accounts_Expecter) GetRuntimeAccountPublicKey(address interface{}, keyIndex interface{}) *Accounts_GetRuntimeAccountPublicKey_Call {
	return &Accounts_GetRuntimeAccountPublicKey_Call{Call: _e.mock.On("GetRuntimeAccountPublicKey", address, keyIndex)}
}

func (_c *Accounts_GetRuntimeAccountPublicKey_Call) Run(run func(address flow.Address, keyIndex uint32)) *Accounts_GetRuntimeAccountPublicKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Address
		if args[0] != nil {
			arg0 = args[0].(flow.Address)
		}
		var arg1 uint32
		if args[1] != nil {
			arg1 = args[1].(uint32)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Accounts_GetRuntimeAccountPublicKey_Call) Return(runtimeAccountPublicKey flow.RuntimeAccountPublicKey, err error) *Accounts_GetRuntimeAccountPublicKey_Call {
	_c.Call.Return(runtimeAccountPublicKey, err)
	return _c
}

func (_c *Accounts_GetRuntimeAccountPublicKey_Call) RunAndReturn(run func(address flow.Address, keyIndex uint32) (flow.RuntimeAccountPublicKey, error)) *Accounts_GetRuntimeAccountPublicKey_Call {
	_c.Call.Return(run)
	return _c
}

// GetStorageUsed provides a mock function for the type Accounts
func (_mock *Accounts) GetStorageUsed(address flow.Address) (uint64, error) {
	ret := _mock.Called(address)

	if len(ret) == 0 {
		panic("no return value specified for GetStorageUsed")
	}

	var r0 uint64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Address) (uint64, error)); ok {
		return returnFunc(address)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Address) uint64); ok {
		r0 = returnFunc(address)
	} else {
		r0 = ret.Get(0).(uint64)
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Address) error); ok {
		r1 = returnFunc(address)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Accounts_GetStorageUsed_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetStorageUsed'
type Accounts_GetStorageUsed_Call struct {
	*mock.Call
}

// GetStorageUsed is a helper method to define mock.On call
//   - address flow.Address
func (_e *Accounts_Expecter) GetStorageUsed(address interface{}) *Accounts_GetStorageUsed_Call {
	return &Accounts_GetStorageUsed_Call{Call: _e.mock.On("GetStorageUsed", address)}
}

func (_c *Accounts_GetStorageUsed_Call) Run(run func(address flow.Address)) *Accounts_GetStorageUsed_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Address
		if args[0] != nil {
			arg0 = args[0].(flow.Address)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Accounts_GetStorageUsed_Call) Return(v uint64, err error) *Accounts_GetStorageUsed_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *Accounts_GetStorageUsed_Call) RunAndReturn(run func(address flow.Address) (uint64, error)) *Accounts_GetStorageUsed_Call {
	_c.Call.Return(run)
	return _c
}

// GetValue provides a mock function for the type Accounts
func (_mock *Accounts) GetValue(id flow.RegisterID) (flow.RegisterValue, error) {
	ret := _mock.Called(id)

	if len(ret) == 0 {
		panic("no return value specified for GetValue")
	}

	var r0 flow.RegisterValue
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.RegisterID) (flow.RegisterValue, error)); ok {
		return returnFunc(id)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.RegisterID) flow.RegisterValue); ok {
		r0 = returnFunc(id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.RegisterValue)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.RegisterID) error); ok {
		r1 = returnFunc(id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Accounts_GetValue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetValue'
type Accounts_GetValue_Call struct {
	*mock.Call
}

// GetValue is a helper method to define mock.On call
//   - id flow.RegisterID
func (_e *Accounts_Expecter) GetValue(id interface{}) *Accounts_GetValue_Call {
	return &Accounts_GetValue_Call{Call: _e.mock.On("GetValue", id)}
}

func (_c *Accounts_GetValue_Call) Run(run func(id flow.RegisterID)) *Accounts_GetValue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.RegisterID
		if args[0] != nil {
			arg0 = args[0].(flow.RegisterID)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Accounts_GetValue_Call) Return(v flow.RegisterValue, err error) *Accounts_GetValue_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *Accounts_GetValue_Call) RunAndReturn(run func(id flow.RegisterID) (flow.RegisterValue, error)) *Accounts_GetValue_Call {
	_c.Call.Return(run)
	return _c
}

// IncrementAccountPublicKeySequenceNumber provides a mock function for the type Accounts
func (_mock *Accounts) IncrementAccountPublicKeySequenceNumber(address flow.Address, keyIndex uint32) error {
	ret := _mock.Called(address, keyIndex)

	if len(ret) == 0 {
		panic("no return value specified for IncrementAccountPublicKeySequenceNumber")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(flow.Address, uint32) error); ok {
		r0 = returnFunc(address, keyIndex)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Accounts_IncrementAccountPublicKeySequenceNumber_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IncrementAccountPublicKeySequenceNumber'
type Accounts_IncrementAccountPublicKeySequenceNumber_Call struct {
	*mock.Call
}

// IncrementAccountPublicKeySequenceNumber is a helper method to define mock.On call
//   - address flow.Address
//   - keyIndex uint32
func (_e *Accounts_Expecter) IncrementAccountPublicKeySequenceNumber(address interface{}, keyIndex interface{}) *Accounts_IncrementAccountPublicKeySequenceNumber_Call {
	return &Accounts_IncrementAccountPublicKeySequenceNumber_Call{Call: _e.mock.On("IncrementAccountPublicKeySequenceNumber", address, keyIndex)}
}

func (_c *Accounts_IncrementAccountPublicKeySequenceNumber_Call) Run(run func(address flow.Address, keyIndex uint32)) *Accounts_IncrementAccountPublicKeySequenceNumber_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Address
		if args[0] != nil {
			arg0 = args[0].(flow.Address)
		}
		var arg1 uint32
		if args[1] != nil {
			arg1 = args[1].(uint32)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Accounts_IncrementAccountPublicKeySequenceNumber_Call) Return(err error) *Accounts_IncrementAccountPublicKeySequenceNumber_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Accounts_IncrementAccountPublicKeySequenceNumber_Call) RunAndReturn(run func(address flow.Address, keyIndex uint32) error) *Accounts_IncrementAccountPublicKeySequenceNumber_Call {
	_c.Call.Return(run)
	return _c
}

// RevokeAccountPublicKey provides a mock function for the type Accounts
func (_mock *Accounts) RevokeAccountPublicKey(address flow.Address, keyIndex uint32) error {
	ret := _mock.Called(address, keyIndex)

	if len(ret) == 0 {
		panic("no return value specified for RevokeAccountPublicKey")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(flow.Address, uint32) error); ok {
		r0 = returnFunc(address, keyIndex)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Accounts_RevokeAccountPublicKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RevokeAccountPublicKey'
type Accounts_RevokeAccountPublicKey_Call struct {
	*mock.Call
}

// RevokeAccountPublicKey is a helper method to define mock.On call
//   - address flow.Address
//   - keyIndex uint32
func (_e *Accounts_Expecter) RevokeAccountPublicKey(address interface{}, keyIndex interface{}) *Accounts_RevokeAccountPublicKey_Call {
	return &Accounts_RevokeAccountPublicKey_Call{Call: _e.mock.On("RevokeAccountPublicKey", address, keyIndex)}
}

func (_c *Accounts_RevokeAccountPublicKey_Call) Run(run func(address flow.Address, keyIndex uint32)) *Accounts_RevokeAccountPublicKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Address
		if args[0] != nil {
			arg0 = args[0].(flow.Address)
		}
		var arg1 uint32
		if args[1] != nil {
			arg1 = args[1].(uint32)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Accounts_RevokeAccountPublicKey_Call) Return(err error) *Accounts_RevokeAccountPublicKey_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Accounts_RevokeAccountPublicKey_Call) RunAndReturn(run func(address flow.Address, keyIndex uint32) error) *Accounts_RevokeAccountPublicKey_Call {
	_c.Call.Return(run)
	return _c
}

// SetContract provides a mock function for the type Accounts
func (_mock *Accounts) SetContract(contractName string, address flow.Address, contract []byte) error {
	ret := _mock.Called(contractName, address, contract)

	if len(ret) == 0 {
		panic("no return value specified for SetContract")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string, flow.Address, []byte) error); ok {
		r0 = returnFunc(contractName, address, contract)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Accounts_SetContract_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetContract'
type Accounts_SetContract_Call struct {
	*mock.Call
}

// SetContract is a helper method to define mock.On call
//   - contractName string
//   - address flow.Address
//   - contract []byte
func (_e *Accounts_Expecter) SetContract(contractName interface{}, address interface{}, contract interface{}) *Accounts_SetContract_Call {
	return &Accounts_SetContract_Call{Call: _e.mock.On("SetContract", contractName, address, contract)}
}

func (_c *Accounts_SetContract_Call) Run(run func(contractName string, address flow.Address, contract []byte)) *Accounts_SetContract_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 flow.Address
		if args[1] != nil {
			arg1 = args[1].(flow.Address)
		}
		var arg2 []byte
		if args[2] != nil {
			arg2 = args[2].([]byte)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Accounts_SetContract_Call) Return(err error) *Accounts_SetContract_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Accounts_SetContract_Call) RunAndReturn(run func(contractName string, address flow.Address, contract []byte) error) *Accounts_SetContract_Call {
	_c.Call.Return(run)
	return _c
}

// SetValue provides a mock function for the type Accounts
func (_mock *Accounts) SetValue(id flow.RegisterID, value flow.RegisterValue) error {
	ret := _mock.Called(id, value)

	if len(ret) == 0 {
		panic("no return value specified for SetValue")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(flow.RegisterID, flow.RegisterValue) error); ok {
		r0 = returnFunc(id, value)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Accounts_SetValue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetValue'
type Accounts_SetValue_Call struct {
	*mock.Call
}

// SetValue is a helper method to define mock.On call
//   - id flow.RegisterID
//   - value flow.RegisterValue
func (_e *Accounts_Expecter) SetValue(id interface{}, value interface{}) *Accounts_SetValue_Call {
	return &Accounts_SetValue_Call{Call: _e.mock.On("SetValue", id, value)}
}

func (_c *Accounts_SetValue_Call) Run(run func(id flow.RegisterID, value flow.RegisterValue)) *Accounts_SetValue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.RegisterID
		if args[0] != nil {
			arg0 = args[0].(flow.RegisterID)
		}
		var arg1 flow.RegisterValue
		if args[1] != nil {
			arg1 = args[1].(flow.RegisterValue)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Accounts_SetValue_Call) Return(err error) *Accounts_SetValue_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Accounts_SetValue_Call) RunAndReturn(run func(id flow.RegisterID, value flow.RegisterValue) error) *Accounts_SetValue_Call {
	_c.Call.Return(run)
	return _c
}

// NewBlockInfo creates a new instance of BlockInfo. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewBlockInfo(t interface {
	mock.TestingT
	Cleanup(func())
}) *BlockInfo {
	mock := &BlockInfo{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// BlockInfo is an autogenerated mock type for the BlockInfo type
type BlockInfo struct {
	mock.Mock
}

type BlockInfo_Expecter struct {
	mock *mock.Mock
}

func (_m *BlockInfo) EXPECT() *BlockInfo_Expecter {
	return &BlockInfo_Expecter{mock: &_m.Mock}
}

// GetBlockAtHeight provides a mock function for the type BlockInfo
func (_mock *BlockInfo) GetBlockAtHeight(height uint64) (runtime.Block, bool, error) {
	ret := _mock.Called(height)

	if len(ret) == 0 {
		panic("no return value specified for GetBlockAtHeight")
	}

	var r0 runtime.Block
	var r1 bool
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(uint64) (runtime.Block, bool, error)); ok {
		return returnFunc(height)
	}
	if returnFunc, ok := ret.Get(0).(func(uint64) runtime.Block); ok {
		r0 = returnFunc(height)
	} else {
		r0 = ret.Get(0).(runtime.Block)
	}
	if returnFunc, ok := ret.Get(1).(func(uint64) bool); ok {
		r1 = returnFunc(height)
	} else {
		r1 = ret.Get(1).(bool)
	}
	if returnFunc, ok := ret.Get(2).(func(uint64) error); ok {
		r2 = returnFunc(height)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// BlockInfo_GetBlockAtHeight_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBlockAtHeight'
type BlockInfo_GetBlockAtHeight_Call struct {
	*mock.Call
}

// GetBlockAtHeight is a helper method to define mock.On call
//   - height uint64
func (_e *BlockInfo_Expecter) GetBlockAtHeight(height interface{}) *BlockInfo_GetBlockAtHeight_Call {
	return &BlockInfo_GetBlockAtHeight_Call{Call: _e.mock.On("GetBlockAtHeight", height)}
}

func (_c *BlockInfo_GetBlockAtHeight_Call) Run(run func(height uint64)) *BlockInfo_GetBlockAtHeight_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *BlockInfo_GetBlockAtHeight_Call) Return(v runtime.Block, b bool, err error) *BlockInfo_GetBlockAtHeight_Call {
	_c.Call.Return(v, b, err)
	return _c
}

func (_c *BlockInfo_GetBlockAtHeight_Call) RunAndReturn(run func(height uint64) (runtime.Block, bool, error)) *BlockInfo_GetBlockAtHeight_Call {
	_c.Call.Return(run)
	return _c
}

// GetCurrentBlockHeight provides a mock function for the type BlockInfo
func (_mock *BlockInfo) GetCurrentBlockHeight() (uint64, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetCurrentBlockHeight")
	}

	var r0 uint64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (uint64, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() uint64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint64)
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// BlockInfo_GetCurrentBlockHeight_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCurrentBlockHeight'
type BlockInfo_GetCurrentBlockHeight_Call struct {
	*mock.Call
}

// GetCurrentBlockHeight is a helper method to define mock.On call
func (_e *BlockInfo_Expecter) GetCurrentBlockHeight() *BlockInfo_GetCurrentBlockHeight_Call {
	return &BlockInfo_GetCurrentBlockHeight_Call{Call: _e.mock.On("GetCurrentBlockHeight")}
}

func (_c *BlockInfo_GetCurrentBlockHeight_Call) Run(run func()) *BlockInfo_GetCurrentBlockHeight_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *BlockInfo_GetCurrentBlockHeight_Call) Return(v uint64, err error) *BlockInfo_GetCurrentBlockHeight_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *BlockInfo_GetCurrentBlockHeight_Call) RunAndReturn(run func() (uint64, error)) *BlockInfo_GetCurrentBlockHeight_Call {
	_c.Call.Return(run)
	return _c
}

// NewBlocks creates a new instance of Blocks. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewBlocks(t interface {
	mock.TestingT
	Cleanup(func())
}) *Blocks {
	mock := &Blocks{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Blocks is an autogenerated mock type for the Blocks type
type Blocks struct {
	mock.Mock
}

type Blocks_Expecter struct {
	mock *mock.Mock
}

func (_m *Blocks) EXPECT() *Blocks_Expecter {
	return &Blocks_Expecter{mock: &_m.Mock}
}

// ByHeightFrom provides a mock function for the type Blocks
func (_mock *Blocks) ByHeightFrom(height uint64, header *flow.Header) (*flow.Header, error) {
	ret := _mock.Called(height, header)

	if len(ret) == 0 {
		panic("no return value specified for ByHeightFrom")
	}

	var r0 *flow.Header
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(uint64, *flow.Header) (*flow.Header, error)); ok {
		return returnFunc(height, header)
	}
	if returnFunc, ok := ret.Get(0).(func(uint64, *flow.Header) *flow.Header); ok {
		r0 = returnFunc(height, header)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.Header)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(uint64, *flow.Header) error); ok {
		r1 = returnFunc(height, header)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Blocks_ByHeightFrom_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByHeightFrom'
type Blocks_ByHeightFrom_Call struct {
	*mock.Call
}

// ByHeightFrom is a helper method to define mock.On call
//   - height uint64
//   - header *flow.Header
func (_e *Blocks_Expecter) ByHeightFrom(height interface{}, header interface{}) *Blocks_ByHeightFrom_Call {
	return &Blocks_ByHeightFrom_Call{Call: _e.mock.On("ByHeightFrom", height, header)}
}

func (_c *Blocks_ByHeightFrom_Call) Run(run func(height uint64, header *flow.Header)) *Blocks_ByHeightFrom_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		var arg1 *flow.Header
		if args[1] != nil {
			arg1 = args[1].(*flow.Header)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Blocks_ByHeightFrom_Call) Return(header1 *flow.Header, err error) *Blocks_ByHeightFrom_Call {
	_c.Call.Return(header1, err)
	return _c
}

func (_c *Blocks_ByHeightFrom_Call) RunAndReturn(run func(height uint64, header *flow.Header) (*flow.Header, error)) *Blocks_ByHeightFrom_Call {
	_c.Call.Return(run)
	return _c
}

// NewContractUpdater creates a new instance of ContractUpdater. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewContractUpdater(t interface {
	mock.TestingT
	Cleanup(func())
}) *ContractUpdater {
	mock := &ContractUpdater{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// ContractUpdater is an autogenerated mock type for the ContractUpdater type
type ContractUpdater struct {
	mock.Mock
}

type ContractUpdater_Expecter struct {
	mock *mock.Mock
}

func (_m *ContractUpdater) EXPECT() *ContractUpdater_Expecter {
	return &ContractUpdater_Expecter{mock: &_m.Mock}
}

// Commit provides a mock function for the type ContractUpdater
func (_mock *ContractUpdater) Commit() (environment.ContractUpdates, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Commit")
	}

	var r0 environment.ContractUpdates
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (environment.ContractUpdates, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() environment.ContractUpdates); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(environment.ContractUpdates)
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ContractUpdater_Commit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Commit'
type ContractUpdater_Commit_Call struct {
	*mock.Call
}

// Commit is a helper method to define mock.On call
func (_e *ContractUpdater_Expecter) Commit() *ContractUpdater_Commit_Call {
	return &ContractUpdater_Commit_Call{Call: _e.mock.On("Commit")}
}

func (_c *ContractUpdater_Commit_Call) Run(run func()) *ContractUpdater_Commit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ContractUpdater_Commit_Call) Return(contractUpdates environment.ContractUpdates, err error) *ContractUpdater_Commit_Call {
	_c.Call.Return(contractUpdates, err)
	return _c
}

func (_c *ContractUpdater_Commit_Call) RunAndReturn(run func() (environment.ContractUpdates, error)) *ContractUpdater_Commit_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveAccountContractCode provides a mock function for the type ContractUpdater
func (_mock *ContractUpdater) RemoveAccountContractCode(location common.AddressLocation) error {
	ret := _mock.Called(location)

	if len(ret) == 0 {
		panic("no return value specified for RemoveAccountContractCode")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(common.AddressLocation) error); ok {
		r0 = returnFunc(location)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ContractUpdater_RemoveAccountContractCode_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveAccountContractCode'
type ContractUpdater_RemoveAccountContractCode_Call struct {
	*mock.Call
}

// RemoveAccountContractCode is a helper method to define mock.On call
//   - location common.AddressLocation
func (_e *ContractUpdater_Expecter) RemoveAccountContractCode(location interface{}) *ContractUpdater_RemoveAccountContractCode_Call {
	return &ContractUpdater_RemoveAccountContractCode_Call{Call: _e.mock.On("RemoveAccountContractCode", location)}
}

func (_c *ContractUpdater_RemoveAccountContractCode_Call) Run(run func(location common.AddressLocation)) *ContractUpdater_RemoveAccountContractCode_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 common.AddressLocation
		if args[0] != nil {
			arg0 = args[0].(common.AddressLocation)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ContractUpdater_RemoveAccountContractCode_Call) Return(err error) *ContractUpdater_RemoveAccountContractCode_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ContractUpdater_RemoveAccountContractCode_Call) RunAndReturn(run func(location common.AddressLocation) error) *ContractUpdater_RemoveAccountContractCode_Call {
	_c.Call.Return(run)
	return _c
}

// Reset provides a mock function for the type ContractUpdater
func (_mock *ContractUpdater) Reset() {
	_mock.Called()
	return
}

// ContractUpdater_Reset_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Reset'
type ContractUpdater_Reset_Call struct {
	*mock.Call
}

// Reset is a helper method to define mock.On call
func (_e *ContractUpdater_Expecter) Reset() *ContractUpdater_Reset_Call {
	return &ContractUpdater_Reset_Call{Call: _e.mock.On("Reset")}
}

func (_c *ContractUpdater_Reset_Call) Run(run func()) *ContractUpdater_Reset_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ContractUpdater_Reset_Call) Return() *ContractUpdater_Reset_Call {
	_c.Call.Return()
	return _c
}

func (_c *ContractUpdater_Reset_Call) RunAndReturn(run func()) *ContractUpdater_Reset_Call {
	_c.Run(run)
	return _c
}

// UpdateAccountContractCode provides a mock function for the type ContractUpdater
func (_mock *ContractUpdater) UpdateAccountContractCode(location common.AddressLocation, code []byte) error {
	ret := _mock.Called(location, code)

	if len(ret) == 0 {
		panic("no return value specified for UpdateAccountContractCode")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(common.AddressLocation, []byte) error); ok {
		r0 = returnFunc(location, code)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ContractUpdater_UpdateAccountContractCode_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateAccountContractCode'
type ContractUpdater_UpdateAccountContractCode_Call struct {
	*mock.Call
}

// UpdateAccountContractCode is a helper method to define mock.On call
//   - location common.AddressLocation
//   - code []byte
func (_e *ContractUpdater_Expecter) UpdateAccountContractCode(location interface{}, code interface{}) *ContractUpdater_UpdateAccountContractCode_Call {
	return &ContractUpdater_UpdateAccountContractCode_Call{Call: _e.mock.On("UpdateAccountContractCode", location, code)}
}

func (_c *ContractUpdater_UpdateAccountContractCode_Call) Run(run func(location common.AddressLocation, code []byte)) *ContractUpdater_UpdateAccountContractCode_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 common.AddressLocation
		if args[0] != nil {
			arg0 = args[0].(common.AddressLocation)
		}
		var arg1 []byte
		if args[1] != nil {
			arg1 = args[1].([]byte)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ContractUpdater_UpdateAccountContractCode_Call) Return(err error) *ContractUpdater_UpdateAccountContractCode_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ContractUpdater_UpdateAccountContractCode_Call) RunAndReturn(run func(location common.AddressLocation, code []byte) error) *ContractUpdater_UpdateAccountContractCode_Call {
	_c.Call.Return(run)
	return _c
}

// NewContractUpdaterStubs creates a new instance of ContractUpdaterStubs. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewContractUpdaterStubs(t interface {
	mock.TestingT
	Cleanup(func())
}) *ContractUpdaterStubs {
	mock := &ContractUpdaterStubs{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// ContractUpdaterStubs is an autogenerated mock type for the ContractUpdaterStubs type
type ContractUpdaterStubs struct {
	mock.Mock
}

type ContractUpdaterStubs_Expecter struct {
	mock *mock.Mock
}

func (_m *ContractUpdaterStubs) EXPECT() *ContractUpdaterStubs_Expecter {
	return &ContractUpdaterStubs_Expecter{mock: &_m.Mock}
}

// GetAuthorizedAccounts provides a mock function for the type ContractUpdaterStubs
func (_mock *ContractUpdaterStubs) GetAuthorizedAccounts(path cadence.Path) []flow.Address {
	ret := _mock.Called(path)

	if len(ret) == 0 {
		panic("no return value specified for GetAuthorizedAccounts")
	}

	var r0 []flow.Address
	if returnFunc, ok := ret.Get(0).(func(cadence.Path) []flow.Address); ok {
		r0 = returnFunc(path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]flow.Address)
		}
	}
	return r0
}

// ContractUpdaterStubs_GetAuthorizedAccounts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAuthorizedAccounts'
type ContractUpdaterStubs_GetAuthorizedAccounts_Call struct {
	*mock.Call
}

// GetAuthorizedAccounts is a helper method to define mock.On call
//   - path cadence.Path
func (_e *ContractUpdaterStubs_Expecter) GetAuthorizedAccounts(path interface{}) *ContractUpdaterStubs_GetAuthorizedAccounts_Call {
	return &ContractUpdaterStubs_GetAuthorizedAccounts_Call{Call: _e.mock.On("GetAuthorizedAccounts", path)}
}

func (_c *ContractUpdaterStubs_GetAuthorizedAccounts_Call) Run(run func(path cadence.Path)) *ContractUpdaterStubs_GetAuthorizedAccounts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 cadence.Path
		if args[0] != nil {
			arg0 = args[0].(cadence.Path)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ContractUpdaterStubs_GetAuthorizedAccounts_Call) Return(addresss []flow.Address) *ContractUpdaterStubs_GetAuthorizedAccounts_Call {
	_c.Call.Return(addresss)
	return _c
}

func (_c *ContractUpdaterStubs_GetAuthorizedAccounts_Call) RunAndReturn(run func(path cadence.Path) []flow.Address) *ContractUpdaterStubs_GetAuthorizedAccounts_Call {
	_c.Call.Return(run)
	return _c
}

// RestrictedDeploymentEnabled provides a mock function for the type ContractUpdaterStubs
func (_mock *ContractUpdaterStubs) RestrictedDeploymentEnabled() bool {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for RestrictedDeploymentEnabled")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func() bool); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// ContractUpdaterStubs_RestrictedDeploymentEnabled_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RestrictedDeploymentEnabled'
type ContractUpdaterStubs_RestrictedDeploymentEnabled_Call struct {
	*mock.Call
}

// RestrictedDeploymentEnabled is a helper method to define mock.On call
func (_e *ContractUpdaterStubs_Expecter) RestrictedDeploymentEnabled() *ContractUpdaterStubs_RestrictedDeploymentEnabled_Call {
	return &ContractUpdaterStubs_RestrictedDeploymentEnabled_Call{Call: _e.mock.On("RestrictedDeploymentEnabled")}
}

func (_c *ContractUpdaterStubs_RestrictedDeploymentEnabled_Call) Run(run func()) *ContractUpdaterStubs_RestrictedDeploymentEnabled_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ContractUpdaterStubs_RestrictedDeploymentEnabled_Call) Return(b bool) *ContractUpdaterStubs_RestrictedDeploymentEnabled_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *ContractUpdaterStubs_RestrictedDeploymentEnabled_Call) RunAndReturn(run func() bool) *ContractUpdaterStubs_RestrictedDeploymentEnabled_Call {
	_c.Call.Return(run)
	return _c
}

// RestrictedRemovalEnabled provides a mock function for the type ContractUpdaterStubs
func (_mock *ContractUpdaterStubs) RestrictedRemovalEnabled() bool {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for RestrictedRemovalEnabled")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func() bool); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// ContractUpdaterStubs_RestrictedRemovalEnabled_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RestrictedRemovalEnabled'
type ContractUpdaterStubs_RestrictedRemovalEnabled_Call struct {
	*mock.Call
}

// RestrictedRemovalEnabled is a helper method to define mock.On call
func (_e *ContractUpdaterStubs_Expecter) RestrictedRemovalEnabled() *ContractUpdaterStubs_RestrictedRemovalEnabled_Call {
	return &ContractUpdaterStubs_RestrictedRemovalEnabled_Call{Call: _e.mock.On("RestrictedRemovalEnabled")}
}

func (_c *ContractUpdaterStubs_RestrictedRemovalEnabled_Call) Run(run func()) *ContractUpdaterStubs_RestrictedRemovalEnabled_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ContractUpdaterStubs_RestrictedRemovalEnabled_Call) Return(b bool) *ContractUpdaterStubs_RestrictedRemovalEnabled_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *ContractUpdaterStubs_RestrictedRemovalEnabled_Call) RunAndReturn(run func() bool) *ContractUpdaterStubs_RestrictedRemovalEnabled_Call {
	_c.Call.Return(run)
	return _c
}

// NewCryptoLibrary creates a new instance of CryptoLibrary. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewCryptoLibrary(t interface {
	mock.TestingT
	Cleanup(func())
}) *CryptoLibrary {
	mock := &CryptoLibrary{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// CryptoLibrary is an autogenerated mock type for the CryptoLibrary type
type CryptoLibrary struct {
	mock.Mock
}

type CryptoLibrary_Expecter struct {
	mock *mock.Mock
}

func (_m *CryptoLibrary) EXPECT() *CryptoLibrary_Expecter {
	return &CryptoLibrary_Expecter{mock: &_m.Mock}
}

// BLSAggregatePublicKeys provides a mock function for the type CryptoLibrary
func (_mock *CryptoLibrary) BLSAggregatePublicKeys(keys []*runtime.PublicKey) (*runtime.PublicKey, error) {
	ret := _mock.Called(keys)

	if len(ret) == 0 {
		panic("no return value specified for BLSAggregatePublicKeys")
	}

	var r0 *runtime.PublicKey
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]*runtime.PublicKey) (*runtime.PublicKey, error)); ok {
		return returnFunc(keys)
	}
	if returnFunc, ok := ret.Get(0).(func([]*runtime.PublicKey) *runtime.PublicKey); ok {
		r0 = returnFunc(keys)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*runtime.PublicKey)
		}
	}
	if returnFunc, ok := ret.Get(1).(func([]*runtime.PublicKey) error); ok {
		r1 = returnFunc(keys)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// CryptoLibrary_BLSAggregatePublicKeys_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BLSAggregatePublicKeys'
type CryptoLibrary_BLSAggregatePublicKeys_Call struct {
	*mock.Call
}

// BLSAggregatePublicKeys is a helper method to define mock.On call
//   - keys []*runtime.PublicKey
func (_e *CryptoLibrary_Expecter) BLSAggregatePublicKeys(keys interface{}) *CryptoLibrary_BLSAggregatePublicKeys_Call {
	return &CryptoLibrary_BLSAggregatePublicKeys_Call{Call: _e.mock.On("BLSAggregatePublicKeys", keys)}
}

func (_c *CryptoLibrary_BLSAggregatePublicKeys_Call) Run(run func(keys []*runtime.PublicKey)) *CryptoLibrary_BLSAggregatePublicKeys_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []*runtime.PublicKey
		if args[0] != nil {
			arg0 = args[0].([]*runtime.PublicKey)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *CryptoLibrary_BLSAggregatePublicKeys_Call) Return(v *runtime.PublicKey, err error) *CryptoLibrary_BLSAggregatePublicKeys_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *CryptoLibrary_BLSAggregatePublicKeys_Call) RunAndReturn(run func(keys []*runtime.PublicKey) (*runtime.PublicKey, error)) *CryptoLibrary_BLSAggregatePublicKeys_Call {
	_c.Call.Return(run)
	return _c
}

// BLSAggregateSignatures provides a mock function for the type CryptoLibrary
func (_mock *CryptoLibrary) BLSAggregateSignatures(sigs [][]byte) ([]byte, error) {
	ret := _mock.Called(sigs)

	if len(ret) == 0 {
		panic("no return value specified for BLSAggregateSignatures")
	}

	var r0 []byte
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([][]byte) ([]byte, error)); ok {
		return returnFunc(sigs)
	}
	if returnFunc, ok := ret.Get(0).(func([][]byte) []byte); ok {
		r0 = returnFunc(sigs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}
	if returnFunc, ok := ret.Get(1).(func([][]byte) error); ok {
		r1 = returnFunc(sigs)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// CryptoLibrary_BLSAggregateSignatures_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BLSAggregateSignatures'
type CryptoLibrary_BLSAggregateSignatures_Call struct {
	*mock.Call
}

// BLSAggregateSignatures is a helper method to define mock.On call
//   - sigs [][]byte
func (_e *CryptoLibrary_Expecter) BLSAggregateSignatures(sigs interface{}) *CryptoLibrary_BLSAggregateSignatures_Call {
	return &CryptoLibrary_BLSAggregateSignatures_Call{Call: _e.mock.On("BLSAggregateSignatures", sigs)}
}

func (_c *CryptoLibrary_BLSAggregateSignatures_Call) Run(run func(sigs [][]byte)) *CryptoLibrary_BLSAggregateSignatures_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 [][]byte
		if args[0] != nil {
			arg0 = args[0].([][]byte)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *CryptoLibrary_BLSAggregateSignatures_Call) Return(bytes []byte, err error) *CryptoLibrary_BLSAggregateSignatures_Call {
	_c.Call.Return(bytes, err)
	return _c
}

func (_c *CryptoLibrary_BLSAggregateSignatures_Call) RunAndReturn(run func(sigs [][]byte) ([]byte, error)) *CryptoLibrary_BLSAggregateSignatures_Call {
	_c.Call.Return(run)
	return _c
}

// BLSVerifyPOP provides a mock function for the type CryptoLibrary
func (_mock *CryptoLibrary) BLSVerifyPOP(pk *runtime.PublicKey, sig []byte) (bool, error) {
	ret := _mock.Called(pk, sig)

	if len(ret) == 0 {
		panic("no return value specified for BLSVerifyPOP")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*runtime.PublicKey, []byte) (bool, error)); ok {
		return returnFunc(pk, sig)
	}
	if returnFunc, ok := ret.Get(0).(func(*runtime.PublicKey, []byte) bool); ok {
		r0 = returnFunc(pk, sig)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(*runtime.PublicKey, []byte) error); ok {
		r1 = returnFunc(pk, sig)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// CryptoLibrary_BLSVerifyPOP_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BLSVerifyPOP'
type CryptoLibrary_BLSVerifyPOP_Call struct {
	*mock.Call
}

// BLSVerifyPOP is a helper method to define mock.On call
//   - pk *runtime.PublicKey
//   - sig []byte
func (_e *CryptoLibrary_Expecter) BLSVerifyPOP(pk interface{}, sig interface{}) *CryptoLibrary_BLSVerifyPOP_Call {
	return &CryptoLibrary_BLSVerifyPOP_Call{Call: _e.mock.On("BLSVerifyPOP", pk, sig)}
}

func (_c *CryptoLibrary_BLSVerifyPOP_Call) Run(run func(pk *runtime.PublicKey, sig []byte)) *CryptoLibrary_BLSVerifyPOP_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *runtime.PublicKey
		if args[0] != nil {
			arg0 = args[0].(*runtime.PublicKey)
		}
		var arg1 []byte
		if args[1] != nil {
			arg1 = args[1].([]byte)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *CryptoLibrary_BLSVerifyPOP_Call) Return(b bool, err error) *CryptoLibrary_BLSVerifyPOP_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *CryptoLibrary_BLSVerifyPOP_Call) RunAndReturn(run func(pk *runtime.PublicKey, sig []byte) (bool, error)) *CryptoLibrary_BLSVerifyPOP_Call {
	_c.Call.Return(run)
	return _c
}

// Hash provides a mock function for the type CryptoLibrary
func (_mock *CryptoLibrary) Hash(data []byte, tag string, hashAlgorithm runtime.HashAlgorithm) ([]byte, error) {
	ret := _mock.Called(data, tag, hashAlgorithm)

	if len(ret) == 0 {
		panic("no return value specified for Hash")
	}

	var r0 []byte
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]byte, string, runtime.HashAlgorithm) ([]byte, error)); ok {
		return returnFunc(data, tag, hashAlgorithm)
	}
	if returnFunc, ok := ret.Get(0).(func([]byte, string, runtime.HashAlgorithm) []byte); ok {
		r0 = returnFunc(data, tag, hashAlgorithm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}
	if returnFunc, ok := ret.Get(1).(func([]byte, string, runtime.HashAlgorithm) error); ok {
		r1 = returnFunc(data, tag, hashAlgorithm)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// CryptoLibrary_Hash_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Hash'
type CryptoLibrary_Hash_Call struct {
	*mock.Call
}

// Hash is a helper method to define mock.On call
//   - data []byte
//   - tag string
//   - hashAlgorithm runtime.HashAlgorithm
func (_e *CryptoLibrary_Expecter) Hash(data interface{}, tag interface{}, hashAlgorithm interface{}) *CryptoLibrary_Hash_Call {
	return &CryptoLibrary_Hash_Call{Call: _e.mock.On("Hash", data, tag, hashAlgorithm)}
}

func (_c *CryptoLibrary_Hash_Call) Run(run func(data []byte, tag string, hashAlgorithm runtime.HashAlgorithm)) *CryptoLibrary_Hash_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []byte
		if args[0] != nil {
			arg0 = args[0].([]byte)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 runtime.HashAlgorithm
		if args[2] != nil {
			arg2 = args[2].(runtime.HashAlgorithm)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *CryptoLibrary_Hash_Call) Return(bytes []byte, err error) *CryptoLibrary_Hash_Call {
	_c.Call.Return(bytes, err)
	return _c
}

func (_c *CryptoLibrary_Hash_Call) RunAndReturn(run func(data []byte, tag string, hashAlgorithm runtime.HashAlgorithm) ([]byte, error)) *CryptoLibrary_Hash_Call {
	_c.Call.Return(run)
	return _c
}

// ValidatePublicKey provides a mock function for the type CryptoLibrary
func (_mock *CryptoLibrary) ValidatePublicKey(pk *runtime.PublicKey) error {
	ret := _mock.Called(pk)

	if len(ret) == 0 {
		panic("no return value specified for ValidatePublicKey")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*runtime.PublicKey) error); ok {
		r0 = returnFunc(pk)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// CryptoLibrary_ValidatePublicKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ValidatePublicKey'
type CryptoLibrary_ValidatePublicKey_Call struct {
	*mock.Call
}

// ValidatePublicKey is a helper method to define mock.On call
//   - pk *runtime.PublicKey
func (_e *CryptoLibrary_Expecter) ValidatePublicKey(pk interface{}) *CryptoLibrary_ValidatePublicKey_Call {
	return &CryptoLibrary_ValidatePublicKey_Call{Call: _e.mock.On("ValidatePublicKey", pk)}
}

func (_c *CryptoLibrary_ValidatePublicKey_Call) Run(run func(pk *runtime.PublicKey)) *CryptoLibrary_ValidatePublicKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *runtime.PublicKey
		if args[0] != nil {
			arg0 = args[0].(*runtime.PublicKey)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *CryptoLibrary_ValidatePublicKey_Call) Return(err error) *CryptoLibrary_ValidatePublicKey_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *CryptoLibrary_ValidatePublicKey_Call) RunAndReturn(run func(pk *runtime.PublicKey) error) *CryptoLibrary_ValidatePublicKey_Call {
	_c.Call.Return(run)
	return _c
}

// VerifySignature provides a mock function for the type CryptoLibrary
func (_mock *CryptoLibrary) VerifySignature(signature []byte, tag string, signedData []byte, publicKey []byte, signatureAlgorithm runtime.SignatureAlgorithm, hashAlgorithm runtime.HashAlgorithm) (bool, error) {
	ret := _mock.Called(signature, tag, signedData, publicKey, signatureAlgorithm, hashAlgorithm)

	if len(ret) == 0 {
		panic("no return value specified for VerifySignature")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]byte, string, []byte, []byte, runtime.SignatureAlgorithm, runtime.HashAlgorithm) (bool, error)); ok {
		return returnFunc(signature, tag, signedData, publicKey, signatureAlgorithm, hashAlgorithm)
	}
	if returnFunc, ok := ret.Get(0).(func([]byte, string, []byte, []byte, runtime.SignatureAlgorithm, runtime.HashAlgorithm) bool); ok {
		r0 = returnFunc(signature, tag, signedData, publicKey, signatureAlgorithm, hashAlgorithm)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func([]byte, string, []byte, []byte, runtime.SignatureAlgorithm, runtime.HashAlgorithm) error); ok {
		r1 = returnFunc(signature, tag, signedData, publicKey, signatureAlgorithm, hashAlgorithm)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// CryptoLibrary_VerifySignature_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'VerifySignature'
type CryptoLibrary_VerifySignature_Call struct {
	*mock.Call
}

// VerifySignature is a helper method to define mock.On call
//   - signature []byte
//   - tag string
//   - signedData []byte
//   - publicKey []byte
//   - signatureAlgorithm runtime.SignatureAlgorithm
//   - hashAlgorithm runtime.HashAlgorithm
func (_e *CryptoLibrary_Expecter) VerifySignature(signature interface{}, tag interface{}, signedData interface{}, publicKey interface{}, signatureAlgorithm interface{}, hashAlgorithm interface{}) *CryptoLibrary_VerifySignature_Call {
	return &CryptoLibrary_VerifySignature_Call{Call: _e.mock.On("VerifySignature", signature, tag, signedData, publicKey, signatureAlgorithm, hashAlgorithm)}
}

func (_c *CryptoLibrary_VerifySignature_Call) Run(run func(signature []byte, tag string, signedData []byte, publicKey []byte, signatureAlgorithm runtime.SignatureAlgorithm, hashAlgorithm runtime.HashAlgorithm)) *CryptoLibrary_VerifySignature_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []byte
		if args[0] != nil {
			arg0 = args[0].([]byte)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 []byte
		if args[2] != nil {
			arg2 = args[2].([]byte)
		}
		var arg3 []byte
		if args[3] != nil {
			arg3 = args[3].([]byte)
		}
		var arg4 runtime.SignatureAlgorithm
		if args[4] != nil {
			arg4 = args[4].(runtime.SignatureAlgorithm)
		}
		var arg5 runtime.HashAlgorithm
		if args[5] != nil {
			arg5 = args[5].(runtime.HashAlgorithm)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
			arg5,
		)
	})
	return _c
}

func (_c *CryptoLibrary_VerifySignature_Call) Return(b bool, err error) *CryptoLibrary_VerifySignature_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *CryptoLibrary_VerifySignature_Call) RunAndReturn(run func(signature []byte, tag string, signedData []byte, publicKey []byte, signatureAlgorithm runtime.SignatureAlgorithm, hashAlgorithm runtime.HashAlgorithm) (bool, error)) *CryptoLibrary_VerifySignature_Call {
	_c.Call.Return(run)
	return _c
}

// NewEnvironment creates a new instance of Environment. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewEnvironment(t interface {
	mock.TestingT
	Cleanup(func())
}) *Environment {
	mock := &Environment{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Environment is an autogenerated mock type for the Environment type
type Environment struct {
	mock.Mock
}

type Environment_Expecter struct {
	mock *mock.Mock
}

func (_m *Environment) EXPECT() *Environment_Expecter {
	return &Environment_Expecter{mock: &_m.Mock}
}

// AccountKeysCount provides a mock function for the type Environment
func (_mock *Environment) AccountKeysCount(address runtime.Address) (uint32, error) {
	ret := _mock.Called(address)

	if len(ret) == 0 {
		panic("no return value specified for AccountKeysCount")
	}

	var r0 uint32
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(runtime.Address) (uint32, error)); ok {
		return returnFunc(address)
	}
	if returnFunc, ok := ret.Get(0).(func(runtime.Address) uint32); ok {
		r0 = returnFunc(address)
	} else {
		r0 = ret.Get(0).(uint32)
	}
	if returnFunc, ok := ret.Get(1).(func(runtime.Address) error); ok {
		r1 = returnFunc(address)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Environment_AccountKeysCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AccountKeysCount'
type Environment_AccountKeysCount_Call struct {
	*mock.Call
}

// AccountKeysCount is a helper method to define mock.On call
//   - address runtime.Address
func (_e *Environment_Expecter) AccountKeysCount(address interface{}) *Environment_AccountKeysCount_Call {
	return &Environment_AccountKeysCount_Call{Call: _e.mock.On("AccountKeysCount", address)}
}

func (_c *Environment_AccountKeysCount_Call) Run(run func(address runtime.Address)) *Environment_AccountKeysCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 runtime.Address
		if args[0] != nil {
			arg0 = args[0].(runtime.Address)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Environment_AccountKeysCount_Call) Return(v uint32, err error) *Environment_AccountKeysCount_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *Environment_AccountKeysCount_Call) RunAndReturn(run func(address runtime.Address) (uint32, error)) *Environment_AccountKeysCount_Call {
	_c.Call.Return(run)
	return _c
}

// AccountsStorageCapacity provides a mock function for the type Environment
func (_mock *Environment) AccountsStorageCapacity(addresses []flow.Address, payer flow.Address, maxTxFees uint64) (cadence.Value, error) {
	ret := _mock.Called(addresses, payer, maxTxFees)

	if len(ret) == 0 {
		panic("no return value specified for AccountsStorageCapacity")
	}

	var r0 cadence.Value
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]flow.Address, flow.Address, uint64) (cadence.Value, error)); ok {
		return returnFunc(addresses, payer, maxTxFees)
	}
	if returnFunc, ok := ret.Get(0).(func([]flow.Address, flow.Address, uint64) cadence.Value); ok {
		r0 = returnFunc(addresses, payer, maxTxFees)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(cadence.Value)
		}
	}
	if returnFunc, ok := ret.Get(1).(func([]flow.Address, flow.Address, uint64) error); ok {
		r1 = returnFunc(addresses, payer, maxTxFees)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Environment_AccountsStorageCapacity_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AccountsStorageCapacity'
type Environment_AccountsStorageCapacity_Call struct {
	*mock.Call
}

// AccountsStorageCapacity is a helper method to define mock.On call
//   - addresses []flow.Address
//   - payer flow.Address
//   - maxTxFees uint64
func (_e *Environment_Expecter) AccountsStorageCapacity(addresses interface{}, payer interface{}, maxTxFees interface{}) *Environment_AccountsStorageCapacity_Call {
	return &Environment_AccountsStorageCapacity_Call{Call: _e.mock.On("AccountsStorageCapacity", addresses, payer, maxTxFees)}
}

func (_c *Environment_AccountsStorageCapacity_Call) Run(run func(addresses []flow.Address, payer flow.Address, maxTxFees uint64)) *Environment_AccountsStorageCapacity_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []flow.Address
		if args[0] != nil {
			arg0 = args[0].([]flow.Address)
		}
		var arg1 flow.Address
		if args[1] != nil {
			arg1 = args[1].(flow.Address)
		}
		var arg2 uint64
		if args[2] != nil {
			arg2 = args[2].(uint64)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Environment_AccountsStorageCapacity_Call) Return(value cadence.Value, err error) *Environment_AccountsStorageCapacity_Call {
	_c.Call.Return(value, err)
	return _c
}

func (_c *Environment_AccountsStorageCapacity_Call) RunAndReturn(run func(addresses []flow.Address, payer flow.Address, maxTxFees uint64) (cadence.Value, error)) *Environment_AccountsStorageCapacity_Call {
	_c.Call.Return(run)
	return _c
}

// AddAccountKey provides a mock function for the type Environment
func (_mock *Environment) AddAccountKey(address runtime.Address, publicKey *runtime.PublicKey, hashAlgo runtime.HashAlgorithm, weight int) (*runtime.AccountKey, error) {
	ret := _mock.Called(address, publicKey, hashAlgo, weight)

	if len(ret) == 0 {
		panic("no return value specified for AddAccountKey")
	}

	var r0 *runtime.AccountKey
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(runtime.Address, *runtime.PublicKey, runtime.HashAlgorithm, int) (*runtime.AccountKey, error)); ok {
		return returnFunc(address, publicKey, hashAlgo, weight)
	}
	if returnFunc, ok := ret.Get(0).(func(runtime.Address, *runtime.PublicKey, runtime.HashAlgorithm, int) *runtime.AccountKey); ok {
		r0 = returnFunc(address, publicKey, hashAlgo, weight)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*runtime.AccountKey)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(runtime.Address, *runtime.PublicKey, runtime.HashAlgorithm, int) error); ok {
		r1 = returnFunc(address, publicKey, hashAlgo, weight)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Environment_AddAccountKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddAccountKey'
type Environment_AddAccountKey_Call struct {
	*mock.Call
}

// AddAccountKey is a helper method to define mock.On call
//   - address runtime.Address
//   - publicKey *runtime.PublicKey
//   - hashAlgo runtime.HashAlgorithm
//   - weight int
func (_e *Environment_Expecter) AddAccountKey(address interface{}, publicKey interface{}, hashAlgo interface{}, weight interface{}) *Environment_AddAccountKey_Call {
	return &Environment_AddAccountKey_Call{Call: _e.mock.On("AddAccountKey", address, publicKey, hashAlgo, weight)}
}

func (_c *Environment_AddAccountKey_Call) Run(run func(address runtime.Address, publicKey *runtime.PublicKey, hashAlgo runtime.HashAlgorithm, weight int)) *Environment_AddAccountKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 runtime.Address
		if args[0] != nil {
			arg0 = args[0].(runtime.Address)
		}
		var arg1 *runtime.PublicKey
		if args[1] != nil {
			arg1 = args[1].(*runtime.PublicKey)
		}
		var arg2 runtime.HashAlgorithm
		if args[2] != nil {
			arg2 = args[2].(runtime.HashAlgorithm)
		}
		var arg3 int
		if args[3] != nil {
			arg3 = args[3].(int)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *Environment_AddAccountKey_Call) Return(v *runtime.AccountKey, err error) *Environment_AddAccountKey_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *Environment_AddAccountKey_Call) RunAndReturn(run func(address runtime.Address, publicKey *runtime.PublicKey, hashAlgo runtime.HashAlgorithm, weight int) (*runtime.AccountKey, error)) *Environment_AddAccountKey_Call {
	_c.Call.Return(run)
	return _c
}

// AllocateSlabIndex provides a mock function for the type Environment
func (_mock *Environment) AllocateSlabIndex(owner []byte) (atree.SlabIndex, error) {
	ret := _mock.Called(owner)

	if len(ret) == 0 {
		panic("no return value specified for AllocateSlabIndex")
	}

	var r0 atree.SlabIndex
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]byte) (atree.SlabIndex, error)); ok {
		return returnFunc(owner)
	}
	if returnFunc, ok := ret.Get(0).(func([]byte) atree.SlabIndex); ok {
		r0 = returnFunc(owner)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(atree.SlabIndex)
		}
	}
	if returnFunc, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = returnFunc(owner)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Environment_AllocateSlabIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AllocateSlabIndex'
type Environment_AllocateSlabIndex_Call struct {
	*mock.Call
}

// AllocateSlabIndex is a helper method to define mock.On call
//   - owner []byte
func (_e *Environment_Expecter) AllocateSlabIndex(owner interface{}) *Environment_AllocateSlabIndex_Call {
	return &Environment_AllocateSlabIndex_Call{Call: _e.mock.On("AllocateSlabIndex", owner)}
}

func (_c *Environment_AllocateSlabIndex_Call) Run(run func(owner []byte)) *Environment_AllocateSlabIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []byte
		if args[0] != nil {
			arg0 = args[0].([]byte)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Environment_AllocateSlabIndex_Call) Return(slabIndex atree.SlabIndex, err error) *Environment_AllocateSlabIndex_Call {
	_c.Call.Return(slabIndex, err)
	return _c
}

func (_c *Environment_AllocateSlabIndex_Call) RunAndReturn(run func(owner []byte) (atree.SlabIndex, error)) *Environment_AllocateSlabIndex_Call {
	_c.Call.Return(run)
	return _c
}

// BLSAggregatePublicKeys provides a mock function for the type Environment
func (_mock *Environment) BLSAggregatePublicKeys(publicKeys []*runtime.PublicKey) (*runtime.PublicKey, error) {
	ret := _mock.Called(publicKeys)

	if len(ret) == 0 {
		panic("no return value specified for BLSAggregatePublicKeys")
	}

	var r0 *runtime.PublicKey
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]*runtime.PublicKey) (*runtime.PublicKey, error)); ok {
		return returnFunc(publicKeys)
	}
	if returnFunc, ok := ret.Get(0).(func([]*runtime.PublicKey) *runtime.PublicKey); ok {
		r0 = returnFunc(publicKeys)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*runtime.PublicKey)
		}
	}
	if returnFunc, ok := ret.Get(1).(func([]*runtime.PublicKey) error); ok {
		r1 = returnFunc(publicKeys)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Environment_BLSAggregatePublicKeys_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BLSAggregatePublicKeys'
type Environment_BLSAggregatePublicKeys_Call struct {
	*mock.Call
}

// BLSAggregatePublicKeys is a helper method to define mock.On call
//   - publicKeys []*runtime.PublicKey
func (_e *Environment_Expecter) BLSAggregatePublicKeys(publicKeys interface{}) *Environment_BLSAggregatePublicKeys_Call {
	return &Environment_BLSAggregatePublicKeys_Call{Call: _e.mock.On("BLSAggregatePublicKeys", publicKeys)}
}

func (_c *Environment_BLSAggregatePublicKeys_Call) Run(run func(publicKeys []*runtime.PublicKey)) *Environment_BLSAggregatePublicKeys_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []*runtime.PublicKey
		if args[0] != nil {
			arg0 = args[0].([]*runtime.PublicKey)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Environment_BLSAggregatePublicKeys_Call) Return(v *runtime.PublicKey, err error) *Environment_BLSAggregatePublicKeys_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *Environment_BLSAggregatePublicKeys_Call) RunAndReturn(run func(publicKeys []*runtime.PublicKey) (*runtime.PublicKey, error)) *Environment_BLSAggregatePublicKeys_Call {
	_c.Call.Return(run)
	return _c
}

// BLSAggregateSignatures provides a mock function for the type Environment
func (_mock *Environment) BLSAggregateSignatures(signatures [][]byte) ([]byte, error) {
	ret := _mock.Called(signatures)

	if len(ret) == 0 {
		panic("no return value specified for BLSAggregateSignatures")
	}

	var r0 []byte
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([][]byte) ([]byte, error)); ok {
		return returnFunc(signatures)
	}
	if returnFunc, ok := ret.Get(0).(func([][]byte) []byte); ok {
		r0 = returnFunc(signatures)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}
	if returnFunc, ok := ret.Get(1).(func([][]byte) error); ok {
		r1 = returnFunc(signatures)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Environment_BLSAggregateSignatures_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BLSAggregateSignatures'
type Environment_BLSAggregateSignatures_Call struct {
	*mock.Call
}

// BLSAggregateSignatures is a helper method to define mock.On call
//   - signatures [][]byte
func (_e *Environment_Expecter) BLSAggregateSignatures(signatures interface{}) *Environment_BLSAggregateSignatures_Call {
	return &Environment_BLSAggregateSignatures_Call{Call: _e.mock.On("BLSAggregateSignatures", signatures)}
}

func (_c *Environment_BLSAggregateSignatures_Call) Run(run func(signatures [][]byte)) *Environment_BLSAggregateSignatures_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 [][]byte
		if args[0] != nil {
			arg0 = args[0].([][]byte)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Environment_BLSAggregateSignatures_Call) Return(bytes []byte, err error) *Environment_BLSAggregateSignatures_Call {
	_c.Call.Return(bytes, err)
	return _c
}

func (_c *Environment_BLSAggregateSignatures_Call) RunAndReturn(run func(signatures [][]byte) ([]byte, error)) *Environment_BLSAggregateSignatures_Call {
	_c.Call.Return(run)
	return _c
}

// BLSVerifyPOP provides a mock function for the type Environment
func (_mock *Environment) BLSVerifyPOP(publicKey *runtime.PublicKey, signature []byte) (bool, error) {
	ret := _mock.Called(publicKey, signature)

	if len(ret) == 0 {
		panic("no return value specified for BLSVerifyPOP")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*runtime.PublicKey, []byte) (bool, error)); ok {
		return returnFunc(publicKey, signature)
	}
	if returnFunc, ok := ret.Get(0).(func(*runtime.PublicKey, []byte) bool); ok {
		r0 = returnFunc(publicKey, signature)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(*runtime.PublicKey, []byte) error); ok {
		r1 = returnFunc(publicKey, signature)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Environment_BLSVerifyPOP_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BLSVerifyPOP'
type Environment_BLSVerifyPOP_Call struct {
	*mock.Call
}

// BLSVerifyPOP is a helper method to define mock.On call
//   - publicKey *runtime.PublicKey
//   - signature []byte
func (_e *Environment_Expecter) BLSVerifyPOP(publicKey interface{}, signature interface{}) *Environment_BLSVerifyPOP_Call {
	return &Environment_BLSVerifyPOP_Call{Call: _e.mock.On("BLSVerifyPOP", publicKey, signature)}
}

func (_c *Environment_BLSVerifyPOP_Call) Run(run func(publicKey *runtime.PublicKey, signature []byte)) *Environment_BLSVerifyPOP_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *runtime.PublicKey
		if args[0] != nil {
			arg0 = args[0].(*runtime.PublicKey)
		}
		var arg1 []byte
		if args[1] != nil {
			arg1 = args[1].([]byte)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Environment_BLSVerifyPOP_Call) Return(b bool, err error) *Environment_BLSVerifyPOP_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *Environment_BLSVerifyPOP_Call) RunAndReturn(run func(publicKey *runtime.PublicKey, signature []byte) (bool, error)) *Environment_BLSVerifyPOP_Call {
	_c.Call.Return(run)
	return _c
}

// BorrowCadenceRuntime provides a mock function for the type Environment
func (_mock *Environment) BorrowCadenceRuntime() *runtime0.ReusableCadenceRuntime {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for BorrowCadenceRuntime")
	}

	var r0 *runtime0.ReusableCadenceRuntime
	if returnFunc, ok := ret.Get(0).(func() *runtime0.ReusableCadenceRuntime); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*runtime0.ReusableCadenceRuntime)
		}
	}
	return r0
}

// Environment_BorrowCadenceRuntime_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BorrowCadenceRuntime'
type Environment_BorrowCadenceRuntime_Call struct {
	*mock.Call
}

// BorrowCadenceRuntime is a helper method to define mock.On call
func (_e *Environment_Expecter) BorrowCadenceRuntime() *Environment_BorrowCadenceRuntime_Call {
	return &Environment_BorrowCadenceRuntime_Call{Call: _e.mock.On("BorrowCadenceRuntime")}
}

func (_c *Environment_BorrowCadenceRuntime_Call) Run(run func()) *Environment_BorrowCadenceRuntime_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Environment_BorrowCadenceRuntime_Call) Return(reusableCadenceRuntime *runtime0.ReusableCadenceRuntime) *Environment_BorrowCadenceRuntime_Call {
	_c.Call.Return(reusableCadenceRuntime)
	return _c
}

func (_c *Environment_BorrowCadenceRuntime_Call) RunAndReturn(run func() *runtime0.ReusableCadenceRuntime) *Environment_BorrowCadenceRuntime_Call {
	_c.Call.Return(run)
	return _c
}

// CheckPayerBalanceAndGetMaxTxFees provides a mock function for the type Environment
func (_mock *Environment) CheckPayerBalanceAndGetMaxTxFees(payer flow.Address, inclusionEffort uint64, executionEffort uint64) (cadence.Value, error) {
	ret := _mock.Called(payer, inclusionEffort, executionEffort)

	if len(ret) == 0 {
		panic("no return value specified for CheckPayerBalanceAndGetMaxTxFees")
	}

	var r0 cadence.Value
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Address, uint64, uint64) (cadence.Value, error)); ok {
		return returnFunc(payer, inclusionEffort, executionEffort)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Address, uint64, uint64) cadence.Value); ok {
		r0 = returnFunc(payer, inclusionEffort, executionEffort)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(cadence.Value)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Address, uint64, uint64) error); ok {
		r1 = returnFunc(payer, inclusionEffort, executionEffort)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Environment_CheckPayerBalanceAndGetMaxTxFees_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckPayerBalanceAndGetMaxTxFees'
type Environment_CheckPayerBalanceAndGetMaxTxFees_Call struct {
	*mock.Call
}

// CheckPayerBalanceAndGetMaxTxFees is a helper method to define mock.On call
//   - payer flow.Address
//   - inclusionEffort uint64
//   - executionEffort uint64
func (_e *Environment_Expecter) CheckPayerBalanceAndGetMaxTxFees(payer interface{}, inclusionEffort interface{}, executionEffort interface{}) *Environment_CheckPayerBalanceAndGetMaxTxFees_Call {
	return &Environment_CheckPayerBalanceAndGetMaxTxFees_Call{Call: _e.mock.On("CheckPayerBalanceAndGetMaxTxFees", payer, inclusionEffort, executionEffort)}
}

func (_c *Environment_CheckPayerBalanceAndGetMaxTxFees_Call) Run(run func(payer flow.Address, inclusionEffort uint64, executionEffort uint64)) *Environment_CheckPayerBalanceAndGetMaxTxFees_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Address
		if args[0] != nil {
			arg0 = args[0].(flow.Address)
		}
		var arg1 uint64
		if args[1] != nil {
			arg1 = args[1].(uint64)
		}
		var arg2 uint64
		if args[2] != nil {
			arg2 = args[2].(uint64)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Environment_CheckPayerBalanceAndGetMaxTxFees_Call) Return(value cadence.Value, err error) *Environment_CheckPayerBalanceAndGetMaxTxFees_Call {
	_c.Call.Return(value, err)
	return _c
}

func (_c *Environment_CheckPayerBalanceAndGetMaxTxFees_Call) RunAndReturn(run func(payer flow.Address, inclusionEffort uint64, executionEffort uint64) (cadence.Value, error)) *Environment_CheckPayerBalanceAndGetMaxTxFees_Call {
	_c.Call.Return(run)
	return _c
}

// ComputationAvailable provides a mock function for the type Environment
func (_mock *Environment) ComputationAvailable(computationUsage common.ComputationUsage) bool {
	ret := _mock.Called(computationUsage)

	if len(ret) == 0 {
		panic("no return value specified for ComputationAvailable")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(common.ComputationUsage) bool); ok {
		r0 = returnFunc(computationUsage)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// Environment_ComputationAvailable_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ComputationAvailable'
type Environment_ComputationAvailable_Call struct {
	*mock.Call
}

// ComputationAvailable is a helper method to define mock.On call
//   - computationUsage common.ComputationUsage
func (_e *Environment_Expecter) ComputationAvailable(computationUsage interface{}) *Environment_ComputationAvailable_Call {
	return &Environment_ComputationAvailable_Call{Call: _e.mock.On("ComputationAvailable", computationUsage)}
}

func (_c *Environment_ComputationAvailable_Call) Run(run func(computationUsage common.ComputationUsage)) *Environment_ComputationAvailable_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 common.ComputationUsage
		if args[0] != nil {
			arg0 = args[0].(common.ComputationUsage)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Environment_ComputationAvailable_Call) Return(b bool) *Environment_ComputationAvailable_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *Environment_ComputationAvailable_Call) RunAndReturn(run func(computationUsage common.ComputationUsage) bool) *Environment_ComputationAvailable_Call {
	_c.Call.Return(run)
	return _c
}

// ComputationIntensities provides a mock function for the type Environment
func (_mock *Environment) ComputationIntensities() meter.MeteredComputationIntensities {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for ComputationIntensities")
	}

	var r0 meter.MeteredComputationIntensities
	if returnFunc, ok := ret.Get(0).(func() meter.MeteredComputationIntensities); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(meter.MeteredComputationIntensities)
		}
	}
	return r0
}

// Environment_ComputationIntensities_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ComputationIntensities'
type Environment_ComputationIntensities_Call struct {
	*mock.Call
}

// ComputationIntensities is a helper method to define mock.On call
func (_e *Environment_Expecter) ComputationIntensities() *Environment_ComputationIntensities_Call {
	return &Environment_ComputationIntensities_Call{Call: _e.mock.On("ComputationIntensities")}
}

func (_c *Environment_ComputationIntensities_Call) Run(run func()) *Environment_ComputationIntensities_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Environment_ComputationIntensities_Call) Return(meteredComputationIntensities meter.MeteredComputationIntensities) *Environment_ComputationIntensities_Call {
	_c.Call.Return(meteredComputationIntensities)
	return _c
}

func (_c *Environment_ComputationIntensities_Call) RunAndReturn(run func() meter.MeteredComputationIntensities) *Environment_ComputationIntensities_Call {
	_c.Call.Return(run)
	return _c
}

// ComputationRemaining provides a mock function for the type Environment
func (_mock *Environment) ComputationRemaining(kind common.ComputationKind) uint64 {
	ret := _mock.Called(kind)

	if len(ret) == 0 {
		panic("no return value specified for ComputationRemaining")
	}

	var r0 uint64
	if returnFunc, ok := ret.Get(0).(func(common.ComputationKind) uint64); ok {
		r0 = returnFunc(kind)
	} else {
		r0 = ret.Get(0).(uint64)
	}
	return r0
}

// Environment_ComputationRemaining_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ComputationRemaining'
type Environment_ComputationRemaining_Call struct {
	*mock.Call
}

// ComputationRemaining is a helper method to define mock.On call
//   - kind common.ComputationKind
func (_e *Environment_Expecter) ComputationRemaining(kind interface{}) *Environment_ComputationRemaining_Call {
	return &Environment_ComputationRemaining_Call{Call: _e.mock.On("ComputationRemaining", kind)}
}

func (_c *Environment_ComputationRemaining_Call) Run(run func(kind common.ComputationKind)) *Environment_ComputationRemaining_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 common.ComputationKind
		if args[0] != nil {
			arg0 = args[0].(common.ComputationKind)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Environment_ComputationRemaining_Call) Return(v uint64) *Environment_ComputationRemaining_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *Environment_ComputationRemaining_Call) RunAndReturn(run func(kind common.ComputationKind) uint64) *Environment_ComputationRemaining_Call {
	_c.Call.Return(run)
	return _c
}

// ComputationUsed provides a mock function for the type Environment
func (_mock *Environment) ComputationUsed() (uint64, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for ComputationUsed")
	}

	var r0 uint64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (uint64, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() uint64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint64)
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Environment_ComputationUsed_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ComputationUsed'
type Environment_ComputationUsed_Call struct {
	*mock.Call
}

// ComputationUsed is a helper method to define mock.On call
func (_e *Environment_Expecter) ComputationUsed() *Environment_ComputationUsed_Call {
	return &Environment_ComputationUsed_Call{Call: _e.mock.On("ComputationUsed")}
}

func (_c *Environment_ComputationUsed_Call) Run(run func()) *Environment_ComputationUsed_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Environment_ComputationUsed_Call) Return(v uint64, err error) *Environment_ComputationUsed_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *Environment_ComputationUsed_Call) RunAndReturn(run func() (uint64, error)) *Environment_ComputationUsed_Call {
	_c.Call.Return(run)
	return _c
}

// ConvertedServiceEvents provides a mock function for the type Environment
func (_mock *Environment) ConvertedServiceEvents() flow.ServiceEventList {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for ConvertedServiceEvents")
	}

	var r0 flow.ServiceEventList
	if returnFunc, ok := ret.Get(0).(func() flow.ServiceEventList); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.ServiceEventList)
		}
	}
	return r0
}

// Environment_ConvertedServiceEvents_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConvertedServiceEvents'
type Environment_ConvertedServiceEvents_Call struct {
	*mock.Call
}

// ConvertedServiceEvents is a helper method to define mock.On call
func (_e *Environment_Expecter) ConvertedServiceEvents() *Environment_ConvertedServiceEvents_Call {
	return &Environment_ConvertedServiceEvents_Call{Call: _e.mock.On("ConvertedServiceEvents")}
}

func (_c *Environment_ConvertedServiceEvents_Call) Run(run func()) *Environment_ConvertedServiceEvents_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Environment_ConvertedServiceEvents_Call) Return(serviceEventList flow.ServiceEventList) *Environment_ConvertedServiceEvents_Call {
	_c.Call.Return(serviceEventList)
	return _c
}

func (_c *Environment_ConvertedServiceEvents_Call) RunAndReturn(run func() flow.ServiceEventList) *Environment_ConvertedServiceEvents_Call {
	_c.Call.Return(run)
	return _c
}

// CreateAccount provides a mock function for the type Environment
func (_mock *Environment) CreateAccount(payer runtime.Address) (runtime.Address, error) {
	ret := _mock.Called(payer)

	if len(ret) == 0 {
		panic("no return value specified for CreateAccount")
	}

	var r0 runtime.Address
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(runtime.Address) (runtime.Address, error)); ok {
		return returnFunc(payer)
	}
	if returnFunc, ok := ret.Get(0).(func(runtime.Address) runtime.Address); ok {
		r0 = returnFunc(payer)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(runtime.Address)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(runtime.Address) error); ok {
		r1 = returnFunc(payer)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Environment_CreateAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateAccount'
type Environment_CreateAccount_Call struct {
	*mock.Call
}

// CreateAccount is a helper method to define mock.On call
//   - payer runtime.Address
func (_e *Environment_Expecter) CreateAccount(payer interface{}) *Environment_CreateAccount_Call {
	return &Environment_CreateAccount_Call{Call: _e.mock.On("CreateAccount", payer)}
}

func (_c *Environment_CreateAccount_Call) Run(run func(payer runtime.Address)) *Environment_CreateAccount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 runtime.Address
		if args[0] != nil {
			arg0 = args[0].(runtime.Address)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Environment_CreateAccount_Call) Return(address runtime.Address, err error) *Environment_CreateAccount_Call {
	_c.Call.Return(address, err)
	return _c
}

func (_c *Environment_CreateAccount_Call) RunAndReturn(run func(payer runtime.Address) (runtime.Address, error)) *Environment_CreateAccount_Call {
	_c.Call.Return(run)
	return _c
}

// DecodeArgument provides a mock function for the type Environment
func (_mock *Environment) DecodeArgument(argument []byte, argumentType cadence.Type) (cadence.Value, error) {
	ret := _mock.Called(argument, argumentType)

	if len(ret) == 0 {
		panic("no return value specified for DecodeArgument")
	}

	var r0 cadence.Value
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]byte, cadence.Type) (cadence.Value, error)); ok {
		return returnFunc(argument, argumentType)
	}
	if returnFunc, ok := ret.Get(0).(func([]byte, cadence.Type) cadence.Value); ok {
		r0 = returnFunc(argument, argumentType)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(cadence.Value)
		}
	}
	if returnFunc, ok := ret.Get(1).(func([]byte, cadence.Type) error); ok {
		r1 = returnFunc(argument, argumentType)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Environment_DecodeArgument_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DecodeArgument'
type Environment_DecodeArgument_Call struct {
	*mock.Call
}

// DecodeArgument is a helper method to define mock.On call
//   - argument []byte
//   - argumentType cadence.Type
func (_e *Environment_Expecter) DecodeArgument(argument interface{}, argumentType interface{}) *Environment_DecodeArgument_Call {
	return &Environment_DecodeArgument_Call{Call: _e.mock.On("DecodeArgument", argument, argumentType)}
}

func (_c *Environment_DecodeArgument_Call) Run(run func(argument []byte, argumentType cadence.Type)) *Environment_DecodeArgument_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []byte
		if args[0] != nil {
			arg0 = args[0].([]byte)
		}
		var arg1 cadence.Type
		if args[1] != nil {
			arg1 = args[1].(cadence.Type)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Environment_DecodeArgument_Call) Return(value cadence.Value, err error) *Environment_DecodeArgument_Call {
	_c.Call.Return(value, err)
	return _c
}

func (_c *Environment_DecodeArgument_Call) RunAndReturn(run func(argument []byte, argumentType cadence.Type) (cadence.Value, error)) *Environment_DecodeArgument_Call {
	_c.Call.Return(run)
	return _c
}

// DeductTransactionFees provides a mock function for the type Environment
func (_mock *Environment) DeductTransactionFees(payer flow.Address, inclusionEffort uint64, executionEffort uint64) (cadence.Value, error) {
	ret := _mock.Called(payer, inclusionEffort, executionEffort)

	if len(ret) == 0 {
		panic("no return value specified for DeductTransactionFees")
	}

	var r0 cadence.Value
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Address, uint64, uint64) (cadence.Value, error)); ok {
		return returnFunc(payer, inclusionEffort, executionEffort)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Address, uint64, uint64) cadence.Value); ok {
		r0 = returnFunc(payer, inclusionEffort, executionEffort)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(cadence.Value)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Address, uint64, uint64) error); ok {
		r1 = returnFunc(payer, inclusionEffort, executionEffort)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Environment_DeductTransactionFees_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeductTransactionFees'
type Environment_DeductTransactionFees_Call struct {
	*mock.Call
}

// DeductTransactionFees is a helper method to define mock.On call
//   - payer flow.Address
//   - inclusionEffort uint64
//   - executionEffort uint64
func (_e *Environment_Expecter) DeductTransactionFees(payer interface{}, inclusionEffort interface{}, executionEffort interface{}) *Environment_DeductTransactionFees_Call {
	return &Environment_DeductTransactionFees_Call{Call: _e.mock.On("DeductTransactionFees", payer, inclusionEffort, executionEffort)}
}

func (_c *Environment_DeductTransactionFees_Call) Run(run func(payer flow.Address, inclusionEffort uint64, executionEffort uint64)) *Environment_DeductTransactionFees_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Address
		if args[0] != nil {
			arg0 = args[0].(flow.Address)
		}
		var arg1 uint64
		if args[1] != nil {
			arg1 = args[1].(uint64)
		}
		var arg2 uint64
		if args[2] != nil {
			arg2 = args[2].(uint64)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Environment_DeductTransactionFees_Call) Return(value cadence.Value, err error) *Environment_DeductTransactionFees_Call {
	_c.Call.Return(value, err)
	return _c
}

func (_c *Environment_DeductTransactionFees_Call) RunAndReturn(run func(payer flow.Address, inclusionEffort uint64, executionEffort uint64) (cadence.Value, error)) *Environment_DeductTransactionFees_Call {
	_c.Call.Return(run)
	return _c
}

// EVMBlockExecuted provides a mock function for the type Environment
func (_mock *Environment) EVMBlockExecuted(txCount int, totalGasUsed uint64, totalSupplyInFlow float64) {
	_mock.Called(txCount, totalGasUsed, totalSupplyInFlow)
	return
}

// Environment_EVMBlockExecuted_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EVMBlockExecuted'
type Environment_EVMBlockExecuted_Call struct {
	*mock.Call
}

// EVMBlockExecuted is a helper method to define mock.On call
//   - txCount int
//   - totalGasUsed uint64
//   - totalSupplyInFlow float64
func (_e *Environment_Expecter) EVMBlockExecuted(txCount interface{}, totalGasUsed interface{}, totalSupplyInFlow interface{}) *Environment_EVMBlockExecuted_Call {
	return &Environment_EVMBlockExecuted_Call{Call: _e.mock.On("EVMBlockExecuted", txCount, totalGasUsed, totalSupplyInFlow)}
}

func (_c *Environment_EVMBlockExecuted_Call) Run(run func(txCount int, totalGasUsed uint64, totalSupplyInFlow float64)) *Environment_EVMBlockExecuted_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 int
		if args[0] != nil {
			arg0 = args[0].(int)
		}
		var arg1 uint64
		if args[1] != nil {
			arg1 = args[1].(uint64)
		}
		var arg2 float64
		if args[2] != nil {
			arg2 = args[2].(float64)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Environment_EVMBlockExecuted_Call) Return() *Environment_EVMBlockExecuted_Call {
	_c.Call.Return()
	return _c
}

func (_c *Environment_EVMBlockExecuted_Call) RunAndReturn(run func(txCount int, totalGasUsed uint64, totalSupplyInFlow float64)) *Environment_EVMBlockExecuted_Call {
	_c.Run(run)
	return _c
}

// EVMTransactionExecuted provides a mock function for the type Environment
func (_mock *Environment) EVMTransactionExecuted(gasUsed uint64, isDirectCall bool, failed bool) {
	_mock.Called(gasUsed, isDirectCall, failed)
	return
}

// Environment_EVMTransactionExecuted_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EVMTransactionExecuted'
type Environment_EVMTransactionExecuted_Call struct {
	*mock.Call
}

// EVMTransactionExecuted is a helper method to define mock.On call
//   - gasUsed uint64
//   - isDirectCall bool
//   - failed bool
func (_e *Environment_Expecter) EVMTransactionExecuted(gasUsed interface{}, isDirectCall interface{}, failed interface{}) *Environment_EVMTransactionExecuted_Call {
	return &Environment_EVMTransactionExecuted_Call{Call: _e.mock.On("EVMTransactionExecuted", gasUsed, isDirectCall, failed)}
}

func (_c *Environment_EVMTransactionExecuted_Call) Run(run func(gasUsed uint64, isDirectCall bool, failed bool)) *Environment_EVMTransactionExecuted_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		var arg1 bool
		if args[1] != nil {
			arg1 = args[1].(bool)
		}
		var arg2 bool
		if args[2] != nil {
			arg2 = args[2].(bool)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Environment_EVMTransactionExecuted_Call) Return() *Environment_EVMTransactionExecuted_Call {
	_c.Call.Return()
	return _c
}

func (_c *Environment_EVMTransactionExecuted_Call) RunAndReturn(run func(gasUsed uint64, isDirectCall bool, failed bool)) *Environment_EVMTransactionExecuted_Call {
	_c.Run(run)
	return _c
}

// EmitEvent provides a mock function for the type Environment
func (_mock *Environment) EmitEvent(event cadence.Event) error {
	ret := _mock.Called(event)

	if len(ret) == 0 {
		panic("no return value specified for EmitEvent")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(cadence.Event) error); ok {
		r0 = returnFunc(event)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Environment_EmitEvent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EmitEvent'
type Environment_EmitEvent_Call struct {
	*mock.Call
}

// EmitEvent is a helper method to define mock.On call
//   - event cadence.Event
func (_e *Environment_Expecter) EmitEvent(event interface{}) *Environment_EmitEvent_Call {
	return &Environment_EmitEvent_Call{Call: _e.mock.On("EmitEvent", event)}
}

func (_c *Environment_EmitEvent_Call) Run(run func(event cadence.Event)) *Environment_EmitEvent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 cadence.Event
		if args[0] != nil {
			arg0 = args[0].(cadence.Event)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Environment_EmitEvent_Call) Return(err error) *Environment_EmitEvent_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Environment_EmitEvent_Call) RunAndReturn(run func(event cadence.Event) error) *Environment_EmitEvent_Call {
	_c.Call.Return(run)
	return _c
}

// Events provides a mock function for the type Environment
func (_mock *Environment) Events() flow.EventsList {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Events")
	}

	var r0 flow.EventsList
	if returnFunc, ok := ret.Get(0).(func() flow.EventsList); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.EventsList)
		}
	}
	return r0
}

// Environment_Events_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Events'
type Environment_Events_Call struct {
	*mock.Call
}

// Events is a helper method to define mock.On call
func (_e *Environment_Expecter) Events() *Environment_Events_Call {
	return &Environment_Events_Call{Call: _e.mock.On("Events")}
}

func (_c *Environment_Events_Call) Run(run func()) *Environment_Events_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Environment_Events_Call) Return(eventsList flow.EventsList) *Environment_Events_Call {
	_c.Call.Return(eventsList)
	return _c
}

func (_c *Environment_Events_Call) RunAndReturn(run func() flow.EventsList) *Environment_Events_Call {
	_c.Call.Return(run)
	return _c
}

// FlushPendingUpdates provides a mock function for the type Environment
func (_mock *Environment) FlushPendingUpdates() (environment.ContractUpdates, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for FlushPendingUpdates")
	}

	var r0 environment.ContractUpdates
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (environment.ContractUpdates, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() environment.ContractUpdates); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(environment.ContractUpdates)
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Environment_FlushPendingUpdates_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FlushPendingUpdates'
type Environment_FlushPendingUpdates_Call struct {
	*mock.Call
}

// FlushPendingUpdates is a helper method to define mock.On call
func (_e *Environment_Expecter) FlushPendingUpdates() *Environment_FlushPendingUpdates_Call {
	return &Environment_FlushPendingUpdates_Call{Call: _e.mock.On("FlushPendingUpdates")}
}

func (_c *Environment_FlushPendingUpdates_Call) Run(run func()) *Environment_FlushPendingUpdates_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Environment_FlushPendingUpdates_Call) Return(contractUpdates environment.ContractUpdates, err error) *Environment_FlushPendingUpdates_Call {
	_c.Call.Return(contractUpdates, err)
	return _c
}

func (_c *Environment_FlushPendingUpdates_Call) RunAndReturn(run func() (environment.ContractUpdates, error)) *Environment_FlushPendingUpdates_Call {
	_c.Call.Return(run)
	return _c
}

// GenerateAccountID provides a mock function for the type Environment
func (_mock *Environment) GenerateAccountID(address common.Address) (uint64, error) {
	ret := _mock.Called(address)

	if len(ret) == 0 {
		panic("no return value specified for GenerateAccountID")
	}

	var r0 uint64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(common.Address) (uint64, error)); ok {
		return returnFunc(address)
	}
	if returnFunc, ok := ret.Get(0).(func(common.Address) uint64); ok {
		r0 = returnFunc(address)
	} else {
		r0 = ret.Get(0).(uint64)
	}
	if returnFunc, ok := ret.Get(1).(func(common.Address) error); ok {
		r1 = returnFunc(address)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Environment_GenerateAccountID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GenerateAccountID'
type Environment_GenerateAccountID_Call struct {
	*mock.Call
}

// GenerateAccountID is a helper method to define mock.On call
//   - address common.Address
func (_e *Environment_Expecter) GenerateAccountID(address interface{}) *Environment_GenerateAccountID_Call {
	return &Environment_GenerateAccountID_Call{Call: _e.mock.On("GenerateAccountID", address)}
}

func (_c *Environment_GenerateAccountID_Call) Run(run func(address common.Address)) *Environment_GenerateAccountID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 common.Address
		if args[0] != nil {
			arg0 = args[0].(common.Address)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Environment_GenerateAccountID_Call) Return(v uint64, err error) *Environment_GenerateAccountID_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *Environment_GenerateAccountID_Call) RunAndReturn(run func(address common.Address) (uint64, error)) *Environment_GenerateAccountID_Call {
	_c.Call.Return(run)
	return _c
}

// GenerateUUID provides a mock function for the type Environment
func (_mock *Environment) GenerateUUID() (uint64, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GenerateUUID")
	}

	var r0 uint64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (uint64, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() uint64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint64)
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Environment_GenerateUUID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GenerateUUID'
type Environment_GenerateUUID_Call struct {
	*mock.Call
}

// GenerateUUID is a helper method to define mock.On call
func (_e *Environment_Expecter) GenerateUUID() *Environment_GenerateUUID_Call {
	return &Environment_GenerateUUID_Call{Call: _e.mock.On("GenerateUUID")}
}

func (_c *Environment_GenerateUUID_Call) Run(run func()) *Environment_GenerateUUID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Environment_GenerateUUID_Call) Return(v uint64, err error) *Environment_GenerateUUID_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *Environment_GenerateUUID_Call) RunAndReturn(run func() (uint64, error)) *Environment_GenerateUUID_Call {
	_c.Call.Return(run)
	return _c
}

// GetAccount provides a mock function for the type Environment
func (_mock *Environment) GetAccount(address flow.Address) (*flow.Account, error) {
	ret := _mock.Called(address)

	if len(ret) == 0 {
		panic("no return value specified for GetAccount")
	}

	var r0 *flow.Account
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Address) (*flow.Account, error)); ok {
		return returnFunc(address)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Address) *flow.Account); ok {
		r0 = returnFunc(address)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.Account)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Address) error); ok {
		r1 = returnFunc(address)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Environment_GetAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAccount'
type Environment_GetAccount_Call struct {
	*mock.Call
}

// GetAccount is a helper method to define mock.On call
//   - address flow.Address
func (_e *Environment_Expecter) GetAccount(address interface{}) *Environment_GetAccount_Call {
	return &Environment_GetAccount_Call{Call: _e.mock.On("GetAccount", address)}
}

func (_c *Environment_GetAccount_Call) Run(run func(address flow.Address)) *Environment_GetAccount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Address
		if args[0] != nil {
			arg0 = args[0].(flow.Address)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Environment_GetAccount_Call) Return(account *flow.Account, err error) *Environment_GetAccount_Call {
	_c.Call.Return(account, err)
	return _c
}

func (_c *Environment_GetAccount_Call) RunAndReturn(run func(address flow.Address) (*flow.Account, error)) *Environment_GetAccount_Call {
	_c.Call.Return(run)
	return _c
}

// GetAccountAvailableBalance provides a mock function for the type Environment
func (_mock *Environment) GetAccountAvailableBalance(address common.Address) (uint64, error) {
	ret := _mock.Called(address)

	if len(ret) == 0 {
		panic("no return value specified for GetAccountAvailableBalance")
	}

	var r0 uint64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(common.Address) (uint64, error)); ok {
		return returnFunc(address)
	}
	if returnFunc, ok := ret.Get(0).(func(common.Address) uint64); ok {
		r0 = returnFunc(address)
	} else {
		r0 = ret.Get(0).(uint64)
	}
	if returnFunc, ok := ret.Get(1).(func(common.Address) error); ok {
		r1 = returnFunc(address)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Environment_GetAccountAvailableBalance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAccountAvailableBalance'
type Environment_GetAccountAvailableBalance_Call struct {
	*mock.Call
}

// GetAccountAvailableBalance is a helper method to define mock.On call
//   - address common.Address
func (_e *Environment_Expecter) GetAccountAvailableBalance(address interface{}) *Environment_GetAccountAvailableBalance_Call {
	return &Environment_GetAccountAvailableBalance_Call{Call: _e.mock.On("GetAccountAvailableBalance", address)}
}

func (_c *Environment_GetAccountAvailableBalance_Call) Run(run func(address common.Address)) *Environment_GetAccountAvailableBalance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 common.Address
		if args[0] != nil {
			arg0 = args[0].(common.Address)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Environment_GetAccountAvailableBalance_Call) Return(value uint64, err error) *Environment_GetAccountAvailableBalance_Call {
	_c.Call.Return(value, err)
	return _c
}

func (_c *Environment_GetAccountAvailableBalance_Call) RunAndReturn(run func(address common.Address) (uint64, error)) *Environment_GetAccountAvailableBalance_Call {
	_c.Call.Return(run)
	return _c
}

// GetAccountBalance provides a mock function for the type Environment
func (_mock *Environment) GetAccountBalance(address common.Address) (uint64, error) {
	ret := _mock.Called(address)

	if len(ret) == 0 {
		panic("no return value specified for GetAccountBalance")
	}

	var r0 uint64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(common.Address) (uint64, error)); ok {
		return returnFunc(address)
	}
	if returnFunc, ok := ret.Get(0).(func(common.Address) uint64); ok {
		r0 = returnFunc(address)
	} else {
		r0 = ret.Get(0).(uint64)
	}
	if returnFunc, ok := ret.Get(1).(func(common.Address) error); ok {
		r1 = returnFunc(address)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Environment_GetAccountBalance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAccountBalance'
type Environment_GetAccountBalance_Call struct {
	*mock.Call
}

// GetAccountBalance is a helper method to define mock.On call
//   - address common.Address
func (_e *Environment_Expecter) GetAccountBalance(address interface{}) *Environment_GetAccountBalance_Call {
	return &Environment_GetAccountBalance_Call{Call: _e.mock.On("GetAccountBalance", address)}
}

func (_c *Environment_GetAccountBalance_Call) Run(run func(address common.Address)) *Environment_GetAccountBalance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 common.Address
		if args[0] != nil {
			arg0 = args[0].(common.Address)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Environment_GetAccountBalance_Call) Return(value uint64, err error) *Environment_GetAccountBalance_Call {
	_c.Call.Return(value, err)
	return _c
}

func (_c *Environment_GetAccountBalance_Call) RunAndReturn(run func(address common.Address) (uint64, error)) *Environment_GetAccountBalance_Call {
	_c.Call.Return(run)
	return _c
}

// GetAccountContractCode provides a mock function for the type Environment
func (_mock *Environment) GetAccountContractCode(location common.AddressLocation) ([]byte, error) {
	ret := _mock.Called(location)

	if len(ret) == 0 {
		panic("no return value specified for GetAccountContractCode")
	}

	var r0 []byte
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(common.AddressLocation) ([]byte, error)); ok {
		return returnFunc(location)
	}
	if returnFunc, ok := ret.Get(0).(func(common.AddressLocation) []byte); ok {
		r0 = returnFunc(location)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(common.AddressLocation) error); ok {
		r1 = returnFunc(location)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Environment_GetAccountContractCode_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAccountContractCode'
type Environment_GetAccountContractCode_Call struct {
	*mock.Call
}

// GetAccountContractCode is a helper method to define mock.On call
//   - location common.AddressLocation
func (_e *Environment_Expecter) GetAccountContractCode(location interface{}) *Environment_GetAccountContractCode_Call {
	return &Environment_GetAccountContractCode_Call{Call: _e.mock.On("GetAccountContractCode", location)}
}

func (_c *Environment_GetAccountContractCode_Call) Run(run func(location common.AddressLocation)) *Environment_GetAccountContractCode_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 common.AddressLocation
		if args[0] != nil {
			arg0 = args[0].(common.AddressLocation)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Environment_GetAccountContractCode_Call) Return(code []byte, err error) *Environment_GetAccountContractCode_Call {
	_c.Call.Return(code, err)
	return _c
}

func (_c *Environment_GetAccountContractCode_Call) RunAndReturn(run func(location common.AddressLocation) ([]byte, error)) *Environment_GetAccountContractCode_Call {
	_c.Call.Return(run)
	return _c
}

// GetAccountContractNames provides a mock function for the type Environment
func (_mock *Environment) GetAccountContractNames(address runtime.Address) ([]string, error) {
	ret := _mock.Called(address)

	if len(ret) == 0 {
		panic("no return value specified for GetAccountContractNames")
	}

	var r0 []string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(runtime.Address) ([]string, error)); ok {
		return returnFunc(address)
	}
	if returnFunc, ok := ret.Get(0).(func(runtime.Address) []string); ok {
		r0 = returnFunc(address)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(runtime.Address) error); ok {
		r1 = returnFunc(address)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Environment_GetAccountContractNames_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAccountContractNames'
type Environment_GetAccountContractNames_Call struct {
	*mock.Call
}

// GetAccountContractNames is a helper method to define mock.On call
//   - address runtime.Address
func (_e *Environment_Expecter) GetAccountContractNames(address interface{}) *Environment_GetAccountContractNames_Call {
	return &Environment_GetAccountContractNames_Call{Call: _e.mock.On("GetAccountContractNames", address)}
}

func (_c *Environment_GetAccountContractNames_Call) Run(run func(address runtime.Address)) *Environment_GetAccountContractNames_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 runtime.Address
		if args[0] != nil {
			arg0 = args[0].(runtime.Address)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Environment_GetAccountContractNames_Call) Return(strings []string, err error) *Environment_GetAccountContractNames_Call {
	_c.Call.Return(strings, err)
	return _c
}

func (_c *Environment_GetAccountContractNames_Call) RunAndReturn(run func(address runtime.Address) ([]string, error)) *Environment_GetAccountContractNames_Call {
	_c.Call.Return(run)
	return _c
}

// GetAccountKey provides a mock function for the type Environment
func (_mock *Environment) GetAccountKey(address runtime.Address, index uint32) (*runtime.AccountKey, error) {
	ret := _mock.Called(address, index)

	if len(ret) == 0 {
		panic("no return value specified for GetAccountKey")
	}

	var r0 *runtime.AccountKey
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(runtime.Address, uint32) (*runtime.AccountKey, error)); ok {
		return returnFunc(address, index)
	}
	if returnFunc, ok := ret.Get(0).(func(runtime.Address, uint32) *runtime.AccountKey); ok {
		r0 = returnFunc(address, index)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*runtime.AccountKey)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(runtime.Address, uint32) error); ok {
		r1 = returnFunc(address, index)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Environment_GetAccountKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAccountKey'
type Environment_GetAccountKey_Call struct {
	*mock.Call
}

// GetAccountKey is a helper method to define mock.On call
//   - address runtime.Address
//   - index uint32
func (_e *Environment_Expecter) GetAccountKey(address interface{}, index interface{}) *Environment_GetAccountKey_Call {
	return &Environment_GetAccountKey_Call{Call: _e.mock.On("GetAccountKey", address, index)}
}

func (_c *Environment_GetAccountKey_Call) Run(run func(address runtime.Address, index uint32)) *Environment_GetAccountKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 runtime.Address
		if args[0] != nil {
			arg0 = args[0].(runtime.Address)
		}
		var arg1 uint32
		if args[1] != nil {
			arg1 = args[1].(uint32)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Environment_GetAccountKey_Call) Return(v *runtime.AccountKey, err error) *Environment_GetAccountKey_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *Environment_GetAccountKey_Call) RunAndReturn(run func(address runtime.Address, index uint32) (*runtime.AccountKey, error)) *Environment_GetAccountKey_Call {
	_c.Call.Return(run)
	return _c
}

// GetAccountKeys provides a mock function for the type Environment
func (_mock *Environment) GetAccountKeys(address flow.Address) ([]flow.AccountPublicKey, error) {
	ret := _mock.Called(address)

	if len(ret) == 0 {
		panic("no return value specified for GetAccountKeys")
	}

	var r0 []flow.AccountPublicKey
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Address) ([]flow.AccountPublicKey, error)); ok {
		return returnFunc(address)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Address) []flow.AccountPublicKey); ok {
		r0 = returnFunc(address)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]flow.AccountPublicKey)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Address) error); ok {
		r1 = returnFunc(address)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Environment_GetAccountKeys_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAccountKeys'
type Environment_GetAccountKeys_Call struct {
	*mock.Call
}

// GetAccountKeys is a helper method to define mock.On call
//   - address flow.Address
func (_e *Environment_Expecter) GetAccountKeys(address interface{}) *Environment_GetAccountKeys_Call {
	return &Environment_GetAccountKeys_Call{Call: _e.mock.On("GetAccountKeys", address)}
}

func (_c *Environment_GetAccountKeys_Call) Run(run func(address flow.Address)) *Environment_GetAccountKeys_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Address
		if args[0] != nil {
			arg0 = args[0].(flow.Address)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Environment_GetAccountKeys_Call) Return(accountPublicKeys []flow.AccountPublicKey, err error) *Environment_GetAccountKeys_Call {
	_c.Call.Return(accountPublicKeys, err)
	return _c
}

func (_c *Environment_GetAccountKeys_Call) RunAndReturn(run func(address flow.Address) ([]flow.AccountPublicKey, error)) *Environment_GetAccountKeys_Call {
	_c.Call.Return(run)
	return _c
}

// GetBlockAtHeight provides a mock function for the type Environment
func (_mock *Environment) GetBlockAtHeight(height uint64) (runtime.Block, bool, error) {
	ret := _mock.Called(height)

	if len(ret) == 0 {
		panic("no return value specified for GetBlockAtHeight")
	}

	var r0 runtime.Block
	var r1 bool
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(uint64) (runtime.Block, bool, error)); ok {
		return returnFunc(height)
	}
	if returnFunc, ok := ret.Get(0).(func(uint64) runtime.Block); ok {
		r0 = returnFunc(height)
	} else {
		r0 = ret.Get(0).(runtime.Block)
	}
	if returnFunc, ok := ret.Get(1).(func(uint64) bool); ok {
		r1 = returnFunc(height)
	} else {
		r1 = ret.Get(1).(bool)
	}
	if returnFunc, ok := ret.Get(2).(func(uint64) error); ok {
		r2 = returnFunc(height)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// Environment_GetBlockAtHeight_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBlockAtHeight'
type Environment_GetBlockAtHeight_Call struct {
	*mock.Call
}

// GetBlockAtHeight is a helper method to define mock.On call
//   - height uint64
func (_e *Environment_Expecter) GetBlockAtHeight(height interface{}) *Environment_GetBlockAtHeight_Call {
	return &Environment_GetBlockAtHeight_Call{Call: _e.mock.On("GetBlockAtHeight", height)}
}

func (_c *Environment_GetBlockAtHeight_Call) Run(run func(height uint64)) *Environment_GetBlockAtHeight_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Environment_GetBlockAtHeight_Call) Return(block runtime.Block, exists bool, err error) *Environment_GetBlockAtHeight_Call {
	_c.Call.Return(block, exists, err)
	return _c
}

func (_c *Environment_GetBlockAtHeight_Call) RunAndReturn(run func(height uint64) (runtime.Block, bool, error)) *Environment_GetBlockAtHeight_Call {
	_c.Call.Return(run)
	return _c
}

// GetCode provides a mock function for the type Environment
func (_mock *Environment) GetCode(location runtime.Location) ([]byte, error) {
	ret := _mock.Called(location)

	if len(ret) == 0 {
		panic("no return value specified for GetCode")
	}

	var r0 []byte
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(runtime.Location) ([]byte, error)); ok {
		return returnFunc(location)
	}
	if returnFunc, ok := ret.Get(0).(func(runtime.Location) []byte); ok {
		r0 = returnFunc(location)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(runtime.Location) error); ok {
		r1 = returnFunc(location)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Environment_GetCode_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCode'
type Environment_GetCode_Call struct {
	*mock.Call
}

// GetCode is a helper method to define mock.On call
//   - location runtime.Location
func (_e *Environment_Expecter) GetCode(location interface{}) *Environment_GetCode_Call {
	return &Environment_GetCode_Call{Call: _e.mock.On("GetCode", location)}
}

func (_c *Environment_GetCode_Call) Run(run func(location runtime.Location)) *Environment_GetCode_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 runtime.Location
		if args[0] != nil {
			arg0 = args[0].(runtime.Location)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Environment_GetCode_Call) Return(bytes []byte, err error) *Environment_GetCode_Call {
	_c.Call.Return(bytes, err)
	return _c
}

func (_c *Environment_GetCode_Call) RunAndReturn(run func(location runtime.Location) ([]byte, error)) *Environment_GetCode_Call {
	_c.Call.Return(run)
	return _c
}

// GetCurrentBlockHeight provides a mock function for the type Environment
func (_mock *Environment) GetCurrentBlockHeight() (uint64, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetCurrentBlockHeight")
	}

	var r0 uint64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (uint64, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() uint64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint64)
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Environment_GetCurrentBlockHeight_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCurrentBlockHeight'
type Environment_GetCurrentBlockHeight_Call struct {
	*mock.Call
}

// GetCurrentBlockHeight is a helper method to define mock.On call
func (_e *Environment_Expecter) GetCurrentBlockHeight() *Environment_GetCurrentBlockHeight_Call {
	return &Environment_GetCurrentBlockHeight_Call{Call: _e.mock.On("GetCurrentBlockHeight")}
}

func (_c *Environment_GetCurrentBlockHeight_Call) Run(run func()) *Environment_GetCurrentBlockHeight_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Environment_GetCurrentBlockHeight_Call) Return(v uint64, err error) *Environment_GetCurrentBlockHeight_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *Environment_GetCurrentBlockHeight_Call) RunAndReturn(run func() (uint64, error)) *Environment_GetCurrentBlockHeight_Call {
	_c.Call.Return(run)
	return _c
}

// GetOrLoadProgram provides a mock function for the type Environment
func (_mock *Environment) GetOrLoadProgram(location runtime.Location, load func() (*runtime.Program, error)) (*runtime.Program, error) {
	ret := _mock.Called(location, load)

	if len(ret) == 0 {
		panic("no return value specified for GetOrLoadProgram")
	}

	var r0 *runtime.Program
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(runtime.Location, func() (*runtime.Program, error)) (*runtime.Program, error)); ok {
		return returnFunc(location, load)
	}
	if returnFunc, ok := ret.Get(0).(func(runtime.Location, func() (*runtime.Program, error)) *runtime.Program); ok {
		r0 = returnFunc(location, load)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*runtime.Program)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(runtime.Location, func() (*runtime.Program, error)) error); ok {
		r1 = returnFunc(location, load)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Environment_GetOrLoadProgram_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetOrLoadProgram'
type Environment_GetOrLoadProgram_Call struct {
	*mock.Call
}

// GetOrLoadProgram is a helper method to define mock.On call
//   - location runtime.Location
//   - load func() (*runtime.Program, error)
func (_e *Environment_Expecter) GetOrLoadProgram(location interface{}, load interface{}) *Environment_GetOrLoadProgram_Call {
	return &Environment_GetOrLoadProgram_Call{Call: _e.mock.On("GetOrLoadProgram", location, load)}
}

func (_c *Environment_GetOrLoadProgram_Call) Run(run func(location runtime.Location, load func() (*runtime.Program, error))) *Environment_GetOrLoadProgram_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 runtime.Location
		if args[0] != nil {
			arg0 = args[0].(runtime.Location)
		}
		var arg1 func() (*runtime.Program, error)
		if args[1] != nil {
			arg1 = args[1].(func() (*runtime.Program, error))
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Environment_GetOrLoadProgram_Call) Return(program *runtime.Program, err error) *Environment_GetOrLoadProgram_Call {
	_c.Call.Return(program, err)
	return _c
}

func (_c *Environment_GetOrLoadProgram_Call) RunAndReturn(run func(location runtime.Location, load func() (*runtime.Program, error)) (*runtime.Program, error)) *Environment_GetOrLoadProgram_Call {
	_c.Call.Return(run)
	return _c
}

// GetSigningAccounts provides a mock function for the type Environment
func (_mock *Environment) GetSigningAccounts() ([]runtime.Address, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetSigningAccounts")
	}

	var r0 []runtime.Address
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() ([]runtime.Address, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() []runtime.Address); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]runtime.Address)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Environment_GetSigningAccounts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSigningAccounts'
type Environment_GetSigningAccounts_Call struct {
	*mock.Call
}

// GetSigningAccounts is a helper method to define mock.On call
func (_e *Environment_Expecter) GetSigningAccounts() *Environment_GetSigningAccounts_Call {
	return &Environment_GetSigningAccounts_Call{Call: _e.mock.On("GetSigningAccounts")}
}

func (_c *Environment_GetSigningAccounts_Call) Run(run func()) *Environment_GetSigningAccounts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Environment_GetSigningAccounts_Call) Return(vs []runtime.Address, err error) *Environment_GetSigningAccounts_Call {
	_c.Call.Return(vs, err)
	return _c
}

func (_c *Environment_GetSigningAccounts_Call) RunAndReturn(run func() ([]runtime.Address, error)) *Environment_GetSigningAccounts_Call {
	_c.Call.Return(run)
	return _c
}

// GetStorageCapacity provides a mock function for the type Environment
func (_mock *Environment) GetStorageCapacity(address runtime.Address) (uint64, error) {
	ret := _mock.Called(address)

	if len(ret) == 0 {
		panic("no return value specified for GetStorageCapacity")
	}

	var r0 uint64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(runtime.Address) (uint64, error)); ok {
		return returnFunc(address)
	}
	if returnFunc, ok := ret.Get(0).(func(runtime.Address) uint64); ok {
		r0 = returnFunc(address)
	} else {
		r0 = ret.Get(0).(uint64)
	}
	if returnFunc, ok := ret.Get(1).(func(runtime.Address) error); ok {
		r1 = returnFunc(address)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Environment_GetStorageCapacity_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetStorageCapacity'
type Environment_GetStorageCapacity_Call struct {
	*mock.Call
}

// GetStorageCapacity is a helper method to define mock.On call
//   - address runtime.Address
func (_e *Environment_Expecter) GetStorageCapacity(address interface{}) *Environment_GetStorageCapacity_Call {
	return &Environment_GetStorageCapacity_Call{Call: _e.mock.On("GetStorageCapacity", address)}
}

func (_c *Environment_GetStorageCapacity_Call) Run(run func(address runtime.Address)) *Environment_GetStorageCapacity_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 runtime.Address
		if args[0] != nil {
			arg0 = args[0].(runtime.Address)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Environment_GetStorageCapacity_Call) Return(value uint64, err error) *Environment_GetStorageCapacity_Call {
	_c.Call.Return(value, err)
	return _c
}

func (_c *Environment_GetStorageCapacity_Call) RunAndReturn(run func(address runtime.Address) (uint64, error)) *Environment_GetStorageCapacity_Call {
	_c.Call.Return(run)
	return _c
}

// GetStorageUsed provides a mock function for the type Environment
func (_mock *Environment) GetStorageUsed(address runtime.Address) (uint64, error) {
	ret := _mock.Called(address)

	if len(ret) == 0 {
		panic("no return value specified for GetStorageUsed")
	}

	var r0 uint64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(runtime.Address) (uint64, error)); ok {
		return returnFunc(address)
	}
	if returnFunc, ok := ret.Get(0).(func(runtime.Address) uint64); ok {
		r0 = returnFunc(address)
	} else {
		r0 = ret.Get(0).(uint64)
	}
	if returnFunc, ok := ret.Get(1).(func(runtime.Address) error); ok {
		r1 = returnFunc(address)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Environment_GetStorageUsed_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetStorageUsed'
type Environment_GetStorageUsed_Call struct {
	*mock.Call
}

// GetStorageUsed is a helper method to define mock.On call
//   - address runtime.Address
func (_e *Environment_Expecter) GetStorageUsed(address interface{}) *Environment_GetStorageUsed_Call {
	return &Environment_GetStorageUsed_Call{Call: _e.mock.On("GetStorageUsed", address)}
}

func (_c *Environment_GetStorageUsed_Call) Run(run func(address runtime.Address)) *Environment_GetStorageUsed_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 runtime.Address
		if args[0] != nil {
			arg0 = args[0].(runtime.Address)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Environment_GetStorageUsed_Call) Return(value uint64, err error) *Environment_GetStorageUsed_Call {
	_c.Call.Return(value, err)
	return _c
}

func (_c *Environment_GetStorageUsed_Call) RunAndReturn(run func(address runtime.Address) (uint64, error)) *Environment_GetStorageUsed_Call {
	_c.Call.Return(run)
	return _c
}

// GetValue provides a mock function for the type Environment
func (_mock *Environment) GetValue(owner []byte, key []byte) ([]byte, error) {
	ret := _mock.Called(owner, key)

	if len(ret) == 0 {
		panic("no return value specified for GetValue")
	}

	var r0 []byte
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]byte, []byte) ([]byte, error)); ok {
		return returnFunc(owner, key)
	}
	if returnFunc, ok := ret.Get(0).(func([]byte, []byte) []byte); ok {
		r0 = returnFunc(owner, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}
	if returnFunc, ok := ret.Get(1).(func([]byte, []byte) error); ok {
		r1 = returnFunc(owner, key)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Environment_GetValue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetValue'
type Environment_GetValue_Call struct {
	*mock.Call
}

// GetValue is a helper method to define mock.On call
//   - owner []byte
//   - key []byte
func (_e *Environment_Expecter) GetValue(owner interface{}, key interface{}) *Environment_GetValue_Call {
	return &Environment_GetValue_Call{Call: _e.mock.On("GetValue", owner, key)}
}

func (_c *Environment_GetValue_Call) Run(run func(owner []byte, key []byte)) *Environment_GetValue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []byte
		if args[0] != nil {
			arg0 = args[0].([]byte)
		}
		var arg1 []byte
		if args[1] != nil {
			arg1 = args[1].([]byte)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Environment_GetValue_Call) Return(value []byte, err error) *Environment_GetValue_Call {
	_c.Call.Return(value, err)
	return _c
}

func (_c *Environment_GetValue_Call) RunAndReturn(run func(owner []byte, key []byte) ([]byte, error)) *Environment_GetValue_Call {
	_c.Call.Return(run)
	return _c
}

// Hash provides a mock function for the type Environment
func (_mock *Environment) Hash(data []byte, tag string, hashAlgorithm runtime.HashAlgorithm) ([]byte, error) {
	ret := _mock.Called(data, tag, hashAlgorithm)

	if len(ret) == 0 {
		panic("no return value specified for Hash")
	}

	var r0 []byte
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]byte, string, runtime.HashAlgorithm) ([]byte, error)); ok {
		return returnFunc(data, tag, hashAlgorithm)
	}
	if returnFunc, ok := ret.Get(0).(func([]byte, string, runtime.HashAlgorithm) []byte); ok {
		r0 = returnFunc(data, tag, hashAlgorithm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}
	if returnFunc, ok := ret.Get(1).(func([]byte, string, runtime.HashAlgorithm) error); ok {
		r1 = returnFunc(data, tag, hashAlgorithm)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Environment_Hash_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Hash'
type Environment_Hash_Call struct {
	*mock.Call
}

// Hash is a helper method to define mock.On call
//   - data []byte
//   - tag string
//   - hashAlgorithm runtime.HashAlgorithm
func (_e *Environment_Expecter) Hash(data interface{}, tag interface{}, hashAlgorithm interface{}) *Environment_Hash_Call {
	return &Environment_Hash_Call{Call: _e.mock.On("Hash", data, tag, hashAlgorithm)}
}

func (_c *Environment_Hash_Call) Run(run func(data []byte, tag string, hashAlgorithm runtime.HashAlgorithm)) *Environment_Hash_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []byte
		if args[0] != nil {
			arg0 = args[0].([]byte)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 runtime.HashAlgorithm
		if args[2] != nil {
			arg2 = args[2].(runtime.HashAlgorithm)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Environment_Hash_Call) Return(bytes []byte, err error) *Environment_Hash_Call {
	_c.Call.Return(bytes, err)
	return _c
}

func (_c *Environment_Hash_Call) RunAndReturn(run func(data []byte, tag string, hashAlgorithm runtime.HashAlgorithm) ([]byte, error)) *Environment_Hash_Call {
	_c.Call.Return(run)
	return _c
}

// ImplementationDebugLog provides a mock function for the type Environment
func (_mock *Environment) ImplementationDebugLog(message string) error {
	ret := _mock.Called(message)

	if len(ret) == 0 {
		panic("no return value specified for ImplementationDebugLog")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string) error); ok {
		r0 = returnFunc(message)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Environment_ImplementationDebugLog_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ImplementationDebugLog'
type Environment_ImplementationDebugLog_Call struct {
	*mock.Call
}

// ImplementationDebugLog is a helper method to define mock.On call
//   - message string
func (_e *Environment_Expecter) ImplementationDebugLog(message interface{}) *Environment_ImplementationDebugLog_Call {
	return &Environment_ImplementationDebugLog_Call{Call: _e.mock.On("ImplementationDebugLog", message)}
}

func (_c *Environment_ImplementationDebugLog_Call) Run(run func(message string)) *Environment_ImplementationDebugLog_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Environment_ImplementationDebugLog_Call) Return(err error) *Environment_ImplementationDebugLog_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Environment_ImplementationDebugLog_Call) RunAndReturn(run func(message string) error) *Environment_ImplementationDebugLog_Call {
	_c.Call.Return(run)
	return _c
}

// Invoke provides a mock function for the type Environment
func (_mock *Environment) Invoke(spec environment.ContractFunctionSpec, arguments []cadence.Value) (cadence.Value, error) {
	ret := _mock.Called(spec, arguments)

	if len(ret) == 0 {
		panic("no return value specified for Invoke")
	}

	var r0 cadence.Value
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(environment.ContractFunctionSpec, []cadence.Value) (cadence.Value, error)); ok {
		return returnFunc(spec, arguments)
	}
	if returnFunc, ok := ret.Get(0).(func(environment.ContractFunctionSpec, []cadence.Value) cadence.Value); ok {
		r0 = returnFunc(spec, arguments)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(cadence.Value)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(environment.ContractFunctionSpec, []cadence.Value) error); ok {
		r1 = returnFunc(spec, arguments)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Environment_Invoke_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Invoke'
type Environment_Invoke_Call struct {
	*mock.Call
}

// Invoke is a helper method to define mock.On call
//   - spec environment.ContractFunctionSpec
//   - arguments []cadence.Value
func (_e *Environment_Expecter) Invoke(spec interface{}, arguments interface{}) *Environment_Invoke_Call {
	return &Environment_Invoke_Call{Call: _e.mock.On("Invoke", spec, arguments)}
}

func (_c *Environment_Invoke_Call) Run(run func(spec environment.ContractFunctionSpec, arguments []cadence.Value)) *Environment_Invoke_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 environment.ContractFunctionSpec
		if args[0] != nil {
			arg0 = args[0].(environment.ContractFunctionSpec)
		}
		var arg1 []cadence.Value
		if args[1] != nil {
			arg1 = args[1].([]cadence.Value)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Environment_Invoke_Call) Return(value cadence.Value, err error) *Environment_Invoke_Call {
	_c.Call.Return(value, err)
	return _c
}

func (_c *Environment_Invoke_Call) RunAndReturn(run func(spec environment.ContractFunctionSpec, arguments []cadence.Value) (cadence.Value, error)) *Environment_Invoke_Call {
	_c.Call.Return(run)
	return _c
}

// IsServiceAccountAuthorizer provides a mock function for the type Environment
func (_mock *Environment) IsServiceAccountAuthorizer() bool {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for IsServiceAccountAuthorizer")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func() bool); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// Environment_IsServiceAccountAuthorizer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsServiceAccountAuthorizer'
type Environment_IsServiceAccountAuthorizer_Call struct {
	*mock.Call
}

// IsServiceAccountAuthorizer is a helper method to define mock.On call
func (_e *Environment_Expecter) IsServiceAccountAuthorizer() *Environment_IsServiceAccountAuthorizer_Call {
	return &Environment_IsServiceAccountAuthorizer_Call{Call: _e.mock.On("IsServiceAccountAuthorizer")}
}

func (_c *Environment_IsServiceAccountAuthorizer_Call) Run(run func()) *Environment_IsServiceAccountAuthorizer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Environment_IsServiceAccountAuthorizer_Call) Return(b bool) *Environment_IsServiceAccountAuthorizer_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *Environment_IsServiceAccountAuthorizer_Call) RunAndReturn(run func() bool) *Environment_IsServiceAccountAuthorizer_Call {
	_c.Call.Return(run)
	return _c
}

// LimitAccountStorage provides a mock function for the type Environment
func (_mock *Environment) LimitAccountStorage() bool {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for LimitAccountStorage")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func() bool); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// Environment_LimitAccountStorage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LimitAccountStorage'
type Environment_LimitAccountStorage_Call struct {
	*mock.Call
}

// LimitAccountStorage is a helper method to define mock.On call
func (_e *Environment_Expecter) LimitAccountStorage() *Environment_LimitAccountStorage_Call {
	return &Environment_LimitAccountStorage_Call{Call: _e.mock.On("LimitAccountStorage")}
}

func (_c *Environment_LimitAccountStorage_Call) Run(run func()) *Environment_LimitAccountStorage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Environment_LimitAccountStorage_Call) Return(b bool) *Environment_LimitAccountStorage_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *Environment_LimitAccountStorage_Call) RunAndReturn(run func() bool) *Environment_LimitAccountStorage_Call {
	_c.Call.Return(run)
	return _c
}

// Logger provides a mock function for the type Environment
func (_mock *Environment) Logger() zerolog.Logger {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Logger")
	}

	var r0 zerolog.Logger
	if returnFunc, ok := ret.Get(0).(func() zerolog.Logger); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(zerolog.Logger)
	}
	return r0
}

// Environment_Logger_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Logger'
type Environment_Logger_Call struct {
	*mock.Call
}

// Logger is a helper method to define mock.On call
func (_e *Environment_Expecter) Logger() *Environment_Logger_Call {
	return &Environment_Logger_Call{Call: _e.mock.On("Logger")}
}

func (_c *Environment_Logger_Call) Run(run func()) *Environment_Logger_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Environment_Logger_Call) Return(logger zerolog.Logger) *Environment_Logger_Call {
	_c.Call.Return(logger)
	return _c
}

func (_c *Environment_Logger_Call) RunAndReturn(run func() zerolog.Logger) *Environment_Logger_Call {
	_c.Call.Return(run)
	return _c
}

// Logs provides a mock function for the type Environment
func (_mock *Environment) Logs() []string {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Logs")
	}

	var r0 []string
	if returnFunc, ok := ret.Get(0).(func() []string); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}
	return r0
}

// Environment_Logs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Logs'
type Environment_Logs_Call struct {
	*mock.Call
}

// Logs is a helper method to define mock.On call
func (_e *Environment_Expecter) Logs() *Environment_Logs_Call {
	return &Environment_Logs_Call{Call: _e.mock.On("Logs")}
}

func (_c *Environment_Logs_Call) Run(run func()) *Environment_Logs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Environment_Logs_Call) Return(strings []string) *Environment_Logs_Call {
	_c.Call.Return(strings)
	return _c
}

func (_c *Environment_Logs_Call) RunAndReturn(run func() []string) *Environment_Logs_Call {
	_c.Call.Return(run)
	return _c
}

// MemoryUsed provides a mock function for the type Environment
func (_mock *Environment) MemoryUsed() (uint64, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for MemoryUsed")
	}

	var r0 uint64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (uint64, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() uint64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint64)
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Environment_MemoryUsed_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MemoryUsed'
type Environment_MemoryUsed_Call struct {
	*mock.Call
}

// MemoryUsed is a helper method to define mock.On call
func (_e *Environment_Expecter) MemoryUsed() *Environment_MemoryUsed_Call {
	return &Environment_MemoryUsed_Call{Call: _e.mock.On("MemoryUsed")}
}

func (_c *Environment_MemoryUsed_Call) Run(run func()) *Environment_MemoryUsed_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Environment_MemoryUsed_Call) Return(v uint64, err error) *Environment_MemoryUsed_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *Environment_MemoryUsed_Call) RunAndReturn(run func() (uint64, error)) *Environment_MemoryUsed_Call {
	_c.Call.Return(run)
	return _c
}

// MeterComputation provides a mock function for the type Environment
func (_mock *Environment) MeterComputation(usage common.ComputationUsage) error {
	ret := _mock.Called(usage)

	if len(ret) == 0 {
		panic("no return value specified for MeterComputation")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(common.ComputationUsage) error); ok {
		r0 = returnFunc(usage)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Environment_MeterComputation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MeterComputation'
type Environment_MeterComputation_Call struct {
	*mock.Call
}

// MeterComputation is a helper method to define mock.On call
//   - usage common.ComputationUsage
func (_e *Environment_Expecter) MeterComputation(usage interface{}) *Environment_MeterComputation_Call {
	return &Environment_MeterComputation_Call{Call: _e.mock.On("MeterComputation", usage)}
}

func (_c *Environment_MeterComputation_Call) Run(run func(usage common.ComputationUsage)) *Environment_MeterComputation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 common.ComputationUsage
		if args[0] != nil {
			arg0 = args[0].(common.ComputationUsage)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Environment_MeterComputation_Call) Return(err error) *Environment_MeterComputation_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Environment_MeterComputation_Call) RunAndReturn(run func(usage common.ComputationUsage) error) *Environment_MeterComputation_Call {
	_c.Call.Return(run)
	return _c
}

// MeterEmittedEvent provides a mock function for the type Environment
func (_mock *Environment) MeterEmittedEvent(byteSize uint64) error {
	ret := _mock.Called(byteSize)

	if len(ret) == 0 {
		panic("no return value specified for MeterEmittedEvent")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(uint64) error); ok {
		r0 = returnFunc(byteSize)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Environment_MeterEmittedEvent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MeterEmittedEvent'
type Environment_MeterEmittedEvent_Call struct {
	*mock.Call
}

// MeterEmittedEvent is a helper method to define mock.On call
//   - byteSize uint64
func (_e *Environment_Expecter) MeterEmittedEvent(byteSize interface{}) *Environment_MeterEmittedEvent_Call {
	return &Environment_MeterEmittedEvent_Call{Call: _e.mock.On("MeterEmittedEvent", byteSize)}
}

func (_c *Environment_MeterEmittedEvent_Call) Run(run func(byteSize uint64)) *Environment_MeterEmittedEvent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Environment_MeterEmittedEvent_Call) Return(err error) *Environment_MeterEmittedEvent_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Environment_MeterEmittedEvent_Call) RunAndReturn(run func(byteSize uint64) error) *Environment_MeterEmittedEvent_Call {
	_c.Call.Return(run)
	return _c
}

// MeterMemory provides a mock function for the type Environment
func (_mock *Environment) MeterMemory(usage common.MemoryUsage) error {
	ret := _mock.Called(usage)

	if len(ret) == 0 {
		panic("no return value specified for MeterMemory")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(common.MemoryUsage) error); ok {
		r0 = returnFunc(usage)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Environment_MeterMemory_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MeterMemory'
type Environment_MeterMemory_Call struct {
	*mock.Call
}

// MeterMemory is a helper method to define mock.On call
//   - usage common.MemoryUsage
func (_e *Environment_Expecter) MeterMemory(usage interface{}) *Environment_MeterMemory_Call {
	return &Environment_MeterMemory_Call{Call: _e.mock.On("MeterMemory", usage)}
}

func (_c *Environment_MeterMemory_Call) Run(run func(usage common.MemoryUsage)) *Environment_MeterMemory_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 common.MemoryUsage
		if args[0] != nil {
			arg0 = args[0].(common.MemoryUsage)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Environment_MeterMemory_Call) Return(err error) *Environment_MeterMemory_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Environment_MeterMemory_Call) RunAndReturn(run func(usage common.MemoryUsage) error) *Environment_MeterMemory_Call {
	_c.Call.Return(run)
	return _c
}

// MinimumRequiredVersion provides a mock function for the type Environment
func (_mock *Environment) MinimumRequiredVersion() (string, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for MinimumRequiredVersion")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (string, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() string); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Environment_MinimumRequiredVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MinimumRequiredVersion'
type Environment_MinimumRequiredVersion_Call struct {
	*mock.Call
}

// MinimumRequiredVersion is a helper method to define mock.On call
func (_e *Environment_Expecter) MinimumRequiredVersion() *Environment_MinimumRequiredVersion_Call {
	return &Environment_MinimumRequiredVersion_Call{Call: _e.mock.On("MinimumRequiredVersion")}
}

func (_c *Environment_MinimumRequiredVersion_Call) Run(run func()) *Environment_MinimumRequiredVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Environment_MinimumRequiredVersion_Call) Return(s string, err error) *Environment_MinimumRequiredVersion_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *Environment_MinimumRequiredVersion_Call) RunAndReturn(run func() (string, error)) *Environment_MinimumRequiredVersion_Call {
	_c.Call.Return(run)
	return _c
}

// ProgramLog provides a mock function for the type Environment
func (_mock *Environment) ProgramLog(s string) error {
	ret := _mock.Called(s)

	if len(ret) == 0 {
		panic("no return value specified for ProgramLog")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string) error); ok {
		r0 = returnFunc(s)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Environment_ProgramLog_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ProgramLog'
type Environment_ProgramLog_Call struct {
	*mock.Call
}

// ProgramLog is a helper method to define mock.On call
//   - s string
func (_e *Environment_Expecter) ProgramLog(s interface{}) *Environment_ProgramLog_Call {
	return &Environment_ProgramLog_Call{Call: _e.mock.On("ProgramLog", s)}
}

func (_c *Environment_ProgramLog_Call) Run(run func(s string)) *Environment_ProgramLog_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Environment_ProgramLog_Call) Return(err error) *Environment_ProgramLog_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Environment_ProgramLog_Call) RunAndReturn(run func(s string) error) *Environment_ProgramLog_Call {
	_c.Call.Return(run)
	return _c
}

// RandomSourceHistory provides a mock function for the type Environment
func (_mock *Environment) RandomSourceHistory() ([]byte, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for RandomSourceHistory")
	}

	var r0 []byte
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() ([]byte, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() []byte); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Environment_RandomSourceHistory_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RandomSourceHistory'
type Environment_RandomSourceHistory_Call struct {
	*mock.Call
}

// RandomSourceHistory is a helper method to define mock.On call
func (_e *Environment_Expecter) RandomSourceHistory() *Environment_RandomSourceHistory_Call {
	return &Environment_RandomSourceHistory_Call{Call: _e.mock.On("RandomSourceHistory")}
}

func (_c *Environment_RandomSourceHistory_Call) Run(run func()) *Environment_RandomSourceHistory_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Environment_RandomSourceHistory_Call) Return(bytes []byte, err error) *Environment_RandomSourceHistory_Call {
	_c.Call.Return(bytes, err)
	return _c
}

func (_c *Environment_RandomSourceHistory_Call) RunAndReturn(run func() ([]byte, error)) *Environment_RandomSourceHistory_Call {
	_c.Call.Return(run)
	return _c
}

// ReadRandom provides a mock function for the type Environment
func (_mock *Environment) ReadRandom(bytes []byte) error {
	ret := _mock.Called(bytes)

	if len(ret) == 0 {
		panic("no return value specified for ReadRandom")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func([]byte) error); ok {
		r0 = returnFunc(bytes)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Environment_ReadRandom_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadRandom'
type Environment_ReadRandom_Call struct {
	*mock.Call
}

// ReadRandom is a helper method to define mock.On call
//   - bytes []byte
func (_e *Environment_Expecter) ReadRandom(bytes interface{}) *Environment_ReadRandom_Call {
	return &Environment_ReadRandom_Call{Call: _e.mock.On("ReadRandom", bytes)}
}

func (_c *Environment_ReadRandom_Call) Run(run func(bytes []byte)) *Environment_ReadRandom_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []byte
		if args[0] != nil {
			arg0 = args[0].([]byte)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Environment_ReadRandom_Call) Return(err error) *Environment_ReadRandom_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Environment_ReadRandom_Call) RunAndReturn(run func(bytes []byte) error) *Environment_ReadRandom_Call {
	_c.Call.Return(run)
	return _c
}

// RecordTrace provides a mock function for the type Environment
func (_mock *Environment) RecordTrace(operation string, duration time.Duration, attrs []attribute.KeyValue) {
	_mock.Called(operation, duration, attrs)
	return
}

// Environment_RecordTrace_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RecordTrace'
type Environment_RecordTrace_Call struct {
	*mock.Call
}

// RecordTrace is a helper method to define mock.On call
//   - operation string
//   - duration time.Duration
//   - attrs []attribute.KeyValue
func (_e *Environment_Expecter) RecordTrace(operation interface{}, duration interface{}, attrs interface{}) *Environment_RecordTrace_Call {
	return &Environment_RecordTrace_Call{Call: _e.mock.On("RecordTrace", operation, duration, attrs)}
}

func (_c *Environment_RecordTrace_Call) Run(run func(operation string, duration time.Duration, attrs []attribute.KeyValue)) *Environment_RecordTrace_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 time.Duration
		if args[1] != nil {
			arg1 = args[1].(time.Duration)
		}
		var arg2 []attribute.KeyValue
		if args[2] != nil {
			arg2 = args[2].([]attribute.KeyValue)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Environment_RecordTrace_Call) Return() *Environment_RecordTrace_Call {
	_c.Call.Return()
	return _c
}

func (_c *Environment_RecordTrace_Call) RunAndReturn(run func(operation string, duration time.Duration, attrs []attribute.KeyValue)) *Environment_RecordTrace_Call {
	_c.Run(run)
	return _c
}

// RecoverProgram provides a mock function for the type Environment
func (_mock *Environment) RecoverProgram(program *ast.Program, location common.Location) ([]byte, error) {
	ret := _mock.Called(program, location)

	if len(ret) == 0 {
		panic("no return value specified for RecoverProgram")
	}

	var r0 []byte
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*ast.Program, common.Location) ([]byte, error)); ok {
		return returnFunc(program, location)
	}
	if returnFunc, ok := ret.Get(0).(func(*ast.Program, common.Location) []byte); ok {
		r0 = returnFunc(program, location)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*ast.Program, common.Location) error); ok {
		r1 = returnFunc(program, location)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Environment_RecoverProgram_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RecoverProgram'
type Environment_RecoverProgram_Call struct {
	*mock.Call
}

// RecoverProgram is a helper method to define mock.On call
//   - program *ast.Program
//   - location common.Location
func (_e *Environment_Expecter) RecoverProgram(program interface{}, location interface{}) *Environment_RecoverProgram_Call {
	return &Environment_RecoverProgram_Call{Call: _e.mock.On("RecoverProgram", program, location)}
}

func (_c *Environment_RecoverProgram_Call) Run(run func(program *ast.Program, location common.Location)) *Environment_RecoverProgram_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *ast.Program
		if args[0] != nil {
			arg0 = args[0].(*ast.Program)
		}
		var arg1 common.Location
		if args[1] != nil {
			arg1 = args[1].(common.Location)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Environment_RecoverProgram_Call) Return(bytes []byte, err error) *Environment_RecoverProgram_Call {
	_c.Call.Return(bytes, err)
	return _c
}

func (_c *Environment_RecoverProgram_Call) RunAndReturn(run func(program *ast.Program, location common.Location) ([]byte, error)) *Environment_RecoverProgram_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveAccountContractCode provides a mock function for the type Environment
func (_mock *Environment) RemoveAccountContractCode(location common.AddressLocation) error {
	ret := _mock.Called(location)

	if len(ret) == 0 {
		panic("no return value specified for RemoveAccountContractCode")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(common.AddressLocation) error); ok {
		r0 = returnFunc(location)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Environment_RemoveAccountContractCode_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveAccountContractCode'
type Environment_RemoveAccountContractCode_Call struct {
	*mock.Call
}

// RemoveAccountContractCode is a helper method to define mock.On call
//   - location common.AddressLocation
func (_e *Environment_Expecter) RemoveAccountContractCode(location interface{}) *Environment_RemoveAccountContractCode_Call {
	return &Environment_RemoveAccountContractCode_Call{Call: _e.mock.On("RemoveAccountContractCode", location)}
}

func (_c *Environment_RemoveAccountContractCode_Call) Run(run func(location common.AddressLocation)) *Environment_RemoveAccountContractCode_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 common.AddressLocation
		if args[0] != nil {
			arg0 = args[0].(common.AddressLocation)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Environment_RemoveAccountContractCode_Call) Return(err error) *Environment_RemoveAccountContractCode_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Environment_RemoveAccountContractCode_Call) RunAndReturn(run func(location common.AddressLocation) error) *Environment_RemoveAccountContractCode_Call {
	_c.Call.Return(run)
	return _c
}

// Reset provides a mock function for the type Environment
func (_mock *Environment) Reset() {
	_mock.Called()
	return
}

// Environment_Reset_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Reset'
type Environment_Reset_Call struct {
	*mock.Call
}

// Reset is a helper method to define mock.On call
func (_e *Environment_Expecter) Reset() *Environment_Reset_Call {
	return &Environment_Reset_Call{Call: _e.mock.On("Reset")}
}

func (_c *Environment_Reset_Call) Run(run func()) *Environment_Reset_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Environment_Reset_Call) Return() *Environment_Reset_Call {
	_c.Call.Return()
	return _c
}

func (_c *Environment_Reset_Call) RunAndReturn(run func()) *Environment_Reset_Call {
	_c.Run(run)
	return _c
}

// ResolveLocation provides a mock function for the type Environment
func (_mock *Environment) ResolveLocation(identifiers []runtime.Identifier, location runtime.Location) ([]runtime.ResolvedLocation, error) {
	ret := _mock.Called(identifiers, location)

	if len(ret) == 0 {
		panic("no return value specified for ResolveLocation")
	}

	var r0 []runtime.ResolvedLocation
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]runtime.Identifier, runtime.Location) ([]runtime.ResolvedLocation, error)); ok {
		return returnFunc(identifiers, location)
	}
	if returnFunc, ok := ret.Get(0).(func([]runtime.Identifier, runtime.Location) []runtime.ResolvedLocation); ok {
		r0 = returnFunc(identifiers, location)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]runtime.ResolvedLocation)
		}
	}
	if returnFunc, ok := ret.Get(1).(func([]runtime.Identifier, runtime.Location) error); ok {
		r1 = returnFunc(identifiers, location)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Environment_ResolveLocation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ResolveLocation'
type Environment_ResolveLocation_Call struct {
	*mock.Call
}

// ResolveLocation is a helper method to define mock.On call
//   - identifiers []runtime.Identifier
//   - location runtime.Location
func (_e *Environment_Expecter) ResolveLocation(identifiers interface{}, location interface{}) *Environment_ResolveLocation_Call {
	return &Environment_ResolveLocation_Call{Call: _e.mock.On("ResolveLocation", identifiers, location)}
}

func (_c *Environment_ResolveLocation_Call) Run(run func(identifiers []runtime.Identifier, location runtime.Location)) *Environment_ResolveLocation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []runtime.Identifier
		if args[0] != nil {
			arg0 = args[0].([]runtime.Identifier)
		}
		var arg1 runtime.Location
		if args[1] != nil {
			arg1 = args[1].(runtime.Location)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Environment_ResolveLocation_Call) Return(vs []runtime.ResolvedLocation, err error) *Environment_ResolveLocation_Call {
	_c.Call.Return(vs, err)
	return _c
}

func (_c *Environment_ResolveLocation_Call) RunAndReturn(run func(identifiers []runtime.Identifier, location runtime.Location) ([]runtime.ResolvedLocation, error)) *Environment_ResolveLocation_Call {
	_c.Call.Return(run)
	return _c
}

// ResourceOwnerChanged provides a mock function for the type Environment
func (_mock *Environment) ResourceOwnerChanged(interpreter1 *interpreter.Interpreter, resource *interpreter.CompositeValue, oldOwner common.Address, newOwner common.Address) {
	_mock.Called(interpreter1, resource, oldOwner, newOwner)
	return
}

// Environment_ResourceOwnerChanged_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ResourceOwnerChanged'
type Environment_ResourceOwnerChanged_Call struct {
	*mock.Call
}

// ResourceOwnerChanged is a helper method to define mock.On call
//   - interpreter1 *interpreter.Interpreter
//   - resource *interpreter.CompositeValue
//   - oldOwner common.Address
//   - newOwner common.Address
func (_e *Environment_Expecter) ResourceOwnerChanged(interpreter1 interface{}, resource interface{}, oldOwner interface{}, newOwner interface{}) *Environment_ResourceOwnerChanged_Call {
	return &Environment_ResourceOwnerChanged_Call{Call: _e.mock.On("ResourceOwnerChanged", interpreter1, resource, oldOwner, newOwner)}
}

func (_c *Environment_ResourceOwnerChanged_Call) Run(run func(interpreter1 *interpreter.Interpreter, resource *interpreter.CompositeValue, oldOwner common.Address, newOwner common.Address)) *Environment_ResourceOwnerChanged_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *interpreter.Interpreter
		if args[0] != nil {
			arg0 = args[0].(*interpreter.Interpreter)
		}
		var arg1 *interpreter.CompositeValue
		if args[1] != nil {
			arg1 = args[1].(*interpreter.CompositeValue)
		}
		var arg2 common.Address
		if args[2] != nil {
			arg2 = args[2].(common.Address)
		}
		var arg3 common.Address
		if args[3] != nil {
			arg3 = args[3].(common.Address)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *Environment_ResourceOwnerChanged_Call) Return() *Environment_ResourceOwnerChanged_Call {
	_c.Call.Return()
	return _c
}

func (_c *Environment_ResourceOwnerChanged_Call) RunAndReturn(run func(interpreter1 *interpreter.Interpreter, resource *interpreter.CompositeValue, oldOwner common.Address, newOwner common.Address)) *Environment_ResourceOwnerChanged_Call {
	_c.Run(run)
	return _c
}

// ReturnCadenceRuntime provides a mock function for the type Environment
func (_mock *Environment) ReturnCadenceRuntime(reusableCadenceRuntime *runtime0.ReusableCadenceRuntime) {
	_mock.Called(reusableCadenceRuntime)
	return
}

// Environment_ReturnCadenceRuntime_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReturnCadenceRuntime'
type Environment_ReturnCadenceRuntime_Call struct {
	*mock.Call
}

// ReturnCadenceRuntime is a helper method to define mock.On call
//   - reusableCadenceRuntime *runtime0.ReusableCadenceRuntime
func (_e *Environment_Expecter) ReturnCadenceRuntime(reusableCadenceRuntime interface{}) *Environment_ReturnCadenceRuntime_Call {
	return &Environment_ReturnCadenceRuntime_Call{Call: _e.mock.On("ReturnCadenceRuntime", reusableCadenceRuntime)}
}

func (_c *Environment_ReturnCadenceRuntime_Call) Run(run func(reusableCadenceRuntime *runtime0.ReusableCadenceRuntime)) *Environment_ReturnCadenceRuntime_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *runtime0.ReusableCadenceRuntime
		if args[0] != nil {
			arg0 = args[0].(*runtime0.ReusableCadenceRuntime)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Environment_ReturnCadenceRuntime_Call) Return() *Environment_ReturnCadenceRuntime_Call {
	_c.Call.Return()
	return _c
}

func (_c *Environment_ReturnCadenceRuntime_Call) RunAndReturn(run func(reusableCadenceRuntime *runtime0.ReusableCadenceRuntime)) *Environment_ReturnCadenceRuntime_Call {
	_c.Run(run)
	return _c
}

// RevokeAccountKey provides a mock function for the type Environment
func (_mock *Environment) RevokeAccountKey(address runtime.Address, index uint32) (*runtime.AccountKey, error) {
	ret := _mock.Called(address, index)

	if len(ret) == 0 {
		panic("no return value specified for RevokeAccountKey")
	}

	var r0 *runtime.AccountKey
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(runtime.Address, uint32) (*runtime.AccountKey, error)); ok {
		return returnFunc(address, index)
	}
	if returnFunc, ok := ret.Get(0).(func(runtime.Address, uint32) *runtime.AccountKey); ok {
		r0 = returnFunc(address, index)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*runtime.AccountKey)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(runtime.Address, uint32) error); ok {
		r1 = returnFunc(address, index)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Environment_RevokeAccountKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RevokeAccountKey'
type Environment_RevokeAccountKey_Call struct {
	*mock.Call
}

// RevokeAccountKey is a helper method to define mock.On call
//   - address runtime.Address
//   - index uint32
func (_e *Environment_Expecter) RevokeAccountKey(address interface{}, index interface{}) *Environment_RevokeAccountKey_Call {
	return &Environment_RevokeAccountKey_Call{Call: _e.mock.On("RevokeAccountKey", address, index)}
}

func (_c *Environment_RevokeAccountKey_Call) Run(run func(address runtime.Address, index uint32)) *Environment_RevokeAccountKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 runtime.Address
		if args[0] != nil {
			arg0 = args[0].(runtime.Address)
		}
		var arg1 uint32
		if args[1] != nil {
			arg1 = args[1].(uint32)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Environment_RevokeAccountKey_Call) Return(v *runtime.AccountKey, err error) *Environment_RevokeAccountKey_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *Environment_RevokeAccountKey_Call) RunAndReturn(run func(address runtime.Address, index uint32) (*runtime.AccountKey, error)) *Environment_RevokeAccountKey_Call {
	_c.Call.Return(run)
	return _c
}

// RunWithMeteringDisabled provides a mock function for the type Environment
func (_mock *Environment) RunWithMeteringDisabled(f func()) {
	_mock.Called(f)
	return
}

// Environment_RunWithMeteringDisabled_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RunWithMeteringDisabled'
type Environment_RunWithMeteringDisabled_Call struct {
	*mock.Call
}

// RunWithMeteringDisabled is a helper method to define mock.On call
//   - f func()
func (_e *Environment_Expecter) RunWithMeteringDisabled(f interface{}) *Environment_RunWithMeteringDisabled_Call {
	return &Environment_RunWithMeteringDisabled_Call{Call: _e.mock.On("RunWithMeteringDisabled", f)}
}

func (_c *Environment_RunWithMeteringDisabled_Call) Run(run func(f func())) *Environment_RunWithMeteringDisabled_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 func()
		if args[0] != nil {
			arg0 = args[0].(func())
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Environment_RunWithMeteringDisabled_Call) Return() *Environment_RunWithMeteringDisabled_Call {
	_c.Call.Return()
	return _c
}

func (_c *Environment_RunWithMeteringDisabled_Call) RunAndReturn(run func(f func())) *Environment_RunWithMeteringDisabled_Call {
	_c.Run(run)
	return _c
}

// RuntimeSetNumberOfAccounts provides a mock function for the type Environment
func (_mock *Environment) RuntimeSetNumberOfAccounts(count uint64) {
	_mock.Called(count)
	return
}

// Environment_RuntimeSetNumberOfAccounts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RuntimeSetNumberOfAccounts'
type Environment_RuntimeSetNumberOfAccounts_Call struct {
	*mock.Call
}

// RuntimeSetNumberOfAccounts is a helper method to define mock.On call
//   - count uint64
func (_e *Environment_Expecter) RuntimeSetNumberOfAccounts(count interface{}) *Environment_RuntimeSetNumberOfAccounts_Call {
	return &Environment_RuntimeSetNumberOfAccounts_Call{Call: _e.mock.On("RuntimeSetNumberOfAccounts", count)}
}

func (_c *Environment_RuntimeSetNumberOfAccounts_Call) Run(run func(count uint64)) *Environment_RuntimeSetNumberOfAccounts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Environment_RuntimeSetNumberOfAccounts_Call) Return() *Environment_RuntimeSetNumberOfAccounts_Call {
	_c.Call.Return()
	return _c
}

func (_c *Environment_RuntimeSetNumberOfAccounts_Call) RunAndReturn(run func(count uint64)) *Environment_RuntimeSetNumberOfAccounts_Call {
	_c.Run(run)
	return _c
}

// RuntimeTransactionChecked provides a mock function for the type Environment
func (_mock *Environment) RuntimeTransactionChecked(duration time.Duration) {
	_mock.Called(duration)
	return
}

// Environment_RuntimeTransactionChecked_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RuntimeTransactionChecked'
type Environment_RuntimeTransactionChecked_Call struct {
	*mock.Call
}

// RuntimeTransactionChecked is a helper method to define mock.On call
//   - duration time.Duration
func (_e *Environment_Expecter) RuntimeTransactionChecked(duration interface{}) *Environment_RuntimeTransactionChecked_Call {
	return &Environment_RuntimeTransactionChecked_Call{Call: _e.mock.On("RuntimeTransactionChecked", duration)}
}

func (_c *Environment_RuntimeTransactionChecked_Call) Run(run func(duration time.Duration)) *Environment_RuntimeTransactionChecked_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 time.Duration
		if args[0] != nil {
			arg0 = args[0].(time.Duration)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Environment_RuntimeTransactionChecked_Call) Return() *Environment_RuntimeTransactionChecked_Call {
	_c.Call.Return()
	return _c
}

func (_c *Environment_RuntimeTransactionChecked_Call) RunAndReturn(run func(duration time.Duration)) *Environment_RuntimeTransactionChecked_Call {
	_c.Run(run)
	return _c
}

// RuntimeTransactionInterpreted provides a mock function for the type Environment
func (_mock *Environment) RuntimeTransactionInterpreted(duration time.Duration) {
	_mock.Called(duration)
	return
}

// Environment_RuntimeTransactionInterpreted_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RuntimeTransactionInterpreted'
type Environment_RuntimeTransactionInterpreted_Call struct {
	*mock.Call
}

// RuntimeTransactionInterpreted is a helper method to define mock.On call
//   - duration time.Duration
func (_e *Environment_Expecter) RuntimeTransactionInterpreted(duration interface{}) *Environment_RuntimeTransactionInterpreted_Call {
	return &Environment_RuntimeTransactionInterpreted_Call{Call: _e.mock.On("RuntimeTransactionInterpreted", duration)}
}

func (_c *Environment_RuntimeTransactionInterpreted_Call) Run(run func(duration time.Duration)) *Environment_RuntimeTransactionInterpreted_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 time.Duration
		if args[0] != nil {
			arg0 = args[0].(time.Duration)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Environment_RuntimeTransactionInterpreted_Call) Return() *Environment_RuntimeTransactionInterpreted_Call {
	_c.Call.Return()
	return _c
}

func (_c *Environment_RuntimeTransactionInterpreted_Call) RunAndReturn(run func(duration time.Duration)) *Environment_RuntimeTransactionInterpreted_Call {
	_c.Run(run)
	return _c
}

// RuntimeTransactionParsed provides a mock function for the type Environment
func (_mock *Environment) RuntimeTransactionParsed(duration time.Duration) {
	_mock.Called(duration)
	return
}

// Environment_RuntimeTransactionParsed_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RuntimeTransactionParsed'
type Environment_RuntimeTransactionParsed_Call struct {
	*mock.Call
}

// RuntimeTransactionParsed is a helper method to define mock.On call
//   - duration time.Duration
func (_e *Environment_Expecter) RuntimeTransactionParsed(duration interface{}) *Environment_RuntimeTransactionParsed_Call {
	return &Environment_RuntimeTransactionParsed_Call{Call: _e.mock.On("RuntimeTransactionParsed", duration)}
}

func (_c *Environment_RuntimeTransactionParsed_Call) Run(run func(duration time.Duration)) *Environment_RuntimeTransactionParsed_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 time.Duration
		if args[0] != nil {
			arg0 = args[0].(time.Duration)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Environment_RuntimeTransactionParsed_Call) Return() *Environment_RuntimeTransactionParsed_Call {
	_c.Call.Return()
	return _c
}

func (_c *Environment_RuntimeTransactionParsed_Call) RunAndReturn(run func(duration time.Duration)) *Environment_RuntimeTransactionParsed_Call {
	_c.Run(run)
	return _c
}

// RuntimeTransactionProgramsCacheHit provides a mock function for the type Environment
func (_mock *Environment) RuntimeTransactionProgramsCacheHit() {
	_mock.Called()
	return
}

// Environment_RuntimeTransactionProgramsCacheHit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RuntimeTransactionProgramsCacheHit'
type Environment_RuntimeTransactionProgramsCacheHit_Call struct {
	*mock.Call
}

// RuntimeTransactionProgramsCacheHit is a helper method to define mock.On call
func (_e *Environment_Expecter) RuntimeTransactionProgramsCacheHit() *Environment_RuntimeTransactionProgramsCacheHit_Call {
	return &Environment_RuntimeTransactionProgramsCacheHit_Call{Call: _e.mock.On("RuntimeTransactionProgramsCacheHit")}
}

func (_c *Environment_RuntimeTransactionProgramsCacheHit_Call) Run(run func()) *Environment_RuntimeTransactionProgramsCacheHit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Environment_RuntimeTransactionProgramsCacheHit_Call) Return() *Environment_RuntimeTransactionProgramsCacheHit_Call {
	_c.Call.Return()
	return _c
}

func (_c *Environment_RuntimeTransactionProgramsCacheHit_Call) RunAndReturn(run func()) *Environment_RuntimeTransactionProgramsCacheHit_Call {
	_c.Run(run)
	return _c
}

// RuntimeTransactionProgramsCacheMiss provides a mock function for the type Environment
func (_mock *Environment) RuntimeTransactionProgramsCacheMiss() {
	_mock.Called()
	return
}

// Environment_RuntimeTransactionProgramsCacheMiss_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RuntimeTransactionProgramsCacheMiss'
type Environment_RuntimeTransactionProgramsCacheMiss_Call struct {
	*mock.Call
}

// RuntimeTransactionProgramsCacheMiss is a helper method to define mock.On call
func (_e *Environment_Expecter) RuntimeTransactionProgramsCacheMiss() *Environment_RuntimeTransactionProgramsCacheMiss_Call {
	return &Environment_RuntimeTransactionProgramsCacheMiss_Call{Call: _e.mock.On("RuntimeTransactionProgramsCacheMiss")}
}

func (_c *Environment_RuntimeTransactionProgramsCacheMiss_Call) Run(run func()) *Environment_RuntimeTransactionProgramsCacheMiss_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Environment_RuntimeTransactionProgramsCacheMiss_Call) Return() *Environment_RuntimeTransactionProgramsCacheMiss_Call {
	_c.Call.Return()
	return _c
}

func (_c *Environment_RuntimeTransactionProgramsCacheMiss_Call) RunAndReturn(run func()) *Environment_RuntimeTransactionProgramsCacheMiss_Call {
	_c.Run(run)
	return _c
}

// ServiceEvents provides a mock function for the type Environment
func (_mock *Environment) ServiceEvents() flow.EventsList {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for ServiceEvents")
	}

	var r0 flow.EventsList
	if returnFunc, ok := ret.Get(0).(func() flow.EventsList); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.EventsList)
		}
	}
	return r0
}

// Environment_ServiceEvents_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ServiceEvents'
type Environment_ServiceEvents_Call struct {
	*mock.Call
}

// ServiceEvents is a helper method to define mock.On call
func (_e *Environment_Expecter) ServiceEvents() *Environment_ServiceEvents_Call {
	return &Environment_ServiceEvents_Call{Call: _e.mock.On("ServiceEvents")}
}

func (_c *Environment_ServiceEvents_Call) Run(run func()) *Environment_ServiceEvents_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Environment_ServiceEvents_Call) Return(eventsList flow.EventsList) *Environment_ServiceEvents_Call {
	_c.Call.Return(eventsList)
	return _c
}

func (_c *Environment_ServiceEvents_Call) RunAndReturn(run func() flow.EventsList) *Environment_ServiceEvents_Call {
	_c.Call.Return(run)
	return _c
}

// SetNumberOfDeployedCOAs provides a mock function for the type Environment
func (_mock *Environment) SetNumberOfDeployedCOAs(count uint64) {
	_mock.Called(count)
	return
}

// Environment_SetNumberOfDeployedCOAs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetNumberOfDeployedCOAs'
type Environment_SetNumberOfDeployedCOAs_Call struct {
	*mock.Call
}

// SetNumberOfDeployedCOAs is a helper method to define mock.On call
//   - count uint64
func (_e *Environment_Expecter) SetNumberOfDeployedCOAs(count interface{}) *Environment_SetNumberOfDeployedCOAs_Call {
	return &Environment_SetNumberOfDeployedCOAs_Call{Call: _e.mock.On("SetNumberOfDeployedCOAs", count)}
}

func (_c *Environment_SetNumberOfDeployedCOAs_Call) Run(run func(count uint64)) *Environment_SetNumberOfDeployedCOAs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Environment_SetNumberOfDeployedCOAs_Call) Return() *Environment_SetNumberOfDeployedCOAs_Call {
	_c.Call.Return()
	return _c
}

func (_c *Environment_SetNumberOfDeployedCOAs_Call) RunAndReturn(run func(count uint64)) *Environment_SetNumberOfDeployedCOAs_Call {
	_c.Run(run)
	return _c
}

// SetValue provides a mock function for the type Environment
func (_mock *Environment) SetValue(owner []byte, key []byte, value []byte) error {
	ret := _mock.Called(owner, key, value)

	if len(ret) == 0 {
		panic("no return value specified for SetValue")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func([]byte, []byte, []byte) error); ok {
		r0 = returnFunc(owner, key, value)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Environment_SetValue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetValue'
type Environment_SetValue_Call struct {
	*mock.Call
}

// SetValue is a helper method to define mock.On call
//   - owner []byte
//   - key []byte
//   - value []byte
func (_e *Environment_Expecter) SetValue(owner interface{}, key interface{}, value interface{}) *Environment_SetValue_Call {
	return &Environment_SetValue_Call{Call: _e.mock.On("SetValue", owner, key, value)}
}

func (_c *Environment_SetValue_Call) Run(run func(owner []byte, key []byte, value []byte)) *Environment_SetValue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []byte
		if args[0] != nil {
			arg0 = args[0].([]byte)
		}
		var arg1 []byte
		if args[1] != nil {
			arg1 = args[1].([]byte)
		}
		var arg2 []byte
		if args[2] != nil {
			arg2 = args[2].([]byte)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Environment_SetValue_Call) Return(err error) *Environment_SetValue_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Environment_SetValue_Call) RunAndReturn(run func(owner []byte, key []byte, value []byte) error) *Environment_SetValue_Call {
	_c.Call.Return(run)
	return _c
}

// StartChildSpan provides a mock function for the type Environment
func (_mock *Environment) StartChildSpan(name trace.SpanName, options ...trace0.SpanStartOption) tracing.TracerSpan {
	// trace0.SpanStartOption
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, name)
	_ca = append(_ca, _va...)
	ret := _mock.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartChildSpan")
	}

	var r0 tracing.TracerSpan
	if returnFunc, ok := ret.Get(0).(func(trace.SpanName, ...trace0.SpanStartOption) tracing.TracerSpan); ok {
		r0 = returnFunc(name, options...)
	} else {
		r0 = ret.Get(0).(tracing.TracerSpan)
	}
	return r0
}

// Environment_StartChildSpan_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StartChildSpan'
type Environment_StartChildSpan_Call struct {
	*mock.Call
}

// StartChildSpan is a helper method to define mock.On call
//   - name trace.SpanName
//   - options ...trace0.SpanStartOption
func (_e *Environment_Expecter) StartChildSpan(name interface{}, options ...interface{}) *Environment_StartChildSpan_Call {
	return &Environment_StartChildSpan_Call{Call: _e.mock.On("StartChildSpan",
		append([]interface{}{name}, options...)...)}
}

func (_c *Environment_StartChildSpan_Call) Run(run func(name trace.SpanName, options ...trace0.SpanStartOption)) *Environment_StartChildSpan_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 trace.SpanName
		if args[0] != nil {
			arg0 = args[0].(trace.SpanName)
		}
		var arg1 []trace0.SpanStartOption
		variadicArgs := make([]trace0.SpanStartOption, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(trace0.SpanStartOption)
			}
		}
		arg1 = variadicArgs
		run(
			arg0,
			arg1...,
		)
	})
	return _c
}

func (_c *Environment_StartChildSpan_Call) Return(tracerSpan tracing.TracerSpan) *Environment_StartChildSpan_Call {
	_c.Call.Return(tracerSpan)
	return _c
}

func (_c *Environment_StartChildSpan_Call) RunAndReturn(run func(name trace.SpanName, options ...trace0.SpanStartOption) tracing.TracerSpan) *Environment_StartChildSpan_Call {
	_c.Call.Return(run)
	return _c
}

// TotalEmittedEventBytes provides a mock function for the type Environment
func (_mock *Environment) TotalEmittedEventBytes() uint64 {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for TotalEmittedEventBytes")
	}

	var r0 uint64
	if returnFunc, ok := ret.Get(0).(func() uint64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint64)
	}
	return r0
}

// Environment_TotalEmittedEventBytes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TotalEmittedEventBytes'
type Environment_TotalEmittedEventBytes_Call struct {
	*mock.Call
}

// TotalEmittedEventBytes is a helper method to define mock.On call
func (_e *Environment_Expecter) TotalEmittedEventBytes() *Environment_TotalEmittedEventBytes_Call {
	return &Environment_TotalEmittedEventBytes_Call{Call: _e.mock.On("TotalEmittedEventBytes")}
}

func (_c *Environment_TotalEmittedEventBytes_Call) Run(run func()) *Environment_TotalEmittedEventBytes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Environment_TotalEmittedEventBytes_Call) Return(v uint64) *Environment_TotalEmittedEventBytes_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *Environment_TotalEmittedEventBytes_Call) RunAndReturn(run func() uint64) *Environment_TotalEmittedEventBytes_Call {
	_c.Call.Return(run)
	return _c
}

// TransactionFeesEnabled provides a mock function for the type Environment
func (_mock *Environment) TransactionFeesEnabled() bool {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for TransactionFeesEnabled")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func() bool); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// Environment_TransactionFeesEnabled_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TransactionFeesEnabled'
type Environment_TransactionFeesEnabled_Call struct {
	*mock.Call
}

// TransactionFeesEnabled is a helper method to define mock.On call
func (_e *Environment_Expecter) TransactionFeesEnabled() *Environment_TransactionFeesEnabled_Call {
	return &Environment_TransactionFeesEnabled_Call{Call: _e.mock.On("TransactionFeesEnabled")}
}

func (_c *Environment_TransactionFeesEnabled_Call) Run(run func()) *Environment_TransactionFeesEnabled_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Environment_TransactionFeesEnabled_Call) Return(b bool) *Environment_TransactionFeesEnabled_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *Environment_TransactionFeesEnabled_Call) RunAndReturn(run func() bool) *Environment_TransactionFeesEnabled_Call {
	_c.Call.Return(run)
	return _c
}

// TxID provides a mock function for the type Environment
func (_mock *Environment) TxID() flow.Identifier {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for TxID")
	}

	var r0 flow.Identifier
	if returnFunc, ok := ret.Get(0).(func() flow.Identifier); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.Identifier)
		}
	}
	return r0
}

// Environment_TxID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TxID'
type Environment_TxID_Call struct {
	*mock.Call
}

// TxID is a helper method to define mock.On call
func (_e *Environment_Expecter) TxID() *Environment_TxID_Call {
	return &Environment_TxID_Call{Call: _e.mock.On("TxID")}
}

func (_c *Environment_TxID_Call) Run(run func()) *Environment_TxID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Environment_TxID_Call) Return(identifier flow.Identifier) *Environment_TxID_Call {
	_c.Call.Return(identifier)
	return _c
}

func (_c *Environment_TxID_Call) RunAndReturn(run func() flow.Identifier) *Environment_TxID_Call {
	_c.Call.Return(run)
	return _c
}

// TxIndex provides a mock function for the type Environment
func (_mock *Environment) TxIndex() uint32 {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for TxIndex")
	}

	var r0 uint32
	if returnFunc, ok := ret.Get(0).(func() uint32); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint32)
	}
	return r0
}

// Environment_TxIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TxIndex'
type Environment_TxIndex_Call struct {
	*mock.Call
}

// TxIndex is a helper method to define mock.On call
func (_e *Environment_Expecter) TxIndex() *Environment_TxIndex_Call {
	return &Environment_TxIndex_Call{Call: _e.mock.On("TxIndex")}
}

func (_c *Environment_TxIndex_Call) Run(run func()) *Environment_TxIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Environment_TxIndex_Call) Return(v uint32) *Environment_TxIndex_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *Environment_TxIndex_Call) RunAndReturn(run func() uint32) *Environment_TxIndex_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateAccountContractCode provides a mock function for the type Environment
func (_mock *Environment) UpdateAccountContractCode(location common.AddressLocation, code []byte) error {
	ret := _mock.Called(location, code)

	if len(ret) == 0 {
		panic("no return value specified for UpdateAccountContractCode")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(common.AddressLocation, []byte) error); ok {
		r0 = returnFunc(location, code)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Environment_UpdateAccountContractCode_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateAccountContractCode'
type Environment_UpdateAccountContractCode_Call struct {
	*mock.Call
}

// UpdateAccountContractCode is a helper method to define mock.On call
//   - location common.AddressLocation
//   - code []byte
func (_e *Environment_Expecter) UpdateAccountContractCode(location interface{}, code interface{}) *Environment_UpdateAccountContractCode_Call {
	return &Environment_UpdateAccountContractCode_Call{Call: _e.mock.On("UpdateAccountContractCode", location, code)}
}

func (_c *Environment_UpdateAccountContractCode_Call) Run(run func(location common.AddressLocation, code []byte)) *Environment_UpdateAccountContractCode_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 common.AddressLocation
		if args[0] != nil {
			arg0 = args[0].(common.AddressLocation)
		}
		var arg1 []byte
		if args[1] != nil {
			arg1 = args[1].([]byte)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Environment_UpdateAccountContractCode_Call) Return(err error) *Environment_UpdateAccountContractCode_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Environment_UpdateAccountContractCode_Call) RunAndReturn(run func(location common.AddressLocation, code []byte) error) *Environment_UpdateAccountContractCode_Call {
	_c.Call.Return(run)
	return _c
}

// ValidateAccountCapabilitiesGet provides a mock function for the type Environment
func (_mock *Environment) ValidateAccountCapabilitiesGet(context interpreter.AccountCapabilityGetValidationContext, address interpreter.AddressValue, path interpreter.PathValue, wantedBorrowType *sema.ReferenceType, capabilityBorrowType *sema.ReferenceType) (bool, error) {
	ret := _mock.Called(context, address, path, wantedBorrowType, capabilityBorrowType)

	if len(ret) == 0 {
		panic("no return value specified for ValidateAccountCapabilitiesGet")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(interpreter.AccountCapabilityGetValidationContext, interpreter.AddressValue, interpreter.PathValue, *sema.ReferenceType, *sema.ReferenceType) (bool, error)); ok {
		return returnFunc(context, address, path, wantedBorrowType, capabilityBorrowType)
	}
	if returnFunc, ok := ret.Get(0).(func(interpreter.AccountCapabilityGetValidationContext, interpreter.AddressValue, interpreter.PathValue, *sema.ReferenceType, *sema.ReferenceType) bool); ok {
		r0 = returnFunc(context, address, path, wantedBorrowType, capabilityBorrowType)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(interpreter.AccountCapabilityGetValidationContext, interpreter.AddressValue, interpreter.PathValue, *sema.ReferenceType, *sema.ReferenceType) error); ok {
		r1 = returnFunc(context, address, path, wantedBorrowType, capabilityBorrowType)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Environment_ValidateAccountCapabilitiesGet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ValidateAccountCapabilitiesGet'
type Environment_ValidateAccountCapabilitiesGet_Call struct {
	*mock.Call
}

// ValidateAccountCapabilitiesGet is a helper method to define mock.On call
//   - context interpreter.AccountCapabilityGetValidationContext
//   - address interpreter.AddressValue
//   - path interpreter.PathValue
//   - wantedBorrowType *sema.ReferenceType
//   - capabilityBorrowType *sema.ReferenceType
func (_e *Environment_Expecter) ValidateAccountCapabilitiesGet(context interface{}, address interface{}, path interface{}, wantedBorrowType interface{}, capabilityBorrowType interface{}) *Environment_ValidateAccountCapabilitiesGet_Call {
	return &Environment_ValidateAccountCapabilitiesGet_Call{Call: _e.mock.On("ValidateAccountCapabilitiesGet", context, address, path, wantedBorrowType, capabilityBorrowType)}
}

func (_c *Environment_ValidateAccountCapabilitiesGet_Call) Run(run func(context interpreter.AccountCapabilityGetValidationContext, address interpreter.AddressValue, path interpreter.PathValue, wantedBorrowType *sema.ReferenceType, capabilityBorrowType *sema.ReferenceType)) *Environment_ValidateAccountCapabilitiesGet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 interpreter.AccountCapabilityGetValidationContext
		if args[0] != nil {
			arg0 = args[0].(interpreter.AccountCapabilityGetValidationContext)
		}
		var arg1 interpreter.AddressValue
		if args[1] != nil {
			arg1 = args[1].(interpreter.AddressValue)
		}
		var arg2 interpreter.PathValue
		if args[2] != nil {
			arg2 = args[2].(interpreter.PathValue)
		}
		var arg3 *sema.ReferenceType
		if args[3] != nil {
			arg3 = args[3].(*sema.ReferenceType)
		}
		var arg4 *sema.ReferenceType
		if args[4] != nil {
			arg4 = args[4].(*sema.ReferenceType)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *Environment_ValidateAccountCapabilitiesGet_Call) Return(b bool, err error) *Environment_ValidateAccountCapabilitiesGet_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *Environment_ValidateAccountCapabilitiesGet_Call) RunAndReturn(run func(context interpreter.AccountCapabilityGetValidationContext, address interpreter.AddressValue, path interpreter.PathValue, wantedBorrowType *sema.ReferenceType, capabilityBorrowType *sema.ReferenceType) (bool, error)) *Environment_ValidateAccountCapabilitiesGet_Call {
	_c.Call.Return(run)
	return _c
}

// ValidateAccountCapabilitiesPublish provides a mock function for the type Environment
func (_mock *Environment) ValidateAccountCapabilitiesPublish(context interpreter.AccountCapabilityPublishValidationContext, address interpreter.AddressValue, path interpreter.PathValue, capabilityBorrowType *interpreter.ReferenceStaticType) (bool, error) {
	ret := _mock.Called(context, address, path, capabilityBorrowType)

	if len(ret) == 0 {
		panic("no return value specified for ValidateAccountCapabilitiesPublish")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(interpreter.AccountCapabilityPublishValidationContext, interpreter.AddressValue, interpreter.PathValue, *interpreter.ReferenceStaticType) (bool, error)); ok {
		return returnFunc(context, address, path, capabilityBorrowType)
	}
	if returnFunc, ok := ret.Get(0).(func(interpreter.AccountCapabilityPublishValidationContext, interpreter.AddressValue, interpreter.PathValue, *interpreter.ReferenceStaticType) bool); ok {
		r0 = returnFunc(context, address, path, capabilityBorrowType)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(interpreter.AccountCapabilityPublishValidationContext, interpreter.AddressValue, interpreter.PathValue, *interpreter.ReferenceStaticType) error); ok {
		r1 = returnFunc(context, address, path, capabilityBorrowType)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Environment_ValidateAccountCapabilitiesPublish_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ValidateAccountCapabilitiesPublish'
type Environment_ValidateAccountCapabilitiesPublish_Call struct {
	*mock.Call
}

// ValidateAccountCapabilitiesPublish is a helper method to define mock.On call
//   - context interpreter.AccountCapabilityPublishValidationContext
//   - address interpreter.AddressValue
//   - path interpreter.PathValue
//   - capabilityBorrowType *interpreter.ReferenceStaticType
func (_e *Environment_Expecter) ValidateAccountCapabilitiesPublish(context interface{}, address interface{}, path interface{}, capabilityBorrowType interface{}) *Environment_ValidateAccountCapabilitiesPublish_Call {
	return &Environment_ValidateAccountCapabilitiesPublish_Call{Call: _e.mock.On("ValidateAccountCapabilitiesPublish", context, address, path, capabilityBorrowType)}
}

func (_c *Environment_ValidateAccountCapabilitiesPublish_Call) Run(run func(context interpreter.AccountCapabilityPublishValidationContext, address interpreter.AddressValue, path interpreter.PathValue, capabilityBorrowType *interpreter.ReferenceStaticType)) *Environment_ValidateAccountCapabilitiesPublish_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 interpreter.AccountCapabilityPublishValidationContext
		if args[0] != nil {
			arg0 = args[0].(interpreter.AccountCapabilityPublishValidationContext)
		}
		var arg1 interpreter.AddressValue
		if args[1] != nil {
			arg1 = args[1].(interpreter.AddressValue)
		}
		var arg2 interpreter.PathValue
		if args[2] != nil {
			arg2 = args[2].(interpreter.PathValue)
		}
		var arg3 *interpreter.ReferenceStaticType
		if args[3] != nil {
			arg3 = args[3].(*interpreter.ReferenceStaticType)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *Environment_ValidateAccountCapabilitiesPublish_Call) Return(b bool, err error) *Environment_ValidateAccountCapabilitiesPublish_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *Environment_ValidateAccountCapabilitiesPublish_Call) RunAndReturn(run func(context interpreter.AccountCapabilityPublishValidationContext, address interpreter.AddressValue, path interpreter.PathValue, capabilityBorrowType *interpreter.ReferenceStaticType) (bool, error)) *Environment_ValidateAccountCapabilitiesPublish_Call {
	_c.Call.Return(run)
	return _c
}

// ValidatePublicKey provides a mock function for the type Environment
func (_mock *Environment) ValidatePublicKey(key *runtime.PublicKey) error {
	ret := _mock.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for ValidatePublicKey")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*runtime.PublicKey) error); ok {
		r0 = returnFunc(key)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Environment_ValidatePublicKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ValidatePublicKey'
type Environment_ValidatePublicKey_Call struct {
	*mock.Call
}

// ValidatePublicKey is a helper method to define mock.On call
//   - key *runtime.PublicKey
func (_e *Environment_Expecter) ValidatePublicKey(key interface{}) *Environment_ValidatePublicKey_Call {
	return &Environment_ValidatePublicKey_Call{Call: _e.mock.On("ValidatePublicKey", key)}
}

func (_c *Environment_ValidatePublicKey_Call) Run(run func(key *runtime.PublicKey)) *Environment_ValidatePublicKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *runtime.PublicKey
		if args[0] != nil {
			arg0 = args[0].(*runtime.PublicKey)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Environment_ValidatePublicKey_Call) Return(err error) *Environment_ValidatePublicKey_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Environment_ValidatePublicKey_Call) RunAndReturn(run func(key *runtime.PublicKey) error) *Environment_ValidatePublicKey_Call {
	_c.Call.Return(run)
	return _c
}

// ValueExists provides a mock function for the type Environment
func (_mock *Environment) ValueExists(owner []byte, key []byte) (bool, error) {
	ret := _mock.Called(owner, key)

	if len(ret) == 0 {
		panic("no return value specified for ValueExists")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]byte, []byte) (bool, error)); ok {
		return returnFunc(owner, key)
	}
	if returnFunc, ok := ret.Get(0).(func([]byte, []byte) bool); ok {
		r0 = returnFunc(owner, key)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func([]byte, []byte) error); ok {
		r1 = returnFunc(owner, key)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Environment_ValueExists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ValueExists'
type Environment_ValueExists_Call struct {
	*mock.Call
}

// ValueExists is a helper method to define mock.On call
//   - owner []byte
//   - key []byte
func (_e *Environment_Expecter) ValueExists(owner interface{}, key interface{}) *Environment_ValueExists_Call {
	return &Environment_ValueExists_Call{Call: _e.mock.On("ValueExists", owner, key)}
}

func (_c *Environment_ValueExists_Call) Run(run func(owner []byte, key []byte)) *Environment_ValueExists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []byte
		if args[0] != nil {
			arg0 = args[0].([]byte)
		}
		var arg1 []byte
		if args[1] != nil {
			arg1 = args[1].([]byte)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Environment_ValueExists_Call) Return(exists bool, err error) *Environment_ValueExists_Call {
	_c.Call.Return(exists, err)
	return _c
}

func (_c *Environment_ValueExists_Call) RunAndReturn(run func(owner []byte, key []byte) (bool, error)) *Environment_ValueExists_Call {
	_c.Call.Return(run)
	return _c
}

// VerifySignature provides a mock function for the type Environment
func (_mock *Environment) VerifySignature(signature []byte, tag string, signedData []byte, publicKey []byte, signatureAlgorithm runtime.SignatureAlgorithm, hashAlgorithm runtime.HashAlgorithm) (bool, error) {
	ret := _mock.Called(signature, tag, signedData, publicKey, signatureAlgorithm, hashAlgorithm)

	if len(ret) == 0 {
		panic("no return value specified for VerifySignature")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]byte, string, []byte, []byte, runtime.SignatureAlgorithm, runtime.HashAlgorithm) (bool, error)); ok {
		return returnFunc(signature, tag, signedData, publicKey, signatureAlgorithm, hashAlgorithm)
	}
	if returnFunc, ok := ret.Get(0).(func([]byte, string, []byte, []byte, runtime.SignatureAlgorithm, runtime.HashAlgorithm) bool); ok {
		r0 = returnFunc(signature, tag, signedData, publicKey, signatureAlgorithm, hashAlgorithm)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func([]byte, string, []byte, []byte, runtime.SignatureAlgorithm, runtime.HashAlgorithm) error); ok {
		r1 = returnFunc(signature, tag, signedData, publicKey, signatureAlgorithm, hashAlgorithm)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Environment_VerifySignature_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'VerifySignature'
type Environment_VerifySignature_Call struct {
	*mock.Call
}

// VerifySignature is a helper method to define mock.On call
//   - signature []byte
//   - tag string
//   - signedData []byte
//   - publicKey []byte
//   - signatureAlgorithm runtime.SignatureAlgorithm
//   - hashAlgorithm runtime.HashAlgorithm
func (_e *Environment_Expecter) VerifySignature(signature interface{}, tag interface{}, signedData interface{}, publicKey interface{}, signatureAlgorithm interface{}, hashAlgorithm interface{}) *Environment_VerifySignature_Call {
	return &Environment_VerifySignature_Call{Call: _e.mock.On("VerifySignature", signature, tag, signedData, publicKey, signatureAlgorithm, hashAlgorithm)}
}

func (_c *Environment_VerifySignature_Call) Run(run func(signature []byte, tag string, signedData []byte, publicKey []byte, signatureAlgorithm runtime.SignatureAlgorithm, hashAlgorithm runtime.HashAlgorithm)) *Environment_VerifySignature_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []byte
		if args[0] != nil {
			arg0 = args[0].([]byte)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 []byte
		if args[2] != nil {
			arg2 = args[2].([]byte)
		}
		var arg3 []byte
		if args[3] != nil {
			arg3 = args[3].([]byte)
		}
		var arg4 runtime.SignatureAlgorithm
		if args[4] != nil {
			arg4 = args[4].(runtime.SignatureAlgorithm)
		}
		var arg5 runtime.HashAlgorithm
		if args[5] != nil {
			arg5 = args[5].(runtime.HashAlgorithm)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
			arg5,
		)
	})
	return _c
}

func (_c *Environment_VerifySignature_Call) Return(b bool, err error) *Environment_VerifySignature_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *Environment_VerifySignature_Call) RunAndReturn(run func(signature []byte, tag string, signedData []byte, publicKey []byte, signatureAlgorithm runtime.SignatureAlgorithm, hashAlgorithm runtime.HashAlgorithm) (bool, error)) *Environment_VerifySignature_Call {
	_c.Call.Return(run)
	return _c
}

// NewEventEmitter creates a new instance of EventEmitter. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewEventEmitter(t interface {
	mock.TestingT
	Cleanup(func())
}) *EventEmitter {
	mock := &EventEmitter{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// EventEmitter is an autogenerated mock type for the EventEmitter type
type EventEmitter struct {
	mock.Mock
}

type EventEmitter_Expecter struct {
	mock *mock.Mock
}

func (_m *EventEmitter) EXPECT() *EventEmitter_Expecter {
	return &EventEmitter_Expecter{mock: &_m.Mock}
}

// ConvertedServiceEvents provides a mock function for the type EventEmitter
func (_mock *EventEmitter) ConvertedServiceEvents() flow.ServiceEventList {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for ConvertedServiceEvents")
	}

	var r0 flow.ServiceEventList
	if returnFunc, ok := ret.Get(0).(func() flow.ServiceEventList); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.ServiceEventList)
		}
	}
	return r0
}

// EventEmitter_ConvertedServiceEvents_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConvertedServiceEvents'
type EventEmitter_ConvertedServiceEvents_Call struct {
	*mock.Call
}

// ConvertedServiceEvents is a helper method to define mock.On call
func (_e *EventEmitter_Expecter) ConvertedServiceEvents() *EventEmitter_ConvertedServiceEvents_Call {
	return &EventEmitter_ConvertedServiceEvents_Call{Call: _e.mock.On("ConvertedServiceEvents")}
}

func (_c *EventEmitter_ConvertedServiceEvents_Call) Run(run func()) *EventEmitter_ConvertedServiceEvents_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *EventEmitter_ConvertedServiceEvents_Call) Return(serviceEventList flow.ServiceEventList) *EventEmitter_ConvertedServiceEvents_Call {
	_c.Call.Return(serviceEventList)
	return _c
}

func (_c *EventEmitter_ConvertedServiceEvents_Call) RunAndReturn(run func() flow.ServiceEventList) *EventEmitter_ConvertedServiceEvents_Call {
	_c.Call.Return(run)
	return _c
}

// EmitEvent provides a mock function for the type EventEmitter
func (_mock *EventEmitter) EmitEvent(event cadence.Event) error {
	ret := _mock.Called(event)

	if len(ret) == 0 {
		panic("no return value specified for EmitEvent")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(cadence.Event) error); ok {
		r0 = returnFunc(event)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// EventEmitter_EmitEvent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EmitEvent'
type EventEmitter_EmitEvent_Call struct {
	*mock.Call
}

// EmitEvent is a helper method to define mock.On call
//   - event cadence.Event
func (_e *EventEmitter_Expecter) EmitEvent(event interface{}) *EventEmitter_EmitEvent_Call {
	return &EventEmitter_EmitEvent_Call{Call: _e.mock.On("EmitEvent", event)}
}

func (_c *EventEmitter_EmitEvent_Call) Run(run func(event cadence.Event)) *EventEmitter_EmitEvent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 cadence.Event
		if args[0] != nil {
			arg0 = args[0].(cadence.Event)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *EventEmitter_EmitEvent_Call) Return(err error) *EventEmitter_EmitEvent_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *EventEmitter_EmitEvent_Call) RunAndReturn(run func(event cadence.Event) error) *EventEmitter_EmitEvent_Call {
	_c.Call.Return(run)
	return _c
}

// Events provides a mock function for the type EventEmitter
func (_mock *EventEmitter) Events() flow.EventsList {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Events")
	}

	var r0 flow.EventsList
	if returnFunc, ok := ret.Get(0).(func() flow.EventsList); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.EventsList)
		}
	}
	return r0
}

// EventEmitter_Events_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Events'
type EventEmitter_Events_Call struct {
	*mock.Call
}

// Events is a helper method to define mock.On call
func (_e *EventEmitter_Expecter) Events() *EventEmitter_Events_Call {
	return &EventEmitter_Events_Call{Call: _e.mock.On("Events")}
}

func (_c *EventEmitter_Events_Call) Run(run func()) *EventEmitter_Events_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *EventEmitter_Events_Call) Return(eventsList flow.EventsList) *EventEmitter_Events_Call {
	_c.Call.Return(eventsList)
	return _c
}

func (_c *EventEmitter_Events_Call) RunAndReturn(run func() flow.EventsList) *EventEmitter_Events_Call {
	_c.Call.Return(run)
	return _c
}

// Reset provides a mock function for the type EventEmitter
func (_mock *EventEmitter) Reset() {
	_mock.Called()
	return
}

// EventEmitter_Reset_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Reset'
type EventEmitter_Reset_Call struct {
	*mock.Call
}

// Reset is a helper method to define mock.On call
func (_e *EventEmitter_Expecter) Reset() *EventEmitter_Reset_Call {
	return &EventEmitter_Reset_Call{Call: _e.mock.On("Reset")}
}

func (_c *EventEmitter_Reset_Call) Run(run func()) *EventEmitter_Reset_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *EventEmitter_Reset_Call) Return() *EventEmitter_Reset_Call {
	_c.Call.Return()
	return _c
}

func (_c *EventEmitter_Reset_Call) RunAndReturn(run func()) *EventEmitter_Reset_Call {
	_c.Run(run)
	return _c
}

// ServiceEvents provides a mock function for the type EventEmitter
func (_mock *EventEmitter) ServiceEvents() flow.EventsList {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for ServiceEvents")
	}

	var r0 flow.EventsList
	if returnFunc, ok := ret.Get(0).(func() flow.EventsList); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.EventsList)
		}
	}
	return r0
}

// EventEmitter_ServiceEvents_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ServiceEvents'
type EventEmitter_ServiceEvents_Call struct {
	*mock.Call
}

// ServiceEvents is a helper method to define mock.On call
func (_e *EventEmitter_Expecter) ServiceEvents() *EventEmitter_ServiceEvents_Call {
	return &EventEmitter_ServiceEvents_Call{Call: _e.mock.On("ServiceEvents")}
}

func (_c *EventEmitter_ServiceEvents_Call) Run(run func()) *EventEmitter_ServiceEvents_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *EventEmitter_ServiceEvents_Call) Return(eventsList flow.EventsList) *EventEmitter_ServiceEvents_Call {
	_c.Call.Return(eventsList)
	return _c
}

func (_c *EventEmitter_ServiceEvents_Call) RunAndReturn(run func() flow.EventsList) *EventEmitter_ServiceEvents_Call {
	_c.Call.Return(run)
	return _c
}

// NewEventEncoder creates a new instance of EventEncoder. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewEventEncoder(t interface {
	mock.TestingT
	Cleanup(func())
}) *EventEncoder {
	mock := &EventEncoder{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// EventEncoder is an autogenerated mock type for the EventEncoder type
type EventEncoder struct {
	mock.Mock
}

type EventEncoder_Expecter struct {
	mock *mock.Mock
}

func (_m *EventEncoder) EXPECT() *EventEncoder_Expecter {
	return &EventEncoder_Expecter{mock: &_m.Mock}
}

// Encode provides a mock function for the type EventEncoder
func (_mock *EventEncoder) Encode(event cadence.Event) ([]byte, error) {
	ret := _mock.Called(event)

	if len(ret) == 0 {
		panic("no return value specified for Encode")
	}

	var r0 []byte
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(cadence.Event) ([]byte, error)); ok {
		return returnFunc(event)
	}
	if returnFunc, ok := ret.Get(0).(func(cadence.Event) []byte); ok {
		r0 = returnFunc(event)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(cadence.Event) error); ok {
		r1 = returnFunc(event)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// EventEncoder_Encode_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Encode'
type EventEncoder_Encode_Call struct {
	*mock.Call
}

// Encode is a helper method to define mock.On call
//   - event cadence.Event
func (_e *EventEncoder_Expecter) Encode(event interface{}) *EventEncoder_Encode_Call {
	return &EventEncoder_Encode_Call{Call: _e.mock.On("Encode", event)}
}

func (_c *EventEncoder_Encode_Call) Run(run func(event cadence.Event)) *EventEncoder_Encode_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 cadence.Event
		if args[0] != nil {
			arg0 = args[0].(cadence.Event)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *EventEncoder_Encode_Call) Return(bytes []byte, err error) *EventEncoder_Encode_Call {
	_c.Call.Return(bytes, err)
	return _c
}

func (_c *EventEncoder_Encode_Call) RunAndReturn(run func(event cadence.Event) ([]byte, error)) *EventEncoder_Encode_Call {
	_c.Call.Return(run)
	return _c
}

// NewRandomSourceHistoryProvider creates a new instance of RandomSourceHistoryProvider. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewRandomSourceHistoryProvider(t interface {
	mock.TestingT
	Cleanup(func())
}) *RandomSourceHistoryProvider {
	mock := &RandomSourceHistoryProvider{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// RandomSourceHistoryProvider is an autogenerated mock type for the RandomSourceHistoryProvider type
type RandomSourceHistoryProvider struct {
	mock.Mock
}

type RandomSourceHistoryProvider_Expecter struct {
	mock *mock.Mock
}

func (_m *RandomSourceHistoryProvider) EXPECT() *RandomSourceHistoryProvider_Expecter {
	return &RandomSourceHistoryProvider_Expecter{mock: &_m.Mock}
}

// RandomSourceHistory provides a mock function for the type RandomSourceHistoryProvider
func (_mock *RandomSourceHistoryProvider) RandomSourceHistory() ([]byte, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for RandomSourceHistory")
	}

	var r0 []byte
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() ([]byte, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() []byte); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// RandomSourceHistoryProvider_RandomSourceHistory_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RandomSourceHistory'
type RandomSourceHistoryProvider_RandomSourceHistory_Call struct {
	*mock.Call
}

// RandomSourceHistory is a helper method to define mock.On call
func (_e *RandomSourceHistoryProvider_Expecter) RandomSourceHistory() *RandomSourceHistoryProvider_RandomSourceHistory_Call {
	return &RandomSourceHistoryProvider_RandomSourceHistory_Call{Call: _e.mock.On("RandomSourceHistory")}
}

func (_c *RandomSourceHistoryProvider_RandomSourceHistory_Call) Run(run func()) *RandomSourceHistoryProvider_RandomSourceHistory_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *RandomSourceHistoryProvider_RandomSourceHistory_Call) Return(bytes []byte, err error) *RandomSourceHistoryProvider_RandomSourceHistory_Call {
	_c.Call.Return(bytes, err)
	return _c
}

func (_c *RandomSourceHistoryProvider_RandomSourceHistory_Call) RunAndReturn(run func() ([]byte, error)) *RandomSourceHistoryProvider_RandomSourceHistory_Call {
	_c.Call.Return(run)
	return _c
}

// NewContractFunctionInvoker creates a new instance of ContractFunctionInvoker. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewContractFunctionInvoker(t interface {
	mock.TestingT
	Cleanup(func())
}) *ContractFunctionInvoker {
	mock := &ContractFunctionInvoker{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// ContractFunctionInvoker is an autogenerated mock type for the ContractFunctionInvoker type
type ContractFunctionInvoker struct {
	mock.Mock
}

type ContractFunctionInvoker_Expecter struct {
	mock *mock.Mock
}

func (_m *ContractFunctionInvoker) EXPECT() *ContractFunctionInvoker_Expecter {
	return &ContractFunctionInvoker_Expecter{mock: &_m.Mock}
}

// Invoke provides a mock function for the type ContractFunctionInvoker
func (_mock *ContractFunctionInvoker) Invoke(spec environment.ContractFunctionSpec, arguments []cadence.Value) (cadence.Value, error) {
	ret := _mock.Called(spec, arguments)

	if len(ret) == 0 {
		panic("no return value specified for Invoke")
	}

	var r0 cadence.Value
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(environment.ContractFunctionSpec, []cadence.Value) (cadence.Value, error)); ok {
		return returnFunc(spec, arguments)
	}
	if returnFunc, ok := ret.Get(0).(func(environment.ContractFunctionSpec, []cadence.Value) cadence.Value); ok {
		r0 = returnFunc(spec, arguments)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(cadence.Value)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(environment.ContractFunctionSpec, []cadence.Value) error); ok {
		r1 = returnFunc(spec, arguments)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ContractFunctionInvoker_Invoke_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Invoke'
type ContractFunctionInvoker_Invoke_Call struct {
	*mock.Call
}

// Invoke is a helper method to define mock.On call
//   - spec environment.ContractFunctionSpec
//   - arguments []cadence.Value
func (_e *ContractFunctionInvoker_Expecter) Invoke(spec interface{}, arguments interface{}) *ContractFunctionInvoker_Invoke_Call {
	return &ContractFunctionInvoker_Invoke_Call{Call: _e.mock.On("Invoke", spec, arguments)}
}

func (_c *ContractFunctionInvoker_Invoke_Call) Run(run func(spec environment.ContractFunctionSpec, arguments []cadence.Value)) *ContractFunctionInvoker_Invoke_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 environment.ContractFunctionSpec
		if args[0] != nil {
			arg0 = args[0].(environment.ContractFunctionSpec)
		}
		var arg1 []cadence.Value
		if args[1] != nil {
			arg1 = args[1].([]cadence.Value)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ContractFunctionInvoker_Invoke_Call) Return(value cadence.Value, err error) *ContractFunctionInvoker_Invoke_Call {
	_c.Call.Return(value, err)
	return _c
}

func (_c *ContractFunctionInvoker_Invoke_Call) RunAndReturn(run func(spec environment.ContractFunctionSpec, arguments []cadence.Value) (cadence.Value, error)) *ContractFunctionInvoker_Invoke_Call {
	_c.Call.Return(run)
	return _c
}

// NewLoggerProvider creates a new instance of LoggerProvider. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewLoggerProvider(t interface {
	mock.TestingT
	Cleanup(func())
}) *LoggerProvider {
	mock := &LoggerProvider{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// LoggerProvider is an autogenerated mock type for the LoggerProvider type
type LoggerProvider struct {
	mock.Mock
}

type LoggerProvider_Expecter struct {
	mock *mock.Mock
}

func (_m *LoggerProvider) EXPECT() *LoggerProvider_Expecter {
	return &LoggerProvider_Expecter{mock: &_m.Mock}
}

// Logger provides a mock function for the type LoggerProvider
func (_mock *LoggerProvider) Logger() zerolog.Logger {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Logger")
	}

	var r0 zerolog.Logger
	if returnFunc, ok := ret.Get(0).(func() zerolog.Logger); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(zerolog.Logger)
	}
	return r0
}

// LoggerProvider_Logger_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Logger'
type LoggerProvider_Logger_Call struct {
	*mock.Call
}

// Logger is a helper method to define mock.On call
func (_e *LoggerProvider_Expecter) Logger() *LoggerProvider_Logger_Call {
	return &LoggerProvider_Logger_Call{Call: _e.mock.On("Logger")}
}

func (_c *LoggerProvider_Logger_Call) Run(run func()) *LoggerProvider_Logger_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *LoggerProvider_Logger_Call) Return(logger zerolog.Logger) *LoggerProvider_Logger_Call {
	_c.Call.Return(logger)
	return _c
}

func (_c *LoggerProvider_Logger_Call) RunAndReturn(run func() zerolog.Logger) *LoggerProvider_Logger_Call {
	_c.Call.Return(run)
	return _c
}

// NewMeter creates a new instance of Meter. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMeter(t interface {
	mock.TestingT
	Cleanup(func())
}) *Meter {
	mock := &Meter{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Meter is an autogenerated mock type for the Meter type
type Meter struct {
	mock.Mock
}

type Meter_Expecter struct {
	mock *mock.Mock
}

func (_m *Meter) EXPECT() *Meter_Expecter {
	return &Meter_Expecter{mock: &_m.Mock}
}

// ComputationAvailable provides a mock function for the type Meter
func (_mock *Meter) ComputationAvailable(computationUsage common.ComputationUsage) bool {
	ret := _mock.Called(computationUsage)

	if len(ret) == 0 {
		panic("no return value specified for ComputationAvailable")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(common.ComputationUsage) bool); ok {
		r0 = returnFunc(computationUsage)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// Meter_ComputationAvailable_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ComputationAvailable'
type Meter_ComputationAvailable_Call struct {
	*mock.Call
}

// ComputationAvailable is a helper method to define mock.On call
//   - computationUsage common.ComputationUsage
func (_e *Meter_Expecter) ComputationAvailable(computationUsage interface{}) *Meter_ComputationAvailable_Call {
	return &Meter_ComputationAvailable_Call{Call: _e.mock.On("ComputationAvailable", computationUsage)}
}

func (_c *Meter_ComputationAvailable_Call) Run(run func(computationUsage common.ComputationUsage)) *Meter_ComputationAvailable_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 common.ComputationUsage
		if args[0] != nil {
			arg0 = args[0].(common.ComputationUsage)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Meter_ComputationAvailable_Call) Return(b bool) *Meter_ComputationAvailable_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *Meter_ComputationAvailable_Call) RunAndReturn(run func(computationUsage common.ComputationUsage) bool) *Meter_ComputationAvailable_Call {
	_c.Call.Return(run)
	return _c
}

// ComputationIntensities provides a mock function for the type Meter
func (_mock *Meter) ComputationIntensities() meter.MeteredComputationIntensities {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for ComputationIntensities")
	}

	var r0 meter.MeteredComputationIntensities
	if returnFunc, ok := ret.Get(0).(func() meter.MeteredComputationIntensities); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(meter.MeteredComputationIntensities)
		}
	}
	return r0
}

// Meter_ComputationIntensities_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ComputationIntensities'
type Meter_ComputationIntensities_Call struct {
	*mock.Call
}

// ComputationIntensities is a helper method to define mock.On call
func (_e *Meter_Expecter) ComputationIntensities() *Meter_ComputationIntensities_Call {
	return &Meter_ComputationIntensities_Call{Call: _e.mock.On("ComputationIntensities")}
}

func (_c *Meter_ComputationIntensities_Call) Run(run func()) *Meter_ComputationIntensities_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Meter_ComputationIntensities_Call) Return(meteredComputationIntensities meter.MeteredComputationIntensities) *Meter_ComputationIntensities_Call {
	_c.Call.Return(meteredComputationIntensities)
	return _c
}

func (_c *Meter_ComputationIntensities_Call) RunAndReturn(run func() meter.MeteredComputationIntensities) *Meter_ComputationIntensities_Call {
	_c.Call.Return(run)
	return _c
}

// ComputationRemaining provides a mock function for the type Meter
func (_mock *Meter) ComputationRemaining(kind common.ComputationKind) uint64 {
	ret := _mock.Called(kind)

	if len(ret) == 0 {
		panic("no return value specified for ComputationRemaining")
	}

	var r0 uint64
	if returnFunc, ok := ret.Get(0).(func(common.ComputationKind) uint64); ok {
		r0 = returnFunc(kind)
	} else {
		r0 = ret.Get(0).(uint64)
	}
	return r0
}

// Meter_ComputationRemaining_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ComputationRemaining'
type Meter_ComputationRemaining_Call struct {
	*mock.Call
}

// ComputationRemaining is a helper method to define mock.On call
//   - kind common.ComputationKind
func (_e *Meter_Expecter) ComputationRemaining(kind interface{}) *Meter_ComputationRemaining_Call {
	return &Meter_ComputationRemaining_Call{Call: _e.mock.On("ComputationRemaining", kind)}
}

func (_c *Meter_ComputationRemaining_Call) Run(run func(kind common.ComputationKind)) *Meter_ComputationRemaining_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 common.ComputationKind
		if args[0] != nil {
			arg0 = args[0].(common.ComputationKind)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Meter_ComputationRemaining_Call) Return(v uint64) *Meter_ComputationRemaining_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *Meter_ComputationRemaining_Call) RunAndReturn(run func(kind common.ComputationKind) uint64) *Meter_ComputationRemaining_Call {
	_c.Call.Return(run)
	return _c
}

// ComputationUsed provides a mock function for the type Meter
func (_mock *Meter) ComputationUsed() (uint64, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for ComputationUsed")
	}

	var r0 uint64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (uint64, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() uint64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint64)
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Meter_ComputationUsed_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ComputationUsed'
type Meter_ComputationUsed_Call struct {
	*mock.Call
}

// ComputationUsed is a helper method to define mock.On call
func (_e *Meter_Expecter) ComputationUsed() *Meter_ComputationUsed_Call {
	return &Meter_ComputationUsed_Call{Call: _e.mock.On("ComputationUsed")}
}

func (_c *Meter_ComputationUsed_Call) Run(run func()) *Meter_ComputationUsed_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Meter_ComputationUsed_Call) Return(v uint64, err error) *Meter_ComputationUsed_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *Meter_ComputationUsed_Call) RunAndReturn(run func() (uint64, error)) *Meter_ComputationUsed_Call {
	_c.Call.Return(run)
	return _c
}

// MemoryUsed provides a mock function for the type Meter
func (_mock *Meter) MemoryUsed() (uint64, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for MemoryUsed")
	}

	var r0 uint64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (uint64, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() uint64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint64)
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Meter_MemoryUsed_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MemoryUsed'
type Meter_MemoryUsed_Call struct {
	*mock.Call
}

// MemoryUsed is a helper method to define mock.On call
func (_e *Meter_Expecter) MemoryUsed() *Meter_MemoryUsed_Call {
	return &Meter_MemoryUsed_Call{Call: _e.mock.On("MemoryUsed")}
}

func (_c *Meter_MemoryUsed_Call) Run(run func()) *Meter_MemoryUsed_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Meter_MemoryUsed_Call) Return(v uint64, err error) *Meter_MemoryUsed_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *Meter_MemoryUsed_Call) RunAndReturn(run func() (uint64, error)) *Meter_MemoryUsed_Call {
	_c.Call.Return(run)
	return _c
}

// MeterComputation provides a mock function for the type Meter
func (_mock *Meter) MeterComputation(usage common.ComputationUsage) error {
	ret := _mock.Called(usage)

	if len(ret) == 0 {
		panic("no return value specified for MeterComputation")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(common.ComputationUsage) error); ok {
		r0 = returnFunc(usage)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Meter_MeterComputation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MeterComputation'
type Meter_MeterComputation_Call struct {
	*mock.Call
}

// MeterComputation is a helper method to define mock.On call
//   - usage common.ComputationUsage
func (_e *Meter_Expecter) MeterComputation(usage interface{}) *Meter_MeterComputation_Call {
	return &Meter_MeterComputation_Call{Call: _e.mock.On("MeterComputation", usage)}
}

func (_c *Meter_MeterComputation_Call) Run(run func(usage common.ComputationUsage)) *Meter_MeterComputation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 common.ComputationUsage
		if args[0] != nil {
			arg0 = args[0].(common.ComputationUsage)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Meter_MeterComputation_Call) Return(err error) *Meter_MeterComputation_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Meter_MeterComputation_Call) RunAndReturn(run func(usage common.ComputationUsage) error) *Meter_MeterComputation_Call {
	_c.Call.Return(run)
	return _c
}

// MeterEmittedEvent provides a mock function for the type Meter
func (_mock *Meter) MeterEmittedEvent(byteSize uint64) error {
	ret := _mock.Called(byteSize)

	if len(ret) == 0 {
		panic("no return value specified for MeterEmittedEvent")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(uint64) error); ok {
		r0 = returnFunc(byteSize)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Meter_MeterEmittedEvent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MeterEmittedEvent'
type Meter_MeterEmittedEvent_Call struct {
	*mock.Call
}

// MeterEmittedEvent is a helper method to define mock.On call
//   - byteSize uint64
func (_e *Meter_Expecter) MeterEmittedEvent(byteSize interface{}) *Meter_MeterEmittedEvent_Call {
	return &Meter_MeterEmittedEvent_Call{Call: _e.mock.On("MeterEmittedEvent", byteSize)}
}

func (_c *Meter_MeterEmittedEvent_Call) Run(run func(byteSize uint64)) *Meter_MeterEmittedEvent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Meter_MeterEmittedEvent_Call) Return(err error) *Meter_MeterEmittedEvent_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Meter_MeterEmittedEvent_Call) RunAndReturn(run func(byteSize uint64) error) *Meter_MeterEmittedEvent_Call {
	_c.Call.Return(run)
	return _c
}

// MeterMemory provides a mock function for the type Meter
func (_mock *Meter) MeterMemory(usage common.MemoryUsage) error {
	ret := _mock.Called(usage)

	if len(ret) == 0 {
		panic("no return value specified for MeterMemory")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(common.MemoryUsage) error); ok {
		r0 = returnFunc(usage)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Meter_MeterMemory_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MeterMemory'
type Meter_MeterMemory_Call struct {
	*mock.Call
}

// MeterMemory is a helper method to define mock.On call
//   - usage common.MemoryUsage
func (_e *Meter_Expecter) MeterMemory(usage interface{}) *Meter_MeterMemory_Call {
	return &Meter_MeterMemory_Call{Call: _e.mock.On("MeterMemory", usage)}
}

func (_c *Meter_MeterMemory_Call) Run(run func(usage common.MemoryUsage)) *Meter_MeterMemory_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 common.MemoryUsage
		if args[0] != nil {
			arg0 = args[0].(common.MemoryUsage)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Meter_MeterMemory_Call) Return(err error) *Meter_MeterMemory_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Meter_MeterMemory_Call) RunAndReturn(run func(usage common.MemoryUsage) error) *Meter_MeterMemory_Call {
	_c.Call.Return(run)
	return _c
}

// RunWithMeteringDisabled provides a mock function for the type Meter
func (_mock *Meter) RunWithMeteringDisabled(f func()) {
	_mock.Called(f)
	return
}

// Meter_RunWithMeteringDisabled_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RunWithMeteringDisabled'
type Meter_RunWithMeteringDisabled_Call struct {
	*mock.Call
}

// RunWithMeteringDisabled is a helper method to define mock.On call
//   - f func()
func (_e *Meter_Expecter) RunWithMeteringDisabled(f interface{}) *Meter_RunWithMeteringDisabled_Call {
	return &Meter_RunWithMeteringDisabled_Call{Call: _e.mock.On("RunWithMeteringDisabled", f)}
}

func (_c *Meter_RunWithMeteringDisabled_Call) Run(run func(f func())) *Meter_RunWithMeteringDisabled_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 func()
		if args[0] != nil {
			arg0 = args[0].(func())
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Meter_RunWithMeteringDisabled_Call) Return() *Meter_RunWithMeteringDisabled_Call {
	_c.Call.Return()
	return _c
}

func (_c *Meter_RunWithMeteringDisabled_Call) RunAndReturn(run func(f func())) *Meter_RunWithMeteringDisabled_Call {
	_c.Run(run)
	return _c
}

// TotalEmittedEventBytes provides a mock function for the type Meter
func (_mock *Meter) TotalEmittedEventBytes() uint64 {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for TotalEmittedEventBytes")
	}

	var r0 uint64
	if returnFunc, ok := ret.Get(0).(func() uint64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint64)
	}
	return r0
}

// Meter_TotalEmittedEventBytes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TotalEmittedEventBytes'
type Meter_TotalEmittedEventBytes_Call struct {
	*mock.Call
}

// TotalEmittedEventBytes is a helper method to define mock.On call
func (_e *Meter_Expecter) TotalEmittedEventBytes() *Meter_TotalEmittedEventBytes_Call {
	return &Meter_TotalEmittedEventBytes_Call{Call: _e.mock.On("TotalEmittedEventBytes")}
}

func (_c *Meter_TotalEmittedEventBytes_Call) Run(run func()) *Meter_TotalEmittedEventBytes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Meter_TotalEmittedEventBytes_Call) Return(v uint64) *Meter_TotalEmittedEventBytes_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *Meter_TotalEmittedEventBytes_Call) RunAndReturn(run func() uint64) *Meter_TotalEmittedEventBytes_Call {
	_c.Call.Return(run)
	return _c
}

// NewExecutionVersionProvider creates a new instance of ExecutionVersionProvider. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewExecutionVersionProvider(t interface {
	mock.TestingT
	Cleanup(func())
}) *ExecutionVersionProvider {
	mock := &ExecutionVersionProvider{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// ExecutionVersionProvider is an autogenerated mock type for the ExecutionVersionProvider type
type ExecutionVersionProvider struct {
	mock.Mock
}

type ExecutionVersionProvider_Expecter struct {
	mock *mock.Mock
}

func (_m *ExecutionVersionProvider) EXPECT() *ExecutionVersionProvider_Expecter {
	return &ExecutionVersionProvider_Expecter{mock: &_m.Mock}
}

// ExecutionVersion provides a mock function for the type ExecutionVersionProvider
func (_mock *ExecutionVersionProvider) ExecutionVersion() (semver.Version, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for ExecutionVersion")
	}

	var r0 semver.Version
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (semver.Version, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() semver.Version); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(semver.Version)
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ExecutionVersionProvider_ExecutionVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExecutionVersion'
type ExecutionVersionProvider_ExecutionVersion_Call struct {
	*mock.Call
}

// ExecutionVersion is a helper method to define mock.On call
func (_e *ExecutionVersionProvider_Expecter) ExecutionVersion() *ExecutionVersionProvider_ExecutionVersion_Call {
	return &ExecutionVersionProvider_ExecutionVersion_Call{Call: _e.mock.On("ExecutionVersion")}
}

func (_c *ExecutionVersionProvider_ExecutionVersion_Call) Run(run func()) *ExecutionVersionProvider_ExecutionVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ExecutionVersionProvider_ExecutionVersion_Call) Return(version semver.Version, err error) *ExecutionVersionProvider_ExecutionVersion_Call {
	_c.Call.Return(version, err)
	return _c
}

func (_c *ExecutionVersionProvider_ExecutionVersion_Call) RunAndReturn(run func() (semver.Version, error)) *ExecutionVersionProvider_ExecutionVersion_Call {
	_c.Call.Return(run)
	return _c
}

// NewMinimumCadenceRequiredVersion creates a new instance of MinimumCadenceRequiredVersion. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMinimumCadenceRequiredVersion(t interface {
	mock.TestingT
	Cleanup(func())
}) *MinimumCadenceRequiredVersion {
	mock := &MinimumCadenceRequiredVersion{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MinimumCadenceRequiredVersion is an autogenerated mock type for the MinimumCadenceRequiredVersion type
type MinimumCadenceRequiredVersion struct {
	mock.Mock
}

type MinimumCadenceRequiredVersion_Expecter struct {
	mock *mock.Mock
}

func (_m *MinimumCadenceRequiredVersion) EXPECT() *MinimumCadenceRequiredVersion_Expecter {
	return &MinimumCadenceRequiredVersion_Expecter{mock: &_m.Mock}
}

// MinimumRequiredVersion provides a mock function for the type MinimumCadenceRequiredVersion
func (_mock *MinimumCadenceRequiredVersion) MinimumRequiredVersion() (string, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for MinimumRequiredVersion")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (string, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() string); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MinimumCadenceRequiredVersion_MinimumRequiredVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MinimumRequiredVersion'
type MinimumCadenceRequiredVersion_MinimumRequiredVersion_Call struct {
	*mock.Call
}

// MinimumRequiredVersion is a helper method to define mock.On call
func (_e *MinimumCadenceRequiredVersion_Expecter) MinimumRequiredVersion() *MinimumCadenceRequiredVersion_MinimumRequiredVersion_Call {
	return &MinimumCadenceRequiredVersion_MinimumRequiredVersion_Call{Call: _e.mock.On("MinimumRequiredVersion")}
}

func (_c *MinimumCadenceRequiredVersion_MinimumRequiredVersion_Call) Run(run func()) *MinimumCadenceRequiredVersion_MinimumRequiredVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MinimumCadenceRequiredVersion_MinimumRequiredVersion_Call) Return(s string, err error) *MinimumCadenceRequiredVersion_MinimumRequiredVersion_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *MinimumCadenceRequiredVersion_MinimumRequiredVersion_Call) RunAndReturn(run func() (string, error)) *MinimumCadenceRequiredVersion_MinimumRequiredVersion_Call {
	_c.Call.Return(run)
	return _c
}

// NewEVMMetricsReporter creates a new instance of EVMMetricsReporter. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewEVMMetricsReporter(t interface {
	mock.TestingT
	Cleanup(func())
}) *EVMMetricsReporter {
	mock := &EVMMetricsReporter{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// EVMMetricsReporter is an autogenerated mock type for the EVMMetricsReporter type
type EVMMetricsReporter struct {
	mock.Mock
}

type EVMMetricsReporter_Expecter struct {
	mock *mock.Mock
}

func (_m *EVMMetricsReporter) EXPECT() *EVMMetricsReporter_Expecter {
	return &EVMMetricsReporter_Expecter{mock: &_m.Mock}
}

// EVMBlockExecuted provides a mock function for the type EVMMetricsReporter
func (_mock *EVMMetricsReporter) EVMBlockExecuted(txCount int, totalGasUsed uint64, totalSupplyInFlow float64) {
	_mock.Called(txCount, totalGasUsed, totalSupplyInFlow)
	return
}

// EVMMetricsReporter_EVMBlockExecuted_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EVMBlockExecuted'
type EVMMetricsReporter_EVMBlockExecuted_Call struct {
	*mock.Call
}

// EVMBlockExecuted is a helper method to define mock.On call
//   - txCount int
//   - totalGasUsed uint64
//   - totalSupplyInFlow float64
func (_e *EVMMetricsReporter_Expecter) EVMBlockExecuted(txCount interface{}, totalGasUsed interface{}, totalSupplyInFlow interface{}) *EVMMetricsReporter_EVMBlockExecuted_Call {
	return &EVMMetricsReporter_EVMBlockExecuted_Call{Call: _e.mock.On("EVMBlockExecuted", txCount, totalGasUsed, totalSupplyInFlow)}
}

func (_c *EVMMetricsReporter_EVMBlockExecuted_Call) Run(run func(txCount int, totalGasUsed uint64, totalSupplyInFlow float64)) *EVMMetricsReporter_EVMBlockExecuted_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 int
		if args[0] != nil {
			arg0 = args[0].(int)
		}
		var arg1 uint64
		if args[1] != nil {
			arg1 = args[1].(uint64)
		}
		var arg2 float64
		if args[2] != nil {
			arg2 = args[2].(float64)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *EVMMetricsReporter_EVMBlockExecuted_Call) Return() *EVMMetricsReporter_EVMBlockExecuted_Call {
	_c.Call.Return()
	return _c
}

func (_c *EVMMetricsReporter_EVMBlockExecuted_Call) RunAndReturn(run func(txCount int, totalGasUsed uint64, totalSupplyInFlow float64)) *EVMMetricsReporter_EVMBlockExecuted_Call {
	_c.Run(run)
	return _c
}

// EVMTransactionExecuted provides a mock function for the type EVMMetricsReporter
func (_mock *EVMMetricsReporter) EVMTransactionExecuted(gasUsed uint64, isDirectCall bool, failed bool) {
	_mock.Called(gasUsed, isDirectCall, failed)
	return
}

// EVMMetricsReporter_EVMTransactionExecuted_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EVMTransactionExecuted'
type EVMMetricsReporter_EVMTransactionExecuted_Call struct {
	*mock.Call
}

// EVMTransactionExecuted is a helper method to define mock.On call
//   - gasUsed uint64
//   - isDirectCall bool
//   - failed bool
func (_e *EVMMetricsReporter_Expecter) EVMTransactionExecuted(gasUsed interface{}, isDirectCall interface{}, failed interface{}) *EVMMetricsReporter_EVMTransactionExecuted_Call {
	return &EVMMetricsReporter_EVMTransactionExecuted_Call{Call: _e.mock.On("EVMTransactionExecuted", gasUsed, isDirectCall, failed)}
}

func (_c *EVMMetricsReporter_EVMTransactionExecuted_Call) Run(run func(gasUsed uint64, isDirectCall bool, failed bool)) *EVMMetricsReporter_EVMTransactionExecuted_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		var arg1 bool
		if args[1] != nil {
			arg1 = args[1].(bool)
		}
		var arg2 bool
		if args[2] != nil {
			arg2 = args[2].(bool)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *EVMMetricsReporter_EVMTransactionExecuted_Call) Return() *EVMMetricsReporter_EVMTransactionExecuted_Call {
	_c.Call.Return()
	return _c
}

func (_c *EVMMetricsReporter_EVMTransactionExecuted_Call) RunAndReturn(run func(gasUsed uint64, isDirectCall bool, failed bool)) *EVMMetricsReporter_EVMTransactionExecuted_Call {
	_c.Run(run)
	return _c
}

// SetNumberOfDeployedCOAs provides a mock function for the type EVMMetricsReporter
func (_mock *EVMMetricsReporter) SetNumberOfDeployedCOAs(count uint64) {
	_mock.Called(count)
	return
}

// EVMMetricsReporter_SetNumberOfDeployedCOAs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetNumberOfDeployedCOAs'
type EVMMetricsReporter_SetNumberOfDeployedCOAs_Call struct {
	*mock.Call
}

// SetNumberOfDeployedCOAs is a helper method to define mock.On call
//   - count uint64
func (_e *EVMMetricsReporter_Expecter) SetNumberOfDeployedCOAs(count interface{}) *EVMMetricsReporter_SetNumberOfDeployedCOAs_Call {
	return &EVMMetricsReporter_SetNumberOfDeployedCOAs_Call{Call: _e.mock.On("SetNumberOfDeployedCOAs", count)}
}

func (_c *EVMMetricsReporter_SetNumberOfDeployedCOAs_Call) Run(run func(count uint64)) *EVMMetricsReporter_SetNumberOfDeployedCOAs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *EVMMetricsReporter_SetNumberOfDeployedCOAs_Call) Return() *EVMMetricsReporter_SetNumberOfDeployedCOAs_Call {
	_c.Call.Return()
	return _c
}

func (_c *EVMMetricsReporter_SetNumberOfDeployedCOAs_Call) RunAndReturn(run func(count uint64)) *EVMMetricsReporter_SetNumberOfDeployedCOAs_Call {
	_c.Run(run)
	return _c
}

// NewRuntimeMetricsReporter creates a new instance of RuntimeMetricsReporter. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewRuntimeMetricsReporter(t interface {
	mock.TestingT
	Cleanup(func())
}) *RuntimeMetricsReporter {
	mock := &RuntimeMetricsReporter{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// RuntimeMetricsReporter is an autogenerated mock type for the RuntimeMetricsReporter type
type RuntimeMetricsReporter struct {
	mock.Mock
}

type RuntimeMetricsReporter_Expecter struct {
	mock *mock.Mock
}

func (_m *RuntimeMetricsReporter) EXPECT() *RuntimeMetricsReporter_Expecter {
	return &RuntimeMetricsReporter_Expecter{mock: &_m.Mock}
}

// RuntimeSetNumberOfAccounts provides a mock function for the type RuntimeMetricsReporter
func (_mock *RuntimeMetricsReporter) RuntimeSetNumberOfAccounts(count uint64) {
	_mock.Called(count)
	return
}

// RuntimeMetricsReporter_RuntimeSetNumberOfAccounts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RuntimeSetNumberOfAccounts'
type RuntimeMetricsReporter_RuntimeSetNumberOfAccounts_Call struct {
	*mock.Call
}

// RuntimeSetNumberOfAccounts is a helper method to define mock.On call
//   - count uint64
func (_e *RuntimeMetricsReporter_Expecter) RuntimeSetNumberOfAccounts(count interface{}) *RuntimeMetricsReporter_RuntimeSetNumberOfAccounts_Call {
	return &RuntimeMetricsReporter_RuntimeSetNumberOfAccounts_Call{Call: _e.mock.On("RuntimeSetNumberOfAccounts", count)}
}

func (_c *RuntimeMetricsReporter_RuntimeSetNumberOfAccounts_Call) Run(run func(count uint64)) *RuntimeMetricsReporter_RuntimeSetNumberOfAccounts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *RuntimeMetricsReporter_RuntimeSetNumberOfAccounts_Call) Return() *RuntimeMetricsReporter_RuntimeSetNumberOfAccounts_Call {
	_c.Call.Return()
	return _c
}

func (_c *RuntimeMetricsReporter_RuntimeSetNumberOfAccounts_Call) RunAndReturn(run func(count uint64)) *RuntimeMetricsReporter_RuntimeSetNumberOfAccounts_Call {
	_c.Run(run)
	return _c
}

// RuntimeTransactionChecked provides a mock function for the type RuntimeMetricsReporter
func (_mock *RuntimeMetricsReporter) RuntimeTransactionChecked(duration time.Duration) {
	_mock.Called(duration)
	return
}

// RuntimeMetricsReporter_RuntimeTransactionChecked_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RuntimeTransactionChecked'
type RuntimeMetricsReporter_RuntimeTransactionChecked_Call struct {
	*mock.Call
}

// RuntimeTransactionChecked is a helper method to define mock.On call
//   - duration time.Duration
func (_e *RuntimeMetricsReporter_Expecter) RuntimeTransactionChecked(duration interface{}) *RuntimeMetricsReporter_RuntimeTransactionChecked_Call {
	return &RuntimeMetricsReporter_RuntimeTransactionChecked_Call{Call: _e.mock.On("RuntimeTransactionChecked", duration)}
}

func (_c *RuntimeMetricsReporter_RuntimeTransactionChecked_Call) Run(run func(duration time.Duration)) *RuntimeMetricsReporter_RuntimeTransactionChecked_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 time.Duration
		if args[0] != nil {
			arg0 = args[0].(time.Duration)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *RuntimeMetricsReporter_RuntimeTransactionChecked_Call) Return() *RuntimeMetricsReporter_RuntimeTransactionChecked_Call {
	_c.Call.Return()
	return _c
}

func (_c *RuntimeMetricsReporter_RuntimeTransactionChecked_Call) RunAndReturn(run func(duration time.Duration)) *RuntimeMetricsReporter_RuntimeTransactionChecked_Call {
	_c.Run(run)
	return _c
}

// RuntimeTransactionInterpreted provides a mock function for the type RuntimeMetricsReporter
func (_mock *RuntimeMetricsReporter) RuntimeTransactionInterpreted(duration time.Duration) {
	_mock.Called(duration)
	return
}

// RuntimeMetricsReporter_RuntimeTransactionInterpreted_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RuntimeTransactionInterpreted'
type RuntimeMetricsReporter_RuntimeTransactionInterpreted_Call struct {
	*mock.Call
}

// RuntimeTransactionInterpreted is a helper method to define mock.On call
//   - duration time.Duration
func (_e *RuntimeMetricsReporter_Expecter) RuntimeTransactionInterpreted(duration interface{}) *RuntimeMetricsReporter_RuntimeTransactionInterpreted_Call {
	return &RuntimeMetricsReporter_RuntimeTransactionInterpreted_Call{Call: _e.mock.On("RuntimeTransactionInterpreted", duration)}
}

func (_c *RuntimeMetricsReporter_RuntimeTransactionInterpreted_Call) Run(run func(duration time.Duration)) *RuntimeMetricsReporter_RuntimeTransactionInterpreted_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 time.Duration
		if args[0] != nil {
			arg0 = args[0].(time.Duration)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *RuntimeMetricsReporter_RuntimeTransactionInterpreted_Call) Return() *RuntimeMetricsReporter_RuntimeTransactionInterpreted_Call {
	_c.Call.Return()
	return _c
}

func (_c *RuntimeMetricsReporter_RuntimeTransactionInterpreted_Call) RunAndReturn(run func(duration time.Duration)) *RuntimeMetricsReporter_RuntimeTransactionInterpreted_Call {
	_c.Run(run)
	return _c
}

// RuntimeTransactionParsed provides a mock function for the type RuntimeMetricsReporter
func (_mock *RuntimeMetricsReporter) RuntimeTransactionParsed(duration time.Duration) {
	_mock.Called(duration)
	return
}

// RuntimeMetricsReporter_RuntimeTransactionParsed_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RuntimeTransactionParsed'
type RuntimeMetricsReporter_RuntimeTransactionParsed_Call struct {
	*mock.Call
}

// RuntimeTransactionParsed is a helper method to define mock.On call
//   - duration time.Duration
func (_e *RuntimeMetricsReporter_Expecter) RuntimeTransactionParsed(duration interface{}) *RuntimeMetricsReporter_RuntimeTransactionParsed_Call {
	return &RuntimeMetricsReporter_RuntimeTransactionParsed_Call{Call: _e.mock.On("RuntimeTransactionParsed", duration)}
}

func (_c *RuntimeMetricsReporter_RuntimeTransactionParsed_Call) Run(run func(duration time.Duration)) *RuntimeMetricsReporter_RuntimeTransactionParsed_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 time.Duration
		if args[0] != nil {
			arg0 = args[0].(time.Duration)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *RuntimeMetricsReporter_RuntimeTransactionParsed_Call) Return() *RuntimeMetricsReporter_RuntimeTransactionParsed_Call {
	_c.Call.Return()
	return _c
}

func (_c *RuntimeMetricsReporter_RuntimeTransactionParsed_Call) RunAndReturn(run func(duration time.Duration)) *RuntimeMetricsReporter_RuntimeTransactionParsed_Call {
	_c.Run(run)
	return _c
}

// RuntimeTransactionProgramsCacheHit provides a mock function for the type RuntimeMetricsReporter
func (_mock *RuntimeMetricsReporter) RuntimeTransactionProgramsCacheHit() {
	_mock.Called()
	return
}

// RuntimeMetricsReporter_RuntimeTransactionProgramsCacheHit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RuntimeTransactionProgramsCacheHit'
type RuntimeMetricsReporter_RuntimeTransactionProgramsCacheHit_Call struct {
	*mock.Call
}

// RuntimeTransactionProgramsCacheHit is a helper method to define mock.On call
func (_e *RuntimeMetricsReporter_Expecter) RuntimeTransactionProgramsCacheHit() *RuntimeMetricsReporter_RuntimeTransactionProgramsCacheHit_Call {
	return &RuntimeMetricsReporter_RuntimeTransactionProgramsCacheHit_Call{Call: _e.mock.On("RuntimeTransactionProgramsCacheHit")}
}

func (_c *RuntimeMetricsReporter_RuntimeTransactionProgramsCacheHit_Call) Run(run func()) *RuntimeMetricsReporter_RuntimeTransactionProgramsCacheHit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *RuntimeMetricsReporter_RuntimeTransactionProgramsCacheHit_Call) Return() *RuntimeMetricsReporter_RuntimeTransactionProgramsCacheHit_Call {
	_c.Call.Return()
	return _c
}

func (_c *RuntimeMetricsReporter_RuntimeTransactionProgramsCacheHit_Call) RunAndReturn(run func()) *RuntimeMetricsReporter_RuntimeTransactionProgramsCacheHit_Call {
	_c.Run(run)
	return _c
}

// RuntimeTransactionProgramsCacheMiss provides a mock function for the type RuntimeMetricsReporter
func (_mock *RuntimeMetricsReporter) RuntimeTransactionProgramsCacheMiss() {
	_mock.Called()
	return
}

// RuntimeMetricsReporter_RuntimeTransactionProgramsCacheMiss_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RuntimeTransactionProgramsCacheMiss'
type RuntimeMetricsReporter_RuntimeTransactionProgramsCacheMiss_Call struct {
	*mock.Call
}

// RuntimeTransactionProgramsCacheMiss is a helper method to define mock.On call
func (_e *RuntimeMetricsReporter_Expecter) RuntimeTransactionProgramsCacheMiss() *RuntimeMetricsReporter_RuntimeTransactionProgramsCacheMiss_Call {
	return &RuntimeMetricsReporter_RuntimeTransactionProgramsCacheMiss_Call{Call: _e.mock.On("RuntimeTransactionProgramsCacheMiss")}
}

func (_c *RuntimeMetricsReporter_RuntimeTransactionProgramsCacheMiss_Call) Run(run func()) *RuntimeMetricsReporter_RuntimeTransactionProgramsCacheMiss_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *RuntimeMetricsReporter_RuntimeTransactionProgramsCacheMiss_Call) Return() *RuntimeMetricsReporter_RuntimeTransactionProgramsCacheMiss_Call {
	_c.Call.Return()
	return _c
}

func (_c *RuntimeMetricsReporter_RuntimeTransactionProgramsCacheMiss_Call) RunAndReturn(run func()) *RuntimeMetricsReporter_RuntimeTransactionProgramsCacheMiss_Call {
	_c.Run(run)
	return _c
}

// NewMetricsReporter creates a new instance of MetricsReporter. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMetricsReporter(t interface {
	mock.TestingT
	Cleanup(func())
}) *MetricsReporter {
	mock := &MetricsReporter{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MetricsReporter is an autogenerated mock type for the MetricsReporter type
type MetricsReporter struct {
	mock.Mock
}

type MetricsReporter_Expecter struct {
	mock *mock.Mock
}

func (_m *MetricsReporter) EXPECT() *MetricsReporter_Expecter {
	return &MetricsReporter_Expecter{mock: &_m.Mock}
}

// EVMBlockExecuted provides a mock function for the type MetricsReporter
func (_mock *MetricsReporter) EVMBlockExecuted(txCount int, totalGasUsed uint64, totalSupplyInFlow float64) {
	_mock.Called(txCount, totalGasUsed, totalSupplyInFlow)
	return
}

// MetricsReporter_EVMBlockExecuted_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EVMBlockExecuted'
type MetricsReporter_EVMBlockExecuted_Call struct {
	*mock.Call
}

// EVMBlockExecuted is a helper method to define mock.On call
//   - txCount int
//   - totalGasUsed uint64
//   - totalSupplyInFlow float64
func (_e *MetricsReporter_Expecter) EVMBlockExecuted(txCount interface{}, totalGasUsed interface{}, totalSupplyInFlow interface{}) *MetricsReporter_EVMBlockExecuted_Call {
	return &MetricsReporter_EVMBlockExecuted_Call{Call: _e.mock.On("EVMBlockExecuted", txCount, totalGasUsed, totalSupplyInFlow)}
}

func (_c *MetricsReporter_EVMBlockExecuted_Call) Run(run func(txCount int, totalGasUsed uint64, totalSupplyInFlow float64)) *MetricsReporter_EVMBlockExecuted_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 int
		if args[0] != nil {
			arg0 = args[0].(int)
		}
		var arg1 uint64
		if args[1] != nil {
			arg1 = args[1].(uint64)
		}
		var arg2 float64
		if args[2] != nil {
			arg2 = args[2].(float64)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MetricsReporter_EVMBlockExecuted_Call) Return() *MetricsReporter_EVMBlockExecuted_Call {
	_c.Call.Return()
	return _c
}

func (_c *MetricsReporter_EVMBlockExecuted_Call) RunAndReturn(run func(txCount int, totalGasUsed uint64, totalSupplyInFlow float64)) *MetricsReporter_EVMBlockExecuted_Call {
	_c.Run(run)
	return _c
}

// EVMTransactionExecuted provides a mock function for the type MetricsReporter
func (_mock *MetricsReporter) EVMTransactionExecuted(gasUsed uint64, isDirectCall bool, failed bool) {
	_mock.Called(gasUsed, isDirectCall, failed)
	return
}

// MetricsReporter_EVMTransactionExecuted_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EVMTransactionExecuted'
type MetricsReporter_EVMTransactionExecuted_Call struct {
	*mock.Call
}

// EVMTransactionExecuted is a helper method to define mock.On call
//   - gasUsed uint64
//   - isDirectCall bool
//   - failed bool
func (_e *MetricsReporter_Expecter) EVMTransactionExecuted(gasUsed interface{}, isDirectCall interface{}, failed interface{}) *MetricsReporter_EVMTransactionExecuted_Call {
	return &MetricsReporter_EVMTransactionExecuted_Call{Call: _e.mock.On("EVMTransactionExecuted", gasUsed, isDirectCall, failed)}
}

func (_c *MetricsReporter_EVMTransactionExecuted_Call) Run(run func(gasUsed uint64, isDirectCall bool, failed bool)) *MetricsReporter_EVMTransactionExecuted_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		var arg1 bool
		if args[1] != nil {
			arg1 = args[1].(bool)
		}
		var arg2 bool
		if args[2] != nil {
			arg2 = args[2].(bool)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MetricsReporter_EVMTransactionExecuted_Call) Return() *MetricsReporter_EVMTransactionExecuted_Call {
	_c.Call.Return()
	return _c
}

func (_c *MetricsReporter_EVMTransactionExecuted_Call) RunAndReturn(run func(gasUsed uint64, isDirectCall bool, failed bool)) *MetricsReporter_EVMTransactionExecuted_Call {
	_c.Run(run)
	return _c
}

// RuntimeSetNumberOfAccounts provides a mock function for the type MetricsReporter
func (_mock *MetricsReporter) RuntimeSetNumberOfAccounts(count uint64) {
	_mock.Called(count)
	return
}

// MetricsReporter_RuntimeSetNumberOfAccounts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RuntimeSetNumberOfAccounts'
type MetricsReporter_RuntimeSetNumberOfAccounts_Call struct {
	*mock.Call
}

// RuntimeSetNumberOfAccounts is a helper method to define mock.On call
//   - count uint64
func (_e *MetricsReporter_Expecter) RuntimeSetNumberOfAccounts(count interface{}) *MetricsReporter_RuntimeSetNumberOfAccounts_Call {
	return &MetricsReporter_RuntimeSetNumberOfAccounts_Call{Call: _e.mock.On("RuntimeSetNumberOfAccounts", count)}
}

func (_c *MetricsReporter_RuntimeSetNumberOfAccounts_Call) Run(run func(count uint64)) *MetricsReporter_RuntimeSetNumberOfAccounts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MetricsReporter_RuntimeSetNumberOfAccounts_Call) Return() *MetricsReporter_RuntimeSetNumberOfAccounts_Call {
	_c.Call.Return()
	return _c
}

func (_c *MetricsReporter_RuntimeSetNumberOfAccounts_Call) RunAndReturn(run func(count uint64)) *MetricsReporter_RuntimeSetNumberOfAccounts_Call {
	_c.Run(run)
	return _c
}

// RuntimeTransactionChecked provides a mock function for the type MetricsReporter
func (_mock *MetricsReporter) RuntimeTransactionChecked(duration time.Duration) {
	_mock.Called(duration)
	return
}

// MetricsReporter_RuntimeTransactionChecked_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RuntimeTransactionChecked'
type MetricsReporter_RuntimeTransactionChecked_Call struct {
	*mock.Call
}

// RuntimeTransactionChecked is a helper method to define mock.On call
//   - duration time.Duration
func (_e *MetricsReporter_Expecter) RuntimeTransactionChecked(duration interface{}) *MetricsReporter_RuntimeTransactionChecked_Call {
	return &MetricsReporter_RuntimeTransactionChecked_Call{Call: _e.mock.On("RuntimeTransactionChecked", duration)}
}

func (_c *MetricsReporter_RuntimeTransactionChecked_Call) Run(run func(duration time.Duration)) *MetricsReporter_RuntimeTransactionChecked_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 time.Duration
		if args[0] != nil {
			arg0 = args[0].(time.Duration)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MetricsReporter_RuntimeTransactionChecked_Call) Return() *MetricsReporter_RuntimeTransactionChecked_Call {
	_c.Call.Return()
	return _c
}

func (_c *MetricsReporter_RuntimeTransactionChecked_Call) RunAndReturn(run func(duration time.Duration)) *MetricsReporter_RuntimeTransactionChecked_Call {
	_c.Run(run)
	return _c
}

// RuntimeTransactionInterpreted provides a mock function for the type MetricsReporter
func (_mock *MetricsReporter) RuntimeTransactionInterpreted(duration time.Duration) {
	_mock.Called(duration)
	return
}

// MetricsReporter_RuntimeTransactionInterpreted_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RuntimeTransactionInterpreted'
type MetricsReporter_RuntimeTransactionInterpreted_Call struct {
	*mock.Call
}

// RuntimeTransactionInterpreted is a helper method to define mock.On call
//   - duration time.Duration
func (_e *MetricsReporter_Expecter) RuntimeTransactionInterpreted(duration interface{}) *MetricsReporter_RuntimeTransactionInterpreted_Call {
	return &MetricsReporter_RuntimeTransactionInterpreted_Call{Call: _e.mock.On("RuntimeTransactionInterpreted", duration)}
}

func (_c *MetricsReporter_RuntimeTransactionInterpreted_Call) Run(run func(duration time.Duration)) *MetricsReporter_RuntimeTransactionInterpreted_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 time.Duration
		if args[0] != nil {
			arg0 = args[0].(time.Duration)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MetricsReporter_RuntimeTransactionInterpreted_Call) Return() *MetricsReporter_RuntimeTransactionInterpreted_Call {
	_c.Call.Return()
	return _c
}

func (_c *MetricsReporter_RuntimeTransactionInterpreted_Call) RunAndReturn(run func(duration time.Duration)) *MetricsReporter_RuntimeTransactionInterpreted_Call {
	_c.Run(run)
	return _c
}

// RuntimeTransactionParsed provides a mock function for the type MetricsReporter
func (_mock *MetricsReporter) RuntimeTransactionParsed(duration time.Duration) {
	_mock.Called(duration)
	return
}

// MetricsReporter_RuntimeTransactionParsed_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RuntimeTransactionParsed'
type MetricsReporter_RuntimeTransactionParsed_Call struct {
	*mock.Call
}

// RuntimeTransactionParsed is a helper method to define mock.On call
//   - duration time.Duration
func (_e *MetricsReporter_Expecter) RuntimeTransactionParsed(duration interface{}) *MetricsReporter_RuntimeTransactionParsed_Call {
	return &MetricsReporter_RuntimeTransactionParsed_Call{Call: _e.mock.On("RuntimeTransactionParsed", duration)}
}

func (_c *MetricsReporter_RuntimeTransactionParsed_Call) Run(run func(duration time.Duration)) *MetricsReporter_RuntimeTransactionParsed_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 time.Duration
		if args[0] != nil {
			arg0 = args[0].(time.Duration)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MetricsReporter_RuntimeTransactionParsed_Call) Return() *MetricsReporter_RuntimeTransactionParsed_Call {
	_c.Call.Return()
	return _c
}

func (_c *MetricsReporter_RuntimeTransactionParsed_Call) RunAndReturn(run func(duration time.Duration)) *MetricsReporter_RuntimeTransactionParsed_Call {
	_c.Run(run)
	return _c
}

// RuntimeTransactionProgramsCacheHit provides a mock function for the type MetricsReporter
func (_mock *MetricsReporter) RuntimeTransactionProgramsCacheHit() {
	_mock.Called()
	return
}

// MetricsReporter_RuntimeTransactionProgramsCacheHit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RuntimeTransactionProgramsCacheHit'
type MetricsReporter_RuntimeTransactionProgramsCacheHit_Call struct {
	*mock.Call
}

// RuntimeTransactionProgramsCacheHit is a helper method to define mock.On call
func (_e *MetricsReporter_Expecter) RuntimeTransactionProgramsCacheHit() *MetricsReporter_RuntimeTransactionProgramsCacheHit_Call {
	return &MetricsReporter_RuntimeTransactionProgramsCacheHit_Call{Call: _e.mock.On("RuntimeTransactionProgramsCacheHit")}
}

func (_c *MetricsReporter_RuntimeTransactionProgramsCacheHit_Call) Run(run func()) *MetricsReporter_RuntimeTransactionProgramsCacheHit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MetricsReporter_RuntimeTransactionProgramsCacheHit_Call) Return() *MetricsReporter_RuntimeTransactionProgramsCacheHit_Call {
	_c.Call.Return()
	return _c
}

func (_c *MetricsReporter_RuntimeTransactionProgramsCacheHit_Call) RunAndReturn(run func()) *MetricsReporter_RuntimeTransactionProgramsCacheHit_Call {
	_c.Run(run)
	return _c
}

// RuntimeTransactionProgramsCacheMiss provides a mock function for the type MetricsReporter
func (_mock *MetricsReporter) RuntimeTransactionProgramsCacheMiss() {
	_mock.Called()
	return
}

// MetricsReporter_RuntimeTransactionProgramsCacheMiss_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RuntimeTransactionProgramsCacheMiss'
type MetricsReporter_RuntimeTransactionProgramsCacheMiss_Call struct {
	*mock.Call
}

// RuntimeTransactionProgramsCacheMiss is a helper method to define mock.On call
func (_e *MetricsReporter_Expecter) RuntimeTransactionProgramsCacheMiss() *MetricsReporter_RuntimeTransactionProgramsCacheMiss_Call {
	return &MetricsReporter_RuntimeTransactionProgramsCacheMiss_Call{Call: _e.mock.On("RuntimeTransactionProgramsCacheMiss")}
}

func (_c *MetricsReporter_RuntimeTransactionProgramsCacheMiss_Call) Run(run func()) *MetricsReporter_RuntimeTransactionProgramsCacheMiss_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MetricsReporter_RuntimeTransactionProgramsCacheMiss_Call) Return() *MetricsReporter_RuntimeTransactionProgramsCacheMiss_Call {
	_c.Call.Return()
	return _c
}

func (_c *MetricsReporter_RuntimeTransactionProgramsCacheMiss_Call) RunAndReturn(run func()) *MetricsReporter_RuntimeTransactionProgramsCacheMiss_Call {
	_c.Run(run)
	return _c
}

// SetNumberOfDeployedCOAs provides a mock function for the type MetricsReporter
func (_mock *MetricsReporter) SetNumberOfDeployedCOAs(count uint64) {
	_mock.Called(count)
	return
}

// MetricsReporter_SetNumberOfDeployedCOAs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetNumberOfDeployedCOAs'
type MetricsReporter_SetNumberOfDeployedCOAs_Call struct {
	*mock.Call
}

// SetNumberOfDeployedCOAs is a helper method to define mock.On call
//   - count uint64
func (_e *MetricsReporter_Expecter) SetNumberOfDeployedCOAs(count interface{}) *MetricsReporter_SetNumberOfDeployedCOAs_Call {
	return &MetricsReporter_SetNumberOfDeployedCOAs_Call{Call: _e.mock.On("SetNumberOfDeployedCOAs", count)}
}

func (_c *MetricsReporter_SetNumberOfDeployedCOAs_Call) Run(run func(count uint64)) *MetricsReporter_SetNumberOfDeployedCOAs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MetricsReporter_SetNumberOfDeployedCOAs_Call) Return() *MetricsReporter_SetNumberOfDeployedCOAs_Call {
	_c.Call.Return()
	return _c
}

func (_c *MetricsReporter_SetNumberOfDeployedCOAs_Call) RunAndReturn(run func(count uint64)) *MetricsReporter_SetNumberOfDeployedCOAs_Call {
	_c.Run(run)
	return _c
}

// NewEntropyProvider creates a new instance of EntropyProvider. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewEntropyProvider(t interface {
	mock.TestingT
	Cleanup(func())
}) *EntropyProvider {
	mock := &EntropyProvider{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// EntropyProvider is an autogenerated mock type for the EntropyProvider type
type EntropyProvider struct {
	mock.Mock
}

type EntropyProvider_Expecter struct {
	mock *mock.Mock
}

func (_m *EntropyProvider) EXPECT() *EntropyProvider_Expecter {
	return &EntropyProvider_Expecter{mock: &_m.Mock}
}

// RandomSource provides a mock function for the type EntropyProvider
func (_mock *EntropyProvider) RandomSource() ([]byte, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for RandomSource")
	}

	var r0 []byte
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() ([]byte, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() []byte); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// EntropyProvider_RandomSource_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RandomSource'
type EntropyProvider_RandomSource_Call struct {
	*mock.Call
}

// RandomSource is a helper method to define mock.On call
func (_e *EntropyProvider_Expecter) RandomSource() *EntropyProvider_RandomSource_Call {
	return &EntropyProvider_RandomSource_Call{Call: _e.mock.On("RandomSource")}
}

func (_c *EntropyProvider_RandomSource_Call) Run(run func()) *EntropyProvider_RandomSource_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *EntropyProvider_RandomSource_Call) Return(bytes []byte, err error) *EntropyProvider_RandomSource_Call {
	_c.Call.Return(bytes, err)
	return _c
}

func (_c *EntropyProvider_RandomSource_Call) RunAndReturn(run func() ([]byte, error)) *EntropyProvider_RandomSource_Call {
	_c.Call.Return(run)
	return _c
}

// NewRandomGenerator creates a new instance of RandomGenerator. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewRandomGenerator(t interface {
	mock.TestingT
	Cleanup(func())
}) *RandomGenerator {
	mock := &RandomGenerator{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// RandomGenerator is an autogenerated mock type for the RandomGenerator type
type RandomGenerator struct {
	mock.Mock
}

type RandomGenerator_Expecter struct {
	mock *mock.Mock
}

func (_m *RandomGenerator) EXPECT() *RandomGenerator_Expecter {
	return &RandomGenerator_Expecter{mock: &_m.Mock}
}

// ReadRandom provides a mock function for the type RandomGenerator
func (_mock *RandomGenerator) ReadRandom(bytes []byte) error {
	ret := _mock.Called(bytes)

	if len(ret) == 0 {
		panic("no return value specified for ReadRandom")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func([]byte) error); ok {
		r0 = returnFunc(bytes)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// RandomGenerator_ReadRandom_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadRandom'
type RandomGenerator_ReadRandom_Call struct {
	*mock.Call
}

// ReadRandom is a helper method to define mock.On call
//   - bytes []byte
func (_e *RandomGenerator_Expecter) ReadRandom(bytes interface{}) *RandomGenerator_ReadRandom_Call {
	return &RandomGenerator_ReadRandom_Call{Call: _e.mock.On("ReadRandom", bytes)}
}

func (_c *RandomGenerator_ReadRandom_Call) Run(run func(bytes []byte)) *RandomGenerator_ReadRandom_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []byte
		if args[0] != nil {
			arg0 = args[0].([]byte)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *RandomGenerator_ReadRandom_Call) Return(err error) *RandomGenerator_ReadRandom_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *RandomGenerator_ReadRandom_Call) RunAndReturn(run func(bytes []byte) error) *RandomGenerator_ReadRandom_Call {
	_c.Call.Return(run)
	return _c
}

// NewTracer creates a new instance of Tracer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewTracer(t interface {
	mock.TestingT
	Cleanup(func())
}) *Tracer {
	mock := &Tracer{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Tracer is an autogenerated mock type for the Tracer type
type Tracer struct {
	mock.Mock
}

type Tracer_Expecter struct {
	mock *mock.Mock
}

func (_m *Tracer) EXPECT() *Tracer_Expecter {
	return &Tracer_Expecter{mock: &_m.Mock}
}

// StartChildSpan provides a mock function for the type Tracer
func (_mock *Tracer) StartChildSpan(name trace.SpanName, options ...trace0.SpanStartOption) tracing.TracerSpan {
	// trace0.SpanStartOption
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, name)
	_ca = append(_ca, _va...)
	ret := _mock.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartChildSpan")
	}

	var r0 tracing.TracerSpan
	if returnFunc, ok := ret.Get(0).(func(trace.SpanName, ...trace0.SpanStartOption) tracing.TracerSpan); ok {
		r0 = returnFunc(name, options...)
	} else {
		r0 = ret.Get(0).(tracing.TracerSpan)
	}
	return r0
}

// Tracer_StartChildSpan_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StartChildSpan'
type Tracer_StartChildSpan_Call struct {
	*mock.Call
}

// StartChildSpan is a helper method to define mock.On call
//   - name trace.SpanName
//   - options ...trace0.SpanStartOption
func (_e *Tracer_Expecter) StartChildSpan(name interface{}, options ...interface{}) *Tracer_StartChildSpan_Call {
	return &Tracer_StartChildSpan_Call{Call: _e.mock.On("StartChildSpan",
		append([]interface{}{name}, options...)...)}
}

func (_c *Tracer_StartChildSpan_Call) Run(run func(name trace.SpanName, options ...trace0.SpanStartOption)) *Tracer_StartChildSpan_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 trace.SpanName
		if args[0] != nil {
			arg0 = args[0].(trace.SpanName)
		}
		var arg1 []trace0.SpanStartOption
		variadicArgs := make([]trace0.SpanStartOption, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(trace0.SpanStartOption)
			}
		}
		arg1 = variadicArgs
		run(
			arg0,
			arg1...,
		)
	})
	return _c
}

func (_c *Tracer_StartChildSpan_Call) Return(tracerSpan tracing.TracerSpan) *Tracer_StartChildSpan_Call {
	_c.Call.Return(tracerSpan)
	return _c
}

func (_c *Tracer_StartChildSpan_Call) RunAndReturn(run func(name trace.SpanName, options ...trace0.SpanStartOption) tracing.TracerSpan) *Tracer_StartChildSpan_Call {
	_c.Call.Return(run)
	return _c
}

// NewTransactionInfo creates a new instance of TransactionInfo. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewTransactionInfo(t interface {
	mock.TestingT
	Cleanup(func())
}) *TransactionInfo {
	mock := &TransactionInfo{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// TransactionInfo is an autogenerated mock type for the TransactionInfo type
type TransactionInfo struct {
	mock.Mock
}

type TransactionInfo_Expecter struct {
	mock *mock.Mock
}

func (_m *TransactionInfo) EXPECT() *TransactionInfo_Expecter {
	return &TransactionInfo_Expecter{mock: &_m.Mock}
}

// GetSigningAccounts provides a mock function for the type TransactionInfo
func (_mock *TransactionInfo) GetSigningAccounts() ([]common.Address, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetSigningAccounts")
	}

	var r0 []common.Address
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() ([]common.Address, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() []common.Address); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]common.Address)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// TransactionInfo_GetSigningAccounts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSigningAccounts'
type TransactionInfo_GetSigningAccounts_Call struct {
	*mock.Call
}

// GetSigningAccounts is a helper method to define mock.On call
func (_e *TransactionInfo_Expecter) GetSigningAccounts() *TransactionInfo_GetSigningAccounts_Call {
	return &TransactionInfo_GetSigningAccounts_Call{Call: _e.mock.On("GetSigningAccounts")}
}

func (_c *TransactionInfo_GetSigningAccounts_Call) Run(run func()) *TransactionInfo_GetSigningAccounts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *TransactionInfo_GetSigningAccounts_Call) Return(addresss []common.Address, err error) *TransactionInfo_GetSigningAccounts_Call {
	_c.Call.Return(addresss, err)
	return _c
}

func (_c *TransactionInfo_GetSigningAccounts_Call) RunAndReturn(run func() ([]common.Address, error)) *TransactionInfo_GetSigningAccounts_Call {
	_c.Call.Return(run)
	return _c
}

// IsServiceAccountAuthorizer provides a mock function for the type TransactionInfo
func (_mock *TransactionInfo) IsServiceAccountAuthorizer() bool {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for IsServiceAccountAuthorizer")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func() bool); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// TransactionInfo_IsServiceAccountAuthorizer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsServiceAccountAuthorizer'
type TransactionInfo_IsServiceAccountAuthorizer_Call struct {
	*mock.Call
}

// IsServiceAccountAuthorizer is a helper method to define mock.On call
func (_e *TransactionInfo_Expecter) IsServiceAccountAuthorizer() *TransactionInfo_IsServiceAccountAuthorizer_Call {
	return &TransactionInfo_IsServiceAccountAuthorizer_Call{Call: _e.mock.On("IsServiceAccountAuthorizer")}
}

func (_c *TransactionInfo_IsServiceAccountAuthorizer_Call) Run(run func()) *TransactionInfo_IsServiceAccountAuthorizer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *TransactionInfo_IsServiceAccountAuthorizer_Call) Return(b bool) *TransactionInfo_IsServiceAccountAuthorizer_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *TransactionInfo_IsServiceAccountAuthorizer_Call) RunAndReturn(run func() bool) *TransactionInfo_IsServiceAccountAuthorizer_Call {
	_c.Call.Return(run)
	return _c
}

// LimitAccountStorage provides a mock function for the type TransactionInfo
func (_mock *TransactionInfo) LimitAccountStorage() bool {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for LimitAccountStorage")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func() bool); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// TransactionInfo_LimitAccountStorage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LimitAccountStorage'
type TransactionInfo_LimitAccountStorage_Call struct {
	*mock.Call
}

// LimitAccountStorage is a helper method to define mock.On call
func (_e *TransactionInfo_Expecter) LimitAccountStorage() *TransactionInfo_LimitAccountStorage_Call {
	return &TransactionInfo_LimitAccountStorage_Call{Call: _e.mock.On("LimitAccountStorage")}
}

func (_c *TransactionInfo_LimitAccountStorage_Call) Run(run func()) *TransactionInfo_LimitAccountStorage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *TransactionInfo_LimitAccountStorage_Call) Return(b bool) *TransactionInfo_LimitAccountStorage_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *TransactionInfo_LimitAccountStorage_Call) RunAndReturn(run func() bool) *TransactionInfo_LimitAccountStorage_Call {
	_c.Call.Return(run)
	return _c
}

// TransactionFeesEnabled provides a mock function for the type TransactionInfo
func (_mock *TransactionInfo) TransactionFeesEnabled() bool {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for TransactionFeesEnabled")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func() bool); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// TransactionInfo_TransactionFeesEnabled_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TransactionFeesEnabled'
type TransactionInfo_TransactionFeesEnabled_Call struct {
	*mock.Call
}

// TransactionFeesEnabled is a helper method to define mock.On call
func (_e *TransactionInfo_Expecter) TransactionFeesEnabled() *TransactionInfo_TransactionFeesEnabled_Call {
	return &TransactionInfo_TransactionFeesEnabled_Call{Call: _e.mock.On("TransactionFeesEnabled")}
}

func (_c *TransactionInfo_TransactionFeesEnabled_Call) Run(run func()) *TransactionInfo_TransactionFeesEnabled_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *TransactionInfo_TransactionFeesEnabled_Call) Return(b bool) *TransactionInfo_TransactionFeesEnabled_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *TransactionInfo_TransactionFeesEnabled_Call) RunAndReturn(run func() bool) *TransactionInfo_TransactionFeesEnabled_Call {
	_c.Call.Return(run)
	return _c
}

// TxID provides a mock function for the type TransactionInfo
func (_mock *TransactionInfo) TxID() flow.Identifier {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for TxID")
	}

	var r0 flow.Identifier
	if returnFunc, ok := ret.Get(0).(func() flow.Identifier); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.Identifier)
		}
	}
	return r0
}

// TransactionInfo_TxID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TxID'
type TransactionInfo_TxID_Call struct {
	*mock.Call
}

// TxID is a helper method to define mock.On call
func (_e *TransactionInfo_Expecter) TxID() *TransactionInfo_TxID_Call {
	return &TransactionInfo_TxID_Call{Call: _e.mock.On("TxID")}
}

func (_c *TransactionInfo_TxID_Call) Run(run func()) *TransactionInfo_TxID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *TransactionInfo_TxID_Call) Return(identifier flow.Identifier) *TransactionInfo_TxID_Call {
	_c.Call.Return(identifier)
	return _c
}

func (_c *TransactionInfo_TxID_Call) RunAndReturn(run func() flow.Identifier) *TransactionInfo_TxID_Call {
	_c.Call.Return(run)
	return _c
}

// TxIndex provides a mock function for the type TransactionInfo
func (_mock *TransactionInfo) TxIndex() uint32 {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for TxIndex")
	}

	var r0 uint32
	if returnFunc, ok := ret.Get(0).(func() uint32); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint32)
	}
	return r0
}

// TransactionInfo_TxIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TxIndex'
type TransactionInfo_TxIndex_Call struct {
	*mock.Call
}

// TxIndex is a helper method to define mock.On call
func (_e *TransactionInfo_Expecter) TxIndex() *TransactionInfo_TxIndex_Call {
	return &TransactionInfo_TxIndex_Call{Call: _e.mock.On("TxIndex")}
}

func (_c *TransactionInfo_TxIndex_Call) Run(run func()) *TransactionInfo_TxIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *TransactionInfo_TxIndex_Call) Return(v uint32) *TransactionInfo_TxIndex_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *TransactionInfo_TxIndex_Call) RunAndReturn(run func() uint32) *TransactionInfo_TxIndex_Call {
	_c.Call.Return(run)
	return _c
}

// NewUUIDGenerator creates a new instance of UUIDGenerator. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewUUIDGenerator(t interface {
	mock.TestingT
	Cleanup(func())
}) *UUIDGenerator {
	mock := &UUIDGenerator{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// UUIDGenerator is an autogenerated mock type for the UUIDGenerator type
type UUIDGenerator struct {
	mock.Mock
}

type UUIDGenerator_Expecter struct {
	mock *mock.Mock
}

func (_m *UUIDGenerator) EXPECT() *UUIDGenerator_Expecter {
	return &UUIDGenerator_Expecter{mock: &_m.Mock}
}

// GenerateUUID provides a mock function for the type UUIDGenerator
func (_mock *UUIDGenerator) GenerateUUID() (uint64, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GenerateUUID")
	}

	var r0 uint64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (uint64, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() uint64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint64)
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// UUIDGenerator_GenerateUUID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GenerateUUID'
type UUIDGenerator_GenerateUUID_Call struct {
	*mock.Call
}

// GenerateUUID is a helper method to define mock.On call
func (_e *UUIDGenerator_Expecter) GenerateUUID() *UUIDGenerator_GenerateUUID_Call {
	return &UUIDGenerator_GenerateUUID_Call{Call: _e.mock.On("GenerateUUID")}
}

func (_c *UUIDGenerator_GenerateUUID_Call) Run(run func()) *UUIDGenerator_GenerateUUID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *UUIDGenerator_GenerateUUID_Call) Return(v uint64, err error) *UUIDGenerator_GenerateUUID_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *UUIDGenerator_GenerateUUID_Call) RunAndReturn(run func() (uint64, error)) *UUIDGenerator_GenerateUUID_Call {
	_c.Call.Return(run)
	return _c
}

// NewValueStore creates a new instance of ValueStore. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewValueStore(t interface {
	mock.TestingT
	Cleanup(func())
}) *ValueStore {
	mock := &ValueStore{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// ValueStore is an autogenerated mock type for the ValueStore type
type ValueStore struct {
	mock.Mock
}

type ValueStore_Expecter struct {
	mock *mock.Mock
}

func (_m *ValueStore) EXPECT() *ValueStore_Expecter {
	return &ValueStore_Expecter{mock: &_m.Mock}
}

// AllocateSlabIndex provides a mock function for the type ValueStore
func (_mock *ValueStore) AllocateSlabIndex(owner []byte) (atree.SlabIndex, error) {
	ret := _mock.Called(owner)

	if len(ret) == 0 {
		panic("no return value specified for AllocateSlabIndex")
	}

	var r0 atree.SlabIndex
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]byte) (atree.SlabIndex, error)); ok {
		return returnFunc(owner)
	}
	if returnFunc, ok := ret.Get(0).(func([]byte) atree.SlabIndex); ok {
		r0 = returnFunc(owner)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(atree.SlabIndex)
		}
	}
	if returnFunc, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = returnFunc(owner)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ValueStore_AllocateSlabIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AllocateSlabIndex'
type ValueStore_AllocateSlabIndex_Call struct {
	*mock.Call
}

// AllocateSlabIndex is a helper method to define mock.On call
//   - owner []byte
func (_e *ValueStore_Expecter) AllocateSlabIndex(owner interface{}) *ValueStore_AllocateSlabIndex_Call {
	return &ValueStore_AllocateSlabIndex_Call{Call: _e.mock.On("AllocateSlabIndex", owner)}
}

func (_c *ValueStore_AllocateSlabIndex_Call) Run(run func(owner []byte)) *ValueStore_AllocateSlabIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []byte
		if args[0] != nil {
			arg0 = args[0].([]byte)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ValueStore_AllocateSlabIndex_Call) Return(slabIndex atree.SlabIndex, err error) *ValueStore_AllocateSlabIndex_Call {
	_c.Call.Return(slabIndex, err)
	return _c
}

func (_c *ValueStore_AllocateSlabIndex_Call) RunAndReturn(run func(owner []byte) (atree.SlabIndex, error)) *ValueStore_AllocateSlabIndex_Call {
	_c.Call.Return(run)
	return _c
}

// GetValue provides a mock function for the type ValueStore
func (_mock *ValueStore) GetValue(owner []byte, key []byte) ([]byte, error) {
	ret := _mock.Called(owner, key)

	if len(ret) == 0 {
		panic("no return value specified for GetValue")
	}

	var r0 []byte
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]byte, []byte) ([]byte, error)); ok {
		return returnFunc(owner, key)
	}
	if returnFunc, ok := ret.Get(0).(func([]byte, []byte) []byte); ok {
		r0 = returnFunc(owner, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}
	if returnFunc, ok := ret.Get(1).(func([]byte, []byte) error); ok {
		r1 = returnFunc(owner, key)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ValueStore_GetValue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetValue'
type ValueStore_GetValue_Call struct {
	*mock.Call
}

// GetValue is a helper method to define mock.On call
//   - owner []byte
//   - key []byte
func (_e *ValueStore_Expecter) GetValue(owner interface{}, key interface{}) *ValueStore_GetValue_Call {
	return &ValueStore_GetValue_Call{Call: _e.mock.On("GetValue", owner, key)}
}

func (_c *ValueStore_GetValue_Call) Run(run func(owner []byte, key []byte)) *ValueStore_GetValue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []byte
		if args[0] != nil {
			arg0 = args[0].([]byte)
		}
		var arg1 []byte
		if args[1] != nil {
			arg1 = args[1].([]byte)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ValueStore_GetValue_Call) Return(bytes []byte, err error) *ValueStore_GetValue_Call {
	_c.Call.Return(bytes, err)
	return _c
}

func (_c *ValueStore_GetValue_Call) RunAndReturn(run func(owner []byte, key []byte) ([]byte, error)) *ValueStore_GetValue_Call {
	_c.Call.Return(run)
	return _c
}

// SetValue provides a mock function for the type ValueStore
func (_mock *ValueStore) SetValue(owner []byte, key []byte, value []byte) error {
	ret := _mock.Called(owner, key, value)

	if len(ret) == 0 {
		panic("no return value specified for SetValue")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func([]byte, []byte, []byte) error); ok {
		r0 = returnFunc(owner, key, value)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ValueStore_SetValue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetValue'
type ValueStore_SetValue_Call struct {
	*mock.Call
}

// SetValue is a helper method to define mock.On call
//   - owner []byte
//   - key []byte
//   - value []byte
func (_e *ValueStore_Expecter) SetValue(owner interface{}, key interface{}, value interface{}) *ValueStore_SetValue_Call {
	return &ValueStore_SetValue_Call{Call: _e.mock.On("SetValue", owner, key, value)}
}

func (_c *ValueStore_SetValue_Call) Run(run func(owner []byte, key []byte, value []byte)) *ValueStore_SetValue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []byte
		if args[0] != nil {
			arg0 = args[0].([]byte)
		}
		var arg1 []byte
		if args[1] != nil {
			arg1 = args[1].([]byte)
		}
		var arg2 []byte
		if args[2] != nil {
			arg2 = args[2].([]byte)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *ValueStore_SetValue_Call) Return(err error) *ValueStore_SetValue_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ValueStore_SetValue_Call) RunAndReturn(run func(owner []byte, key []byte, value []byte) error) *ValueStore_SetValue_Call {
	_c.Call.Return(run)
	return _c
}

// ValueExists provides a mock function for the type ValueStore
func (_mock *ValueStore) ValueExists(owner []byte, key []byte) (bool, error) {
	ret := _mock.Called(owner, key)

	if len(ret) == 0 {
		panic("no return value specified for ValueExists")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]byte, []byte) (bool, error)); ok {
		return returnFunc(owner, key)
	}
	if returnFunc, ok := ret.Get(0).(func([]byte, []byte) bool); ok {
		r0 = returnFunc(owner, key)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func([]byte, []byte) error); ok {
		r1 = returnFunc(owner, key)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ValueStore_ValueExists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ValueExists'
type ValueStore_ValueExists_Call struct {
	*mock.Call
}

// ValueExists is a helper method to define mock.On call
//   - owner []byte
//   - key []byte
func (_e *ValueStore_Expecter) ValueExists(owner interface{}, key interface{}) *ValueStore_ValueExists_Call {
	return &ValueStore_ValueExists_Call{Call: _e.mock.On("ValueExists", owner, key)}
}

func (_c *ValueStore_ValueExists_Call) Run(run func(owner []byte, key []byte)) *ValueStore_ValueExists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []byte
		if args[0] != nil {
			arg0 = args[0].([]byte)
		}
		var arg1 []byte
		if args[1] != nil {
			arg1 = args[1].([]byte)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ValueStore_ValueExists_Call) Return(b bool, err error) *ValueStore_ValueExists_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *ValueStore_ValueExists_Call) RunAndReturn(run func(owner []byte, key []byte) (bool, error)) *ValueStore_ValueExists_Call {
	_c.Call.Return(run)
	return _c
}
