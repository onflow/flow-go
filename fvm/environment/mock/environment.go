// Code generated by mockery. DO NOT EDIT.

package mock

import (
	atree "github.com/onflow/atree"
	ast "github.com/onflow/cadence/ast"

	attribute "go.opentelemetry.io/otel/attribute"

	cadence "github.com/onflow/cadence"

	common "github.com/onflow/cadence/common"

	environment "github.com/onflow/flow-go/fvm/environment"

	flow "github.com/onflow/flow-go/model/flow"

	interpreter "github.com/onflow/cadence/interpreter"

	meter "github.com/onflow/flow-go/fvm/meter"

	mock "github.com/stretchr/testify/mock"

	oteltrace "go.opentelemetry.io/otel/trace"

	runtime "github.com/onflow/cadence/runtime"

	sema "github.com/onflow/cadence/sema"

	time "time"

	trace "github.com/onflow/flow-go/module/trace"

	tracing "github.com/onflow/flow-go/fvm/tracing"

	zerolog "github.com/rs/zerolog"
)

// Environment is an autogenerated mock type for the Environment type
type Environment struct {
	mock.Mock
}

// AccountKeysCount provides a mock function with given fields: address
func (_m *Environment) AccountKeysCount(address runtime.Address) (uint32, error) {
	ret := _m.Called(address)

	if len(ret) == 0 {
		panic("no return value specified for AccountKeysCount")
	}

	var r0 uint32
	var r1 error
	if rf, ok := ret.Get(0).(func(runtime.Address) (uint32, error)); ok {
		return rf(address)
	}
	if rf, ok := ret.Get(0).(func(runtime.Address) uint32); ok {
		r0 = rf(address)
	} else {
		r0 = ret.Get(0).(uint32)
	}

	if rf, ok := ret.Get(1).(func(runtime.Address) error); ok {
		r1 = rf(address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AccountsStorageCapacity provides a mock function with given fields: addresses, payer, maxTxFees
func (_m *Environment) AccountsStorageCapacity(addresses []flow.Address, payer flow.Address, maxTxFees uint64) (cadence.Value, error) {
	ret := _m.Called(addresses, payer, maxTxFees)

	if len(ret) == 0 {
		panic("no return value specified for AccountsStorageCapacity")
	}

	var r0 cadence.Value
	var r1 error
	if rf, ok := ret.Get(0).(func([]flow.Address, flow.Address, uint64) (cadence.Value, error)); ok {
		return rf(addresses, payer, maxTxFees)
	}
	if rf, ok := ret.Get(0).(func([]flow.Address, flow.Address, uint64) cadence.Value); ok {
		r0 = rf(addresses, payer, maxTxFees)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(cadence.Value)
		}
	}

	if rf, ok := ret.Get(1).(func([]flow.Address, flow.Address, uint64) error); ok {
		r1 = rf(addresses, payer, maxTxFees)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddAccountKey provides a mock function with given fields: address, publicKey, hashAlgo, weight
func (_m *Environment) AddAccountKey(address runtime.Address, publicKey *runtime.PublicKey, hashAlgo runtime.HashAlgorithm, weight int) (*runtime.AccountKey, error) {
	ret := _m.Called(address, publicKey, hashAlgo, weight)

	if len(ret) == 0 {
		panic("no return value specified for AddAccountKey")
	}

	var r0 *runtime.AccountKey
	var r1 error
	if rf, ok := ret.Get(0).(func(runtime.Address, *runtime.PublicKey, runtime.HashAlgorithm, int) (*runtime.AccountKey, error)); ok {
		return rf(address, publicKey, hashAlgo, weight)
	}
	if rf, ok := ret.Get(0).(func(runtime.Address, *runtime.PublicKey, runtime.HashAlgorithm, int) *runtime.AccountKey); ok {
		r0 = rf(address, publicKey, hashAlgo, weight)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*runtime.AccountKey)
		}
	}

	if rf, ok := ret.Get(1).(func(runtime.Address, *runtime.PublicKey, runtime.HashAlgorithm, int) error); ok {
		r1 = rf(address, publicKey, hashAlgo, weight)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AllocateSlabIndex provides a mock function with given fields: owner
func (_m *Environment) AllocateSlabIndex(owner []byte) (atree.SlabIndex, error) {
	ret := _m.Called(owner)

	if len(ret) == 0 {
		panic("no return value specified for AllocateSlabIndex")
	}

	var r0 atree.SlabIndex
	var r1 error
	if rf, ok := ret.Get(0).(func([]byte) (atree.SlabIndex, error)); ok {
		return rf(owner)
	}
	if rf, ok := ret.Get(0).(func([]byte) atree.SlabIndex); ok {
		r0 = rf(owner)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(atree.SlabIndex)
		}
	}

	if rf, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = rf(owner)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BLSAggregatePublicKeys provides a mock function with given fields: publicKeys
func (_m *Environment) BLSAggregatePublicKeys(publicKeys []*runtime.PublicKey) (*runtime.PublicKey, error) {
	ret := _m.Called(publicKeys)

	if len(ret) == 0 {
		panic("no return value specified for BLSAggregatePublicKeys")
	}

	var r0 *runtime.PublicKey
	var r1 error
	if rf, ok := ret.Get(0).(func([]*runtime.PublicKey) (*runtime.PublicKey, error)); ok {
		return rf(publicKeys)
	}
	if rf, ok := ret.Get(0).(func([]*runtime.PublicKey) *runtime.PublicKey); ok {
		r0 = rf(publicKeys)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*runtime.PublicKey)
		}
	}

	if rf, ok := ret.Get(1).(func([]*runtime.PublicKey) error); ok {
		r1 = rf(publicKeys)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BLSAggregateSignatures provides a mock function with given fields: signatures
func (_m *Environment) BLSAggregateSignatures(signatures [][]byte) ([]byte, error) {
	ret := _m.Called(signatures)

	if len(ret) == 0 {
		panic("no return value specified for BLSAggregateSignatures")
	}

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func([][]byte) ([]byte, error)); ok {
		return rf(signatures)
	}
	if rf, ok := ret.Get(0).(func([][]byte) []byte); ok {
		r0 = rf(signatures)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func([][]byte) error); ok {
		r1 = rf(signatures)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BLSVerifyPOP provides a mock function with given fields: publicKey, signature
func (_m *Environment) BLSVerifyPOP(publicKey *runtime.PublicKey, signature []byte) (bool, error) {
	ret := _m.Called(publicKey, signature)

	if len(ret) == 0 {
		panic("no return value specified for BLSVerifyPOP")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(*runtime.PublicKey, []byte) (bool, error)); ok {
		return rf(publicKey, signature)
	}
	if rf, ok := ret.Get(0).(func(*runtime.PublicKey, []byte) bool); ok {
		r0 = rf(publicKey, signature)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(*runtime.PublicKey, []byte) error); ok {
		r1 = rf(publicKey, signature)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CheckPayerBalanceAndGetMaxTxFees provides a mock function with given fields: payer, inclusionEffort, executionEffort
func (_m *Environment) CheckPayerBalanceAndGetMaxTxFees(payer flow.Address, inclusionEffort uint64, executionEffort uint64) (cadence.Value, error) {
	ret := _m.Called(payer, inclusionEffort, executionEffort)

	if len(ret) == 0 {
		panic("no return value specified for CheckPayerBalanceAndGetMaxTxFees")
	}

	var r0 cadence.Value
	var r1 error
	if rf, ok := ret.Get(0).(func(flow.Address, uint64, uint64) (cadence.Value, error)); ok {
		return rf(payer, inclusionEffort, executionEffort)
	}
	if rf, ok := ret.Get(0).(func(flow.Address, uint64, uint64) cadence.Value); ok {
		r0 = rf(payer, inclusionEffort, executionEffort)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(cadence.Value)
		}
	}

	if rf, ok := ret.Get(1).(func(flow.Address, uint64, uint64) error); ok {
		r1 = rf(payer, inclusionEffort, executionEffort)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ComputationAvailable provides a mock function with given fields: _a0
func (_m *Environment) ComputationAvailable(_a0 common.ComputationUsage) bool {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for ComputationAvailable")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func(common.ComputationUsage) bool); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// ComputationIntensities provides a mock function with no fields
func (_m *Environment) ComputationIntensities() meter.MeteredComputationIntensities {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for ComputationIntensities")
	}

	var r0 meter.MeteredComputationIntensities
	if rf, ok := ret.Get(0).(func() meter.MeteredComputationIntensities); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(meter.MeteredComputationIntensities)
		}
	}

	return r0
}

// ComputationUsed provides a mock function with no fields
func (_m *Environment) ComputationUsed() (uint64, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for ComputationUsed")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func() (uint64, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ConvertedServiceEvents provides a mock function with no fields
func (_m *Environment) ConvertedServiceEvents() flow.ServiceEventList {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for ConvertedServiceEvents")
	}

	var r0 flow.ServiceEventList
	if rf, ok := ret.Get(0).(func() flow.ServiceEventList); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.ServiceEventList)
		}
	}

	return r0
}

// CreateAccount provides a mock function with given fields: payer
func (_m *Environment) CreateAccount(payer runtime.Address) (runtime.Address, error) {
	ret := _m.Called(payer)

	if len(ret) == 0 {
		panic("no return value specified for CreateAccount")
	}

	var r0 runtime.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(runtime.Address) (runtime.Address, error)); ok {
		return rf(payer)
	}
	if rf, ok := ret.Get(0).(func(runtime.Address) runtime.Address); ok {
		r0 = rf(payer)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(runtime.Address)
		}
	}

	if rf, ok := ret.Get(1).(func(runtime.Address) error); ok {
		r1 = rf(payer)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DecodeArgument provides a mock function with given fields: argument, argumentType
func (_m *Environment) DecodeArgument(argument []byte, argumentType cadence.Type) (cadence.Value, error) {
	ret := _m.Called(argument, argumentType)

	if len(ret) == 0 {
		panic("no return value specified for DecodeArgument")
	}

	var r0 cadence.Value
	var r1 error
	if rf, ok := ret.Get(0).(func([]byte, cadence.Type) (cadence.Value, error)); ok {
		return rf(argument, argumentType)
	}
	if rf, ok := ret.Get(0).(func([]byte, cadence.Type) cadence.Value); ok {
		r0 = rf(argument, argumentType)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(cadence.Value)
		}
	}

	if rf, ok := ret.Get(1).(func([]byte, cadence.Type) error); ok {
		r1 = rf(argument, argumentType)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeductTransactionFees provides a mock function with given fields: payer, inclusionEffort, executionEffort
func (_m *Environment) DeductTransactionFees(payer flow.Address, inclusionEffort uint64, executionEffort uint64) (cadence.Value, error) {
	ret := _m.Called(payer, inclusionEffort, executionEffort)

	if len(ret) == 0 {
		panic("no return value specified for DeductTransactionFees")
	}

	var r0 cadence.Value
	var r1 error
	if rf, ok := ret.Get(0).(func(flow.Address, uint64, uint64) (cadence.Value, error)); ok {
		return rf(payer, inclusionEffort, executionEffort)
	}
	if rf, ok := ret.Get(0).(func(flow.Address, uint64, uint64) cadence.Value); ok {
		r0 = rf(payer, inclusionEffort, executionEffort)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(cadence.Value)
		}
	}

	if rf, ok := ret.Get(1).(func(flow.Address, uint64, uint64) error); ok {
		r1 = rf(payer, inclusionEffort, executionEffort)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EVMBlockExecuted provides a mock function with given fields: txCount, totalGasUsed, totalSupplyInFlow
func (_m *Environment) EVMBlockExecuted(txCount int, totalGasUsed uint64, totalSupplyInFlow float64) {
	_m.Called(txCount, totalGasUsed, totalSupplyInFlow)
}

// EVMTransactionExecuted provides a mock function with given fields: gasUsed, isDirectCall, failed
func (_m *Environment) EVMTransactionExecuted(gasUsed uint64, isDirectCall bool, failed bool) {
	_m.Called(gasUsed, isDirectCall, failed)
}

// EmitEvent provides a mock function with given fields: _a0
func (_m *Environment) EmitEvent(_a0 cadence.Event) error {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for EmitEvent")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(cadence.Event) error); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Events provides a mock function with no fields
func (_m *Environment) Events() flow.EventsList {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Events")
	}

	var r0 flow.EventsList
	if rf, ok := ret.Get(0).(func() flow.EventsList); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.EventsList)
		}
	}

	return r0
}

// FlushPendingUpdates provides a mock function with no fields
func (_m *Environment) FlushPendingUpdates() (environment.ContractUpdates, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for FlushPendingUpdates")
	}

	var r0 environment.ContractUpdates
	var r1 error
	if rf, ok := ret.Get(0).(func() (environment.ContractUpdates, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() environment.ContractUpdates); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(environment.ContractUpdates)
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GenerateAccountID provides a mock function with given fields: address
func (_m *Environment) GenerateAccountID(address common.Address) (uint64, error) {
	ret := _m.Called(address)

	if len(ret) == 0 {
		panic("no return value specified for GenerateAccountID")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(common.Address) (uint64, error)); ok {
		return rf(address)
	}
	if rf, ok := ret.Get(0).(func(common.Address) uint64); ok {
		r0 = rf(address)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(common.Address) error); ok {
		r1 = rf(address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GenerateUUID provides a mock function with no fields
func (_m *Environment) GenerateUUID() (uint64, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GenerateUUID")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func() (uint64, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAccount provides a mock function with given fields: address
func (_m *Environment) GetAccount(address flow.Address) (*flow.Account, error) {
	ret := _m.Called(address)

	if len(ret) == 0 {
		panic("no return value specified for GetAccount")
	}

	var r0 *flow.Account
	var r1 error
	if rf, ok := ret.Get(0).(func(flow.Address) (*flow.Account, error)); ok {
		return rf(address)
	}
	if rf, ok := ret.Get(0).(func(flow.Address) *flow.Account); ok {
		r0 = rf(address)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.Account)
		}
	}

	if rf, ok := ret.Get(1).(func(flow.Address) error); ok {
		r1 = rf(address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAccountAvailableBalance provides a mock function with given fields: address
func (_m *Environment) GetAccountAvailableBalance(address common.Address) (uint64, error) {
	ret := _m.Called(address)

	if len(ret) == 0 {
		panic("no return value specified for GetAccountAvailableBalance")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(common.Address) (uint64, error)); ok {
		return rf(address)
	}
	if rf, ok := ret.Get(0).(func(common.Address) uint64); ok {
		r0 = rf(address)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(common.Address) error); ok {
		r1 = rf(address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAccountBalance provides a mock function with given fields: address
func (_m *Environment) GetAccountBalance(address common.Address) (uint64, error) {
	ret := _m.Called(address)

	if len(ret) == 0 {
		panic("no return value specified for GetAccountBalance")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(common.Address) (uint64, error)); ok {
		return rf(address)
	}
	if rf, ok := ret.Get(0).(func(common.Address) uint64); ok {
		r0 = rf(address)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(common.Address) error); ok {
		r1 = rf(address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAccountContractCode provides a mock function with given fields: location
func (_m *Environment) GetAccountContractCode(location common.AddressLocation) ([]byte, error) {
	ret := _m.Called(location)

	if len(ret) == 0 {
		panic("no return value specified for GetAccountContractCode")
	}

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func(common.AddressLocation) ([]byte, error)); ok {
		return rf(location)
	}
	if rf, ok := ret.Get(0).(func(common.AddressLocation) []byte); ok {
		r0 = rf(location)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(common.AddressLocation) error); ok {
		r1 = rf(location)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAccountContractNames provides a mock function with given fields: address
func (_m *Environment) GetAccountContractNames(address runtime.Address) ([]string, error) {
	ret := _m.Called(address)

	if len(ret) == 0 {
		panic("no return value specified for GetAccountContractNames")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(runtime.Address) ([]string, error)); ok {
		return rf(address)
	}
	if rf, ok := ret.Get(0).(func(runtime.Address) []string); ok {
		r0 = rf(address)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(runtime.Address) error); ok {
		r1 = rf(address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAccountKey provides a mock function with given fields: address, index
func (_m *Environment) GetAccountKey(address runtime.Address, index uint32) (*runtime.AccountKey, error) {
	ret := _m.Called(address, index)

	if len(ret) == 0 {
		panic("no return value specified for GetAccountKey")
	}

	var r0 *runtime.AccountKey
	var r1 error
	if rf, ok := ret.Get(0).(func(runtime.Address, uint32) (*runtime.AccountKey, error)); ok {
		return rf(address, index)
	}
	if rf, ok := ret.Get(0).(func(runtime.Address, uint32) *runtime.AccountKey); ok {
		r0 = rf(address, index)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*runtime.AccountKey)
		}
	}

	if rf, ok := ret.Get(1).(func(runtime.Address, uint32) error); ok {
		r1 = rf(address, index)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAccountKeys provides a mock function with given fields: address
func (_m *Environment) GetAccountKeys(address flow.Address) ([]flow.AccountPublicKey, error) {
	ret := _m.Called(address)

	if len(ret) == 0 {
		panic("no return value specified for GetAccountKeys")
	}

	var r0 []flow.AccountPublicKey
	var r1 error
	if rf, ok := ret.Get(0).(func(flow.Address) ([]flow.AccountPublicKey, error)); ok {
		return rf(address)
	}
	if rf, ok := ret.Get(0).(func(flow.Address) []flow.AccountPublicKey); ok {
		r0 = rf(address)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]flow.AccountPublicKey)
		}
	}

	if rf, ok := ret.Get(1).(func(flow.Address) error); ok {
		r1 = rf(address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlockAtHeight provides a mock function with given fields: height
func (_m *Environment) GetBlockAtHeight(height uint64) (runtime.Block, bool, error) {
	ret := _m.Called(height)

	if len(ret) == 0 {
		panic("no return value specified for GetBlockAtHeight")
	}

	var r0 runtime.Block
	var r1 bool
	var r2 error
	if rf, ok := ret.Get(0).(func(uint64) (runtime.Block, bool, error)); ok {
		return rf(height)
	}
	if rf, ok := ret.Get(0).(func(uint64) runtime.Block); ok {
		r0 = rf(height)
	} else {
		r0 = ret.Get(0).(runtime.Block)
	}

	if rf, ok := ret.Get(1).(func(uint64) bool); ok {
		r1 = rf(height)
	} else {
		r1 = ret.Get(1).(bool)
	}

	if rf, ok := ret.Get(2).(func(uint64) error); ok {
		r2 = rf(height)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetCode provides a mock function with given fields: location
func (_m *Environment) GetCode(location runtime.Location) ([]byte, error) {
	ret := _m.Called(location)

	if len(ret) == 0 {
		panic("no return value specified for GetCode")
	}

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func(runtime.Location) ([]byte, error)); ok {
		return rf(location)
	}
	if rf, ok := ret.Get(0).(func(runtime.Location) []byte); ok {
		r0 = rf(location)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(runtime.Location) error); ok {
		r1 = rf(location)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCurrentBlockHeight provides a mock function with no fields
func (_m *Environment) GetCurrentBlockHeight() (uint64, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetCurrentBlockHeight")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func() (uint64, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetOrLoadProgram provides a mock function with given fields: location, load
func (_m *Environment) GetOrLoadProgram(location runtime.Location, load func() (*runtime.Program, error)) (*runtime.Program, error) {
	ret := _m.Called(location, load)

	if len(ret) == 0 {
		panic("no return value specified for GetOrLoadProgram")
	}

	var r0 *runtime.Program
	var r1 error
	if rf, ok := ret.Get(0).(func(runtime.Location, func() (*runtime.Program, error)) (*runtime.Program, error)); ok {
		return rf(location, load)
	}
	if rf, ok := ret.Get(0).(func(runtime.Location, func() (*runtime.Program, error)) *runtime.Program); ok {
		r0 = rf(location, load)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*runtime.Program)
		}
	}

	if rf, ok := ret.Get(1).(func(runtime.Location, func() (*runtime.Program, error)) error); ok {
		r1 = rf(location, load)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSigningAccounts provides a mock function with no fields
func (_m *Environment) GetSigningAccounts() ([]runtime.Address, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetSigningAccounts")
	}

	var r0 []runtime.Address
	var r1 error
	if rf, ok := ret.Get(0).(func() ([]runtime.Address, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() []runtime.Address); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]runtime.Address)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetStorageCapacity provides a mock function with given fields: address
func (_m *Environment) GetStorageCapacity(address runtime.Address) (uint64, error) {
	ret := _m.Called(address)

	if len(ret) == 0 {
		panic("no return value specified for GetStorageCapacity")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(runtime.Address) (uint64, error)); ok {
		return rf(address)
	}
	if rf, ok := ret.Get(0).(func(runtime.Address) uint64); ok {
		r0 = rf(address)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(runtime.Address) error); ok {
		r1 = rf(address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetStorageUsed provides a mock function with given fields: address
func (_m *Environment) GetStorageUsed(address runtime.Address) (uint64, error) {
	ret := _m.Called(address)

	if len(ret) == 0 {
		panic("no return value specified for GetStorageUsed")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(runtime.Address) (uint64, error)); ok {
		return rf(address)
	}
	if rf, ok := ret.Get(0).(func(runtime.Address) uint64); ok {
		r0 = rf(address)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(runtime.Address) error); ok {
		r1 = rf(address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetValue provides a mock function with given fields: owner, key
func (_m *Environment) GetValue(owner []byte, key []byte) ([]byte, error) {
	ret := _m.Called(owner, key)

	if len(ret) == 0 {
		panic("no return value specified for GetValue")
	}

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func([]byte, []byte) ([]byte, error)); ok {
		return rf(owner, key)
	}
	if rf, ok := ret.Get(0).(func([]byte, []byte) []byte); ok {
		r0 = rf(owner, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func([]byte, []byte) error); ok {
		r1 = rf(owner, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Hash provides a mock function with given fields: data, tag, hashAlgorithm
func (_m *Environment) Hash(data []byte, tag string, hashAlgorithm runtime.HashAlgorithm) ([]byte, error) {
	ret := _m.Called(data, tag, hashAlgorithm)

	if len(ret) == 0 {
		panic("no return value specified for Hash")
	}

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func([]byte, string, runtime.HashAlgorithm) ([]byte, error)); ok {
		return rf(data, tag, hashAlgorithm)
	}
	if rf, ok := ret.Get(0).(func([]byte, string, runtime.HashAlgorithm) []byte); ok {
		r0 = rf(data, tag, hashAlgorithm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func([]byte, string, runtime.HashAlgorithm) error); ok {
		r1 = rf(data, tag, hashAlgorithm)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ImplementationDebugLog provides a mock function with given fields: message
func (_m *Environment) ImplementationDebugLog(message string) error {
	ret := _m.Called(message)

	if len(ret) == 0 {
		panic("no return value specified for ImplementationDebugLog")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(message)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Invoke provides a mock function with given fields: spec, arguments
func (_m *Environment) Invoke(spec environment.ContractFunctionSpec, arguments []cadence.Value) (cadence.Value, error) {
	ret := _m.Called(spec, arguments)

	if len(ret) == 0 {
		panic("no return value specified for Invoke")
	}

	var r0 cadence.Value
	var r1 error
	if rf, ok := ret.Get(0).(func(environment.ContractFunctionSpec, []cadence.Value) (cadence.Value, error)); ok {
		return rf(spec, arguments)
	}
	if rf, ok := ret.Get(0).(func(environment.ContractFunctionSpec, []cadence.Value) cadence.Value); ok {
		r0 = rf(spec, arguments)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(cadence.Value)
		}
	}

	if rf, ok := ret.Get(1).(func(environment.ContractFunctionSpec, []cadence.Value) error); ok {
		r1 = rf(spec, arguments)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IsServiceAccountAuthorizer provides a mock function with no fields
func (_m *Environment) IsServiceAccountAuthorizer() bool {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for IsServiceAccountAuthorizer")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// LimitAccountStorage provides a mock function with no fields
func (_m *Environment) LimitAccountStorage() bool {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for LimitAccountStorage")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Logger provides a mock function with no fields
func (_m *Environment) Logger() zerolog.Logger {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Logger")
	}

	var r0 zerolog.Logger
	if rf, ok := ret.Get(0).(func() zerolog.Logger); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(zerolog.Logger)
	}

	return r0
}

// Logs provides a mock function with no fields
func (_m *Environment) Logs() []string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Logs")
	}

	var r0 []string
	if rf, ok := ret.Get(0).(func() []string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	return r0
}

// MemoryUsed provides a mock function with no fields
func (_m *Environment) MemoryUsed() (uint64, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for MemoryUsed")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func() (uint64, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MeterComputation provides a mock function with given fields: usage
func (_m *Environment) MeterComputation(usage common.ComputationUsage) error {
	ret := _m.Called(usage)

	if len(ret) == 0 {
		panic("no return value specified for MeterComputation")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(common.ComputationUsage) error); ok {
		r0 = rf(usage)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MeterEmittedEvent provides a mock function with given fields: byteSize
func (_m *Environment) MeterEmittedEvent(byteSize uint64) error {
	ret := _m.Called(byteSize)

	if len(ret) == 0 {
		panic("no return value specified for MeterEmittedEvent")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(uint64) error); ok {
		r0 = rf(byteSize)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MeterMemory provides a mock function with given fields: usage
func (_m *Environment) MeterMemory(usage common.MemoryUsage) error {
	ret := _m.Called(usage)

	if len(ret) == 0 {
		panic("no return value specified for MeterMemory")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(common.MemoryUsage) error); ok {
		r0 = rf(usage)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MinimumRequiredVersion provides a mock function with no fields
func (_m *Environment) MinimumRequiredVersion() (string, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for MinimumRequiredVersion")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func() (string, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ProgramLog provides a mock function with given fields: _a0
func (_m *Environment) ProgramLog(_a0 string) error {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for ProgramLog")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RandomSourceHistory provides a mock function with no fields
func (_m *Environment) RandomSourceHistory() ([]byte, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for RandomSourceHistory")
	}

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func() ([]byte, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() []byte); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReadRandom provides a mock function with given fields: _a0
func (_m *Environment) ReadRandom(_a0 []byte) error {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for ReadRandom")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func([]byte) error); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RecordTrace provides a mock function with given fields: operation, duration, attrs
func (_m *Environment) RecordTrace(operation string, duration time.Duration, attrs []attribute.KeyValue) {
	_m.Called(operation, duration, attrs)
}

// RecoverProgram provides a mock function with given fields: program, location
func (_m *Environment) RecoverProgram(program *ast.Program, location common.Location) ([]byte, error) {
	ret := _m.Called(program, location)

	if len(ret) == 0 {
		panic("no return value specified for RecoverProgram")
	}

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func(*ast.Program, common.Location) ([]byte, error)); ok {
		return rf(program, location)
	}
	if rf, ok := ret.Get(0).(func(*ast.Program, common.Location) []byte); ok {
		r0 = rf(program, location)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(*ast.Program, common.Location) error); ok {
		r1 = rf(program, location)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveAccountContractCode provides a mock function with given fields: location
func (_m *Environment) RemoveAccountContractCode(location common.AddressLocation) error {
	ret := _m.Called(location)

	if len(ret) == 0 {
		panic("no return value specified for RemoveAccountContractCode")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(common.AddressLocation) error); ok {
		r0 = rf(location)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Reset provides a mock function with no fields
func (_m *Environment) Reset() {
	_m.Called()
}

// ResolveLocation provides a mock function with given fields: identifiers, location
func (_m *Environment) ResolveLocation(identifiers []runtime.Identifier, location runtime.Location) ([]runtime.ResolvedLocation, error) {
	ret := _m.Called(identifiers, location)

	if len(ret) == 0 {
		panic("no return value specified for ResolveLocation")
	}

	var r0 []runtime.ResolvedLocation
	var r1 error
	if rf, ok := ret.Get(0).(func([]runtime.Identifier, runtime.Location) ([]runtime.ResolvedLocation, error)); ok {
		return rf(identifiers, location)
	}
	if rf, ok := ret.Get(0).(func([]runtime.Identifier, runtime.Location) []runtime.ResolvedLocation); ok {
		r0 = rf(identifiers, location)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]runtime.ResolvedLocation)
		}
	}

	if rf, ok := ret.Get(1).(func([]runtime.Identifier, runtime.Location) error); ok {
		r1 = rf(identifiers, location)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResourceOwnerChanged provides a mock function with given fields: _a0, resource, oldOwner, newOwner
func (_m *Environment) ResourceOwnerChanged(_a0 *interpreter.Interpreter, resource *interpreter.CompositeValue, oldOwner common.Address, newOwner common.Address) {
	_m.Called(_a0, resource, oldOwner, newOwner)
}

// RevokeAccountKey provides a mock function with given fields: address, index
func (_m *Environment) RevokeAccountKey(address runtime.Address, index uint32) (*runtime.AccountKey, error) {
	ret := _m.Called(address, index)

	if len(ret) == 0 {
		panic("no return value specified for RevokeAccountKey")
	}

	var r0 *runtime.AccountKey
	var r1 error
	if rf, ok := ret.Get(0).(func(runtime.Address, uint32) (*runtime.AccountKey, error)); ok {
		return rf(address, index)
	}
	if rf, ok := ret.Get(0).(func(runtime.Address, uint32) *runtime.AccountKey); ok {
		r0 = rf(address, index)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*runtime.AccountKey)
		}
	}

	if rf, ok := ret.Get(1).(func(runtime.Address, uint32) error); ok {
		r1 = rf(address, index)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RunWithMeteringDisabled provides a mock function with given fields: f
func (_m *Environment) RunWithMeteringDisabled(f func()) {
	_m.Called(f)
}

// RuntimeSetNumberOfAccounts provides a mock function with given fields: count
func (_m *Environment) RuntimeSetNumberOfAccounts(count uint64) {
	_m.Called(count)
}

// RuntimeTransactionChecked provides a mock function with given fields: _a0
func (_m *Environment) RuntimeTransactionChecked(_a0 time.Duration) {
	_m.Called(_a0)
}

// RuntimeTransactionInterpreted provides a mock function with given fields: _a0
func (_m *Environment) RuntimeTransactionInterpreted(_a0 time.Duration) {
	_m.Called(_a0)
}

// RuntimeTransactionParsed provides a mock function with given fields: _a0
func (_m *Environment) RuntimeTransactionParsed(_a0 time.Duration) {
	_m.Called(_a0)
}

// RuntimeTransactionProgramsCacheHit provides a mock function with no fields
func (_m *Environment) RuntimeTransactionProgramsCacheHit() {
	_m.Called()
}

// RuntimeTransactionProgramsCacheMiss provides a mock function with no fields
func (_m *Environment) RuntimeTransactionProgramsCacheMiss() {
	_m.Called()
}

// ServiceEvents provides a mock function with no fields
func (_m *Environment) ServiceEvents() flow.EventsList {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for ServiceEvents")
	}

	var r0 flow.EventsList
	if rf, ok := ret.Get(0).(func() flow.EventsList); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.EventsList)
		}
	}

	return r0
}

// SetNumberOfDeployedCOAs provides a mock function with given fields: count
func (_m *Environment) SetNumberOfDeployedCOAs(count uint64) {
	_m.Called(count)
}

// SetValue provides a mock function with given fields: owner, key, value
func (_m *Environment) SetValue(owner []byte, key []byte, value []byte) error {
	ret := _m.Called(owner, key, value)

	if len(ret) == 0 {
		panic("no return value specified for SetValue")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func([]byte, []byte, []byte) error); ok {
		r0 = rf(owner, key, value)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StartChildSpan provides a mock function with given fields: name, options
func (_m *Environment) StartChildSpan(name trace.SpanName, options ...oteltrace.SpanStartOption) tracing.TracerSpan {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, name)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartChildSpan")
	}

	var r0 tracing.TracerSpan
	if rf, ok := ret.Get(0).(func(trace.SpanName, ...oteltrace.SpanStartOption) tracing.TracerSpan); ok {
		r0 = rf(name, options...)
	} else {
		r0 = ret.Get(0).(tracing.TracerSpan)
	}

	return r0
}

// TotalEmittedEventBytes provides a mock function with no fields
func (_m *Environment) TotalEmittedEventBytes() uint64 {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for TotalEmittedEventBytes")
	}

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	return r0
}

// TransactionFeesEnabled provides a mock function with no fields
func (_m *Environment) TransactionFeesEnabled() bool {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for TransactionFeesEnabled")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// TxID provides a mock function with no fields
func (_m *Environment) TxID() flow.Identifier {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for TxID")
	}

	var r0 flow.Identifier
	if rf, ok := ret.Get(0).(func() flow.Identifier); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.Identifier)
		}
	}

	return r0
}

// TxIndex provides a mock function with no fields
func (_m *Environment) TxIndex() uint32 {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for TxIndex")
	}

	var r0 uint32
	if rf, ok := ret.Get(0).(func() uint32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint32)
	}

	return r0
}

// UpdateAccountContractCode provides a mock function with given fields: location, code
func (_m *Environment) UpdateAccountContractCode(location common.AddressLocation, code []byte) error {
	ret := _m.Called(location, code)

	if len(ret) == 0 {
		panic("no return value specified for UpdateAccountContractCode")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(common.AddressLocation, []byte) error); ok {
		r0 = rf(location, code)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ValidateAccountCapabilitiesGet provides a mock function with given fields: context, address, path, wantedBorrowType, capabilityBorrowType
func (_m *Environment) ValidateAccountCapabilitiesGet(context interpreter.AccountCapabilityGetValidationContext, address interpreter.AddressValue, path interpreter.PathValue, wantedBorrowType *sema.ReferenceType, capabilityBorrowType *sema.ReferenceType) (bool, error) {
	ret := _m.Called(context, address, path, wantedBorrowType, capabilityBorrowType)

	if len(ret) == 0 {
		panic("no return value specified for ValidateAccountCapabilitiesGet")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(interpreter.AccountCapabilityGetValidationContext, interpreter.AddressValue, interpreter.PathValue, *sema.ReferenceType, *sema.ReferenceType) (bool, error)); ok {
		return rf(context, address, path, wantedBorrowType, capabilityBorrowType)
	}
	if rf, ok := ret.Get(0).(func(interpreter.AccountCapabilityGetValidationContext, interpreter.AddressValue, interpreter.PathValue, *sema.ReferenceType, *sema.ReferenceType) bool); ok {
		r0 = rf(context, address, path, wantedBorrowType, capabilityBorrowType)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(interpreter.AccountCapabilityGetValidationContext, interpreter.AddressValue, interpreter.PathValue, *sema.ReferenceType, *sema.ReferenceType) error); ok {
		r1 = rf(context, address, path, wantedBorrowType, capabilityBorrowType)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ValidateAccountCapabilitiesPublish provides a mock function with given fields: context, address, path, capabilityBorrowType
func (_m *Environment) ValidateAccountCapabilitiesPublish(context interpreter.AccountCapabilityPublishValidationContext, address interpreter.AddressValue, path interpreter.PathValue, capabilityBorrowType *interpreter.ReferenceStaticType) (bool, error) {
	ret := _m.Called(context, address, path, capabilityBorrowType)

	if len(ret) == 0 {
		panic("no return value specified for ValidateAccountCapabilitiesPublish")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(interpreter.AccountCapabilityPublishValidationContext, interpreter.AddressValue, interpreter.PathValue, *interpreter.ReferenceStaticType) (bool, error)); ok {
		return rf(context, address, path, capabilityBorrowType)
	}
	if rf, ok := ret.Get(0).(func(interpreter.AccountCapabilityPublishValidationContext, interpreter.AddressValue, interpreter.PathValue, *interpreter.ReferenceStaticType) bool); ok {
		r0 = rf(context, address, path, capabilityBorrowType)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(interpreter.AccountCapabilityPublishValidationContext, interpreter.AddressValue, interpreter.PathValue, *interpreter.ReferenceStaticType) error); ok {
		r1 = rf(context, address, path, capabilityBorrowType)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ValidatePublicKey provides a mock function with given fields: key
func (_m *Environment) ValidatePublicKey(key *runtime.PublicKey) error {
	ret := _m.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for ValidatePublicKey")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*runtime.PublicKey) error); ok {
		r0 = rf(key)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ValueExists provides a mock function with given fields: owner, key
func (_m *Environment) ValueExists(owner []byte, key []byte) (bool, error) {
	ret := _m.Called(owner, key)

	if len(ret) == 0 {
		panic("no return value specified for ValueExists")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func([]byte, []byte) (bool, error)); ok {
		return rf(owner, key)
	}
	if rf, ok := ret.Get(0).(func([]byte, []byte) bool); ok {
		r0 = rf(owner, key)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func([]byte, []byte) error); ok {
		r1 = rf(owner, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VerifySignature provides a mock function with given fields: signature, tag, signedData, publicKey, signatureAlgorithm, hashAlgorithm
func (_m *Environment) VerifySignature(signature []byte, tag string, signedData []byte, publicKey []byte, signatureAlgorithm runtime.SignatureAlgorithm, hashAlgorithm runtime.HashAlgorithm) (bool, error) {
	ret := _m.Called(signature, tag, signedData, publicKey, signatureAlgorithm, hashAlgorithm)

	if len(ret) == 0 {
		panic("no return value specified for VerifySignature")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func([]byte, string, []byte, []byte, runtime.SignatureAlgorithm, runtime.HashAlgorithm) (bool, error)); ok {
		return rf(signature, tag, signedData, publicKey, signatureAlgorithm, hashAlgorithm)
	}
	if rf, ok := ret.Get(0).(func([]byte, string, []byte, []byte, runtime.SignatureAlgorithm, runtime.HashAlgorithm) bool); ok {
		r0 = rf(signature, tag, signedData, publicKey, signatureAlgorithm, hashAlgorithm)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func([]byte, string, []byte, []byte, runtime.SignatureAlgorithm, runtime.HashAlgorithm) error); ok {
		r1 = rf(signature, tag, signedData, publicKey, signatureAlgorithm, hashAlgorithm)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewEnvironment creates a new instance of Environment. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewEnvironment(t interface {
	mock.TestingT
	Cleanup(func())
}) *Environment {
	mock := &Environment{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
