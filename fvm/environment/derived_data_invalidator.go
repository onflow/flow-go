package environment

import (
	"github.com/onflow/cadence/runtime/common"

	"github.com/onflow/flow-go/fvm/derived"
	"github.com/onflow/flow-go/fvm/state"
	"github.com/onflow/flow-go/model/flow"
)

type ContractUpdateKey struct {
	Address flow.Address
	Name    string
}

type ContractUpdate struct {
	ContractUpdateKey
	Code []byte
}

type DerivedDataInvalidator struct {
	ContractUpdateKeys []ContractUpdateKey

	MeterParamOverridesUpdated bool
}

var _ derived.TransactionInvalidator = DerivedDataInvalidator{}

// TODO(patrick): extract contractKeys from executionSnapshot
func NewDerivedDataInvalidator(
	contractKeys []ContractUpdateKey,
	serviceAddress flow.Address,
	executionSnapshot *state.ExecutionSnapshot,
) DerivedDataInvalidator {
	return DerivedDataInvalidator{
		ContractUpdateKeys: contractKeys,
		MeterParamOverridesUpdated: meterParamOverridesUpdated(
			serviceAddress,
			executionSnapshot),
	}
}

func meterParamOverridesUpdated(
	serviceAddress flow.Address,
	executionSnapshot *state.ExecutionSnapshot,
) bool {
	serviceAccount := string(serviceAddress.Bytes())
	storageDomain := common.PathDomainStorage.Identifier()

	for registerId := range executionSnapshot.WriteSet {
		// The meter param override values are stored in the service account.
		if registerId.Owner != serviceAccount {
			continue
		}

		// NOTE: This condition is empirically generated by running the
		// MeterParamOverridesComputer to capture touched registers.
		//
		// The paramater settings are stored as regular fields in the service
		// account.  In general, each account's regular fields are stored in
		// ordered map known only to cadence.  Cadence encodes this map into
		// bytes and split the bytes into slab chunks before storing the slabs
		// into the ledger.  Hence any changes to the stabs indicate changes
		// the ordered map.
		//
		// The meter param overrides use storageDomain as input, so any
		// changes to it must also invalidate the values.
		if registerId.Key == storageDomain || registerId.IsSlabIndex() {
			return true
		}
	}

	return false
}

func (invalidator DerivedDataInvalidator) ProgramInvalidator() derived.ProgramInvalidator {
	return ProgramInvalidator{invalidator}
}

func (invalidator DerivedDataInvalidator) MeterParamOverridesInvalidator() derived.MeterParamOverridesInvalidator {
	return MeterParamOverridesInvalidator{invalidator}
}

type ProgramInvalidator struct {
	DerivedDataInvalidator
}

func (invalidator ProgramInvalidator) ShouldInvalidateEntries() bool {
	return invalidator.MeterParamOverridesUpdated ||
		len(invalidator.ContractUpdateKeys) > 0
}

func (invalidator ProgramInvalidator) ShouldInvalidateEntry(
	location common.AddressLocation,
	program *derived.Program,
	snapshot *state.ExecutionSnapshot,
) bool {
	if invalidator.MeterParamOverridesUpdated {
		// if meter parameters changed we need to invalidate all programs
		return true
	}

	// invalidate all programs depending on any of the contracts that were
	// updated.  A program has itself listed as a dependency, so that this
	// simpler.
	for _, key := range invalidator.ContractUpdateKeys {
		loc := common.AddressLocation{
			Address: common.MustBytesToAddress(key.Address.Bytes()),
			Name:    key.Name,
		}
		_, ok := program.Dependencies[loc]
		if ok {
			return true
		}
	}
	return false
}

type MeterParamOverridesInvalidator struct {
	DerivedDataInvalidator
}

func (invalidator MeterParamOverridesInvalidator) ShouldInvalidateEntries() bool {
	return invalidator.MeterParamOverridesUpdated
}

func (invalidator MeterParamOverridesInvalidator) ShouldInvalidateEntry(
	_ struct{},
	_ derived.MeterParamOverrides,
	_ *state.ExecutionSnapshot,
) bool {
	return invalidator.MeterParamOverridesUpdated
}
