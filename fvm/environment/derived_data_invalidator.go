package environment

import (
	"github.com/onflow/cadence/runtime/common"

	"github.com/onflow/flow-go/fvm/derived"
	"github.com/onflow/flow-go/fvm/state"
)

type ContractUpdateKey struct {
	Address common.Address
	Name    string
}

type ContractUpdate struct {
	ContractUpdateKey
	Code []byte
}

type DerivedDataInvalidator struct {
	ContractUpdateKeys []ContractUpdateKey
	FrozenAccounts     []common.Address

	MeterParamOverridesUpdated bool
}

var _ derived.TransactionInvalidator = DerivedDataInvalidator{}

func NewDerivedDataInvalidator(
	contractKeys []ContractUpdateKey,
	env *facadeEnvironment,
) DerivedDataInvalidator {
	return DerivedDataInvalidator{
		ContractUpdateKeys:         contractKeys,
		FrozenAccounts:             env.FrozenAccounts(),
		MeterParamOverridesUpdated: meterParamOverridesUpdated(env),
	}
}

func meterParamOverridesUpdated(env *facadeEnvironment) bool {
	serviceAccount := string(env.chain.ServiceAddress().Bytes())
	storageDomain := common.PathDomainStorage.Identifier()

	for _, registerId := range env.txnState.UpdatedRegisterIDs() {
		// The meter param override values are stored in the service account.
		if registerId.Owner != serviceAccount {
			continue
		}

		// NOTE: This condition is empirically generated by running the
		// MeterParamOverridesComputer to capture touched registers.
		//
		// The paramater settings are stored as regular fields in the service
		// account.  In general, each account's regular fields are stored in
		// ordered map known only to cadence.  Cadence encodes this map into
		// bytes and split the bytes into slab chunks before storing the slabs
		// into the ledger.  Hence any changes to the stabs indicate changes
		// the ordered map.
		//
		// The meter param overrides use storageDomain as input, so any
		// changes to it must also invalidate the values.
		if registerId.Key == storageDomain || registerId.IsSlabIndex() {
			return true
		}
	}

	return false
}

func (invalidator DerivedDataInvalidator) ProgramInvalidator() derived.ProgramInvalidator {
	return ProgramInvalidator{invalidator}
}

func (invalidator DerivedDataInvalidator) MeterParamOverridesInvalidator() derived.MeterParamOverridesInvalidator {
	return MeterParamOverridesInvalidator{invalidator}
}

type ProgramInvalidator struct {
	DerivedDataInvalidator
}

func (invalidator ProgramInvalidator) ShouldInvalidateEntries() bool {
	return invalidator.MeterParamOverridesUpdated ||
		len(invalidator.ContractUpdateKeys) > 0 ||
		len(invalidator.FrozenAccounts) > 0
}

func (invalidator ProgramInvalidator) ShouldInvalidateEntry(
	location common.AddressLocation,
	program *derived.Program,
	state *state.State,
) bool {
	if invalidator.MeterParamOverridesUpdated {
		// if meter parameters changed we need to invalidate all programs
		return true
	}

	// if an account was (un)frozen we need to invalidate all
	// programs that depend on any contract on that address.
	for _, frozenAccount := range invalidator.FrozenAccounts {
		_, ok := program.Dependencies[frozenAccount]
		if ok {
			return true
		}
	}

	// invalidate all programs depending on any of the contracts that were updated
	// A program has itself listed as a dependency, so that this simpler.
	for _, key := range invalidator.ContractUpdateKeys {
		_, ok := program.Dependencies[key.Address]
		if ok {
			return true
		}
	}
	return false
}

type MeterParamOverridesInvalidator struct {
	DerivedDataInvalidator
}

func (invalidator MeterParamOverridesInvalidator) ShouldInvalidateEntries() bool {
	return invalidator.MeterParamOverridesUpdated
}

func (invalidator MeterParamOverridesInvalidator) ShouldInvalidateEntry(
	_ struct{},
	_ derived.MeterParamOverrides,
	_ *state.State,
) bool {
	return invalidator.MeterParamOverridesUpdated
}
