package flow

// DKGState captures all possible states of the Recoverable Random Beacon State Machine.
type DKGState uint32

const (
	// DKGStateUninitialized - zero value for this enum, indicates that there is no initialized state.
	// Conceptually, this is the 'initial' state of a finite state machine before any transitions.
	DKGStateUninitialized DKGState = iota
	// DKGStateStarted - the DKG process has been started. This state is set when the node enters the [flow.EpochPhaseSetup]
	// phase and starts the DKG process, which will on the happy path result in generating a Random Beacon key.
	DKGStateStarted
	// DKGStateCompleted - the DKG process has been locally completed by this node. This state is set when the node successfully
	// completes the DKG process and has generated a Random Beacon key.
	// ATTENTION: This state does not imply that there is a safe Random Beacon key available for the next epoch. Only after
	// the node enters [flow.EpochPhaseCommitted] and the [flow.EpochCommit] service event has been finalized, we can be sure
	// that our beacon key share is part of the Random Beacon Committee for the next epoch, in this case the state will be [flow.RandomBeaconKeyCommitted].
	DKGStateCompleted
	// RandomBeaconKeyCommitted - the Random Beacon key has been committed. This state is set when the node has observed an [flow.EpochCommit]
	// which contains the public key share that matches the private key share that the node has obtained.
	// A node can obtain a key share by successfully completing the DKG process or by manually injecting a key share obtained
	// by other means (e.g. key recovery).
	// Regardless of the key origin, this is a terminal state which defines a safe Random Beacon key for the next epoch and allows the node
	// to participate in the Random Beacon protocol.
	RandomBeaconKeyCommitted
	// DKGStateFailure - DKG process has failed, this state indicates that we have left the happy path.
	DKGStateFailure
)

func (state DKGState) String() string {
	switch state {
	case DKGStateStarted:
		return "DKGStateStarted"
	case DKGStateCompleted:
		return "DKGStateCompleted"
	case RandomBeaconKeyCommitted:
		return "RandomBeaconKeyCommitted"
	case DKGStateFailure:
		return "DKGStateFailure"
	default:
		return "DKGStateUninitialized"
	}
}

// DKGIndexMap completely describes the DKG committee 𝒟 of size |𝒟| = n.
//
// Formal specification:
//   - If n parties are authorized to participate in the DKG, DKGIndexMap must contain exactly n
//     elements, i.e. n = len(DKGIndexMap)
//   - The values in DKGIndexMap must form the set {0, 1, …, n-1}, as required by the low level cryptography
//     module (convention simplifying the implementation).
//
// Flow's Random Beacon utilizes a threshold signature scheme run by the committee 𝒟.
// In the formal cryptographic protocol for a threshold signature with n parties, the
// individual participants are identified by n public distinct non-negative integers, or simply indices.
// These public indices are agreed upon by all participants and are used by the low-level
// Shamir Secret Sharing [SSS].
// In Flow, the threshold signature keys are generated by a Distributed Key Generation [DKG]. The DKG
// therefore requires the same SSS indices as an input to generate the private key shares of each participant.
// Accordingly, the lower-level cryptographic implementation of the threshold signature and DKG
// works with these indices. The lower-level cryptographic interface requires that the indices are exactly
// the set {0, 1, ..., n-1}.
//
// On the protocol level, only consensus nodes (identified by their nodeIDs) are allowed to contribute
// Random Beacon signature shares. Hence, the protocol level needs to map nodeIDs to the indices when
// calling into the lower-level cryptographic primitives.
//
// CAUTION: It is important to cleanly differentiate between the consensus committee 𝒞, the DKG committee 𝒟
// and the committee ℛ:
//   - For an epoch, the consensus committee 𝒞 contains all nodes that are authorized to vote for blocks. Authority
//     to vote (i.e. membership in the consensus committee) is irrevocably granted for an epoch (though, honest nodes
//     will reject votes and proposals from ejected nodes; nevertheless, ejected nodes formally remain members of
//     the consensus committee).
//   - The DKG committee 𝒟 is the set of parties that were authorized to participate in the DKG (happy path; or
//     eligible to receive a private key share from an alternative source on the fallback path). Mathematically,
//     the DKGIndexMap is a bijective function DKGIndexMap: 𝒟 ↦ {0,1,…,n-1}.
//   - Only consensus nodes are allowed to contribute to the Random Beacon. Informally, we define ℛ as the
//     as the subset of the consensus committee (ℛ ⊆ 𝒞), which _successfully_ completed the DKG (hence ℛ ⊆ 𝒟).
//     Specifically, r ∈ ℛ iff and only if r has a private Random Beacon key share matching the respective public
//     key share in the `EpochCommit` event. In other words, consensus nodes are in ℛ iff and only if they are able
//     to submit valid Random Beacon votes. Based on this definition we note that ℛ ⊆ (𝒟 ∩ 𝒞).
//
// The protocol explicitly ALLOWS additional parties outside the current epoch's consensus committee to participate.
// In particular, there can be a key-value pair (d,i) ∈ DKGIndexMap, such that the nodeID d is *not* a consensus
// committee member, i.e. d ∉ 𝒞. This may be the case when a DKG is run off-protocol to bootstrap the network.
// In terms of sets, this implies we must consistently work with the relatively general
// assumption that 𝒟 \ 𝒞 ≠ ∅ and 𝒞 \ 𝒟 ≠ ∅.
// Nevertheless, in the vast majority of cases (happy path, roughly 98% of epochs) it will be the case that 𝒟 = 𝒞.
// Therefore, we can optimize for the case 𝒟 = 𝒞, as long as we still support the more general case 𝒟 ≠ 𝒞.
// Broadly, this makes the protocol more robust against temporary disruptions and sudden, large fluctuations in node
// participation.
//
// Nevertheless, there is an important liveness constraint: the committee ℛ should be a large number of nodes.
// Specifically, an honest supermajority of consensus nodes must contain enough successful DKG participants
// (about |𝒟|/2 + 1) to produce a valid group signature for the Random Beacon at each block [1, 3].
// Therefore, we have the approximate lower bound |ℛ| ≳ n/2 + 1 = |𝒟|/2 + 1 = len(DKGIndexMap)/2 + 1.
// Operating close to this lower bound would require that every Random Beacon key-holder ϱ ∈ ℛ remaining in the consensus committee is honest
// (incl. quickly responsive) *all the time*. Such a reliability assumption is unsuited for decentralized production networks.
// To reject configurations that are vulnerable to liveness failures, the protocol uses the threshold `t_safety`
// (heuristic, see [2]), which is implemented on the smart contract level.
// Ideally, |ℛ| and therefore |𝒟 ∩ 𝒞| (given that |ℛ| <= |𝒟 ∩ 𝒞|) should be well above 70% . |𝒟|.
// Values in the range 70%-62% of |𝒟| should be considered for short-term recovery cases.
// Values of 62% * |𝒟| or lower (i.e. |ℛ| ≤ 0.62·|𝒟|) are not recommended for any
// production network, as single-node crashes may already be enough to halt consensus.
//
// For further details, see
//   - [1] https://www.notion.so/flowfoundation/Threshold-Signatures-7e26c6dd46ae40f7a83689ba75a785e3?pvs=4
//   - [2] https://www.notion.so/flowfoundation/DKG-contract-success-threshold-86c6bf2b92034855b3c185d7616eb6f1?pvs=4
//   - [3] https://www.notion.so/flowfoundation/Architecture-for-Concurrent-Vote-Processing-41704666bc414a03869b70ba1043605f?pvs=4
type DKGIndexMap map[Identifier]int
