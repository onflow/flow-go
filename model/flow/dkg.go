package flow

// DKGState captures all possible states of the Recoverable Random Beacon State Machine.
type DKGState uint32

const (
	// DKGStateUninitialized - zero value for this enum, indicates that there is no initialized state.
	// Conceptually, this is the 'initial' state of a finite state machine before any transitions.
	DKGStateUninitialized DKGState = iota
	// DKGStateStarted - the DKG process has been started. This state is set when the node enters the [flow.EpochPhaseSetup]
	// phase and starts the DKG process, which will on the happy path result in generating a Random Beacon key.
	DKGStateStarted
	// DKGStateCompleted - the DKG process has been locally completed by this node. This state is set when the node successfully
	// completes the DKG process and has generated a Random Beacon key.
	// ATTENTION: This state does not imply that there is a safe Random Beacon key available for the next epoch. Only after
	// the node enters [flow.EpochPhaseCommitted] and the [flow.EpochCommit] service event has been finalized, we can be sure
	// that our beacon key share is part of the Random Beacon Committee for the next epoch, in this case the state will be [flow.RandomBeaconKeyCommitted].
	DKGStateCompleted
	// RandomBeaconKeyCommitted - the Random Beacon key has been committed. This state is set when the node has observed an [flow.EpochCommit]
	// which contains the public key share that matches the private key share that the node has obtained.
	// A node can obtain a key share by successfully completing the DKG process or by manually injecting a key share obtained
	// by other means (e.g. key recovery).
	// Despite the key origin this is a terminal state which defines a safe Random Beacon key for the next epoch and allow node
	// to participate in the Random Beacon protocol.
	RandomBeaconKeyCommitted
	// DKGStateFailure - DKG process has failed, this state indicates that we have left the happy path.
	DKGStateFailure
)

func (state DKGState) String() string {
	switch state {
	case DKGStateStarted:
		return "DKGStateStarted"
	case DKGStateCompleted:
		return "DKGStateCompleted"
	case RandomBeaconKeyCommitted:
		return "RandomBeaconKeyCommitted"
	case DKGStateFailure:
		return "DKGStateFailure"
	default:
		return "DKGStateUninitialized"
	}
}

// DKGIndexMap completely describes the DKG committee ğ’Ÿ of size |ğ’Ÿ| = n.
//
// Formal specification:
//   - If n parties are authorized to participate in the DKG, DKGIndexMap must contain exactly n
//     elements, i.e. n = len(DKGIndexMap)
//   - The values in DKGIndexMap must form the set {0, 1, â€¦, n-1}, as required by the low level cryptography
//     module (convention simplifying the implementation).
//
// Flow's Random Beacon utilizes a threshold signature scheme run by the committee ğ’Ÿ.
// In the formal cryptographic protocol for a threshold signature with n parties, the
// individual participants are identified by n public distinct non-negative integers, or simply indices.
// These public indices are agreed upon by all participants and are used by the low-level
// Shamir Secret Sharing [SSS].
// In Flow, the threshold signature keys are generated by a Distributed Key Generation [DKG]. The DKG
// therefore requires the same SSS indices as an input to generate the private key shares of each participant.
// Accordingly, the lower-level cryptographic implementation of the threshold signature and DKG
// works with these indices. The lower-level cryptographic interface requires that the indices are exactly
// the set {0, 1, ..., n-1}.
//
// On the protocol level, only consensus nodes (identified by their nodeIDs) are allowed to contribute
// Random Beacon signature shares. Hence, the protocol level needs to map nodeIDs to the indices when
// calling into the lower-level cryptographic primitives.
//
// CAUTION: It is important to cleanly differentiate between the consensus committee ğ’, the DKG committee ğ’Ÿ
// and the committee â„›:
//   - For an epoch, the consensus committee ğ’ contains all nodes that are authorized to vote for blocks. Authority
//     to vote (i.e. membership in the consensus committee) is irrevocably granted for an epoch (though, honest nodes
//     will reject votes and proposals from ejected nodes; nevertheless, ejected nodes formally remain members of
//     the consensus committee).
//   - The DKG committee ğ’Ÿ is the set of parties that were authorized to participate in the DKG (happy path; or
//     eligible to receive a private key share from an alternative source on the fallback path). Mathematically,
//     the DKGIndexMap is a bijective function DKGIndexMap: ğ’Ÿ â†¦ {0,1,â€¦,n-1}.
//   - Only consensus nodes are allowed to contribute to the Random Beacon. Informally, we define â„› as the
//     as the subset of the consensus committee (â„› âŠ† ğ’), which _successfully_ completed the DKG (hence â„› âŠ† ğ’Ÿ).
//     Specifically, r âˆˆ â„› iff and only if r has a private Random Beacon key share matching the respective public
//     key share in the `EpochCommit` event. In other words, consensus nodes are in â„› iff and only if they are able
//     to submit valid Random Beacon votes. Based on this definition we note that â„› âŠ† (ğ’Ÿ âˆ© ğ’).
//
// The protocol explicitly ALLOWS additional parties outside the current epoch's consensus committee to participate.
// In particular, there can be a key-value pair (d,i) âˆˆ DKGIndexMap, such that the nodeID d is *not* a consensus
// committee member, i.e. d âˆ‰ ğ’. This may be the case when a DKG is run off-protocol to bootstrap the network.
// In terms of sets, this implies we must consistently work with the relatively general
// assumption that ğ’Ÿ \ ğ’ â‰  âˆ… and ğ’ \ ğ’Ÿ â‰  âˆ….
// Nevertheless, in the vast majority of cases (happy path, roughly 98% of epochs) it will be the case that ğ’Ÿ = ğ’.
// Therefore, we can optimize for the case ğ’Ÿ = ğ’, as long as we still support the more general case ğ’Ÿ â‰  ğ’.
// Broadly, this makes the protocol more robust against temporary disruptions and sudden, large fluctuations in node
// participation.
//
// Nevertheless, there is an important liveness constraint: the committee â„› should be a large number of nodes.
// Specifically, an honest supermajority of consensus nodes must contain enough successful DKG participants
// (about |ğ’Ÿ|/2 + 1) to produce a valid group signature for the Random Beacon at each block [1, 3].
// Therefore, we have the approximate lower bound |â„›| â‰³ n/2 + 1 = |ğ’Ÿ|/2 + 1 = len(DKGIndexMap)/2 + 1.
// Operating close to this lower bound would require that every Random Beacon key-holder Ï± âˆˆ â„› remaining in the consensus committee is honest
// (incl. quickly responsive) *all the time*. Such a reliability assumption is unsuited for decentralized production networks.
// To reject configurations that are vulnerable to liveness failures, the protocol uses the threshold `t_safety`
// (heuristic, see [2]), which is implemented on the smart contract level.
// Ideally, |â„›| and therefore |ğ’Ÿ âˆ© ğ’| (given that |â„›| <= |ğ’Ÿ âˆ© ğ’|) should be well above 70% . |ğ’Ÿ|.
// Values in the range 70%-62% of |ğ’Ÿ| should be considered for short-term recovery cases.
// Values of 62% * |ğ’Ÿ| or lower (i.e. |â„›| â‰¤ 0.62Â·|ğ’Ÿ|) are not recommended for any
// production network, as single-node crashes may already be enough to halt consensus.
//
// For further details, see
//   - [1] https://www.notion.so/flowfoundation/Threshold-Signatures-7e26c6dd46ae40f7a83689ba75a785e3?pvs=4
//   - [2] https://www.notion.so/flowfoundation/DKG-contract-success-threshold-86c6bf2b92034855b3c185d7616eb6f1?pvs=4
//   - [3] https://www.notion.so/flowfoundation/Architecture-for-Concurrent-Vote-Processing-41704666bc414a03869b70ba1043605f?pvs=4
type DKGIndexMap map[Identifier]int
