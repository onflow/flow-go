package flow_test

import (
	"fmt"
	"math/rand"
	"testing"

	clone "github.com/huandu/go-clone/generic"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/onflow/flow-go/model/flow"
	"github.com/onflow/flow-go/utils/unittest"
)

// TestEpochProtocolStateEntry_EpochPhase tests that all possible instances of an MinEpochStateEntry
// correctly compute the current epoch phase, taking into account EFM status and incorporated service events.
func TestEpochProtocolStateEntry_EpochPhase(t *testing.T) {

	t.Run("EFM triggered", func(t *testing.T) {
		t.Run("tentatively in staking phase", func(t *testing.T) {
			entry := unittest.EpochProtocolStateEntryFixture(flow.EpochPhaseStaking, true)
			assert.Equal(t, flow.EpochPhaseFallback, entry.EpochPhase())
		})
		t.Run("tentatively in setup phase", func(t *testing.T) {
			// Caution, the following is a degenerate edge-case that should _never_ be generated by the
			// FallbackStateMachine. Specifically, the FallbackStateMachine should clear out
			// any tentative values for a subsequent epoch _unless_ that epoch is already committed.
			entry := unittest.EpochProtocolStateEntryFixture(flow.EpochPhaseSetup, true)
			assert.Equal(t, flow.EpochPhaseFallback, entry.EpochPhase())
		})
		t.Run("tentatively in committed phase", func(t *testing.T) {
			entry := unittest.EpochProtocolStateEntryFixture(flow.EpochPhaseCommitted, true)
			assert.Equal(t, flow.EpochPhaseCommitted, entry.EpochPhase())
		})
	})

	t.Run("EFM not triggered", func(t *testing.T) {
		t.Run("tentatively in staking phase", func(t *testing.T) {
			entry := unittest.EpochProtocolStateEntryFixture(flow.EpochPhaseStaking, false)
			assert.Equal(t, flow.EpochPhaseStaking, entry.EpochPhase())
		})
		t.Run("tentatively in setup phase", func(t *testing.T) {
			entry := unittest.EpochProtocolStateEntryFixture(flow.EpochPhaseSetup, false)
			assert.Equal(t, flow.EpochPhaseSetup, entry.EpochPhase())
		})
		t.Run("tentatively in committed phase", func(t *testing.T) {
			entry := unittest.EpochProtocolStateEntryFixture(flow.EpochPhaseCommitted, false)
			assert.Equal(t, flow.EpochPhaseCommitted, entry.EpochPhase())
		})
	})
}

// TestNewRichProtocolStateEntry checks that NewRichEpochStateEntry creates valid identity tables depending on the state
// of epoch which is derived from the protocol state entry.
// It checks for correct handling of both valid and invalid inputs, ensuring that the function
// correctly validates epoch service event consistency and presence.
//
// Valid Cases:
//
// 1. staking-root-protocol-state:
//   - No previous epoch; current epoch is in staking phase.
//
// 2. staking-phase:
//   - Previous and current epochs exist; no next epoch.
//
// 3. setup-phase:
//   - Next epoch setup is present; next epoch commit is nil.
//
// 4. setup-after-spork:
//   - First epoch after spork; no previous epoch; next epoch setup is present.
//
// 5. commit-phase:
//   - Previous, current, and next epochs are fully populated.
//
// 6. commit-after-spork:
//   - First epoch after spork; current and next epochs are committed.
//
// Invalid Cases:
//
// 7. invalid - epoch state is nil:
//   - Verifies that constructor returns an error if EpochStateEntry is nil.
func TestNewRichProtocolStateEntry(t *testing.T) {
	// 1. Conditions right after a spork:
	//  * no previous epoch exists from the perspective of the freshly-sporked protocol state
	//  * network is currently in the staking phase for the next epoch, hence no service events for the next epoch exist
	t.Run("staking-root-protocol-state", func(t *testing.T) {
		setup := unittest.EpochSetupFixture()
		currentEpochCommit := unittest.EpochCommitFixture()
		identities := make(flow.DynamicIdentityEntryList, 0, len(setup.Participants))
		for _, identity := range setup.Participants {
			identities = append(identities, &flow.DynamicIdentityEntry{
				NodeID:  identity.NodeID,
				Ejected: false,
			})
		}
		minStateEntry := &flow.MinEpochStateEntry{
			PreviousEpoch: nil,
			CurrentEpoch: flow.EpochStateContainer{
				SetupID:          setup.ID(),
				CommitID:         currentEpochCommit.ID(),
				ActiveIdentities: identities,
			},
			EpochFallbackTriggered: false,
		}
		stateEntry, err := flow.NewEpochStateEntry(
			flow.UntrustedEpochStateEntry{
				MinEpochStateEntry:  minStateEntry,
				PreviousEpochSetup:  nil,
				PreviousEpochCommit: nil,
				CurrentEpochSetup:   setup,
				CurrentEpochCommit:  currentEpochCommit,
				NextEpochSetup:      nil,
				NextEpochCommit:     nil,
			},
		)
		assert.NoError(t, err)
		assert.Equal(t, flow.EpochPhaseStaking, stateEntry.EpochPhase())

		richStateEntry, err := flow.NewRichEpochStateEntry(stateEntry)
		assert.NoError(t, err)

		expectedIdentities, err := flow.BuildIdentityTable(
			setup.Participants,
			identities,
			nil,
			nil,
			flow.EpochParticipationStatusLeaving,
		)
		assert.NoError(t, err)
		assert.Equal(t, expectedIdentities, richStateEntry.CurrentEpochIdentityTable, "should be equal to current epoch setup participants")
	})

	// 2. Common situation during the staking phase for epoch N+1
	//  * we are currently in Epoch N
	//  * previous epoch N-1 is known (specifically EpochSetup and EpochCommit events)
	//  * network is currently in the staking phase for the next epoch, hence no service events for the next epoch exist
	t.Run("staking-phase", func(t *testing.T) {
		stateEntryFixture := unittest.EpochStateFixture()
		epochStateEntry, err := flow.NewEpochStateEntry(
			flow.UntrustedEpochStateEntry{
				MinEpochStateEntry:  stateEntryFixture.MinEpochStateEntry,
				PreviousEpochSetup:  stateEntryFixture.PreviousEpochSetup,
				PreviousEpochCommit: stateEntryFixture.PreviousEpochCommit,
				CurrentEpochSetup:   stateEntryFixture.CurrentEpochSetup,
				CurrentEpochCommit:  stateEntryFixture.CurrentEpochCommit,
				NextEpochSetup:      nil,
				NextEpochCommit:     nil,
			},
		)
		assert.NoError(t, err)
		assert.Equal(t, flow.EpochPhaseStaking, epochStateEntry.EpochPhase())

		epochRichStateEntry, err := flow.NewRichEpochStateEntry(epochStateEntry)
		assert.NoError(t, err)
		expectedIdentities, err := flow.BuildIdentityTable(
			stateEntryFixture.CurrentEpochSetup.Participants,
			stateEntryFixture.CurrentEpoch.ActiveIdentities,
			stateEntryFixture.PreviousEpochSetup.Participants,
			stateEntryFixture.PreviousEpoch.ActiveIdentities,
			flow.EpochParticipationStatusLeaving,
		)
		assert.NoError(t, err)
		assert.Equal(t, expectedIdentities, epochRichStateEntry.CurrentEpochIdentityTable, "should be equal to current epoch setup participants + previous epoch setup participants")
		assert.Nil(t, epochRichStateEntry.NextEpoch)
	})

	// 3. Common situation during the epoch setup phase for epoch N+1
	//  * we are currently in Epoch N
	//  * previous epoch N-1 is known (specifically EpochSetup and EpochCommit events)
	//  * network is currently in the setup phase for the next epoch, i.e. EpochSetup event (starting setup phase) has already been observed
	t.Run("setup-phase", func(t *testing.T) {
		stateEntryFixture := unittest.EpochStateFixture(unittest.WithNextEpochProtocolState(), func(entry *flow.RichEpochStateEntry) {
			entry.NextEpochCommit = nil
			entry.NextEpoch.CommitID = flow.ZeroID
		})

		stateEntry, err := flow.NewEpochStateEntry(
			flow.UntrustedEpochStateEntry{
				MinEpochStateEntry:  stateEntryFixture.MinEpochStateEntry,
				PreviousEpochSetup:  stateEntryFixture.PreviousEpochSetup,
				PreviousEpochCommit: stateEntryFixture.PreviousEpochCommit,
				CurrentEpochSetup:   stateEntryFixture.CurrentEpochSetup,
				CurrentEpochCommit:  stateEntryFixture.CurrentEpochCommit,
				NextEpochSetup:      stateEntryFixture.NextEpochSetup,
				NextEpochCommit:     nil,
			},
		)
		assert.NoError(t, err)
		assert.Equal(t, flow.EpochPhaseSetup, stateEntry.EpochPhase())

		richStateEntry, err := flow.NewRichEpochStateEntry(stateEntry)
		assert.NoError(t, err)
		expectedIdentities, err := flow.BuildIdentityTable(
			stateEntryFixture.CurrentEpochSetup.Participants,
			stateEntryFixture.CurrentEpoch.ActiveIdentities,
			stateEntryFixture.NextEpochSetup.Participants,
			stateEntryFixture.NextEpoch.ActiveIdentities,
			flow.EpochParticipationStatusJoining,
		)
		assert.NoError(t, err)
		assert.Equal(t, expectedIdentities, richStateEntry.CurrentEpochIdentityTable, "should be equal to current epoch setup participants + next epoch setup participants")
		assert.Nil(t, richStateEntry.NextEpochCommit)
		expectedIdentities, err = flow.BuildIdentityTable(
			stateEntryFixture.NextEpochSetup.Participants,
			stateEntryFixture.NextEpoch.ActiveIdentities,
			stateEntryFixture.CurrentEpochSetup.Participants,
			stateEntryFixture.CurrentEpoch.ActiveIdentities,
			flow.EpochParticipationStatusLeaving,
		)
		assert.NoError(t, err)
		assert.Equal(t, expectedIdentities, richStateEntry.NextEpochIdentityTable, "should be equal to next epoch setup participants + current epoch setup participants")
	})

	// 4. Common situation during the epoch setup phase for first epoch after the spork
	//  * we are currently in Epoch N
	//  * there is no previous epoch as we are in the first epoch after the spork
	//  * network is currently in the setup phase for the next epoch, i.e. EpochSetup event (starting setup phase) has already been observed
	t.Run("setup-after-spork", func(t *testing.T) {
		stateEntryFixture := unittest.EpochStateFixture(unittest.WithNextEpochProtocolState(), func(entry *flow.RichEpochStateEntry) {
			// no previous epoch since we are in the first epoch
			entry.PreviousEpochSetup = nil
			entry.PreviousEpochCommit = nil
			entry.PreviousEpoch = nil

			// next epoch is setup but not committed
			entry.NextEpochCommit = nil
			entry.NextEpoch.CommitID = flow.ZeroID
		})
		// sanity check that previous epoch is not populated in `stateEntry`
		assert.Nil(t, stateEntryFixture.PreviousEpoch)
		assert.Nil(t, stateEntryFixture.PreviousEpochSetup)
		assert.Nil(t, stateEntryFixture.PreviousEpochCommit)

		stateEntry, err := flow.NewEpochStateEntry(
			flow.UntrustedEpochStateEntry{
				MinEpochStateEntry:  stateEntryFixture.MinEpochStateEntry,
				PreviousEpochSetup:  stateEntryFixture.PreviousEpochSetup,
				PreviousEpochCommit: stateEntryFixture.PreviousEpochCommit,
				CurrentEpochSetup:   stateEntryFixture.CurrentEpochSetup,
				CurrentEpochCommit:  stateEntryFixture.CurrentEpochCommit,
				NextEpochSetup:      stateEntryFixture.NextEpochSetup,
				NextEpochCommit:     nil,
			},
		)
		assert.NoError(t, err)
		assert.Equal(t, flow.EpochPhaseSetup, stateEntry.EpochPhase())

		richStateEntry, err := flow.NewRichEpochStateEntry(stateEntry)
		assert.NoError(t, err)
		expectedIdentities, err := flow.BuildIdentityTable(
			stateEntry.CurrentEpochSetup.Participants,
			stateEntry.CurrentEpoch.ActiveIdentities,
			stateEntry.NextEpochSetup.Participants,
			stateEntry.NextEpoch.ActiveIdentities,
			flow.EpochParticipationStatusJoining,
		)
		assert.NoError(t, err)
		assert.Equal(t, expectedIdentities, richStateEntry.CurrentEpochIdentityTable, "should be equal to current epoch setup participants + next epoch setup participants")
		assert.Nil(t, richStateEntry.NextEpochCommit)
		expectedIdentities, err = flow.BuildIdentityTable(
			stateEntry.NextEpochSetup.Participants,
			stateEntry.NextEpoch.ActiveIdentities,
			stateEntry.CurrentEpochSetup.Participants,
			stateEntry.CurrentEpoch.ActiveIdentities,
			flow.EpochParticipationStatusLeaving,
		)
		assert.NoError(t, err)
		assert.Equal(t, expectedIdentities, richStateEntry.NextEpochIdentityTable, "should be equal to next epoch setup participants + current epoch setup participants")
	})

	// 5. Common situation during the epoch commit phase for epoch N+1
	//  * we are currently in Epoch N
	//  * previous epoch N-1 is known (specifically EpochSetup and EpochCommit events)
	//  * The network has completed the epoch commit phase, i.e. published the EpochSetup and EpochCommit events for epoch N+1.
	t.Run("commit-phase", func(t *testing.T) {
		stateEntryFixture := unittest.EpochStateFixture(unittest.WithNextEpochProtocolState())

		stateEntry, err := flow.NewEpochStateEntry(
			flow.UntrustedEpochStateEntry{
				MinEpochStateEntry:  stateEntryFixture.MinEpochStateEntry,
				PreviousEpochSetup:  stateEntryFixture.PreviousEpochSetup,
				PreviousEpochCommit: stateEntryFixture.PreviousEpochCommit,
				CurrentEpochSetup:   stateEntryFixture.CurrentEpochSetup,
				CurrentEpochCommit:  stateEntryFixture.CurrentEpochCommit,
				NextEpochSetup:      stateEntryFixture.NextEpochSetup,
				NextEpochCommit:     stateEntryFixture.NextEpochCommit,
			},
		)
		assert.NoError(t, err)
		assert.Equal(t, flow.EpochPhaseCommitted, stateEntry.EpochPhase())

		richStateEntry, err := flow.NewRichEpochStateEntry(stateEntry)
		assert.NoError(t, err)
		expectedIdentities, err := flow.BuildIdentityTable(
			stateEntry.CurrentEpochSetup.Participants,
			stateEntry.CurrentEpoch.ActiveIdentities,
			stateEntry.NextEpochSetup.Participants,
			stateEntry.NextEpoch.ActiveIdentities,
			flow.EpochParticipationStatusJoining,
		)
		assert.NoError(t, err)
		assert.Equal(t, expectedIdentities, richStateEntry.CurrentEpochIdentityTable, "should be equal to current epoch setup participants + next epoch setup participants")
		expectedIdentities, err = flow.BuildIdentityTable(
			stateEntry.NextEpochSetup.Participants,
			stateEntry.NextEpoch.ActiveIdentities,
			stateEntry.CurrentEpochSetup.Participants,
			stateEntry.CurrentEpoch.ActiveIdentities,
			flow.EpochParticipationStatusLeaving,
		)
		assert.NoError(t, err)
		assert.Equal(t, expectedIdentities, richStateEntry.NextEpochIdentityTable, "should be equal to next epoch setup participants + current epoch setup participants")
	})

	// 6. Common situation during the epoch commit phase for first epoch after the spork
	//  * we are currently in Epoch N
	//  * there is no previous epoch as we are in the first epoch after the spork
	//  * The network has completed the epoch commit phase, i.e. published the EpochSetup and EpochCommit events for epoch N+1.
	t.Run("commit-after-spork", func(t *testing.T) {
		stateEntryFixture := unittest.EpochStateFixture(unittest.WithNextEpochProtocolState(), func(entry *flow.RichEpochStateEntry) {
			// no previous epoch since we are in the first epoch
			entry.PreviousEpochSetup = nil
			entry.PreviousEpochCommit = nil
			entry.PreviousEpoch = nil
		})
		// sanity check that previous epoch is not populated in `stateEntryFixture`
		assert.Nil(t, stateEntryFixture.PreviousEpoch)
		assert.Nil(t, stateEntryFixture.PreviousEpochSetup)
		assert.Nil(t, stateEntryFixture.PreviousEpochCommit)

		stateEntry, err := flow.NewEpochStateEntry(
			flow.UntrustedEpochStateEntry{
				MinEpochStateEntry:  stateEntryFixture.MinEpochStateEntry,
				PreviousEpochSetup:  stateEntryFixture.PreviousEpochSetup,
				PreviousEpochCommit: stateEntryFixture.PreviousEpochCommit,
				CurrentEpochSetup:   stateEntryFixture.CurrentEpochSetup,
				CurrentEpochCommit:  stateEntryFixture.CurrentEpochCommit,
				NextEpochSetup:      stateEntryFixture.NextEpochSetup,
				NextEpochCommit:     stateEntryFixture.NextEpochCommit,
			},
		)
		assert.NoError(t, err)
		assert.Equal(t, flow.EpochPhaseCommitted, stateEntry.EpochPhase())

		richStateEntry, err := flow.NewRichEpochStateEntry(stateEntry)
		assert.NoError(t, err)
		expectedIdentities, err := flow.BuildIdentityTable(
			stateEntryFixture.CurrentEpochSetup.Participants,
			stateEntryFixture.CurrentEpoch.ActiveIdentities,
			stateEntryFixture.NextEpochSetup.Participants,
			stateEntryFixture.NextEpoch.ActiveIdentities,
			flow.EpochParticipationStatusJoining,
		)
		assert.NoError(t, err)
		assert.Equal(t, expectedIdentities, richStateEntry.CurrentEpochIdentityTable, "should be equal to current epoch setup participants + next epoch setup participants")
		expectedIdentities, err = flow.BuildIdentityTable(
			stateEntryFixture.NextEpochSetup.Participants,
			stateEntryFixture.NextEpoch.ActiveIdentities,
			stateEntryFixture.CurrentEpochSetup.Participants,
			stateEntryFixture.CurrentEpoch.ActiveIdentities,
			flow.EpochParticipationStatusLeaving,
		)
		assert.NoError(t, err)
		assert.Equal(t, expectedIdentities, richStateEntry.NextEpochIdentityTable, "should be equal to next epoch setup participants + current epoch setup participants")
	})

	// 7. Invalid: epochState is nil
	t.Run("invalid - epoch state is nil", func(t *testing.T) {
		_, err := flow.NewRichEpochStateEntry(nil)
		require.Error(t, err)
		require.Contains(t, err.Error(), "epoch state must not be nil")
	})
}

// TestNewEpochStateEntry tests the NewEpochStateEntry constructor with various valid and invalid inputs.
//
// Valid Cases:
//
// 1. Valid input with all fields populated:
//   - Should successfully create an EpochStateEntry without error.
//
// 2. Valid input without NextEpochProtocolState:
//   - Should successfully create an EpochStateEntry even if next epoch protocol state is not set.
//
// Invalid Cases:
//
// 3. PreviousEpoch.SetupID mismatch with PreviousEpochSetup.ID:
//   - Should return an error for mismatched setup commitment.
//
// 4. PreviousEpoch.CommitID mismatch with PreviousEpochCommit.ID:
//   - Should return an error for mismatched commit commitment.
//
// 5. PreviousEpoch is nil but PreviousEpochSetup is non-nil:
//   - Should return an error for unexpected previous epoch's setup event.
//
// 6. PreviousEpoch is nil but PreviousEpochCommit is non-nil:
//   - Should return an error for unexpected previous epoch's commit event.
//
// 7. CurrentEpoch.SetupID mismatch with CurrentEpochSetup.ID:
//   - Should return an error for mismatched current epoch's setup event.
//
// 8. CurrentEpoch.CommitID mismatch with CurrentEpochCommit.ID:
//   - Should return an error for mismatched current epoch's commit event.
//
// 9. NextEpoch is nil but NextEpochSetup is non-nil:
//   - Should return an error for unexpected next epoch's setup event.
//
// 10. NextEpoch is nil but NextEpochCommit is non-nil:
//   - Should return an error for unexpected next epoch's commit event.
//
// 11. NextEpoch.SetupID is non-zero but mismatches NextEpochSetup.ID:
//   - Should return an error for next epoch's mismatched setup event.
//
// 12. NextEpoch.CommitID is non-zero but mismatches NextEpochCommit.ID:
//   - Should return an error for mismatched next epoch's commit event.
//
// 13. NextEpoch.CommitID is zero but NextEpochCommit is non-nil:
//   - Should return an error for unexpected commit event.
func TestNewEpochStateEntry(t *testing.T) {
	// 1. Valid input with all fields
	t.Run("valid input with all fields", func(t *testing.T) {
		stateEntryFixture := unittest.EpochStateFixture(unittest.WithNextEpochProtocolState())
		entry, err := flow.NewEpochStateEntry(
			flow.UntrustedEpochStateEntry{
				MinEpochStateEntry:  stateEntryFixture.MinEpochStateEntry,
				PreviousEpochSetup:  stateEntryFixture.PreviousEpochSetup,
				PreviousEpochCommit: stateEntryFixture.PreviousEpochCommit,
				CurrentEpochSetup:   stateEntryFixture.CurrentEpochSetup,
				CurrentEpochCommit:  stateEntryFixture.CurrentEpochCommit,
				NextEpochSetup:      stateEntryFixture.NextEpochSetup,
				NextEpochCommit:     stateEntryFixture.NextEpochCommit,
			},
		)
		require.NoError(t, err)
		require.NotNil(t, entry)
	})

	// 2. Valid input without NextEpochProtocolState
	t.Run("valid input without NextEpochProtocolState", func(t *testing.T) {
		stateEntryFixture := unittest.EpochStateFixture()
		entry, err := flow.NewEpochStateEntry(
			flow.UntrustedEpochStateEntry{
				MinEpochStateEntry:  stateEntryFixture.MinEpochStateEntry,
				PreviousEpochSetup:  stateEntryFixture.PreviousEpochSetup,
				PreviousEpochCommit: stateEntryFixture.PreviousEpochCommit,
				CurrentEpochSetup:   stateEntryFixture.CurrentEpochSetup,
				CurrentEpochCommit:  stateEntryFixture.CurrentEpochCommit,
				NextEpochSetup:      stateEntryFixture.NextEpochSetup,
				NextEpochCommit:     stateEntryFixture.NextEpochCommit,
			},
		)
		require.NoError(t, err)
		require.NotNil(t, entry)
	})

	// 3. Invalid: PreviousEpoch is set, but PreviousEpochSetup is nil
	t.Run("invalid - previous epoch set but no setup event", func(t *testing.T) {
		stateEntryFixture := unittest.EpochStateFixture(unittest.WithNextEpochProtocolState(), func(entry *flow.RichEpochStateEntry) {
			entry.PreviousEpochSetup = nil
		})
		_, err := flow.NewEpochStateEntry(
			flow.UntrustedEpochStateEntry{
				MinEpochStateEntry:  stateEntryFixture.MinEpochStateEntry,
				PreviousEpochSetup:  stateEntryFixture.PreviousEpochSetup,
				PreviousEpochCommit: stateEntryFixture.PreviousEpochCommit,
				CurrentEpochSetup:   stateEntryFixture.CurrentEpochSetup,
				CurrentEpochCommit:  stateEntryFixture.CurrentEpochCommit,
				NextEpochSetup:      stateEntryFixture.NextEpochSetup,
				NextEpochCommit:     stateEntryFixture.NextEpochCommit,
			},
		)
		require.Error(t, err)
		expectedMsg := fmt.Sprintf(
			"supplied previous epoch's setup event (%x) does not match commitment (%x) in MinEpochStateEntry",
			stateEntryFixture.PreviousEpochSetup.ID(),
			stateEntryFixture.MinEpochStateEntry.PreviousEpoch.SetupID,
		)
		require.Contains(t, err.Error(), expectedMsg)
	})

	// 4. Invalid: PreviousEpoch.CommitID doesn't match PreviousEpochCommit.ID()
	t.Run("invalid - previous commit ID mismatch", func(t *testing.T) {
		stateEntryFixture := unittest.EpochStateFixture(unittest.WithNextEpochProtocolState(), func(entry *flow.RichEpochStateEntry) {
			entry.PreviousEpoch.CommitID = flow.ZeroID // incorrect
		})
		_, err := flow.NewEpochStateEntry(
			flow.UntrustedEpochStateEntry{
				MinEpochStateEntry:  stateEntryFixture.MinEpochStateEntry,
				PreviousEpochSetup:  stateEntryFixture.PreviousEpochSetup,
				PreviousEpochCommit: stateEntryFixture.PreviousEpochCommit,
				CurrentEpochSetup:   stateEntryFixture.CurrentEpochSetup,
				CurrentEpochCommit:  stateEntryFixture.CurrentEpochCommit,
				NextEpochSetup:      stateEntryFixture.NextEpochSetup,
				NextEpochCommit:     stateEntryFixture.NextEpochCommit,
			},
		)
		require.Error(t, err)
		expectedMsg := fmt.Sprintf(
			"supplied previous epoch's commit event (%x) does not match commitment (%x) in MinEpochStateEntry",
			stateEntryFixture.PreviousEpochCommit.ID(),
			stateEntryFixture.PreviousEpoch.CommitID,
		)
		require.Contains(t, err.Error(), expectedMsg)
	})

	// 5. Invalid: PreviousEpoch is nil, but PreviousEpochSetup is non-nil
	t.Run("invalid - nil previous epoch but has setup event", func(t *testing.T) {
		stateEntryFixture := unittest.EpochStateFixture(unittest.WithNextEpochProtocolState(), func(entry *flow.RichEpochStateEntry) {
			entry.PreviousEpoch = nil
		})
		_, err := flow.NewEpochStateEntry(
			flow.UntrustedEpochStateEntry{
				MinEpochStateEntry:  stateEntryFixture.MinEpochStateEntry,
				PreviousEpochSetup:  stateEntryFixture.PreviousEpochSetup,
				PreviousEpochCommit: stateEntryFixture.PreviousEpochCommit,
				CurrentEpochSetup:   stateEntryFixture.CurrentEpochSetup,
				CurrentEpochCommit:  stateEntryFixture.CurrentEpochCommit,
				NextEpochSetup:      stateEntryFixture.NextEpochSetup,
				NextEpochCommit:     stateEntryFixture.NextEpochCommit,
			},
		)
		require.Error(t, err)
		require.Contains(t, err.Error(), "no previous epoch but gotten non-nil EpochSetup event")
	})

	// 6. Invalid: PreviousEpoch is nil, but PreviousEpochCommit is non-nil
	t.Run("invalid - nil previous epoch but has commit event", func(t *testing.T) {
		stateEntryFixture := unittest.EpochStateFixture(unittest.WithNextEpochProtocolState(), func(entry *flow.RichEpochStateEntry) {
			entry.PreviousEpoch = nil
			entry.PreviousEpochSetup = nil
		})
		_, err := flow.NewEpochStateEntry(
			flow.UntrustedEpochStateEntry{
				MinEpochStateEntry:  stateEntryFixture.MinEpochStateEntry,
				PreviousEpochSetup:  stateEntryFixture.PreviousEpochSetup,
				PreviousEpochCommit: stateEntryFixture.PreviousEpochCommit,
				CurrentEpochSetup:   stateEntryFixture.CurrentEpochSetup,
				CurrentEpochCommit:  stateEntryFixture.CurrentEpochCommit,
				NextEpochSetup:      stateEntryFixture.NextEpochSetup,
				NextEpochCommit:     stateEntryFixture.NextEpochCommit,
			},
		)
		require.Error(t, err)
		require.Contains(t, err.Error(), "no previous epoch but gotten non-nil EpochCommit event")
	})

	// 7. Invalid: CurrentEpoch.SetupID doesn't match CurrentEpochSetup.ID()
	t.Run("invalid - current setup ID mismatch", func(t *testing.T) {
		stateEntryFixture := unittest.EpochStateFixture(unittest.WithNextEpochProtocolState(), func(entry *flow.RichEpochStateEntry) {
			entry.CurrentEpoch.SetupID = unittest.IdentifierFixture() // incorrect
		})
		_, err := flow.NewEpochStateEntry(
			flow.UntrustedEpochStateEntry{
				MinEpochStateEntry:  stateEntryFixture.MinEpochStateEntry,
				PreviousEpochSetup:  stateEntryFixture.PreviousEpochSetup,
				PreviousEpochCommit: stateEntryFixture.PreviousEpochCommit,
				CurrentEpochSetup:   stateEntryFixture.CurrentEpochSetup,
				CurrentEpochCommit:  stateEntryFixture.CurrentEpochCommit,
				NextEpochSetup:      stateEntryFixture.NextEpochSetup,
				NextEpochCommit:     stateEntryFixture.NextEpochCommit,
			},
		)
		require.Error(t, err)
		expectedMsg := fmt.Sprintf(
			"supplied current epoch's setup event (%x) does not match commitment (%x) in MinEpochStateEntry",
			stateEntryFixture.CurrentEpochSetup.ID(),
			stateEntryFixture.CurrentEpoch.SetupID,
		)
		require.Contains(t, err.Error(), expectedMsg)
	})

	// 8. Invalid: CurrentEpoch.CommitID doesn't match CurrentEpochCommit.ID()
	t.Run("invalid - current commit ID mismatch", func(t *testing.T) {
		stateEntryFixture := unittest.EpochStateFixture(unittest.WithNextEpochProtocolState(), func(entry *flow.RichEpochStateEntry) {
			entry.CurrentEpoch.CommitID = unittest.IdentifierFixture() // incorrect
		})
		_, err := flow.NewEpochStateEntry(
			flow.UntrustedEpochStateEntry{
				MinEpochStateEntry:  stateEntryFixture.MinEpochStateEntry,
				PreviousEpochSetup:  stateEntryFixture.PreviousEpochSetup,
				PreviousEpochCommit: stateEntryFixture.PreviousEpochCommit,
				CurrentEpochSetup:   stateEntryFixture.CurrentEpochSetup,
				CurrentEpochCommit:  stateEntryFixture.CurrentEpochCommit,
				NextEpochSetup:      stateEntryFixture.NextEpochSetup,
				NextEpochCommit:     stateEntryFixture.NextEpochCommit,
			},
		)
		require.Error(t, err)
		expectedMsg := fmt.Sprintf(
			"supplied current epoch's commit event (%x) does not match commitment (%x) in MinEpochStateEntry",
			stateEntryFixture.CurrentEpochCommit.ID(),
			stateEntryFixture.CurrentEpoch.CommitID,
		)
		require.Contains(t, err.Error(), expectedMsg)
	})

	// 9. Invalid: NextEpoch is nil, but NextEpochSetup is non-nil
	t.Run("invalid - nil next epoch but has setup event", func(t *testing.T) {
		stateEntryFixture := unittest.EpochStateFixture(unittest.WithNextEpochProtocolState(), func(entry *flow.RichEpochStateEntry) {
			entry.NextEpoch = nil
		})
		_, err := flow.NewEpochStateEntry(
			flow.UntrustedEpochStateEntry{
				MinEpochStateEntry:  stateEntryFixture.MinEpochStateEntry,
				PreviousEpochSetup:  stateEntryFixture.PreviousEpochSetup,
				PreviousEpochCommit: stateEntryFixture.PreviousEpochCommit,
				CurrentEpochSetup:   stateEntryFixture.CurrentEpochSetup,
				CurrentEpochCommit:  stateEntryFixture.CurrentEpochCommit,
				NextEpochSetup:      stateEntryFixture.NextEpochSetup,
				NextEpochCommit:     stateEntryFixture.NextEpochCommit,
			},
		)
		require.Error(t, err)
		require.Contains(t, err.Error(), "no next epoch but gotten non-nil EpochSetup event")
	})

	// 10. Invalid: NextEpoch is nil, but NextEpochCommit is non-nil
	t.Run("invalid - nil next epoch but has commit event", func(t *testing.T) {
		stateEntryFixture := unittest.EpochStateFixture(unittest.WithNextEpochProtocolState(), func(entry *flow.RichEpochStateEntry) {
			entry.NextEpoch = nil
			entry.NextEpochSetup = nil
		})
		_, err := flow.NewEpochStateEntry(
			flow.UntrustedEpochStateEntry{
				MinEpochStateEntry:  stateEntryFixture.MinEpochStateEntry,
				PreviousEpochSetup:  stateEntryFixture.PreviousEpochSetup,
				PreviousEpochCommit: stateEntryFixture.PreviousEpochCommit,
				CurrentEpochSetup:   stateEntryFixture.CurrentEpochSetup,
				CurrentEpochCommit:  stateEntryFixture.CurrentEpochCommit,
				NextEpochSetup:      stateEntryFixture.NextEpochSetup,
				NextEpochCommit:     stateEntryFixture.NextEpochCommit,
			},
		)
		require.Error(t, err)
		require.Contains(t, err.Error(), "no next epoch but gotten non-nil EpochCommit")
	})

	// 11. Invalid: NextEpoch.SetupID ≠ NextEpochSetup.ID
	t.Run("invalid - next commit ID mismatch", func(t *testing.T) {
		stateEntryFixture := unittest.EpochStateFixture(unittest.WithNextEpochProtocolState(), func(entry *flow.RichEpochStateEntry) {
			entry.NextEpoch.SetupID = unittest.IdentifierFixture() // incorrect
		})
		_, err := flow.NewEpochStateEntry(
			flow.UntrustedEpochStateEntry{
				MinEpochStateEntry:  stateEntryFixture.MinEpochStateEntry,
				PreviousEpochSetup:  stateEntryFixture.PreviousEpochSetup,
				PreviousEpochCommit: stateEntryFixture.PreviousEpochCommit,
				CurrentEpochSetup:   stateEntryFixture.CurrentEpochSetup,
				CurrentEpochCommit:  stateEntryFixture.CurrentEpochCommit,
				NextEpochSetup:      stateEntryFixture.NextEpochSetup,
				NextEpochCommit:     stateEntryFixture.NextEpochCommit,
			},
		)
		require.Error(t, err)
		expectedMsg := fmt.Sprintf(
			"supplied next epoch's setup event (%x) does not match commitment (%x) in MinEpochStateEntry",
			stateEntryFixture.NextEpoch.SetupID,
			stateEntryFixture.NextEpochSetup.ID(),
		)
		require.Contains(t, err.Error(), expectedMsg)
	})

	// 12. Invalid: NextEpoch.CommitID ≠ ZeroID, but NextEpochCommit.ID doesn't match
	t.Run("invalid - next commit ID mismatch", func(t *testing.T) {
		stateEntryFixture := unittest.EpochStateFixture(unittest.WithNextEpochProtocolState(), func(entry *flow.RichEpochStateEntry) {
			entry.NextEpoch.CommitID = unittest.IdentifierFixture() // incorrect
		})
		_, err := flow.NewEpochStateEntry(
			flow.UntrustedEpochStateEntry{
				MinEpochStateEntry:  stateEntryFixture.MinEpochStateEntry,
				PreviousEpochSetup:  stateEntryFixture.PreviousEpochSetup,
				PreviousEpochCommit: stateEntryFixture.PreviousEpochCommit,
				CurrentEpochSetup:   stateEntryFixture.CurrentEpochSetup,
				CurrentEpochCommit:  stateEntryFixture.CurrentEpochCommit,
				NextEpochSetup:      stateEntryFixture.NextEpochSetup,
				NextEpochCommit:     stateEntryFixture.NextEpochCommit,
			},
		)
		require.Error(t, err)
		expectedMsg := fmt.Sprintf(
			"supplied next epoch's commit event (%x) does not match commitment (%x) in MinEpochStateEntry",
			stateEntryFixture.NextEpoch.CommitID,
			stateEntryFixture.NextEpochCommit.ID(),
		)
		require.Contains(t, err.Error(), expectedMsg)
	})

	// 13. Invalid: NextEpoch.CommitID == ZeroID, but NextEpochCommit is non-nil
	t.Run("invalid - uncommitted next epoch but has commit event", func(t *testing.T) {
		stateEntryFixture := unittest.EpochStateFixture(unittest.WithNextEpochProtocolState(), func(entry *flow.RichEpochStateEntry) {
			entry.NextEpoch.CommitID = flow.ZeroID
		})
		_, err := flow.NewEpochStateEntry(
			flow.UntrustedEpochStateEntry{
				MinEpochStateEntry:  stateEntryFixture.MinEpochStateEntry,
				PreviousEpochSetup:  stateEntryFixture.PreviousEpochSetup,
				PreviousEpochCommit: stateEntryFixture.PreviousEpochCommit,
				CurrentEpochSetup:   stateEntryFixture.CurrentEpochSetup,
				CurrentEpochCommit:  stateEntryFixture.CurrentEpochCommit,
				NextEpochSetup:      stateEntryFixture.NextEpochSetup,
				NextEpochCommit:     stateEntryFixture.NextEpochCommit,
			},
		)
		require.Error(t, err)
		expectedMsg := "next epoch not yet committed but got EpochCommit event"
		require.Contains(t, err.Error(), expectedMsg)
	})
}

// TestProtocolStateEntry_Copy tests if the copy method returns a deep copy of the entry.
// All changes to copy shouldn't affect the original entry -- except for key changes.
func TestProtocolStateEntry_Copy(t *testing.T) {
	entry := unittest.EpochStateFixture(unittest.WithNextEpochProtocolState()).MinEpochStateEntry
	cpy := entry.Copy()
	assert.Equal(t, entry, cpy)
	assert.NotSame(t, entry.NextEpoch, cpy.NextEpoch)
	assert.NotSame(t, entry.PreviousEpoch, cpy.PreviousEpoch)

	cpy.EpochFallbackTriggered = !entry.EpochFallbackTriggered
	assert.NotEqual(t, entry, cpy)

	assertEpochContainer := func(entry, cpy *flow.EpochStateContainer) {
		assert.Equal(t, entry.ActiveIdentities[0], cpy.ActiveIdentities[0])
		cpy.ActiveIdentities[0].Ejected = true
		assert.NotEqual(t, entry.ActiveIdentities[0], cpy.ActiveIdentities[0])

		cpy.ActiveIdentities = append(cpy.ActiveIdentities, &flow.DynamicIdentityEntry{
			NodeID:  unittest.IdentifierFixture(),
			Ejected: false,
		})
		assert.NotEqual(t, entry.ActiveIdentities, cpy.ActiveIdentities)

		cpy.EpochExtensions = append(cpy.EpochExtensions, flow.EpochExtension{
			FirstView: 13,
		})
		assert.NotEqual(t, entry.EpochExtensions, cpy.EpochExtensions)
	}
	assertEpochContainer(entry.PreviousEpoch, cpy.PreviousEpoch)
	assertEpochContainer(&entry.CurrentEpoch, &cpy.CurrentEpoch)
	assertEpochContainer(entry.NextEpoch, cpy.NextEpoch)
}

// TestEpochStateEntry_EpochCounter tests if the epoch counter is correctly computed for the entry.
// The epoch counter should be equal to the counter of the current epoch setup and commit regardless of the previous or next epoch.
func TestEpochStateEntry_EpochCounter(t *testing.T) {
	t.Run("with-previous-epoch", func(t *testing.T) {
		entry := unittest.EpochStateFixture()
		assert.Equal(t, entry.EpochCounter(), entry.CurrentEpochSetup.Counter)
		assert.Equal(t, entry.EpochCounter(), entry.CurrentEpochCommit.Counter)
	})
	t.Run("root-epoch", func(t *testing.T) {
		entry := unittest.EpochStateFixture(func(entry *flow.RichEpochStateEntry) {
			entry.PreviousEpoch = nil
			entry.PreviousEpochSetup = nil
			entry.PreviousEpochCommit = nil
		})
		assert.Equal(t, entry.EpochCounter(), entry.CurrentEpochSetup.Counter)
		assert.Equal(t, entry.EpochCounter(), entry.CurrentEpochCommit.Counter)
	})
	t.Run("with-next-epoch", func(t *testing.T) {
		entry := unittest.EpochStateFixture(unittest.WithNextEpochProtocolState())
		assert.Equal(t, entry.EpochCounter(), entry.CurrentEpochSetup.Counter)
		assert.Equal(t, entry.EpochCounter(), entry.CurrentEpochCommit.Counter)
	})
}

// TestEpochStateEntry_CurrentEpochFinalView tests if the final view of the current epoch is correctly computed,
// it has to be equal:
// - to the final view of the current epoch setup if there are no extensions
// - to the final view of the last extension if there are multiple extensions
func TestEpochStateEntry_CurrentEpochFinalView(t *testing.T) {
	t.Run("no-extension", func(t *testing.T) {
		entry := unittest.EpochStateFixture()
		assert.Equal(t, entry.CurrentEpochSetup.FinalView, entry.CurrentEpochFinalView())
	})
	t.Run("multiple-extension", func(t *testing.T) {
		entry := unittest.EpochStateFixture()
		extraViews := uint64(1000)
		entry.CurrentEpoch.EpochExtensions = []flow.EpochExtension{
			{
				FirstView: entry.CurrentEpochSetup.FinalView + 1,
				FinalView: entry.CurrentEpochSetup.FinalView + extraViews,
			},
		}
		assert.Equal(t, entry.CurrentEpochSetup.FinalView+extraViews, entry.CurrentEpochFinalView())
		entry.CurrentEpoch.EpochExtensions = append(entry.CurrentEpoch.EpochExtensions, flow.EpochExtension{
			FirstView: entry.CurrentEpoch.EpochExtensions[0].FinalView + 1,
			FinalView: entry.CurrentEpoch.EpochExtensions[0].FinalView + extraViews,
		})
		assert.Equal(t, entry.CurrentEpochSetup.FinalView+2*extraViews, entry.CurrentEpochFinalView())
	})
}

// TestBuildIdentityTable tests if BuildIdentityTable returns a correct identity, whenever we pass arguments with or without
// overlap. It also tests if the function returns an error when the arguments are not ordered in the same order.
func TestBuildIdentityTable(t *testing.T) {
	t.Run("invalid-adjacent-identity-status", func(t *testing.T) {
		targetEpochIdentities := unittest.IdentityListFixture(10).Sort(flow.Canonical[flow.Identity])
		adjacentEpochIdentities := unittest.IdentityListFixture(10).Sort(flow.Canonical[flow.Identity])

		// Per convention, BuildIdentityTable only accepts EpochParticipationStatusLeaving or EpochParticipationStatusJoining
		// for the *adjacent* epoch, because these are the only sensible values.
		for _, status := range []flow.EpochParticipationStatus{flow.EpochParticipationStatusActive, flow.EpochParticipationStatusEjected} {
			identityList, err := flow.BuildIdentityTable(
				targetEpochIdentities.ToSkeleton(),
				flow.DynamicIdentityEntryListFromIdentities(targetEpochIdentities),
				adjacentEpochIdentities.ToSkeleton(),
				flow.DynamicIdentityEntryListFromIdentities(adjacentEpochIdentities),
				status,
			)
			assert.Error(t, err)
			assert.Empty(t, identityList)
		}
	})
	t.Run("happy-path-no-identities-overlap", func(t *testing.T) {
		targetEpochIdentities := unittest.IdentityListFixture(10).Sort(flow.Canonical[flow.Identity])
		adjacentEpochIdentities := unittest.IdentityListFixture(10).Sort(flow.Canonical[flow.Identity])

		identityList, err := flow.BuildIdentityTable(
			targetEpochIdentities.ToSkeleton(),
			flow.DynamicIdentityEntryListFromIdentities(targetEpochIdentities),
			adjacentEpochIdentities.ToSkeleton(),
			flow.DynamicIdentityEntryListFromIdentities(adjacentEpochIdentities),
			flow.EpochParticipationStatusLeaving,
		)
		assert.NoError(t, err)

		expectedIdentities := targetEpochIdentities.Union(adjacentEpochIdentities.Map(func(identity flow.Identity) flow.Identity {
			identity.EpochParticipationStatus = flow.EpochParticipationStatusLeaving
			return identity
		}))
		assert.Equal(t, expectedIdentities, identityList)
	})
	t.Run("happy-path-identities-overlap", func(t *testing.T) {
		targetEpochIdentities := unittest.IdentityListFixture(10).Sort(flow.Canonical[flow.Identity])
		adjacentEpochIdentities := unittest.IdentityListFixture(10)
		sampledIdentities, err := targetEpochIdentities.Sample(2)
		// change address so we can assert that we take identities from target epoch and not adjacent epoch
		for i, identity := range sampledIdentities.Copy() {
			identity.Address = fmt.Sprintf("%d", i)
			adjacentEpochIdentities = append(adjacentEpochIdentities, identity)
		}
		assert.NoError(t, err)
		adjacentEpochIdentities = adjacentEpochIdentities.Sort(flow.Canonical[flow.Identity])

		identityList, err := flow.BuildIdentityTable(
			targetEpochIdentities.ToSkeleton(),
			flow.DynamicIdentityEntryListFromIdentities(targetEpochIdentities),
			adjacentEpochIdentities.ToSkeleton(),
			flow.DynamicIdentityEntryListFromIdentities(adjacentEpochIdentities),
			flow.EpochParticipationStatusJoining,
		)
		assert.NoError(t, err)

		expectedIdentities := targetEpochIdentities.Union(adjacentEpochIdentities.Map(func(identity flow.Identity) flow.Identity {
			identity.EpochParticipationStatus = flow.EpochParticipationStatusJoining
			return identity
		}))
		assert.Equal(t, expectedIdentities, identityList)
	})
	t.Run("target-epoch-identities-not-ordered", func(t *testing.T) {
		targetEpochIdentities := unittest.IdentityListFixture(10).Sort(flow.Canonical[flow.Identity])
		targetEpochIdentitySkeletons, err := targetEpochIdentities.ToSkeleton().Shuffle()
		assert.NoError(t, err)
		targetEpochDynamicIdentities := flow.DynamicIdentityEntryListFromIdentities(targetEpochIdentities)

		adjacentEpochIdentities := unittest.IdentityListFixture(10).Sort(flow.Canonical[flow.Identity])
		identityList, err := flow.BuildIdentityTable(
			targetEpochIdentitySkeletons,
			targetEpochDynamicIdentities,
			adjacentEpochIdentities.ToSkeleton(),
			flow.DynamicIdentityEntryListFromIdentities(adjacentEpochIdentities),
			flow.EpochParticipationStatusLeaving,
		)
		assert.Error(t, err)
		assert.Empty(t, identityList)
	})
	t.Run("adjacent-epoch-identities-not-ordered", func(t *testing.T) {
		adjacentEpochIdentities := unittest.IdentityListFixture(10).Sort(flow.Canonical[flow.Identity])
		adjacentEpochIdentitySkeletons, err := adjacentEpochIdentities.ToSkeleton().Shuffle()
		assert.NoError(t, err)
		adjacentEpochDynamicIdentities := flow.DynamicIdentityEntryListFromIdentities(adjacentEpochIdentities)

		targetEpochIdentities := unittest.IdentityListFixture(10).Sort(flow.Canonical[flow.Identity])
		identityList, err := flow.BuildIdentityTable(
			targetEpochIdentities.ToSkeleton(),
			flow.DynamicIdentityEntryListFromIdentities(targetEpochIdentities),
			adjacentEpochIdentitySkeletons,
			adjacentEpochDynamicIdentities,
			flow.EpochParticipationStatusLeaving,
		)
		assert.Error(t, err)
		assert.Empty(t, identityList)
	})
}

// TestNewEpochStateContainer tests the NewEpochStateContainer constructor with valid and invalid inputs.
//
// Valid Cases:
//
// 1. Valid input with all fields:
//   - Should successfully construct an EpochStateContainer.
//
// 2. Valid input with zero CommitID and nil EpochExtensions:
//   - Should successfully construct an EpochStateContainer.
//
// Invalid Cases:
//
// 3. Invalid input with zero SetupID:
//   - Should return an error indicating SetupID must not be zero.
//
// 4. Invalid input with nil ActiveIdentities:
//   - Should return an error indicating ActiveIdentities must not be nil.
//
// 5. Invalid input with unsorted ActiveIdentities:
//   - Should return an error indicating ActiveIdentities are not sorted.
func  (t *testing.T) {
	identities := unittest.DynamicIdentityEntryListFixture(3)
	sortedIdentities := identities.Sort(flow.IdentifierCanonical)

	// Copy and shuffle to ensure it's unsorted
	unsortedIdentities := sortedIdentities.Copy()
	unsortedIdentities[0], unsortedIdentities[1] = unsortedIdentities[1], unsortedIdentities[0]

	// 1. Valid input with all fields
	t.Run("valid input with all fields", func(t *testing.T) {
		container, err := flow.NewEpochStateContainer(
			flow.UntrustedEpochStateContainer{
				SetupID:          unittest.IdentifierFixture(),
				CommitID:         unittest.IdentifierFixture(),
				ActiveIdentities: sortedIdentities,
				EpochExtensions: []flow.EpochExtension{
					{FirstView: 100, FinalView: 200},
				},
			},
		)

		require.NoError(t, err)
		require.NotNil(t, container)
	})

	// 2. Valid input with zero CommitID and nil EpochExtensions
	t.Run("valid input with zero CommitID and nil EpochExtensions", func(t *testing.T) {
		container, err := flow.NewEpochStateContainer(
			flow.UntrustedEpochStateContainer{
				SetupID:          unittest.IdentifierFixture(),
				CommitID:         flow.ZeroID,
				ActiveIdentities: sortedIdentities,
				EpochExtensions:  nil,
			},
		)

		require.NoError(t, err)
		require.NotNil(t, container)
	})

	// 3. Invalid input with zero SetupID
	t.Run("invalid - zero SetupID", func(t *testing.T) {
		_, err := flow.NewEpochStateContainer(
			flow.UntrustedEpochStateContainer{
				SetupID:          flow.ZeroID,
				ActiveIdentities: sortedIdentities,
			},
		)
		require.Error(t, err)
		require.Contains(t, err.Error(), "SetupID must not be zero")
	})

	// 4. Invalid input with nil ActiveIdentities
	t.Run("invalid - nil ActiveIdentities", func(t *testing.T) {
		_, err := flow.NewEpochStateContainer(
			flow.UntrustedEpochStateContainer{
				SetupID: unittest.IdentifierFixture(),
			},
		)
		require.Error(t, err)
		require.Contains(t, err.Error(), "ActiveIdentities must not be nil")
	})

	// 5. Invalid input with unsorted ActiveIdentities
	t.Run("invalid - unsorted ActiveIdentities", func(t *testing.T) {
		_, err := flow.NewEpochStateContainer(
			flow.UntrustedEpochStateContainer{
				SetupID:          unittest.IdentifierFixture(),
				ActiveIdentities: unsortedIdentities,
			},
		)
		require.Error(t, err)
		require.Contains(t, err.Error(), "ActiveIdentities are not sorted")
	})
}

// TestNewMinEpochStateEntry validates the behavior of the NewMinEpochStateEntry constructor function.
// It checks for correct handling of both valid and invalid inputs.
//
// Test Cases:
//
// 1. Valid input with all fields:
//   - Ensures that providing a valid current epoch and optional previous/next epochs creates a MinEpochStateEntry.
//
// 2. Valid input with nil PreviousEpoch and NextEpoch:
//   - Ensures that entry construction still succeeds with only CurrentEpoch.
//
// 3. Invalid input: empty CurrentEpoch:
//   - Verifies that constructor returns an error if CurrentEpoch is not populated.
func TestNewMinEpochStateEntry(t *testing.T) {
	identities := unittest.DynamicIdentityEntryListFixture(3)

	currentEpoch := flow.EpochStateContainer{
		SetupID:          unittest.IdentifierFixture(),
		CommitID:         unittest.IdentifierFixture(),
		ActiveIdentities: identities,
	}

	previousEpoch := &flow.EpochStateContainer{
		SetupID:          unittest.IdentifierFixture(),
		CommitID:         unittest.IdentifierFixture(),
		ActiveIdentities: identities,
	}

	nextEpoch := &flow.EpochStateContainer{
		SetupID:          unittest.IdentifierFixture(),
		CommitID:         unittest.IdentifierFixture(),
		ActiveIdentities: identities,
	}

	// 1. Valid input with all fields
	t.Run("valid input with all fields", func(t *testing.T) {
		untrusted := flow.UntrustedMinEpochStateEntry{
			PreviousEpoch:          previousEpoch,
			CurrentEpoch:           currentEpoch,
			NextEpoch:              nextEpoch,
			EpochFallbackTriggered: true,
		}

		entry, err := flow.NewMinEpochStateEntry(untrusted)
		require.NoError(t, err)
		require.NotNil(t, entry)
	})

	// 2. Valid input with nil PreviousEpoch and NextEpoch
	t.Run("valid input with nil PreviousEpoch and NextEpoch", func(t *testing.T) {
		untrusted := flow.UntrustedMinEpochStateEntry{
			PreviousEpoch:          nil,
			CurrentEpoch:           currentEpoch,
			NextEpoch:              nil,
			EpochFallbackTriggered: false,
		}

		entry, err := flow.NewMinEpochStateEntry(untrusted)
		require.NoError(t, err)
		require.NotNil(t, entry)
	})

	// 3. Invalid input: empty CurrentEpoch
	t.Run("empty CurrentEpoch", func(t *testing.T) {
		untrusted := flow.UntrustedMinEpochStateEntry{
			PreviousEpoch:          nil,
			CurrentEpoch:           flow.EpochStateContainer{}, // Empty
			NextEpoch:              nil,
			EpochFallbackTriggered: false,
		}

		entry, err := flow.NewMinEpochStateEntry(untrusted)
		require.Error(t, err)
		require.Nil(t, entry)
		require.Contains(t, err.Error(), "current epoch must not be empty")
	})
}

// TestEpochStateContainer_EqualTo verifies the correctness of the EqualTo method on EpochStateContainer.
// It checks that containers are considered equal if and only if all fields match.
func TestEpochStateContainer_EqualTo(t *testing.T) {
	// Create two containers with different values
	identities1 := unittest.DynamicIdentityEntryListFixture(3)
	identities2 := unittest.DynamicIdentityEntryListFixture(3)

	c1 := &flow.EpochStateContainer{
		SetupID:          unittest.IdentifierFixture(),
		CommitID:         unittest.IdentifierFixture(),
		ActiveIdentities: identities1,
		EpochExtensions: []flow.EpochExtension{
			{
				FirstView: 201,
				FinalView: 300,
			},
		},
	}

	c2 := &flow.EpochStateContainer{
		SetupID:          unittest.IdentifierFixture(),
		CommitID:         unittest.IdentifierFixture(),
		ActiveIdentities: identities2,
		EpochExtensions: []flow.EpochExtension{
			{
				FirstView: 301,
				FinalView: 400,
			},
		},
	}

	require.False(t, c1.EqualTo(c2), "Initially, all fields differ; EqualTo should return false")

	// List of mutations to apply to c1 to gradually make it equal to c2
	mutations := []func(){
		func() {
			c1.SetupID = c2.SetupID
		},
		func() {
			c1.CommitID = c2.CommitID
		},
		func() {
			c1.ActiveIdentities = clone.Clone(c2.ActiveIdentities)
		},
		func() {
			c1.EpochExtensions = clone.Clone(c2.EpochExtensions)
		},
	}

	// Shuffle the order of mutations
	rand.Shuffle(len(mutations), func(i, j int) {
		mutations[i], mutations[j] = mutations[j], mutations[i]
	})

	// Apply each mutation one at a time, except the last.
	// After each step, the containers should still not be equal.
	for _, mutation := range mutations[:len(mutations)-1] {
		mutation()
		require.False(t, c1.EqualTo(c2))
	}

	// Final mutation should make the containers fully equal.
	mutations[len(mutations)-1]()
	require.True(t, c1.EqualTo(c2))
}

// TestEpochStateContainer_EqualTo_Nil verifies the behavior of the EqualTo method on EpochStateContainer when either
// or both the receiver and the function input are nil.
func TestEpochStateContainer_EqualTo_Nil(t *testing.T) {
	var nilContainer *flow.EpochStateContainer
	nonNil := &flow.EpochStateContainer{
		SetupID:          unittest.IdentifierFixture(),
		CommitID:         unittest.IdentifierFixture(),
		ActiveIdentities: unittest.DynamicIdentityEntryListFixture(3),
		EpochExtensions: []flow.EpochExtension{
			{
				FirstView: 201,
				FinalView: 300,
			},
		},
	}

	t.Run("nil receiver", func(t *testing.T) {
		require.False(t, nilContainer.EqualTo(nonNil))
	})

	t.Run("nil input", func(t *testing.T) {
		require.False(t, nonNil.EqualTo(nilContainer))
	})

	t.Run("both nil", func(t *testing.T) {
		require.True(t, nilContainer.EqualTo(nil))
	})
}

// TestEpochExtension_EqualTo verifies the correctness of the EqualTo method on EpochExtension.
// It checks that EpochExtensions are considered equal if and only if all fields match.
func TestEpochExtension_EqualTo(t *testing.T) {
	// Create two extensions with different values
	ext1 := &flow.EpochExtension{
		FirstView: 100,
		FinalView: 200,
	}
	ext2 := &flow.EpochExtension{
		FirstView: 300,
		FinalView: 400,
	}

	require.False(t, ext1.EqualTo(ext2), "Initially, all fields differ; EqualTo should return false")

	// List of mutations to apply to ext1 to gradually make it equal to ext2
	mutations := []func(){
		func() {
			ext1.FirstView = ext2.FirstView
		},
		func() {
			ext1.FinalView = ext2.FinalView
		},
	}

	// Shuffle the order of mutations
	rand.Shuffle(len(mutations), func(i, j int) {
		mutations[i], mutations[j] = mutations[j], mutations[i]
	})

	// Apply each mutation one at a time, except the last.
	// After each step, the extensions should still not be equal.
	for _, mutation := range mutations[:len(mutations)-1] {
		mutation()
		require.False(t, ext1.EqualTo(ext2))
	}

	// Final mutation should make the extensions fully equal.
	mutations[len(mutations)-1]()
	require.True(t, ext1.EqualTo(ext2))
}

// TestEpochExtension_EqualTo_Nil verifies the behavior of the EqualTo method on EpochExtension when either
// or both the receiver and the function input are nil.
func TestEpochExtension_EqualTo_Nil(t *testing.T) {
	var nilExt *flow.EpochExtension
	nonNil := &flow.EpochExtension{
		FirstView: 1,
		FinalView: 2,
	}

	t.Run("nil receiver", func(t *testing.T) {
		require.False(t, nilExt.EqualTo(nonNil))
	})

	t.Run("nil input", func(t *testing.T) {
		require.False(t, nonNil.EqualTo(nilExt))
	})

	t.Run("both nil", func(t *testing.T) {
		require.True(t, nilExt.EqualTo(nil))
	})
}

// TestDynamicIdentityEntry_EqualTo verifies the correctness of the EqualTo method on DynamicIdentityEntry.
// It checks that DynamicIdentityEntries are considered equal if and only if all fields match.
func TestDynamicIdentityEntry_EqualTo(t *testing.T) {
	entry1 := &flow.DynamicIdentityEntry{
		NodeID:  unittest.IdentifierFixture(),
		Ejected: false,
	}
	entry2 := &flow.DynamicIdentityEntry{
		NodeID:  unittest.IdentifierFixture(),
		Ejected: true,
	}

	require.False(t, entry1.EqualTo(entry2), "Initially, all fields differ; EqualTo should return false")

	// List of mutations to gradually make entry1 equal to entry2
	mutations := []func(){
		func() {
			entry1.NodeID = entry2.NodeID
		},
		func() {
			entry1.Ejected = entry2.Ejected
		},
	}

	// Shuffle mutation order
	rand.Shuffle(len(mutations), func(i, j int) {
		mutations[i], mutations[j] = mutations[j], mutations[i]
	})

	// Apply each mutation one at a time, except the last.
	for _, mutation := range mutations[:len(mutations)-1] {
		mutation()
		require.False(t, entry1.EqualTo(entry2))
	}

	// Final mutation: should now be equal
	mutations[len(mutations)-1]()
	require.True(t, entry1.EqualTo(entry2))
}

// TestDynamicIdentityEntry_EqualTo_Nil verifies the behavior of EqualTo on DynamicIdentityEntry when one or both inputs are nil.
func TestDynamicIdentityEntry_EqualTo_Nil(t *testing.T) {
	var nilEntry *flow.DynamicIdentityEntry
	nonNil := &flow.DynamicIdentityEntry{
		NodeID:  unittest.IdentifierFixture(),
		Ejected: false,
	}

	t.Run("nil receiver", func(t *testing.T) {
		require.False(t, nilEntry.EqualTo(nonNil))
	})

	t.Run("nil input", func(t *testing.T) {
		require.False(t, nonNil.EqualTo(nilEntry))
	})

	t.Run("both nil", func(t *testing.T) {
		require.True(t, nilEntry.EqualTo(nil))
	})
}
