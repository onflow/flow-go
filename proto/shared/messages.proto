syntax = "proto3";

import "google/protobuf/timestamp.proto";

package flow.shared.messages;

option go_package = "shared";

message BlockHeader {
  bytes hash = 1;
  bytes previousBlockHash = 2;
  uint64 height = 3;
  uint32 transactionCount = 4;
}

message Block {
  string chainID = 1;
  uint64 height = 2;
  bytes previousBlockHash = 3;
  google.protobuf.Timestamp timestamp = 4;
  repeated SignedCollectionHash signedCollectionHashes = 5;
  repeated BlockSeal blockSeals = 6;
  repeated bytes signatures = 7;
}

// When computation results for past blocks become available, a corresponding execution receipt
// (issued by execution nodes) and result approval (issued by access nodes) is issued.
//
// We want to persist the execution receipt (assuming the results are consistent) and
// the result approval in subsequent blocks. This step is called _sealing a block_.
//
// This is a sub-message for a block seal. This will allow us later to (optionally) seal
// multiple past blocks in one new block without revising the structure.
//
message BlockSeal {
  bytes blockHash = 1;
  bytes executionReceiptHash = 2;
  repeated bytes executionReceiptSignatures = 3; // Signatures from EN that issued the original ExecutionReceipt
  repeated bytes resultApprovalSignatures = 4; // Signatures from AN that approved the  ExecutionReceipt
}

message IntermediateRegisters {
  bytes transactionHash = 1;
  // the register changes at the end of computing the transaction
  repeated Register registers = 2;
  uint64 computeUsed = 3;
}

// Generated by each execution node individually; submitted to access nodes.
message ExecutionReceipt {
  bytes previousReceiptHash = 1;
  bytes blockHash = 2;
  repeated Register initialRegisters = 3; // Registers at start of the block
  repeated IntermediateRegisters intermediateRegistersList = 4;
  repeated bytes signatures = 5;
}

// Issued by the access nodes once they agree with the values
// for the computation that they were assigned to check.
message ResultApproval {
  uint64 blockHeight = 1;
  bytes executionReceiptHash = 2;
  bytes resultApprovalSignature = 3; // Signature over executionReceiptHash.  The equal payload across all ANs is needed for aggreagation into blockseals.
  uint64 proof = 4; // The verification proof.
  bytes signature = 5; // The final signature over all the above fields to prevent external manipulation.
}

message Register {
  bytes id = 1;
  bytes value = 2;
}

message AccountSignature {
  bytes account = 1;
  bytes signature = 2;
}

enum TransactionStatus {
  STATUS_PENDING = 0;
  STATUS_FINALIZED = 1;
  STATUS_REVERTED = 2;
  STATUS_SEALED = 3;
}

message Transaction {
  bytes script = 1;
  bytes reference_block_hash = 2;
  uint64 nonce = 3;
  uint64 compute_limit = 4;
  bytes PayerAccount = 5;
  repeated bytes ScriptAccounts = 6;
  repeated AccountSignature signatures = 7;
  TransactionStatus status = 8;
}

message Collection {
  repeated Transaction transactions = 1;
  bytes foundationBlockHash = 2;
}

message SignedCollectionHash {
  bytes collectionHash = 1;
  repeated bytes signatures = 2;
}

message Account {
  bytes address = 1;
  uint64 balance = 2;
  bytes code = 3;
  repeated AccountKey keys = 4;
}

message AccountKey {
  bytes public_key = 1;
  uint32 weight = 2;
}
