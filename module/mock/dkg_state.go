// Code generated by mockery. DO NOT EDIT.

package mock

import (
	crypto "github.com/onflow/crypto"
	mock "github.com/stretchr/testify/mock"
)

// DKGState is an autogenerated mock type for the DKGState type
type DKGState struct {
	mock.Mock
}

// End provides a mock function with no fields
func (_m *DKGState) End() (crypto.PrivateKey, crypto.PublicKey, []crypto.PublicKey, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for End")
	}

	var r0 crypto.PrivateKey
	var r1 crypto.PublicKey
	var r2 []crypto.PublicKey
	var r3 error
	if rf, ok := ret.Get(0).(func() (crypto.PrivateKey, crypto.PublicKey, []crypto.PublicKey, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() crypto.PrivateKey); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(crypto.PrivateKey)
		}
	}

	if rf, ok := ret.Get(1).(func() crypto.PublicKey); ok {
		r1 = rf()
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(crypto.PublicKey)
		}
	}

	if rf, ok := ret.Get(2).(func() []crypto.PublicKey); ok {
		r2 = rf()
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]crypto.PublicKey)
		}
	}

	if rf, ok := ret.Get(3).(func() error); ok {
		r3 = rf()
	} else {
		r3 = ret.Error(3)
	}

	return r0, r1, r2, r3
}

// ForceDisqualify provides a mock function with given fields: participant
func (_m *DKGState) ForceDisqualify(participant int) error {
	ret := _m.Called(participant)

	if len(ret) == 0 {
		panic("no return value specified for ForceDisqualify")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(int) error); ok {
		r0 = rf(participant)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// HandleBroadcastMsg provides a mock function with given fields: orig, msg
func (_m *DKGState) HandleBroadcastMsg(orig int, msg []byte) error {
	ret := _m.Called(orig, msg)

	if len(ret) == 0 {
		panic("no return value specified for HandleBroadcastMsg")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(int, []byte) error); ok {
		r0 = rf(orig, msg)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// HandlePrivateMsg provides a mock function with given fields: orig, msg
func (_m *DKGState) HandlePrivateMsg(orig int, msg []byte) error {
	ret := _m.Called(orig, msg)

	if len(ret) == 0 {
		panic("no return value specified for HandlePrivateMsg")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(int, []byte) error); ok {
		r0 = rf(orig, msg)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NextTimeout provides a mock function with no fields
func (_m *DKGState) NextTimeout() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for NextTimeout")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Running provides a mock function with no fields
func (_m *DKGState) Running() bool {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Running")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Size provides a mock function with no fields
func (_m *DKGState) Size() int {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Size")
	}

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// Start provides a mock function with given fields: seed
func (_m *DKGState) Start(seed []byte) error {
	ret := _m.Called(seed)

	if len(ret) == 0 {
		panic("no return value specified for Start")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func([]byte) error); ok {
		r0 = rf(seed)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Threshold provides a mock function with no fields
func (_m *DKGState) Threshold() int {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Threshold")
	}

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// NewDKGState creates a new instance of DKGState. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewDKGState(t interface {
	mock.TestingT
	Cleanup(func())
}) *DKGState {
	mock := &DKGState{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
