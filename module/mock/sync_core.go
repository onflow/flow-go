// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mock

import (
	"github.com/onflow/flow-go/model/chainsync"
	"github.com/onflow/flow-go/model/flow"
	mock "github.com/stretchr/testify/mock"
)

// NewSyncCore creates a new instance of SyncCore. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewSyncCore(t interface {
	mock.TestingT
	Cleanup(func())
}) *SyncCore {
	mock := &SyncCore{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// SyncCore is an autogenerated mock type for the SyncCore type
type SyncCore struct {
	mock.Mock
}

type SyncCore_Expecter struct {
	mock *mock.Mock
}

func (_m *SyncCore) EXPECT() *SyncCore_Expecter {
	return &SyncCore_Expecter{mock: &_m.Mock}
}

// BatchRequested provides a mock function for the type SyncCore
func (_mock *SyncCore) BatchRequested(batch chainsync.Batch) {
	_mock.Called(batch)
	return
}

// SyncCore_BatchRequested_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BatchRequested'
type SyncCore_BatchRequested_Call struct {
	*mock.Call
}

// BatchRequested is a helper method to define mock.On call
//   - batch chainsync.Batch
func (_e *SyncCore_Expecter) BatchRequested(batch interface{}) *SyncCore_BatchRequested_Call {
	return &SyncCore_BatchRequested_Call{Call: _e.mock.On("BatchRequested", batch)}
}

func (_c *SyncCore_BatchRequested_Call) Run(run func(batch chainsync.Batch)) *SyncCore_BatchRequested_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 chainsync.Batch
		if args[0] != nil {
			arg0 = args[0].(chainsync.Batch)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *SyncCore_BatchRequested_Call) Return() *SyncCore_BatchRequested_Call {
	_c.Call.Return()
	return _c
}

func (_c *SyncCore_BatchRequested_Call) RunAndReturn(run func(batch chainsync.Batch)) *SyncCore_BatchRequested_Call {
	_c.Run(run)
	return _c
}

// HandleBlock provides a mock function for the type SyncCore
func (_mock *SyncCore) HandleBlock(header *flow.Header) bool {
	ret := _mock.Called(header)

	if len(ret) == 0 {
		panic("no return value specified for HandleBlock")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(*flow.Header) bool); ok {
		r0 = returnFunc(header)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// SyncCore_HandleBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HandleBlock'
type SyncCore_HandleBlock_Call struct {
	*mock.Call
}

// HandleBlock is a helper method to define mock.On call
//   - header *flow.Header
func (_e *SyncCore_Expecter) HandleBlock(header interface{}) *SyncCore_HandleBlock_Call {
	return &SyncCore_HandleBlock_Call{Call: _e.mock.On("HandleBlock", header)}
}

func (_c *SyncCore_HandleBlock_Call) Run(run func(header *flow.Header)) *SyncCore_HandleBlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *flow.Header
		if args[0] != nil {
			arg0 = args[0].(*flow.Header)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *SyncCore_HandleBlock_Call) Return(b bool) *SyncCore_HandleBlock_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *SyncCore_HandleBlock_Call) RunAndReturn(run func(header *flow.Header) bool) *SyncCore_HandleBlock_Call {
	_c.Call.Return(run)
	return _c
}

// HandleHeight provides a mock function for the type SyncCore
func (_mock *SyncCore) HandleHeight(final *flow.Header, height uint64) {
	_mock.Called(final, height)
	return
}

// SyncCore_HandleHeight_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HandleHeight'
type SyncCore_HandleHeight_Call struct {
	*mock.Call
}

// HandleHeight is a helper method to define mock.On call
//   - final *flow.Header
//   - height uint64
func (_e *SyncCore_Expecter) HandleHeight(final interface{}, height interface{}) *SyncCore_HandleHeight_Call {
	return &SyncCore_HandleHeight_Call{Call: _e.mock.On("HandleHeight", final, height)}
}

func (_c *SyncCore_HandleHeight_Call) Run(run func(final *flow.Header, height uint64)) *SyncCore_HandleHeight_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *flow.Header
		if args[0] != nil {
			arg0 = args[0].(*flow.Header)
		}
		var arg1 uint64
		if args[1] != nil {
			arg1 = args[1].(uint64)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *SyncCore_HandleHeight_Call) Return() *SyncCore_HandleHeight_Call {
	_c.Call.Return()
	return _c
}

func (_c *SyncCore_HandleHeight_Call) RunAndReturn(run func(final *flow.Header, height uint64)) *SyncCore_HandleHeight_Call {
	_c.Run(run)
	return _c
}

// RangeRequested provides a mock function for the type SyncCore
func (_mock *SyncCore) RangeRequested(ran chainsync.Range) {
	_mock.Called(ran)
	return
}

// SyncCore_RangeRequested_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RangeRequested'
type SyncCore_RangeRequested_Call struct {
	*mock.Call
}

// RangeRequested is a helper method to define mock.On call
//   - ran chainsync.Range
func (_e *SyncCore_Expecter) RangeRequested(ran interface{}) *SyncCore_RangeRequested_Call {
	return &SyncCore_RangeRequested_Call{Call: _e.mock.On("RangeRequested", ran)}
}

func (_c *SyncCore_RangeRequested_Call) Run(run func(ran chainsync.Range)) *SyncCore_RangeRequested_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 chainsync.Range
		if args[0] != nil {
			arg0 = args[0].(chainsync.Range)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *SyncCore_RangeRequested_Call) Return() *SyncCore_RangeRequested_Call {
	_c.Call.Return()
	return _c
}

func (_c *SyncCore_RangeRequested_Call) RunAndReturn(run func(ran chainsync.Range)) *SyncCore_RangeRequested_Call {
	_c.Run(run)
	return _c
}

// ScanPending provides a mock function for the type SyncCore
func (_mock *SyncCore) ScanPending(final *flow.Header) ([]chainsync.Range, []chainsync.Batch) {
	ret := _mock.Called(final)

	if len(ret) == 0 {
		panic("no return value specified for ScanPending")
	}

	var r0 []chainsync.Range
	var r1 []chainsync.Batch
	if returnFunc, ok := ret.Get(0).(func(*flow.Header) ([]chainsync.Range, []chainsync.Batch)); ok {
		return returnFunc(final)
	}
	if returnFunc, ok := ret.Get(0).(func(*flow.Header) []chainsync.Range); ok {
		r0 = returnFunc(final)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]chainsync.Range)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*flow.Header) []chainsync.Batch); ok {
		r1 = returnFunc(final)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]chainsync.Batch)
		}
	}
	return r0, r1
}

// SyncCore_ScanPending_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ScanPending'
type SyncCore_ScanPending_Call struct {
	*mock.Call
}

// ScanPending is a helper method to define mock.On call
//   - final *flow.Header
func (_e *SyncCore_Expecter) ScanPending(final interface{}) *SyncCore_ScanPending_Call {
	return &SyncCore_ScanPending_Call{Call: _e.mock.On("ScanPending", final)}
}

func (_c *SyncCore_ScanPending_Call) Run(run func(final *flow.Header)) *SyncCore_ScanPending_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *flow.Header
		if args[0] != nil {
			arg0 = args[0].(*flow.Header)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *SyncCore_ScanPending_Call) Return(ranges []chainsync.Range, batchs []chainsync.Batch) *SyncCore_ScanPending_Call {
	_c.Call.Return(ranges, batchs)
	return _c
}

func (_c *SyncCore_ScanPending_Call) RunAndReturn(run func(final *flow.Header) ([]chainsync.Range, []chainsync.Batch)) *SyncCore_ScanPending_Call {
	_c.Call.Return(run)
	return _c
}

// WithinTolerance provides a mock function for the type SyncCore
func (_mock *SyncCore) WithinTolerance(final *flow.Header, height uint64) bool {
	ret := _mock.Called(final, height)

	if len(ret) == 0 {
		panic("no return value specified for WithinTolerance")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(*flow.Header, uint64) bool); ok {
		r0 = returnFunc(final, height)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// SyncCore_WithinTolerance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithinTolerance'
type SyncCore_WithinTolerance_Call struct {
	*mock.Call
}

// WithinTolerance is a helper method to define mock.On call
//   - final *flow.Header
//   - height uint64
func (_e *SyncCore_Expecter) WithinTolerance(final interface{}, height interface{}) *SyncCore_WithinTolerance_Call {
	return &SyncCore_WithinTolerance_Call{Call: _e.mock.On("WithinTolerance", final, height)}
}

func (_c *SyncCore_WithinTolerance_Call) Run(run func(final *flow.Header, height uint64)) *SyncCore_WithinTolerance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *flow.Header
		if args[0] != nil {
			arg0 = args[0].(*flow.Header)
		}
		var arg1 uint64
		if args[1] != nil {
			arg1 = args[1].(uint64)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *SyncCore_WithinTolerance_Call) Return(b bool) *SyncCore_WithinTolerance_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *SyncCore_WithinTolerance_Call) RunAndReturn(run func(final *flow.Header, height uint64) bool) *SyncCore_WithinTolerance_Call {
	_c.Call.Return(run)
	return _c
}
