// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mock

import (
	"github.com/onflow/crypto"
	"github.com/onflow/crypto/hash"
	mock "github.com/stretchr/testify/mock"
)

// NewDKGState creates a new instance of DKGState. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewDKGState(t interface {
	mock.TestingT
	Cleanup(func())
}) *DKGState {
	mock := &DKGState{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// DKGState is an autogenerated mock type for the DKGState type
type DKGState struct {
	mock.Mock
}

type DKGState_Expecter struct {
	mock *mock.Mock
}

func (_m *DKGState) EXPECT() *DKGState_Expecter {
	return &DKGState_Expecter{mock: &_m.Mock}
}

// End provides a mock function for the type DKGState
func (_mock *DKGState) End() (crypto.PrivateKey, crypto.PublicKey, []crypto.PublicKey, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for End")
	}

	var r0 crypto.PrivateKey
	var r1 crypto.PublicKey
	var r2 []crypto.PublicKey
	var r3 error
	if returnFunc, ok := ret.Get(0).(func() (crypto.PrivateKey, crypto.PublicKey, []crypto.PublicKey, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() crypto.PrivateKey); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(crypto.PrivateKey)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() crypto.PublicKey); ok {
		r1 = returnFunc()
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(crypto.PublicKey)
		}
	}
	if returnFunc, ok := ret.Get(2).(func() []crypto.PublicKey); ok {
		r2 = returnFunc()
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]crypto.PublicKey)
		}
	}
	if returnFunc, ok := ret.Get(3).(func() error); ok {
		r3 = returnFunc()
	} else {
		r3 = ret.Error(3)
	}
	return r0, r1, r2, r3
}

// DKGState_End_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'End'
type DKGState_End_Call struct {
	*mock.Call
}

// End is a helper method to define mock.On call
func (_e *DKGState_Expecter) End() *DKGState_End_Call {
	return &DKGState_End_Call{Call: _e.mock.On("End")}
}

func (_c *DKGState_End_Call) Run(run func()) *DKGState_End_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *DKGState_End_Call) Return(privateKey crypto.PrivateKey, publicKey crypto.PublicKey, publicKeys []crypto.PublicKey, err error) *DKGState_End_Call {
	_c.Call.Return(privateKey, publicKey, publicKeys, err)
	return _c
}

func (_c *DKGState_End_Call) RunAndReturn(run func() (crypto.PrivateKey, crypto.PublicKey, []crypto.PublicKey, error)) *DKGState_End_Call {
	_c.Call.Return(run)
	return _c
}

// ForceDisqualify provides a mock function for the type DKGState
func (_mock *DKGState) ForceDisqualify(participant int) error {
	ret := _mock.Called(participant)

	if len(ret) == 0 {
		panic("no return value specified for ForceDisqualify")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(int) error); ok {
		r0 = returnFunc(participant)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// DKGState_ForceDisqualify_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ForceDisqualify'
type DKGState_ForceDisqualify_Call struct {
	*mock.Call
}

// ForceDisqualify is a helper method to define mock.On call
//   - participant int
func (_e *DKGState_Expecter) ForceDisqualify(participant interface{}) *DKGState_ForceDisqualify_Call {
	return &DKGState_ForceDisqualify_Call{Call: _e.mock.On("ForceDisqualify", participant)}
}

func (_c *DKGState_ForceDisqualify_Call) Run(run func(participant int)) *DKGState_ForceDisqualify_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 int
		if args[0] != nil {
			arg0 = args[0].(int)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *DKGState_ForceDisqualify_Call) Return(err error) *DKGState_ForceDisqualify_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *DKGState_ForceDisqualify_Call) RunAndReturn(run func(participant int) error) *DKGState_ForceDisqualify_Call {
	_c.Call.Return(run)
	return _c
}

// HandleBroadcastMsg provides a mock function for the type DKGState
func (_mock *DKGState) HandleBroadcastMsg(orig int, msg []byte) error {
	ret := _mock.Called(orig, msg)

	if len(ret) == 0 {
		panic("no return value specified for HandleBroadcastMsg")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(int, []byte) error); ok {
		r0 = returnFunc(orig, msg)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// DKGState_HandleBroadcastMsg_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HandleBroadcastMsg'
type DKGState_HandleBroadcastMsg_Call struct {
	*mock.Call
}

// HandleBroadcastMsg is a helper method to define mock.On call
//   - orig int
//   - msg []byte
func (_e *DKGState_Expecter) HandleBroadcastMsg(orig interface{}, msg interface{}) *DKGState_HandleBroadcastMsg_Call {
	return &DKGState_HandleBroadcastMsg_Call{Call: _e.mock.On("HandleBroadcastMsg", orig, msg)}
}

func (_c *DKGState_HandleBroadcastMsg_Call) Run(run func(orig int, msg []byte)) *DKGState_HandleBroadcastMsg_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 int
		if args[0] != nil {
			arg0 = args[0].(int)
		}
		var arg1 []byte
		if args[1] != nil {
			arg1 = args[1].([]byte)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *DKGState_HandleBroadcastMsg_Call) Return(err error) *DKGState_HandleBroadcastMsg_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *DKGState_HandleBroadcastMsg_Call) RunAndReturn(run func(orig int, msg []byte) error) *DKGState_HandleBroadcastMsg_Call {
	_c.Call.Return(run)
	return _c
}

// HandlePrivateMsg provides a mock function for the type DKGState
func (_mock *DKGState) HandlePrivateMsg(orig int, msg []byte) error {
	ret := _mock.Called(orig, msg)

	if len(ret) == 0 {
		panic("no return value specified for HandlePrivateMsg")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(int, []byte) error); ok {
		r0 = returnFunc(orig, msg)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// DKGState_HandlePrivateMsg_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HandlePrivateMsg'
type DKGState_HandlePrivateMsg_Call struct {
	*mock.Call
}

// HandlePrivateMsg is a helper method to define mock.On call
//   - orig int
//   - msg []byte
func (_e *DKGState_Expecter) HandlePrivateMsg(orig interface{}, msg interface{}) *DKGState_HandlePrivateMsg_Call {
	return &DKGState_HandlePrivateMsg_Call{Call: _e.mock.On("HandlePrivateMsg", orig, msg)}
}

func (_c *DKGState_HandlePrivateMsg_Call) Run(run func(orig int, msg []byte)) *DKGState_HandlePrivateMsg_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 int
		if args[0] != nil {
			arg0 = args[0].(int)
		}
		var arg1 []byte
		if args[1] != nil {
			arg1 = args[1].([]byte)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *DKGState_HandlePrivateMsg_Call) Return(err error) *DKGState_HandlePrivateMsg_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *DKGState_HandlePrivateMsg_Call) RunAndReturn(run func(orig int, msg []byte) error) *DKGState_HandlePrivateMsg_Call {
	_c.Call.Return(run)
	return _c
}

// NextTimeout provides a mock function for the type DKGState
func (_mock *DKGState) NextTimeout() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for NextTimeout")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// DKGState_NextTimeout_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NextTimeout'
type DKGState_NextTimeout_Call struct {
	*mock.Call
}

// NextTimeout is a helper method to define mock.On call
func (_e *DKGState_Expecter) NextTimeout() *DKGState_NextTimeout_Call {
	return &DKGState_NextTimeout_Call{Call: _e.mock.On("NextTimeout")}
}

func (_c *DKGState_NextTimeout_Call) Run(run func()) *DKGState_NextTimeout_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *DKGState_NextTimeout_Call) Return(err error) *DKGState_NextTimeout_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *DKGState_NextTimeout_Call) RunAndReturn(run func() error) *DKGState_NextTimeout_Call {
	_c.Call.Return(run)
	return _c
}

// Running provides a mock function for the type DKGState
func (_mock *DKGState) Running() bool {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Running")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func() bool); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// DKGState_Running_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Running'
type DKGState_Running_Call struct {
	*mock.Call
}

// Running is a helper method to define mock.On call
func (_e *DKGState_Expecter) Running() *DKGState_Running_Call {
	return &DKGState_Running_Call{Call: _e.mock.On("Running")}
}

func (_c *DKGState_Running_Call) Run(run func()) *DKGState_Running_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *DKGState_Running_Call) Return(b bool) *DKGState_Running_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *DKGState_Running_Call) RunAndReturn(run func() bool) *DKGState_Running_Call {
	_c.Call.Return(run)
	return _c
}

// Size provides a mock function for the type DKGState
func (_mock *DKGState) Size() int {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Size")
	}

	var r0 int
	if returnFunc, ok := ret.Get(0).(func() int); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(int)
	}
	return r0
}

// DKGState_Size_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Size'
type DKGState_Size_Call struct {
	*mock.Call
}

// Size is a helper method to define mock.On call
func (_e *DKGState_Expecter) Size() *DKGState_Size_Call {
	return &DKGState_Size_Call{Call: _e.mock.On("Size")}
}

func (_c *DKGState_Size_Call) Run(run func()) *DKGState_Size_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *DKGState_Size_Call) Return(n int) *DKGState_Size_Call {
	_c.Call.Return(n)
	return _c
}

func (_c *DKGState_Size_Call) RunAndReturn(run func() int) *DKGState_Size_Call {
	_c.Call.Return(run)
	return _c
}

// Start provides a mock function for the type DKGState
func (_mock *DKGState) Start(seed []byte) error {
	ret := _mock.Called(seed)

	if len(ret) == 0 {
		panic("no return value specified for Start")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func([]byte) error); ok {
		r0 = returnFunc(seed)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// DKGState_Start_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Start'
type DKGState_Start_Call struct {
	*mock.Call
}

// Start is a helper method to define mock.On call
//   - seed []byte
func (_e *DKGState_Expecter) Start(seed interface{}) *DKGState_Start_Call {
	return &DKGState_Start_Call{Call: _e.mock.On("Start", seed)}
}

func (_c *DKGState_Start_Call) Run(run func(seed []byte)) *DKGState_Start_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []byte
		if args[0] != nil {
			arg0 = args[0].([]byte)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *DKGState_Start_Call) Return(err error) *DKGState_Start_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *DKGState_Start_Call) RunAndReturn(run func(seed []byte) error) *DKGState_Start_Call {
	_c.Call.Return(run)
	return _c
}

// Threshold provides a mock function for the type DKGState
func (_mock *DKGState) Threshold() int {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Threshold")
	}

	var r0 int
	if returnFunc, ok := ret.Get(0).(func() int); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(int)
	}
	return r0
}

// DKGState_Threshold_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Threshold'
type DKGState_Threshold_Call struct {
	*mock.Call
}

// Threshold is a helper method to define mock.On call
func (_e *DKGState_Expecter) Threshold() *DKGState_Threshold_Call {
	return &DKGState_Threshold_Call{Call: _e.mock.On("Threshold")}
}

func (_c *DKGState_Threshold_Call) Run(run func()) *DKGState_Threshold_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *DKGState_Threshold_Call) Return(n int) *DKGState_Threshold_Call {
	_c.Call.Return(n)
	return _c
}

func (_c *DKGState_Threshold_Call) RunAndReturn(run func() int) *DKGState_Threshold_Call {
	_c.Call.Return(run)
	return _c
}

// NewDKGProcessor creates a new instance of DKGProcessor. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewDKGProcessor(t interface {
	mock.TestingT
	Cleanup(func())
}) *DKGProcessor {
	mock := &DKGProcessor{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// DKGProcessor is an autogenerated mock type for the DKGProcessor type
type DKGProcessor struct {
	mock.Mock
}

type DKGProcessor_Expecter struct {
	mock *mock.Mock
}

func (_m *DKGProcessor) EXPECT() *DKGProcessor_Expecter {
	return &DKGProcessor_Expecter{mock: &_m.Mock}
}

// Broadcast provides a mock function for the type DKGProcessor
func (_mock *DKGProcessor) Broadcast(data []byte) {
	_mock.Called(data)
	return
}

// DKGProcessor_Broadcast_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Broadcast'
type DKGProcessor_Broadcast_Call struct {
	*mock.Call
}

// Broadcast is a helper method to define mock.On call
//   - data []byte
func (_e *DKGProcessor_Expecter) Broadcast(data interface{}) *DKGProcessor_Broadcast_Call {
	return &DKGProcessor_Broadcast_Call{Call: _e.mock.On("Broadcast", data)}
}

func (_c *DKGProcessor_Broadcast_Call) Run(run func(data []byte)) *DKGProcessor_Broadcast_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []byte
		if args[0] != nil {
			arg0 = args[0].([]byte)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *DKGProcessor_Broadcast_Call) Return() *DKGProcessor_Broadcast_Call {
	_c.Call.Return()
	return _c
}

func (_c *DKGProcessor_Broadcast_Call) RunAndReturn(run func(data []byte)) *DKGProcessor_Broadcast_Call {
	_c.Run(run)
	return _c
}

// Disqualify provides a mock function for the type DKGProcessor
func (_mock *DKGProcessor) Disqualify(index int, log string) {
	_mock.Called(index, log)
	return
}

// DKGProcessor_Disqualify_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Disqualify'
type DKGProcessor_Disqualify_Call struct {
	*mock.Call
}

// Disqualify is a helper method to define mock.On call
//   - index int
//   - log string
func (_e *DKGProcessor_Expecter) Disqualify(index interface{}, log interface{}) *DKGProcessor_Disqualify_Call {
	return &DKGProcessor_Disqualify_Call{Call: _e.mock.On("Disqualify", index, log)}
}

func (_c *DKGProcessor_Disqualify_Call) Run(run func(index int, log string)) *DKGProcessor_Disqualify_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 int
		if args[0] != nil {
			arg0 = args[0].(int)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *DKGProcessor_Disqualify_Call) Return() *DKGProcessor_Disqualify_Call {
	_c.Call.Return()
	return _c
}

func (_c *DKGProcessor_Disqualify_Call) RunAndReturn(run func(index int, log string)) *DKGProcessor_Disqualify_Call {
	_c.Run(run)
	return _c
}

// FlagMisbehavior provides a mock function for the type DKGProcessor
func (_mock *DKGProcessor) FlagMisbehavior(index int, log string) {
	_mock.Called(index, log)
	return
}

// DKGProcessor_FlagMisbehavior_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FlagMisbehavior'
type DKGProcessor_FlagMisbehavior_Call struct {
	*mock.Call
}

// FlagMisbehavior is a helper method to define mock.On call
//   - index int
//   - log string
func (_e *DKGProcessor_Expecter) FlagMisbehavior(index interface{}, log interface{}) *DKGProcessor_FlagMisbehavior_Call {
	return &DKGProcessor_FlagMisbehavior_Call{Call: _e.mock.On("FlagMisbehavior", index, log)}
}

func (_c *DKGProcessor_FlagMisbehavior_Call) Run(run func(index int, log string)) *DKGProcessor_FlagMisbehavior_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 int
		if args[0] != nil {
			arg0 = args[0].(int)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *DKGProcessor_FlagMisbehavior_Call) Return() *DKGProcessor_FlagMisbehavior_Call {
	_c.Call.Return()
	return _c
}

func (_c *DKGProcessor_FlagMisbehavior_Call) RunAndReturn(run func(index int, log string)) *DKGProcessor_FlagMisbehavior_Call {
	_c.Run(run)
	return _c
}

// PrivateSend provides a mock function for the type DKGProcessor
func (_mock *DKGProcessor) PrivateSend(dest int, data []byte) {
	_mock.Called(dest, data)
	return
}

// DKGProcessor_PrivateSend_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PrivateSend'
type DKGProcessor_PrivateSend_Call struct {
	*mock.Call
}

// PrivateSend is a helper method to define mock.On call
//   - dest int
//   - data []byte
func (_e *DKGProcessor_Expecter) PrivateSend(dest interface{}, data interface{}) *DKGProcessor_PrivateSend_Call {
	return &DKGProcessor_PrivateSend_Call{Call: _e.mock.On("PrivateSend", dest, data)}
}

func (_c *DKGProcessor_PrivateSend_Call) Run(run func(dest int, data []byte)) *DKGProcessor_PrivateSend_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 int
		if args[0] != nil {
			arg0 = args[0].(int)
		}
		var arg1 []byte
		if args[1] != nil {
			arg1 = args[1].([]byte)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *DKGProcessor_PrivateSend_Call) Return() *DKGProcessor_PrivateSend_Call {
	_c.Call.Return()
	return _c
}

func (_c *DKGProcessor_PrivateSend_Call) RunAndReturn(run func(dest int, data []byte)) *DKGProcessor_PrivateSend_Call {
	_c.Run(run)
	return _c
}

// newSigner creates a new instance of signer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func newSigner(t interface {
	mock.TestingT
	Cleanup(func())
}) *signer {
	mock := &signer{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// signer is an autogenerated mock type for the signer type
type signer struct {
	mock.Mock
}

type signer_Expecter struct {
	mock *mock.Mock
}

func (_m *signer) EXPECT() *signer_Expecter {
	return &signer_Expecter{mock: &_m.Mock}
}

// decodePrivateKey provides a mock function for the type signer
func (_mock *signer) decodePrivateKey(bytes []byte) (crypto.PrivateKey, error) {
	ret := _mock.Called(bytes)

	if len(ret) == 0 {
		panic("no return value specified for decodePrivateKey")
	}

	var r0 crypto.PrivateKey
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]byte) (crypto.PrivateKey, error)); ok {
		return returnFunc(bytes)
	}
	if returnFunc, ok := ret.Get(0).(func([]byte) crypto.PrivateKey); ok {
		r0 = returnFunc(bytes)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(crypto.PrivateKey)
		}
	}
	if returnFunc, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = returnFunc(bytes)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// signer_decodePrivateKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'decodePrivateKey'
type signer_decodePrivateKey_Call struct {
	*mock.Call
}

// decodePrivateKey is a helper method to define mock.On call
//   - bytes []byte
func (_e *signer_Expecter) decodePrivateKey(bytes interface{}) *signer_decodePrivateKey_Call {
	return &signer_decodePrivateKey_Call{Call: _e.mock.On("decodePrivateKey", bytes)}
}

func (_c *signer_decodePrivateKey_Call) Run(run func(bytes []byte)) *signer_decodePrivateKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []byte
		if args[0] != nil {
			arg0 = args[0].([]byte)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *signer_decodePrivateKey_Call) Return(privateKey crypto.PrivateKey, err error) *signer_decodePrivateKey_Call {
	_c.Call.Return(privateKey, err)
	return _c
}

func (_c *signer_decodePrivateKey_Call) RunAndReturn(run func(bytes []byte) (crypto.PrivateKey, error)) *signer_decodePrivateKey_Call {
	_c.Call.Return(run)
	return _c
}

// decodePublicKey provides a mock function for the type signer
func (_mock *signer) decodePublicKey(bytes []byte) (crypto.PublicKey, error) {
	ret := _mock.Called(bytes)

	if len(ret) == 0 {
		panic("no return value specified for decodePublicKey")
	}

	var r0 crypto.PublicKey
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]byte) (crypto.PublicKey, error)); ok {
		return returnFunc(bytes)
	}
	if returnFunc, ok := ret.Get(0).(func([]byte) crypto.PublicKey); ok {
		r0 = returnFunc(bytes)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(crypto.PublicKey)
		}
	}
	if returnFunc, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = returnFunc(bytes)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// signer_decodePublicKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'decodePublicKey'
type signer_decodePublicKey_Call struct {
	*mock.Call
}

// decodePublicKey is a helper method to define mock.On call
//   - bytes []byte
func (_e *signer_Expecter) decodePublicKey(bytes interface{}) *signer_decodePublicKey_Call {
	return &signer_decodePublicKey_Call{Call: _e.mock.On("decodePublicKey", bytes)}
}

func (_c *signer_decodePublicKey_Call) Run(run func(bytes []byte)) *signer_decodePublicKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []byte
		if args[0] != nil {
			arg0 = args[0].([]byte)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *signer_decodePublicKey_Call) Return(publicKey crypto.PublicKey, err error) *signer_decodePublicKey_Call {
	_c.Call.Return(publicKey, err)
	return _c
}

func (_c *signer_decodePublicKey_Call) RunAndReturn(run func(bytes []byte) (crypto.PublicKey, error)) *signer_decodePublicKey_Call {
	_c.Call.Return(run)
	return _c
}

// decodePublicKeyCompressed provides a mock function for the type signer
func (_mock *signer) decodePublicKeyCompressed(bytes []byte) (crypto.PublicKey, error) {
	ret := _mock.Called(bytes)

	if len(ret) == 0 {
		panic("no return value specified for decodePublicKeyCompressed")
	}

	var r0 crypto.PublicKey
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]byte) (crypto.PublicKey, error)); ok {
		return returnFunc(bytes)
	}
	if returnFunc, ok := ret.Get(0).(func([]byte) crypto.PublicKey); ok {
		r0 = returnFunc(bytes)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(crypto.PublicKey)
		}
	}
	if returnFunc, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = returnFunc(bytes)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// signer_decodePublicKeyCompressed_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'decodePublicKeyCompressed'
type signer_decodePublicKeyCompressed_Call struct {
	*mock.Call
}

// decodePublicKeyCompressed is a helper method to define mock.On call
//   - bytes []byte
func (_e *signer_Expecter) decodePublicKeyCompressed(bytes interface{}) *signer_decodePublicKeyCompressed_Call {
	return &signer_decodePublicKeyCompressed_Call{Call: _e.mock.On("decodePublicKeyCompressed", bytes)}
}

func (_c *signer_decodePublicKeyCompressed_Call) Run(run func(bytes []byte)) *signer_decodePublicKeyCompressed_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []byte
		if args[0] != nil {
			arg0 = args[0].([]byte)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *signer_decodePublicKeyCompressed_Call) Return(publicKey crypto.PublicKey, err error) *signer_decodePublicKeyCompressed_Call {
	_c.Call.Return(publicKey, err)
	return _c
}

func (_c *signer_decodePublicKeyCompressed_Call) RunAndReturn(run func(bytes []byte) (crypto.PublicKey, error)) *signer_decodePublicKeyCompressed_Call {
	_c.Call.Return(run)
	return _c
}

// generatePrivateKey provides a mock function for the type signer
func (_mock *signer) generatePrivateKey(bytes []byte) (crypto.PrivateKey, error) {
	ret := _mock.Called(bytes)

	if len(ret) == 0 {
		panic("no return value specified for generatePrivateKey")
	}

	var r0 crypto.PrivateKey
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]byte) (crypto.PrivateKey, error)); ok {
		return returnFunc(bytes)
	}
	if returnFunc, ok := ret.Get(0).(func([]byte) crypto.PrivateKey); ok {
		r0 = returnFunc(bytes)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(crypto.PrivateKey)
		}
	}
	if returnFunc, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = returnFunc(bytes)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// signer_generatePrivateKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'generatePrivateKey'
type signer_generatePrivateKey_Call struct {
	*mock.Call
}

// generatePrivateKey is a helper method to define mock.On call
//   - bytes []byte
func (_e *signer_Expecter) generatePrivateKey(bytes interface{}) *signer_generatePrivateKey_Call {
	return &signer_generatePrivateKey_Call{Call: _e.mock.On("generatePrivateKey", bytes)}
}

func (_c *signer_generatePrivateKey_Call) Run(run func(bytes []byte)) *signer_generatePrivateKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []byte
		if args[0] != nil {
			arg0 = args[0].([]byte)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *signer_generatePrivateKey_Call) Return(privateKey crypto.PrivateKey, err error) *signer_generatePrivateKey_Call {
	_c.Call.Return(privateKey, err)
	return _c
}

func (_c *signer_generatePrivateKey_Call) RunAndReturn(run func(bytes []byte) (crypto.PrivateKey, error)) *signer_generatePrivateKey_Call {
	_c.Call.Return(run)
	return _c
}

// NewPrivateKey creates a new instance of PrivateKey. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewPrivateKey(t interface {
	mock.TestingT
	Cleanup(func())
}) *PrivateKey {
	mock := &PrivateKey{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// PrivateKey is an autogenerated mock type for the PrivateKey type
type PrivateKey struct {
	mock.Mock
}

type PrivateKey_Expecter struct {
	mock *mock.Mock
}

func (_m *PrivateKey) EXPECT() *PrivateKey_Expecter {
	return &PrivateKey_Expecter{mock: &_m.Mock}
}

// Algorithm provides a mock function for the type PrivateKey
func (_mock *PrivateKey) Algorithm() crypto.SigningAlgorithm {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Algorithm")
	}

	var r0 crypto.SigningAlgorithm
	if returnFunc, ok := ret.Get(0).(func() crypto.SigningAlgorithm); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(crypto.SigningAlgorithm)
	}
	return r0
}

// PrivateKey_Algorithm_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Algorithm'
type PrivateKey_Algorithm_Call struct {
	*mock.Call
}

// Algorithm is a helper method to define mock.On call
func (_e *PrivateKey_Expecter) Algorithm() *PrivateKey_Algorithm_Call {
	return &PrivateKey_Algorithm_Call{Call: _e.mock.On("Algorithm")}
}

func (_c *PrivateKey_Algorithm_Call) Run(run func()) *PrivateKey_Algorithm_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *PrivateKey_Algorithm_Call) Return(signingAlgorithm crypto.SigningAlgorithm) *PrivateKey_Algorithm_Call {
	_c.Call.Return(signingAlgorithm)
	return _c
}

func (_c *PrivateKey_Algorithm_Call) RunAndReturn(run func() crypto.SigningAlgorithm) *PrivateKey_Algorithm_Call {
	_c.Call.Return(run)
	return _c
}

// Encode provides a mock function for the type PrivateKey
func (_mock *PrivateKey) Encode() []byte {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Encode")
	}

	var r0 []byte
	if returnFunc, ok := ret.Get(0).(func() []byte); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}
	return r0
}

// PrivateKey_Encode_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Encode'
type PrivateKey_Encode_Call struct {
	*mock.Call
}

// Encode is a helper method to define mock.On call
func (_e *PrivateKey_Expecter) Encode() *PrivateKey_Encode_Call {
	return &PrivateKey_Encode_Call{Call: _e.mock.On("Encode")}
}

func (_c *PrivateKey_Encode_Call) Run(run func()) *PrivateKey_Encode_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *PrivateKey_Encode_Call) Return(bytes []byte) *PrivateKey_Encode_Call {
	_c.Call.Return(bytes)
	return _c
}

func (_c *PrivateKey_Encode_Call) RunAndReturn(run func() []byte) *PrivateKey_Encode_Call {
	_c.Call.Return(run)
	return _c
}

// Equals provides a mock function for the type PrivateKey
func (_mock *PrivateKey) Equals(privateKey crypto.PrivateKey) bool {
	ret := _mock.Called(privateKey)

	if len(ret) == 0 {
		panic("no return value specified for Equals")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(crypto.PrivateKey) bool); ok {
		r0 = returnFunc(privateKey)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// PrivateKey_Equals_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Equals'
type PrivateKey_Equals_Call struct {
	*mock.Call
}

// Equals is a helper method to define mock.On call
//   - privateKey crypto.PrivateKey
func (_e *PrivateKey_Expecter) Equals(privateKey interface{}) *PrivateKey_Equals_Call {
	return &PrivateKey_Equals_Call{Call: _e.mock.On("Equals", privateKey)}
}

func (_c *PrivateKey_Equals_Call) Run(run func(privateKey crypto.PrivateKey)) *PrivateKey_Equals_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 crypto.PrivateKey
		if args[0] != nil {
			arg0 = args[0].(crypto.PrivateKey)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PrivateKey_Equals_Call) Return(b bool) *PrivateKey_Equals_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *PrivateKey_Equals_Call) RunAndReturn(run func(privateKey crypto.PrivateKey) bool) *PrivateKey_Equals_Call {
	_c.Call.Return(run)
	return _c
}

// PublicKey provides a mock function for the type PrivateKey
func (_mock *PrivateKey) PublicKey() crypto.PublicKey {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for PublicKey")
	}

	var r0 crypto.PublicKey
	if returnFunc, ok := ret.Get(0).(func() crypto.PublicKey); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(crypto.PublicKey)
		}
	}
	return r0
}

// PrivateKey_PublicKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PublicKey'
type PrivateKey_PublicKey_Call struct {
	*mock.Call
}

// PublicKey is a helper method to define mock.On call
func (_e *PrivateKey_Expecter) PublicKey() *PrivateKey_PublicKey_Call {
	return &PrivateKey_PublicKey_Call{Call: _e.mock.On("PublicKey")}
}

func (_c *PrivateKey_PublicKey_Call) Run(run func()) *PrivateKey_PublicKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *PrivateKey_PublicKey_Call) Return(publicKey crypto.PublicKey) *PrivateKey_PublicKey_Call {
	_c.Call.Return(publicKey)
	return _c
}

func (_c *PrivateKey_PublicKey_Call) RunAndReturn(run func() crypto.PublicKey) *PrivateKey_PublicKey_Call {
	_c.Call.Return(run)
	return _c
}

// Sign provides a mock function for the type PrivateKey
func (_mock *PrivateKey) Sign(bytes []byte, hasher hash.Hasher) (crypto.Signature, error) {
	ret := _mock.Called(bytes, hasher)

	if len(ret) == 0 {
		panic("no return value specified for Sign")
	}

	var r0 crypto.Signature
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]byte, hash.Hasher) (crypto.Signature, error)); ok {
		return returnFunc(bytes, hasher)
	}
	if returnFunc, ok := ret.Get(0).(func([]byte, hash.Hasher) crypto.Signature); ok {
		r0 = returnFunc(bytes, hasher)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(crypto.Signature)
		}
	}
	if returnFunc, ok := ret.Get(1).(func([]byte, hash.Hasher) error); ok {
		r1 = returnFunc(bytes, hasher)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// PrivateKey_Sign_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Sign'
type PrivateKey_Sign_Call struct {
	*mock.Call
}

// Sign is a helper method to define mock.On call
//   - bytes []byte
//   - hasher hash.Hasher
func (_e *PrivateKey_Expecter) Sign(bytes interface{}, hasher interface{}) *PrivateKey_Sign_Call {
	return &PrivateKey_Sign_Call{Call: _e.mock.On("Sign", bytes, hasher)}
}

func (_c *PrivateKey_Sign_Call) Run(run func(bytes []byte, hasher hash.Hasher)) *PrivateKey_Sign_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []byte
		if args[0] != nil {
			arg0 = args[0].([]byte)
		}
		var arg1 hash.Hasher
		if args[1] != nil {
			arg1 = args[1].(hash.Hasher)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *PrivateKey_Sign_Call) Return(signature crypto.Signature, err error) *PrivateKey_Sign_Call {
	_c.Call.Return(signature, err)
	return _c
}

func (_c *PrivateKey_Sign_Call) RunAndReturn(run func(bytes []byte, hasher hash.Hasher) (crypto.Signature, error)) *PrivateKey_Sign_Call {
	_c.Call.Return(run)
	return _c
}

// Size provides a mock function for the type PrivateKey
func (_mock *PrivateKey) Size() int {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Size")
	}

	var r0 int
	if returnFunc, ok := ret.Get(0).(func() int); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(int)
	}
	return r0
}

// PrivateKey_Size_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Size'
type PrivateKey_Size_Call struct {
	*mock.Call
}

// Size is a helper method to define mock.On call
func (_e *PrivateKey_Expecter) Size() *PrivateKey_Size_Call {
	return &PrivateKey_Size_Call{Call: _e.mock.On("Size")}
}

func (_c *PrivateKey_Size_Call) Run(run func()) *PrivateKey_Size_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *PrivateKey_Size_Call) Return(n int) *PrivateKey_Size_Call {
	_c.Call.Return(n)
	return _c
}

func (_c *PrivateKey_Size_Call) RunAndReturn(run func() int) *PrivateKey_Size_Call {
	_c.Call.Return(run)
	return _c
}

// String provides a mock function for the type PrivateKey
func (_mock *PrivateKey) String() string {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for String")
	}

	var r0 string
	if returnFunc, ok := ret.Get(0).(func() string); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(string)
	}
	return r0
}

// PrivateKey_String_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'String'
type PrivateKey_String_Call struct {
	*mock.Call
}

// String is a helper method to define mock.On call
func (_e *PrivateKey_Expecter) String() *PrivateKey_String_Call {
	return &PrivateKey_String_Call{Call: _e.mock.On("String")}
}

func (_c *PrivateKey_String_Call) Run(run func()) *PrivateKey_String_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *PrivateKey_String_Call) Return(s string) *PrivateKey_String_Call {
	_c.Call.Return(s)
	return _c
}

func (_c *PrivateKey_String_Call) RunAndReturn(run func() string) *PrivateKey_String_Call {
	_c.Call.Return(run)
	return _c
}

// NewPublicKey creates a new instance of PublicKey. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewPublicKey(t interface {
	mock.TestingT
	Cleanup(func())
}) *PublicKey {
	mock := &PublicKey{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// PublicKey is an autogenerated mock type for the PublicKey type
type PublicKey struct {
	mock.Mock
}

type PublicKey_Expecter struct {
	mock *mock.Mock
}

func (_m *PublicKey) EXPECT() *PublicKey_Expecter {
	return &PublicKey_Expecter{mock: &_m.Mock}
}

// Algorithm provides a mock function for the type PublicKey
func (_mock *PublicKey) Algorithm() crypto.SigningAlgorithm {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Algorithm")
	}

	var r0 crypto.SigningAlgorithm
	if returnFunc, ok := ret.Get(0).(func() crypto.SigningAlgorithm); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(crypto.SigningAlgorithm)
	}
	return r0
}

// PublicKey_Algorithm_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Algorithm'
type PublicKey_Algorithm_Call struct {
	*mock.Call
}

// Algorithm is a helper method to define mock.On call
func (_e *PublicKey_Expecter) Algorithm() *PublicKey_Algorithm_Call {
	return &PublicKey_Algorithm_Call{Call: _e.mock.On("Algorithm")}
}

func (_c *PublicKey_Algorithm_Call) Run(run func()) *PublicKey_Algorithm_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *PublicKey_Algorithm_Call) Return(signingAlgorithm crypto.SigningAlgorithm) *PublicKey_Algorithm_Call {
	_c.Call.Return(signingAlgorithm)
	return _c
}

func (_c *PublicKey_Algorithm_Call) RunAndReturn(run func() crypto.SigningAlgorithm) *PublicKey_Algorithm_Call {
	_c.Call.Return(run)
	return _c
}

// Encode provides a mock function for the type PublicKey
func (_mock *PublicKey) Encode() []byte {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Encode")
	}

	var r0 []byte
	if returnFunc, ok := ret.Get(0).(func() []byte); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}
	return r0
}

// PublicKey_Encode_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Encode'
type PublicKey_Encode_Call struct {
	*mock.Call
}

// Encode is a helper method to define mock.On call
func (_e *PublicKey_Expecter) Encode() *PublicKey_Encode_Call {
	return &PublicKey_Encode_Call{Call: _e.mock.On("Encode")}
}

func (_c *PublicKey_Encode_Call) Run(run func()) *PublicKey_Encode_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *PublicKey_Encode_Call) Return(bytes []byte) *PublicKey_Encode_Call {
	_c.Call.Return(bytes)
	return _c
}

func (_c *PublicKey_Encode_Call) RunAndReturn(run func() []byte) *PublicKey_Encode_Call {
	_c.Call.Return(run)
	return _c
}

// EncodeCompressed provides a mock function for the type PublicKey
func (_mock *PublicKey) EncodeCompressed() []byte {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for EncodeCompressed")
	}

	var r0 []byte
	if returnFunc, ok := ret.Get(0).(func() []byte); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}
	return r0
}

// PublicKey_EncodeCompressed_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EncodeCompressed'
type PublicKey_EncodeCompressed_Call struct {
	*mock.Call
}

// EncodeCompressed is a helper method to define mock.On call
func (_e *PublicKey_Expecter) EncodeCompressed() *PublicKey_EncodeCompressed_Call {
	return &PublicKey_EncodeCompressed_Call{Call: _e.mock.On("EncodeCompressed")}
}

func (_c *PublicKey_EncodeCompressed_Call) Run(run func()) *PublicKey_EncodeCompressed_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *PublicKey_EncodeCompressed_Call) Return(bytes []byte) *PublicKey_EncodeCompressed_Call {
	_c.Call.Return(bytes)
	return _c
}

func (_c *PublicKey_EncodeCompressed_Call) RunAndReturn(run func() []byte) *PublicKey_EncodeCompressed_Call {
	_c.Call.Return(run)
	return _c
}

// Equals provides a mock function for the type PublicKey
func (_mock *PublicKey) Equals(publicKey crypto.PublicKey) bool {
	ret := _mock.Called(publicKey)

	if len(ret) == 0 {
		panic("no return value specified for Equals")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(crypto.PublicKey) bool); ok {
		r0 = returnFunc(publicKey)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// PublicKey_Equals_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Equals'
type PublicKey_Equals_Call struct {
	*mock.Call
}

// Equals is a helper method to define mock.On call
//   - publicKey crypto.PublicKey
func (_e *PublicKey_Expecter) Equals(publicKey interface{}) *PublicKey_Equals_Call {
	return &PublicKey_Equals_Call{Call: _e.mock.On("Equals", publicKey)}
}

func (_c *PublicKey_Equals_Call) Run(run func(publicKey crypto.PublicKey)) *PublicKey_Equals_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 crypto.PublicKey
		if args[0] != nil {
			arg0 = args[0].(crypto.PublicKey)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PublicKey_Equals_Call) Return(b bool) *PublicKey_Equals_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *PublicKey_Equals_Call) RunAndReturn(run func(publicKey crypto.PublicKey) bool) *PublicKey_Equals_Call {
	_c.Call.Return(run)
	return _c
}

// Size provides a mock function for the type PublicKey
func (_mock *PublicKey) Size() int {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Size")
	}

	var r0 int
	if returnFunc, ok := ret.Get(0).(func() int); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(int)
	}
	return r0
}

// PublicKey_Size_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Size'
type PublicKey_Size_Call struct {
	*mock.Call
}

// Size is a helper method to define mock.On call
func (_e *PublicKey_Expecter) Size() *PublicKey_Size_Call {
	return &PublicKey_Size_Call{Call: _e.mock.On("Size")}
}

func (_c *PublicKey_Size_Call) Run(run func()) *PublicKey_Size_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *PublicKey_Size_Call) Return(n int) *PublicKey_Size_Call {
	_c.Call.Return(n)
	return _c
}

func (_c *PublicKey_Size_Call) RunAndReturn(run func() int) *PublicKey_Size_Call {
	_c.Call.Return(run)
	return _c
}

// String provides a mock function for the type PublicKey
func (_mock *PublicKey) String() string {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for String")
	}

	var r0 string
	if returnFunc, ok := ret.Get(0).(func() string); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(string)
	}
	return r0
}

// PublicKey_String_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'String'
type PublicKey_String_Call struct {
	*mock.Call
}

// String is a helper method to define mock.On call
func (_e *PublicKey_Expecter) String() *PublicKey_String_Call {
	return &PublicKey_String_Call{Call: _e.mock.On("String")}
}

func (_c *PublicKey_String_Call) Run(run func()) *PublicKey_String_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *PublicKey_String_Call) Return(s string) *PublicKey_String_Call {
	_c.Call.Return(s)
	return _c
}

func (_c *PublicKey_String_Call) RunAndReturn(run func() string) *PublicKey_String_Call {
	_c.Call.Return(run)
	return _c
}

// Verify provides a mock function for the type PublicKey
func (_mock *PublicKey) Verify(signature crypto.Signature, bytes []byte, hasher hash.Hasher) (bool, error) {
	ret := _mock.Called(signature, bytes, hasher)

	if len(ret) == 0 {
		panic("no return value specified for Verify")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(crypto.Signature, []byte, hash.Hasher) (bool, error)); ok {
		return returnFunc(signature, bytes, hasher)
	}
	if returnFunc, ok := ret.Get(0).(func(crypto.Signature, []byte, hash.Hasher) bool); ok {
		r0 = returnFunc(signature, bytes, hasher)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(crypto.Signature, []byte, hash.Hasher) error); ok {
		r1 = returnFunc(signature, bytes, hasher)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// PublicKey_Verify_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Verify'
type PublicKey_Verify_Call struct {
	*mock.Call
}

// Verify is a helper method to define mock.On call
//   - signature crypto.Signature
//   - bytes []byte
//   - hasher hash.Hasher
func (_e *PublicKey_Expecter) Verify(signature interface{}, bytes interface{}, hasher interface{}) *PublicKey_Verify_Call {
	return &PublicKey_Verify_Call{Call: _e.mock.On("Verify", signature, bytes, hasher)}
}

func (_c *PublicKey_Verify_Call) Run(run func(signature crypto.Signature, bytes []byte, hasher hash.Hasher)) *PublicKey_Verify_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 crypto.Signature
		if args[0] != nil {
			arg0 = args[0].(crypto.Signature)
		}
		var arg1 []byte
		if args[1] != nil {
			arg1 = args[1].([]byte)
		}
		var arg2 hash.Hasher
		if args[2] != nil {
			arg2 = args[2].(hash.Hasher)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *PublicKey_Verify_Call) Return(b bool, err error) *PublicKey_Verify_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *PublicKey_Verify_Call) RunAndReturn(run func(signature crypto.Signature, bytes []byte, hasher hash.Hasher) (bool, error)) *PublicKey_Verify_Call {
	_c.Call.Return(run)
	return _c
}

// NewThresholdSignatureInspector creates a new instance of ThresholdSignatureInspector. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewThresholdSignatureInspector(t interface {
	mock.TestingT
	Cleanup(func())
}) *ThresholdSignatureInspector {
	mock := &ThresholdSignatureInspector{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// ThresholdSignatureInspector is an autogenerated mock type for the ThresholdSignatureInspector type
type ThresholdSignatureInspector struct {
	mock.Mock
}

type ThresholdSignatureInspector_Expecter struct {
	mock *mock.Mock
}

func (_m *ThresholdSignatureInspector) EXPECT() *ThresholdSignatureInspector_Expecter {
	return &ThresholdSignatureInspector_Expecter{mock: &_m.Mock}
}

// EnoughShares provides a mock function for the type ThresholdSignatureInspector
func (_mock *ThresholdSignatureInspector) EnoughShares() bool {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for EnoughShares")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func() bool); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// ThresholdSignatureInspector_EnoughShares_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnoughShares'
type ThresholdSignatureInspector_EnoughShares_Call struct {
	*mock.Call
}

// EnoughShares is a helper method to define mock.On call
func (_e *ThresholdSignatureInspector_Expecter) EnoughShares() *ThresholdSignatureInspector_EnoughShares_Call {
	return &ThresholdSignatureInspector_EnoughShares_Call{Call: _e.mock.On("EnoughShares")}
}

func (_c *ThresholdSignatureInspector_EnoughShares_Call) Run(run func()) *ThresholdSignatureInspector_EnoughShares_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ThresholdSignatureInspector_EnoughShares_Call) Return(b bool) *ThresholdSignatureInspector_EnoughShares_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *ThresholdSignatureInspector_EnoughShares_Call) RunAndReturn(run func() bool) *ThresholdSignatureInspector_EnoughShares_Call {
	_c.Call.Return(run)
	return _c
}

// HasShare provides a mock function for the type ThresholdSignatureInspector
func (_mock *ThresholdSignatureInspector) HasShare(index int) (bool, error) {
	ret := _mock.Called(index)

	if len(ret) == 0 {
		panic("no return value specified for HasShare")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(int) (bool, error)); ok {
		return returnFunc(index)
	}
	if returnFunc, ok := ret.Get(0).(func(int) bool); ok {
		r0 = returnFunc(index)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(int) error); ok {
		r1 = returnFunc(index)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ThresholdSignatureInspector_HasShare_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HasShare'
type ThresholdSignatureInspector_HasShare_Call struct {
	*mock.Call
}

// HasShare is a helper method to define mock.On call
//   - index int
func (_e *ThresholdSignatureInspector_Expecter) HasShare(index interface{}) *ThresholdSignatureInspector_HasShare_Call {
	return &ThresholdSignatureInspector_HasShare_Call{Call: _e.mock.On("HasShare", index)}
}

func (_c *ThresholdSignatureInspector_HasShare_Call) Run(run func(index int)) *ThresholdSignatureInspector_HasShare_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 int
		if args[0] != nil {
			arg0 = args[0].(int)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ThresholdSignatureInspector_HasShare_Call) Return(b bool, err error) *ThresholdSignatureInspector_HasShare_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *ThresholdSignatureInspector_HasShare_Call) RunAndReturn(run func(index int) (bool, error)) *ThresholdSignatureInspector_HasShare_Call {
	_c.Call.Return(run)
	return _c
}

// ThresholdSignature provides a mock function for the type ThresholdSignatureInspector
func (_mock *ThresholdSignatureInspector) ThresholdSignature() (crypto.Signature, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for ThresholdSignature")
	}

	var r0 crypto.Signature
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (crypto.Signature, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() crypto.Signature); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(crypto.Signature)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ThresholdSignatureInspector_ThresholdSignature_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ThresholdSignature'
type ThresholdSignatureInspector_ThresholdSignature_Call struct {
	*mock.Call
}

// ThresholdSignature is a helper method to define mock.On call
func (_e *ThresholdSignatureInspector_Expecter) ThresholdSignature() *ThresholdSignatureInspector_ThresholdSignature_Call {
	return &ThresholdSignatureInspector_ThresholdSignature_Call{Call: _e.mock.On("ThresholdSignature")}
}

func (_c *ThresholdSignatureInspector_ThresholdSignature_Call) Run(run func()) *ThresholdSignatureInspector_ThresholdSignature_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ThresholdSignatureInspector_ThresholdSignature_Call) Return(signature crypto.Signature, err error) *ThresholdSignatureInspector_ThresholdSignature_Call {
	_c.Call.Return(signature, err)
	return _c
}

func (_c *ThresholdSignatureInspector_ThresholdSignature_Call) RunAndReturn(run func() (crypto.Signature, error)) *ThresholdSignatureInspector_ThresholdSignature_Call {
	_c.Call.Return(run)
	return _c
}

// TrustedAdd provides a mock function for the type ThresholdSignatureInspector
func (_mock *ThresholdSignatureInspector) TrustedAdd(index int, share crypto.Signature) (bool, error) {
	ret := _mock.Called(index, share)

	if len(ret) == 0 {
		panic("no return value specified for TrustedAdd")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(int, crypto.Signature) (bool, error)); ok {
		return returnFunc(index, share)
	}
	if returnFunc, ok := ret.Get(0).(func(int, crypto.Signature) bool); ok {
		r0 = returnFunc(index, share)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(int, crypto.Signature) error); ok {
		r1 = returnFunc(index, share)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ThresholdSignatureInspector_TrustedAdd_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TrustedAdd'
type ThresholdSignatureInspector_TrustedAdd_Call struct {
	*mock.Call
}

// TrustedAdd is a helper method to define mock.On call
//   - index int
//   - share crypto.Signature
func (_e *ThresholdSignatureInspector_Expecter) TrustedAdd(index interface{}, share interface{}) *ThresholdSignatureInspector_TrustedAdd_Call {
	return &ThresholdSignatureInspector_TrustedAdd_Call{Call: _e.mock.On("TrustedAdd", index, share)}
}

func (_c *ThresholdSignatureInspector_TrustedAdd_Call) Run(run func(index int, share crypto.Signature)) *ThresholdSignatureInspector_TrustedAdd_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 int
		if args[0] != nil {
			arg0 = args[0].(int)
		}
		var arg1 crypto.Signature
		if args[1] != nil {
			arg1 = args[1].(crypto.Signature)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ThresholdSignatureInspector_TrustedAdd_Call) Return(b bool, err error) *ThresholdSignatureInspector_TrustedAdd_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *ThresholdSignatureInspector_TrustedAdd_Call) RunAndReturn(run func(index int, share crypto.Signature) (bool, error)) *ThresholdSignatureInspector_TrustedAdd_Call {
	_c.Call.Return(run)
	return _c
}

// VerifyAndAdd provides a mock function for the type ThresholdSignatureInspector
func (_mock *ThresholdSignatureInspector) VerifyAndAdd(index int, share crypto.Signature) (bool, bool, error) {
	ret := _mock.Called(index, share)

	if len(ret) == 0 {
		panic("no return value specified for VerifyAndAdd")
	}

	var r0 bool
	var r1 bool
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(int, crypto.Signature) (bool, bool, error)); ok {
		return returnFunc(index, share)
	}
	if returnFunc, ok := ret.Get(0).(func(int, crypto.Signature) bool); ok {
		r0 = returnFunc(index, share)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(int, crypto.Signature) bool); ok {
		r1 = returnFunc(index, share)
	} else {
		r1 = ret.Get(1).(bool)
	}
	if returnFunc, ok := ret.Get(2).(func(int, crypto.Signature) error); ok {
		r2 = returnFunc(index, share)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// ThresholdSignatureInspector_VerifyAndAdd_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'VerifyAndAdd'
type ThresholdSignatureInspector_VerifyAndAdd_Call struct {
	*mock.Call
}

// VerifyAndAdd is a helper method to define mock.On call
//   - index int
//   - share crypto.Signature
func (_e *ThresholdSignatureInspector_Expecter) VerifyAndAdd(index interface{}, share interface{}) *ThresholdSignatureInspector_VerifyAndAdd_Call {
	return &ThresholdSignatureInspector_VerifyAndAdd_Call{Call: _e.mock.On("VerifyAndAdd", index, share)}
}

func (_c *ThresholdSignatureInspector_VerifyAndAdd_Call) Run(run func(index int, share crypto.Signature)) *ThresholdSignatureInspector_VerifyAndAdd_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 int
		if args[0] != nil {
			arg0 = args[0].(int)
		}
		var arg1 crypto.Signature
		if args[1] != nil {
			arg1 = args[1].(crypto.Signature)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ThresholdSignatureInspector_VerifyAndAdd_Call) Return(b bool, b1 bool, err error) *ThresholdSignatureInspector_VerifyAndAdd_Call {
	_c.Call.Return(b, b1, err)
	return _c
}

func (_c *ThresholdSignatureInspector_VerifyAndAdd_Call) RunAndReturn(run func(index int, share crypto.Signature) (bool, bool, error)) *ThresholdSignatureInspector_VerifyAndAdd_Call {
	_c.Call.Return(run)
	return _c
}

// VerifyShare provides a mock function for the type ThresholdSignatureInspector
func (_mock *ThresholdSignatureInspector) VerifyShare(index int, share crypto.Signature) (bool, error) {
	ret := _mock.Called(index, share)

	if len(ret) == 0 {
		panic("no return value specified for VerifyShare")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(int, crypto.Signature) (bool, error)); ok {
		return returnFunc(index, share)
	}
	if returnFunc, ok := ret.Get(0).(func(int, crypto.Signature) bool); ok {
		r0 = returnFunc(index, share)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(int, crypto.Signature) error); ok {
		r1 = returnFunc(index, share)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ThresholdSignatureInspector_VerifyShare_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'VerifyShare'
type ThresholdSignatureInspector_VerifyShare_Call struct {
	*mock.Call
}

// VerifyShare is a helper method to define mock.On call
//   - index int
//   - share crypto.Signature
func (_e *ThresholdSignatureInspector_Expecter) VerifyShare(index interface{}, share interface{}) *ThresholdSignatureInspector_VerifyShare_Call {
	return &ThresholdSignatureInspector_VerifyShare_Call{Call: _e.mock.On("VerifyShare", index, share)}
}

func (_c *ThresholdSignatureInspector_VerifyShare_Call) Run(run func(index int, share crypto.Signature)) *ThresholdSignatureInspector_VerifyShare_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 int
		if args[0] != nil {
			arg0 = args[0].(int)
		}
		var arg1 crypto.Signature
		if args[1] != nil {
			arg1 = args[1].(crypto.Signature)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ThresholdSignatureInspector_VerifyShare_Call) Return(b bool, err error) *ThresholdSignatureInspector_VerifyShare_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *ThresholdSignatureInspector_VerifyShare_Call) RunAndReturn(run func(index int, share crypto.Signature) (bool, error)) *ThresholdSignatureInspector_VerifyShare_Call {
	_c.Call.Return(run)
	return _c
}

// VerifyThresholdSignature provides a mock function for the type ThresholdSignatureInspector
func (_mock *ThresholdSignatureInspector) VerifyThresholdSignature(thresholdSignature crypto.Signature) (bool, error) {
	ret := _mock.Called(thresholdSignature)

	if len(ret) == 0 {
		panic("no return value specified for VerifyThresholdSignature")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(crypto.Signature) (bool, error)); ok {
		return returnFunc(thresholdSignature)
	}
	if returnFunc, ok := ret.Get(0).(func(crypto.Signature) bool); ok {
		r0 = returnFunc(thresholdSignature)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(crypto.Signature) error); ok {
		r1 = returnFunc(thresholdSignature)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ThresholdSignatureInspector_VerifyThresholdSignature_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'VerifyThresholdSignature'
type ThresholdSignatureInspector_VerifyThresholdSignature_Call struct {
	*mock.Call
}

// VerifyThresholdSignature is a helper method to define mock.On call
//   - thresholdSignature crypto.Signature
func (_e *ThresholdSignatureInspector_Expecter) VerifyThresholdSignature(thresholdSignature interface{}) *ThresholdSignatureInspector_VerifyThresholdSignature_Call {
	return &ThresholdSignatureInspector_VerifyThresholdSignature_Call{Call: _e.mock.On("VerifyThresholdSignature", thresholdSignature)}
}

func (_c *ThresholdSignatureInspector_VerifyThresholdSignature_Call) Run(run func(thresholdSignature crypto.Signature)) *ThresholdSignatureInspector_VerifyThresholdSignature_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 crypto.Signature
		if args[0] != nil {
			arg0 = args[0].(crypto.Signature)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ThresholdSignatureInspector_VerifyThresholdSignature_Call) Return(b bool, err error) *ThresholdSignatureInspector_VerifyThresholdSignature_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *ThresholdSignatureInspector_VerifyThresholdSignature_Call) RunAndReturn(run func(thresholdSignature crypto.Signature) (bool, error)) *ThresholdSignatureInspector_VerifyThresholdSignature_Call {
	_c.Call.Return(run)
	return _c
}

// NewThresholdSignatureParticipant creates a new instance of ThresholdSignatureParticipant. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewThresholdSignatureParticipant(t interface {
	mock.TestingT
	Cleanup(func())
}) *ThresholdSignatureParticipant {
	mock := &ThresholdSignatureParticipant{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// ThresholdSignatureParticipant is an autogenerated mock type for the ThresholdSignatureParticipant type
type ThresholdSignatureParticipant struct {
	mock.Mock
}

type ThresholdSignatureParticipant_Expecter struct {
	mock *mock.Mock
}

func (_m *ThresholdSignatureParticipant) EXPECT() *ThresholdSignatureParticipant_Expecter {
	return &ThresholdSignatureParticipant_Expecter{mock: &_m.Mock}
}

// EnoughShares provides a mock function for the type ThresholdSignatureParticipant
func (_mock *ThresholdSignatureParticipant) EnoughShares() bool {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for EnoughShares")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func() bool); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// ThresholdSignatureParticipant_EnoughShares_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnoughShares'
type ThresholdSignatureParticipant_EnoughShares_Call struct {
	*mock.Call
}

// EnoughShares is a helper method to define mock.On call
func (_e *ThresholdSignatureParticipant_Expecter) EnoughShares() *ThresholdSignatureParticipant_EnoughShares_Call {
	return &ThresholdSignatureParticipant_EnoughShares_Call{Call: _e.mock.On("EnoughShares")}
}

func (_c *ThresholdSignatureParticipant_EnoughShares_Call) Run(run func()) *ThresholdSignatureParticipant_EnoughShares_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ThresholdSignatureParticipant_EnoughShares_Call) Return(b bool) *ThresholdSignatureParticipant_EnoughShares_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *ThresholdSignatureParticipant_EnoughShares_Call) RunAndReturn(run func() bool) *ThresholdSignatureParticipant_EnoughShares_Call {
	_c.Call.Return(run)
	return _c
}

// HasShare provides a mock function for the type ThresholdSignatureParticipant
func (_mock *ThresholdSignatureParticipant) HasShare(index int) (bool, error) {
	ret := _mock.Called(index)

	if len(ret) == 0 {
		panic("no return value specified for HasShare")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(int) (bool, error)); ok {
		return returnFunc(index)
	}
	if returnFunc, ok := ret.Get(0).(func(int) bool); ok {
		r0 = returnFunc(index)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(int) error); ok {
		r1 = returnFunc(index)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ThresholdSignatureParticipant_HasShare_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HasShare'
type ThresholdSignatureParticipant_HasShare_Call struct {
	*mock.Call
}

// HasShare is a helper method to define mock.On call
//   - index int
func (_e *ThresholdSignatureParticipant_Expecter) HasShare(index interface{}) *ThresholdSignatureParticipant_HasShare_Call {
	return &ThresholdSignatureParticipant_HasShare_Call{Call: _e.mock.On("HasShare", index)}
}

func (_c *ThresholdSignatureParticipant_HasShare_Call) Run(run func(index int)) *ThresholdSignatureParticipant_HasShare_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 int
		if args[0] != nil {
			arg0 = args[0].(int)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ThresholdSignatureParticipant_HasShare_Call) Return(b bool, err error) *ThresholdSignatureParticipant_HasShare_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *ThresholdSignatureParticipant_HasShare_Call) RunAndReturn(run func(index int) (bool, error)) *ThresholdSignatureParticipant_HasShare_Call {
	_c.Call.Return(run)
	return _c
}

// SignShare provides a mock function for the type ThresholdSignatureParticipant
func (_mock *ThresholdSignatureParticipant) SignShare() (crypto.Signature, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for SignShare")
	}

	var r0 crypto.Signature
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (crypto.Signature, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() crypto.Signature); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(crypto.Signature)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ThresholdSignatureParticipant_SignShare_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SignShare'
type ThresholdSignatureParticipant_SignShare_Call struct {
	*mock.Call
}

// SignShare is a helper method to define mock.On call
func (_e *ThresholdSignatureParticipant_Expecter) SignShare() *ThresholdSignatureParticipant_SignShare_Call {
	return &ThresholdSignatureParticipant_SignShare_Call{Call: _e.mock.On("SignShare")}
}

func (_c *ThresholdSignatureParticipant_SignShare_Call) Run(run func()) *ThresholdSignatureParticipant_SignShare_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ThresholdSignatureParticipant_SignShare_Call) Return(signature crypto.Signature, err error) *ThresholdSignatureParticipant_SignShare_Call {
	_c.Call.Return(signature, err)
	return _c
}

func (_c *ThresholdSignatureParticipant_SignShare_Call) RunAndReturn(run func() (crypto.Signature, error)) *ThresholdSignatureParticipant_SignShare_Call {
	_c.Call.Return(run)
	return _c
}

// ThresholdSignature provides a mock function for the type ThresholdSignatureParticipant
func (_mock *ThresholdSignatureParticipant) ThresholdSignature() (crypto.Signature, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for ThresholdSignature")
	}

	var r0 crypto.Signature
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (crypto.Signature, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() crypto.Signature); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(crypto.Signature)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ThresholdSignatureParticipant_ThresholdSignature_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ThresholdSignature'
type ThresholdSignatureParticipant_ThresholdSignature_Call struct {
	*mock.Call
}

// ThresholdSignature is a helper method to define mock.On call
func (_e *ThresholdSignatureParticipant_Expecter) ThresholdSignature() *ThresholdSignatureParticipant_ThresholdSignature_Call {
	return &ThresholdSignatureParticipant_ThresholdSignature_Call{Call: _e.mock.On("ThresholdSignature")}
}

func (_c *ThresholdSignatureParticipant_ThresholdSignature_Call) Run(run func()) *ThresholdSignatureParticipant_ThresholdSignature_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ThresholdSignatureParticipant_ThresholdSignature_Call) Return(signature crypto.Signature, err error) *ThresholdSignatureParticipant_ThresholdSignature_Call {
	_c.Call.Return(signature, err)
	return _c
}

func (_c *ThresholdSignatureParticipant_ThresholdSignature_Call) RunAndReturn(run func() (crypto.Signature, error)) *ThresholdSignatureParticipant_ThresholdSignature_Call {
	_c.Call.Return(run)
	return _c
}

// TrustedAdd provides a mock function for the type ThresholdSignatureParticipant
func (_mock *ThresholdSignatureParticipant) TrustedAdd(index int, share crypto.Signature) (bool, error) {
	ret := _mock.Called(index, share)

	if len(ret) == 0 {
		panic("no return value specified for TrustedAdd")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(int, crypto.Signature) (bool, error)); ok {
		return returnFunc(index, share)
	}
	if returnFunc, ok := ret.Get(0).(func(int, crypto.Signature) bool); ok {
		r0 = returnFunc(index, share)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(int, crypto.Signature) error); ok {
		r1 = returnFunc(index, share)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ThresholdSignatureParticipant_TrustedAdd_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TrustedAdd'
type ThresholdSignatureParticipant_TrustedAdd_Call struct {
	*mock.Call
}

// TrustedAdd is a helper method to define mock.On call
//   - index int
//   - share crypto.Signature
func (_e *ThresholdSignatureParticipant_Expecter) TrustedAdd(index interface{}, share interface{}) *ThresholdSignatureParticipant_TrustedAdd_Call {
	return &ThresholdSignatureParticipant_TrustedAdd_Call{Call: _e.mock.On("TrustedAdd", index, share)}
}

func (_c *ThresholdSignatureParticipant_TrustedAdd_Call) Run(run func(index int, share crypto.Signature)) *ThresholdSignatureParticipant_TrustedAdd_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 int
		if args[0] != nil {
			arg0 = args[0].(int)
		}
		var arg1 crypto.Signature
		if args[1] != nil {
			arg1 = args[1].(crypto.Signature)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ThresholdSignatureParticipant_TrustedAdd_Call) Return(b bool, err error) *ThresholdSignatureParticipant_TrustedAdd_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *ThresholdSignatureParticipant_TrustedAdd_Call) RunAndReturn(run func(index int, share crypto.Signature) (bool, error)) *ThresholdSignatureParticipant_TrustedAdd_Call {
	_c.Call.Return(run)
	return _c
}

// VerifyAndAdd provides a mock function for the type ThresholdSignatureParticipant
func (_mock *ThresholdSignatureParticipant) VerifyAndAdd(index int, share crypto.Signature) (bool, bool, error) {
	ret := _mock.Called(index, share)

	if len(ret) == 0 {
		panic("no return value specified for VerifyAndAdd")
	}

	var r0 bool
	var r1 bool
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(int, crypto.Signature) (bool, bool, error)); ok {
		return returnFunc(index, share)
	}
	if returnFunc, ok := ret.Get(0).(func(int, crypto.Signature) bool); ok {
		r0 = returnFunc(index, share)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(int, crypto.Signature) bool); ok {
		r1 = returnFunc(index, share)
	} else {
		r1 = ret.Get(1).(bool)
	}
	if returnFunc, ok := ret.Get(2).(func(int, crypto.Signature) error); ok {
		r2 = returnFunc(index, share)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// ThresholdSignatureParticipant_VerifyAndAdd_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'VerifyAndAdd'
type ThresholdSignatureParticipant_VerifyAndAdd_Call struct {
	*mock.Call
}

// VerifyAndAdd is a helper method to define mock.On call
//   - index int
//   - share crypto.Signature
func (_e *ThresholdSignatureParticipant_Expecter) VerifyAndAdd(index interface{}, share interface{}) *ThresholdSignatureParticipant_VerifyAndAdd_Call {
	return &ThresholdSignatureParticipant_VerifyAndAdd_Call{Call: _e.mock.On("VerifyAndAdd", index, share)}
}

func (_c *ThresholdSignatureParticipant_VerifyAndAdd_Call) Run(run func(index int, share crypto.Signature)) *ThresholdSignatureParticipant_VerifyAndAdd_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 int
		if args[0] != nil {
			arg0 = args[0].(int)
		}
		var arg1 crypto.Signature
		if args[1] != nil {
			arg1 = args[1].(crypto.Signature)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ThresholdSignatureParticipant_VerifyAndAdd_Call) Return(b bool, b1 bool, err error) *ThresholdSignatureParticipant_VerifyAndAdd_Call {
	_c.Call.Return(b, b1, err)
	return _c
}

func (_c *ThresholdSignatureParticipant_VerifyAndAdd_Call) RunAndReturn(run func(index int, share crypto.Signature) (bool, bool, error)) *ThresholdSignatureParticipant_VerifyAndAdd_Call {
	_c.Call.Return(run)
	return _c
}

// VerifyShare provides a mock function for the type ThresholdSignatureParticipant
func (_mock *ThresholdSignatureParticipant) VerifyShare(index int, share crypto.Signature) (bool, error) {
	ret := _mock.Called(index, share)

	if len(ret) == 0 {
		panic("no return value specified for VerifyShare")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(int, crypto.Signature) (bool, error)); ok {
		return returnFunc(index, share)
	}
	if returnFunc, ok := ret.Get(0).(func(int, crypto.Signature) bool); ok {
		r0 = returnFunc(index, share)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(int, crypto.Signature) error); ok {
		r1 = returnFunc(index, share)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ThresholdSignatureParticipant_VerifyShare_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'VerifyShare'
type ThresholdSignatureParticipant_VerifyShare_Call struct {
	*mock.Call
}

// VerifyShare is a helper method to define mock.On call
//   - index int
//   - share crypto.Signature
func (_e *ThresholdSignatureParticipant_Expecter) VerifyShare(index interface{}, share interface{}) *ThresholdSignatureParticipant_VerifyShare_Call {
	return &ThresholdSignatureParticipant_VerifyShare_Call{Call: _e.mock.On("VerifyShare", index, share)}
}

func (_c *ThresholdSignatureParticipant_VerifyShare_Call) Run(run func(index int, share crypto.Signature)) *ThresholdSignatureParticipant_VerifyShare_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 int
		if args[0] != nil {
			arg0 = args[0].(int)
		}
		var arg1 crypto.Signature
		if args[1] != nil {
			arg1 = args[1].(crypto.Signature)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ThresholdSignatureParticipant_VerifyShare_Call) Return(b bool, err error) *ThresholdSignatureParticipant_VerifyShare_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *ThresholdSignatureParticipant_VerifyShare_Call) RunAndReturn(run func(index int, share crypto.Signature) (bool, error)) *ThresholdSignatureParticipant_VerifyShare_Call {
	_c.Call.Return(run)
	return _c
}

// VerifyThresholdSignature provides a mock function for the type ThresholdSignatureParticipant
func (_mock *ThresholdSignatureParticipant) VerifyThresholdSignature(thresholdSignature crypto.Signature) (bool, error) {
	ret := _mock.Called(thresholdSignature)

	if len(ret) == 0 {
		panic("no return value specified for VerifyThresholdSignature")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(crypto.Signature) (bool, error)); ok {
		return returnFunc(thresholdSignature)
	}
	if returnFunc, ok := ret.Get(0).(func(crypto.Signature) bool); ok {
		r0 = returnFunc(thresholdSignature)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(crypto.Signature) error); ok {
		r1 = returnFunc(thresholdSignature)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ThresholdSignatureParticipant_VerifyThresholdSignature_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'VerifyThresholdSignature'
type ThresholdSignatureParticipant_VerifyThresholdSignature_Call struct {
	*mock.Call
}

// VerifyThresholdSignature is a helper method to define mock.On call
//   - thresholdSignature crypto.Signature
func (_e *ThresholdSignatureParticipant_Expecter) VerifyThresholdSignature(thresholdSignature interface{}) *ThresholdSignatureParticipant_VerifyThresholdSignature_Call {
	return &ThresholdSignatureParticipant_VerifyThresholdSignature_Call{Call: _e.mock.On("VerifyThresholdSignature", thresholdSignature)}
}

func (_c *ThresholdSignatureParticipant_VerifyThresholdSignature_Call) Run(run func(thresholdSignature crypto.Signature)) *ThresholdSignatureParticipant_VerifyThresholdSignature_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 crypto.Signature
		if args[0] != nil {
			arg0 = args[0].(crypto.Signature)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ThresholdSignatureParticipant_VerifyThresholdSignature_Call) Return(b bool, err error) *ThresholdSignatureParticipant_VerifyThresholdSignature_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *ThresholdSignatureParticipant_VerifyThresholdSignature_Call) RunAndReturn(run func(thresholdSignature crypto.Signature) (bool, error)) *ThresholdSignatureParticipant_VerifyThresholdSignature_Call {
	_c.Call.Return(run)
	return _c
}
