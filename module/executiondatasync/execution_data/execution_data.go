package execution_data

import (
	"github.com/onflow/flow-go/ledger"
	"github.com/onflow/flow-go/model/flow"
)

// DefaultMaxBlobSize is the default maximum size of a blob.
// This is calibrated to fit within a libp2p message and not exceed the max size recommended by bitswap.
const DefaultMaxBlobSize = 1 << 20 // 1MiB

// ChunkExecutionData represents the execution data of a chunk
type ChunkExecutionData struct {
	// Collection is the collection for which this chunk was executed
	Collection *flow.Collection

	// Events are the events generated by executing the collection
	Events flow.EventsList

	// TrieUpdate is the trie update generated by executing the collection
	// This includes a list of all registers updated during the execution
	TrieUpdate *ledger.TrieUpdate

	// TransactionResults are the results of executing the transactions in the collection
	// This includes all of the data from flow.TransactionResult, except uses a boolean
	// value to indicate if an error occurred instead of a full error message.
	TransactionResults []TransactionResult
}

// BlockExecutionData represents the execution data of a block.
type BlockExecutionData struct {
	BlockID             flow.Identifier
	ChunkExecutionDatas []*ChunkExecutionData
}

// TransactionResult represents a flow.TransactionResult that's encoded within a ChunkExecutionData.
//
// The primary difference is this version includes a boolean value indicated if the transaction's
// execution resulted in an error, instead of the full error message. Error messages are prone to
// non-determinism due to (undiscovered) bugs in the execution and verification code. Rather than
// including the error and risking execution forks if an undetected bug is introduced, we simplify
// it to just a boolean value.
type TransactionResult struct {
	// TransactionID is the ID of the transaction this result was emitted from.
	TransactionID flow.Identifier
	// HasError is true if the transaction's execution resulted in an error, false otherwise.
	HasError bool
	// ComputationUsed is amount of computation used while executing the transaction.
	ComputationUsed uint64
}

// ConvertTransactionResults converts a list of flow.TransactionResults into a list of
// execution_data.TransactionResults to be included in a ChunkExecutionData.
func ConvertTransactionResults(results flow.TransactionResults) []TransactionResult {
	if len(results) == 0 {
		return nil
	}

	converted := make([]TransactionResult, len(results))
	for i, txResult := range results {
		converted[i] = TransactionResult{
			TransactionID:   txResult.TransactionID,
			ComputationUsed: txResult.ComputationUsed,
			HasError:        txResult.ErrorMessage != "",
		}
	}
	return converted
}
