// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mock

import (
	"net"
	"time"

	"github.com/onflow/flow-go/model/chunks"
	"github.com/onflow/flow-go/model/flow"
	"github.com/onflow/flow-go/model/verification"
	"github.com/onflow/flow-go/module/executiondatasync/execution_data"
	"github.com/onflow/flow-go/module/mempool"
	mock "github.com/stretchr/testify/mock"
)

// NewAssignments creates a new instance of Assignments. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewAssignments(t interface {
	mock.TestingT
	Cleanup(func())
}) *Assignments {
	mock := &Assignments{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Assignments is an autogenerated mock type for the Assignments type
type Assignments struct {
	mock.Mock
}

type Assignments_Expecter struct {
	mock *mock.Mock
}

func (_m *Assignments) EXPECT() *Assignments_Expecter {
	return &Assignments_Expecter{mock: &_m.Mock}
}

// Add provides a mock function for the type Assignments
func (_mock *Assignments) Add(identifier flow.Identifier, assignment *chunks.Assignment) bool {
	ret := _mock.Called(identifier, assignment)

	if len(ret) == 0 {
		panic("no return value specified for Add")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, *chunks.Assignment) bool); ok {
		r0 = returnFunc(identifier, assignment)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// Assignments_Add_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Add'
type Assignments_Add_Call struct {
	*mock.Call
}

// Add is a helper method to define mock.On call
//   - identifier flow.Identifier
//   - assignment *chunks.Assignment
func (_e *Assignments_Expecter) Add(identifier interface{}, assignment interface{}) *Assignments_Add_Call {
	return &Assignments_Add_Call{Call: _e.mock.On("Add", identifier, assignment)}
}

func (_c *Assignments_Add_Call) Run(run func(identifier flow.Identifier, assignment *chunks.Assignment)) *Assignments_Add_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		var arg1 *chunks.Assignment
		if args[1] != nil {
			arg1 = args[1].(*chunks.Assignment)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Assignments_Add_Call) Return(b bool) *Assignments_Add_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *Assignments_Add_Call) RunAndReturn(run func(identifier flow.Identifier, assignment *chunks.Assignment) bool) *Assignments_Add_Call {
	_c.Call.Return(run)
	return _c
}

// Adjust provides a mock function for the type Assignments
func (_mock *Assignments) Adjust(key flow.Identifier, f func(*chunks.Assignment) *chunks.Assignment) (*chunks.Assignment, bool) {
	ret := _mock.Called(key, f)

	if len(ret) == 0 {
		panic("no return value specified for Adjust")
	}

	var r0 *chunks.Assignment
	var r1 bool
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, func(*chunks.Assignment) *chunks.Assignment) (*chunks.Assignment, bool)); ok {
		return returnFunc(key, f)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, func(*chunks.Assignment) *chunks.Assignment) *chunks.Assignment); ok {
		r0 = returnFunc(key, f)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*chunks.Assignment)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier, func(*chunks.Assignment) *chunks.Assignment) bool); ok {
		r1 = returnFunc(key, f)
	} else {
		r1 = ret.Get(1).(bool)
	}
	return r0, r1
}

// Assignments_Adjust_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Adjust'
type Assignments_Adjust_Call struct {
	*mock.Call
}

// Adjust is a helper method to define mock.On call
//   - key flow.Identifier
//   - f func(*chunks.Assignment) *chunks.Assignment
func (_e *Assignments_Expecter) Adjust(key interface{}, f interface{}) *Assignments_Adjust_Call {
	return &Assignments_Adjust_Call{Call: _e.mock.On("Adjust", key, f)}
}

func (_c *Assignments_Adjust_Call) Run(run func(key flow.Identifier, f func(*chunks.Assignment) *chunks.Assignment)) *Assignments_Adjust_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		var arg1 func(*chunks.Assignment) *chunks.Assignment
		if args[1] != nil {
			arg1 = args[1].(func(*chunks.Assignment) *chunks.Assignment)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Assignments_Adjust_Call) Return(assignment *chunks.Assignment, b bool) *Assignments_Adjust_Call {
	_c.Call.Return(assignment, b)
	return _c
}

func (_c *Assignments_Adjust_Call) RunAndReturn(run func(key flow.Identifier, f func(*chunks.Assignment) *chunks.Assignment) (*chunks.Assignment, bool)) *Assignments_Adjust_Call {
	_c.Call.Return(run)
	return _c
}

// All provides a mock function for the type Assignments
func (_mock *Assignments) All() map[flow.Identifier]*chunks.Assignment {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for All")
	}

	var r0 map[flow.Identifier]*chunks.Assignment
	if returnFunc, ok := ret.Get(0).(func() map[flow.Identifier]*chunks.Assignment); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[flow.Identifier]*chunks.Assignment)
		}
	}
	return r0
}

// Assignments_All_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'All'
type Assignments_All_Call struct {
	*mock.Call
}

// All is a helper method to define mock.On call
func (_e *Assignments_Expecter) All() *Assignments_All_Call {
	return &Assignments_All_Call{Call: _e.mock.On("All")}
}

func (_c *Assignments_All_Call) Run(run func()) *Assignments_All_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Assignments_All_Call) Return(identifierToAssignment map[flow.Identifier]*chunks.Assignment) *Assignments_All_Call {
	_c.Call.Return(identifierToAssignment)
	return _c
}

func (_c *Assignments_All_Call) RunAndReturn(run func() map[flow.Identifier]*chunks.Assignment) *Assignments_All_Call {
	_c.Call.Return(run)
	return _c
}

// Clear provides a mock function for the type Assignments
func (_mock *Assignments) Clear() {
	_mock.Called()
	return
}

// Assignments_Clear_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Clear'
type Assignments_Clear_Call struct {
	*mock.Call
}

// Clear is a helper method to define mock.On call
func (_e *Assignments_Expecter) Clear() *Assignments_Clear_Call {
	return &Assignments_Clear_Call{Call: _e.mock.On("Clear")}
}

func (_c *Assignments_Clear_Call) Run(run func()) *Assignments_Clear_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Assignments_Clear_Call) Return() *Assignments_Clear_Call {
	_c.Call.Return()
	return _c
}

func (_c *Assignments_Clear_Call) RunAndReturn(run func()) *Assignments_Clear_Call {
	_c.Run(run)
	return _c
}

// Get provides a mock function for the type Assignments
func (_mock *Assignments) Get(identifier flow.Identifier) (*chunks.Assignment, bool) {
	ret := _mock.Called(identifier)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *chunks.Assignment
	var r1 bool
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (*chunks.Assignment, bool)); ok {
		return returnFunc(identifier)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) *chunks.Assignment); ok {
		r0 = returnFunc(identifier)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*chunks.Assignment)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) bool); ok {
		r1 = returnFunc(identifier)
	} else {
		r1 = ret.Get(1).(bool)
	}
	return r0, r1
}

// Assignments_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type Assignments_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - identifier flow.Identifier
func (_e *Assignments_Expecter) Get(identifier interface{}) *Assignments_Get_Call {
	return &Assignments_Get_Call{Call: _e.mock.On("Get", identifier)}
}

func (_c *Assignments_Get_Call) Run(run func(identifier flow.Identifier)) *Assignments_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Assignments_Get_Call) Return(assignment *chunks.Assignment, b bool) *Assignments_Get_Call {
	_c.Call.Return(assignment, b)
	return _c
}

func (_c *Assignments_Get_Call) RunAndReturn(run func(identifier flow.Identifier) (*chunks.Assignment, bool)) *Assignments_Get_Call {
	_c.Call.Return(run)
	return _c
}

// Has provides a mock function for the type Assignments
func (_mock *Assignments) Has(identifier flow.Identifier) bool {
	ret := _mock.Called(identifier)

	if len(ret) == 0 {
		panic("no return value specified for Has")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) bool); ok {
		r0 = returnFunc(identifier)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// Assignments_Has_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Has'
type Assignments_Has_Call struct {
	*mock.Call
}

// Has is a helper method to define mock.On call
//   - identifier flow.Identifier
func (_e *Assignments_Expecter) Has(identifier interface{}) *Assignments_Has_Call {
	return &Assignments_Has_Call{Call: _e.mock.On("Has", identifier)}
}

func (_c *Assignments_Has_Call) Run(run func(identifier flow.Identifier)) *Assignments_Has_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Assignments_Has_Call) Return(b bool) *Assignments_Has_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *Assignments_Has_Call) RunAndReturn(run func(identifier flow.Identifier) bool) *Assignments_Has_Call {
	_c.Call.Return(run)
	return _c
}

// Remove provides a mock function for the type Assignments
func (_mock *Assignments) Remove(identifier flow.Identifier) bool {
	ret := _mock.Called(identifier)

	if len(ret) == 0 {
		panic("no return value specified for Remove")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) bool); ok {
		r0 = returnFunc(identifier)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// Assignments_Remove_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Remove'
type Assignments_Remove_Call struct {
	*mock.Call
}

// Remove is a helper method to define mock.On call
//   - identifier flow.Identifier
func (_e *Assignments_Expecter) Remove(identifier interface{}) *Assignments_Remove_Call {
	return &Assignments_Remove_Call{Call: _e.mock.On("Remove", identifier)}
}

func (_c *Assignments_Remove_Call) Run(run func(identifier flow.Identifier)) *Assignments_Remove_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Assignments_Remove_Call) Return(b bool) *Assignments_Remove_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *Assignments_Remove_Call) RunAndReturn(run func(identifier flow.Identifier) bool) *Assignments_Remove_Call {
	_c.Call.Return(run)
	return _c
}

// Size provides a mock function for the type Assignments
func (_mock *Assignments) Size() uint {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Size")
	}

	var r0 uint
	if returnFunc, ok := ret.Get(0).(func() uint); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint)
	}
	return r0
}

// Assignments_Size_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Size'
type Assignments_Size_Call struct {
	*mock.Call
}

// Size is a helper method to define mock.On call
func (_e *Assignments_Expecter) Size() *Assignments_Size_Call {
	return &Assignments_Size_Call{Call: _e.mock.On("Size")}
}

func (_c *Assignments_Size_Call) Run(run func()) *Assignments_Size_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Assignments_Size_Call) Return(v uint) *Assignments_Size_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *Assignments_Size_Call) RunAndReturn(run func() uint) *Assignments_Size_Call {
	_c.Call.Return(run)
	return _c
}

// Values provides a mock function for the type Assignments
func (_mock *Assignments) Values() []*chunks.Assignment {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Values")
	}

	var r0 []*chunks.Assignment
	if returnFunc, ok := ret.Get(0).(func() []*chunks.Assignment); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*chunks.Assignment)
		}
	}
	return r0
}

// Assignments_Values_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Values'
type Assignments_Values_Call struct {
	*mock.Call
}

// Values is a helper method to define mock.On call
func (_e *Assignments_Expecter) Values() *Assignments_Values_Call {
	return &Assignments_Values_Call{Call: _e.mock.On("Values")}
}

func (_c *Assignments_Values_Call) Run(run func()) *Assignments_Values_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Assignments_Values_Call) Return(assignments []*chunks.Assignment) *Assignments_Values_Call {
	_c.Call.Return(assignments)
	return _c
}

func (_c *Assignments_Values_Call) RunAndReturn(run func() []*chunks.Assignment) *Assignments_Values_Call {
	_c.Call.Return(run)
	return _c
}

// NewBackData creates a new instance of BackData. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewBackData[K comparable, V any](t interface {
	mock.TestingT
	Cleanup(func())
}) *BackData[K, V] {
	mock := &BackData[K, V]{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// BackData is an autogenerated mock type for the BackData type
type BackData[K comparable, V any] struct {
	mock.Mock
}

type BackData_Expecter[K comparable, V any] struct {
	mock *mock.Mock
}

func (_m *BackData[K, V]) EXPECT() *BackData_Expecter[K, V] {
	return &BackData_Expecter[K, V]{mock: &_m.Mock}
}

// Add provides a mock function for the type BackData
func (_mock *BackData[K, V]) Add(key K, value V) bool {
	ret := _mock.Called(key, value)

	if len(ret) == 0 {
		panic("no return value specified for Add")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(K, V) bool); ok {
		r0 = returnFunc(key, value)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// BackData_Add_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Add'
type BackData_Add_Call[K comparable, V any] struct {
	*mock.Call
}

// Add is a helper method to define mock.On call
//   - key K
//   - value V
func (_e *BackData_Expecter[K, V]) Add(key interface{}, value interface{}) *BackData_Add_Call[K, V] {
	return &BackData_Add_Call[K, V]{Call: _e.mock.On("Add", key, value)}
}

func (_c *BackData_Add_Call[K, V]) Run(run func(key K, value V)) *BackData_Add_Call[K, V] {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 K
		if args[0] != nil {
			arg0 = args[0].(K)
		}
		var arg1 V
		if args[1] != nil {
			arg1 = args[1].(V)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *BackData_Add_Call[K, V]) Return(b bool) *BackData_Add_Call[K, V] {
	_c.Call.Return(b)
	return _c
}

func (_c *BackData_Add_Call[K, V]) RunAndReturn(run func(key K, value V) bool) *BackData_Add_Call[K, V] {
	_c.Call.Return(run)
	return _c
}

// All provides a mock function for the type BackData
func (_mock *BackData[K, V]) All() map[K]V {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for All")
	}

	var r0 map[K]V
	if returnFunc, ok := ret.Get(0).(func() map[K]V); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[K]V)
		}
	}
	return r0
}

// BackData_All_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'All'
type BackData_All_Call[K comparable, V any] struct {
	*mock.Call
}

// All is a helper method to define mock.On call
func (_e *BackData_Expecter[K, V]) All() *BackData_All_Call[K, V] {
	return &BackData_All_Call[K, V]{Call: _e.mock.On("All")}
}

func (_c *BackData_All_Call[K, V]) Run(run func()) *BackData_All_Call[K, V] {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *BackData_All_Call[K, V]) Return(vToV map[K]V) *BackData_All_Call[K, V] {
	_c.Call.Return(vToV)
	return _c
}

func (_c *BackData_All_Call[K, V]) RunAndReturn(run func() map[K]V) *BackData_All_Call[K, V] {
	_c.Call.Return(run)
	return _c
}

// Clear provides a mock function for the type BackData
func (_mock *BackData[K, V]) Clear() {
	_mock.Called()
	return
}

// BackData_Clear_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Clear'
type BackData_Clear_Call[K comparable, V any] struct {
	*mock.Call
}

// Clear is a helper method to define mock.On call
func (_e *BackData_Expecter[K, V]) Clear() *BackData_Clear_Call[K, V] {
	return &BackData_Clear_Call[K, V]{Call: _e.mock.On("Clear")}
}

func (_c *BackData_Clear_Call[K, V]) Run(run func()) *BackData_Clear_Call[K, V] {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *BackData_Clear_Call[K, V]) Return() *BackData_Clear_Call[K, V] {
	_c.Call.Return()
	return _c
}

func (_c *BackData_Clear_Call[K, V]) RunAndReturn(run func()) *BackData_Clear_Call[K, V] {
	_c.Run(run)
	return _c
}

// Get provides a mock function for the type BackData
func (_mock *BackData[K, V]) Get(key K) (V, bool) {
	ret := _mock.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 V
	var r1 bool
	if returnFunc, ok := ret.Get(0).(func(K) (V, bool)); ok {
		return returnFunc(key)
	}
	if returnFunc, ok := ret.Get(0).(func(K) V); ok {
		r0 = returnFunc(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(V)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(K) bool); ok {
		r1 = returnFunc(key)
	} else {
		r1 = ret.Get(1).(bool)
	}
	return r0, r1
}

// BackData_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type BackData_Get_Call[K comparable, V any] struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - key K
func (_e *BackData_Expecter[K, V]) Get(key interface{}) *BackData_Get_Call[K, V] {
	return &BackData_Get_Call[K, V]{Call: _e.mock.On("Get", key)}
}

func (_c *BackData_Get_Call[K, V]) Run(run func(key K)) *BackData_Get_Call[K, V] {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 K
		if args[0] != nil {
			arg0 = args[0].(K)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *BackData_Get_Call[K, V]) Return(v V, b bool) *BackData_Get_Call[K, V] {
	_c.Call.Return(v, b)
	return _c
}

func (_c *BackData_Get_Call[K, V]) RunAndReturn(run func(key K) (V, bool)) *BackData_Get_Call[K, V] {
	_c.Call.Return(run)
	return _c
}

// Has provides a mock function for the type BackData
func (_mock *BackData[K, V]) Has(key K) bool {
	ret := _mock.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for Has")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(K) bool); ok {
		r0 = returnFunc(key)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// BackData_Has_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Has'
type BackData_Has_Call[K comparable, V any] struct {
	*mock.Call
}

// Has is a helper method to define mock.On call
//   - key K
func (_e *BackData_Expecter[K, V]) Has(key interface{}) *BackData_Has_Call[K, V] {
	return &BackData_Has_Call[K, V]{Call: _e.mock.On("Has", key)}
}

func (_c *BackData_Has_Call[K, V]) Run(run func(key K)) *BackData_Has_Call[K, V] {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 K
		if args[0] != nil {
			arg0 = args[0].(K)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *BackData_Has_Call[K, V]) Return(b bool) *BackData_Has_Call[K, V] {
	_c.Call.Return(b)
	return _c
}

func (_c *BackData_Has_Call[K, V]) RunAndReturn(run func(key K) bool) *BackData_Has_Call[K, V] {
	_c.Call.Return(run)
	return _c
}

// Keys provides a mock function for the type BackData
func (_mock *BackData[K, V]) Keys() []K {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Keys")
	}

	var r0 []K
	if returnFunc, ok := ret.Get(0).(func() []K); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]K)
		}
	}
	return r0
}

// BackData_Keys_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Keys'
type BackData_Keys_Call[K comparable, V any] struct {
	*mock.Call
}

// Keys is a helper method to define mock.On call
func (_e *BackData_Expecter[K, V]) Keys() *BackData_Keys_Call[K, V] {
	return &BackData_Keys_Call[K, V]{Call: _e.mock.On("Keys")}
}

func (_c *BackData_Keys_Call[K, V]) Run(run func()) *BackData_Keys_Call[K, V] {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *BackData_Keys_Call[K, V]) Return(vs []K) *BackData_Keys_Call[K, V] {
	_c.Call.Return(vs)
	return _c
}

func (_c *BackData_Keys_Call[K, V]) RunAndReturn(run func() []K) *BackData_Keys_Call[K, V] {
	_c.Call.Return(run)
	return _c
}

// Remove provides a mock function for the type BackData
func (_mock *BackData[K, V]) Remove(key K) (V, bool) {
	ret := _mock.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for Remove")
	}

	var r0 V
	var r1 bool
	if returnFunc, ok := ret.Get(0).(func(K) (V, bool)); ok {
		return returnFunc(key)
	}
	if returnFunc, ok := ret.Get(0).(func(K) V); ok {
		r0 = returnFunc(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(V)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(K) bool); ok {
		r1 = returnFunc(key)
	} else {
		r1 = ret.Get(1).(bool)
	}
	return r0, r1
}

// BackData_Remove_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Remove'
type BackData_Remove_Call[K comparable, V any] struct {
	*mock.Call
}

// Remove is a helper method to define mock.On call
//   - key K
func (_e *BackData_Expecter[K, V]) Remove(key interface{}) *BackData_Remove_Call[K, V] {
	return &BackData_Remove_Call[K, V]{Call: _e.mock.On("Remove", key)}
}

func (_c *BackData_Remove_Call[K, V]) Run(run func(key K)) *BackData_Remove_Call[K, V] {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 K
		if args[0] != nil {
			arg0 = args[0].(K)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *BackData_Remove_Call[K, V]) Return(v V, b bool) *BackData_Remove_Call[K, V] {
	_c.Call.Return(v, b)
	return _c
}

func (_c *BackData_Remove_Call[K, V]) RunAndReturn(run func(key K) (V, bool)) *BackData_Remove_Call[K, V] {
	_c.Call.Return(run)
	return _c
}

// Size provides a mock function for the type BackData
func (_mock *BackData[K, V]) Size() uint {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Size")
	}

	var r0 uint
	if returnFunc, ok := ret.Get(0).(func() uint); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint)
	}
	return r0
}

// BackData_Size_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Size'
type BackData_Size_Call[K comparable, V any] struct {
	*mock.Call
}

// Size is a helper method to define mock.On call
func (_e *BackData_Expecter[K, V]) Size() *BackData_Size_Call[K, V] {
	return &BackData_Size_Call[K, V]{Call: _e.mock.On("Size")}
}

func (_c *BackData_Size_Call[K, V]) Run(run func()) *BackData_Size_Call[K, V] {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *BackData_Size_Call[K, V]) Return(v uint) *BackData_Size_Call[K, V] {
	_c.Call.Return(v)
	return _c
}

func (_c *BackData_Size_Call[K, V]) RunAndReturn(run func() uint) *BackData_Size_Call[K, V] {
	_c.Call.Return(run)
	return _c
}

// Values provides a mock function for the type BackData
func (_mock *BackData[K, V]) Values() []V {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Values")
	}

	var r0 []V
	if returnFunc, ok := ret.Get(0).(func() []V); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]V)
		}
	}
	return r0
}

// BackData_Values_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Values'
type BackData_Values_Call[K comparable, V any] struct {
	*mock.Call
}

// Values is a helper method to define mock.On call
func (_e *BackData_Expecter[K, V]) Values() *BackData_Values_Call[K, V] {
	return &BackData_Values_Call[K, V]{Call: _e.mock.On("Values")}
}

func (_c *BackData_Values_Call[K, V]) Run(run func()) *BackData_Values_Call[K, V] {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *BackData_Values_Call[K, V]) Return(vs []V) *BackData_Values_Call[K, V] {
	_c.Call.Return(vs)
	return _c
}

func (_c *BackData_Values_Call[K, V]) RunAndReturn(run func() []V) *BackData_Values_Call[K, V] {
	_c.Call.Return(run)
	return _c
}

// NewChunkRequests creates a new instance of ChunkRequests. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewChunkRequests(t interface {
	mock.TestingT
	Cleanup(func())
}) *ChunkRequests {
	mock := &ChunkRequests{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// ChunkRequests is an autogenerated mock type for the ChunkRequests type
type ChunkRequests struct {
	mock.Mock
}

type ChunkRequests_Expecter struct {
	mock *mock.Mock
}

func (_m *ChunkRequests) EXPECT() *ChunkRequests_Expecter {
	return &ChunkRequests_Expecter{mock: &_m.Mock}
}

// Add provides a mock function for the type ChunkRequests
func (_mock *ChunkRequests) Add(request *verification.ChunkDataPackRequest) bool {
	ret := _mock.Called(request)

	if len(ret) == 0 {
		panic("no return value specified for Add")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(*verification.ChunkDataPackRequest) bool); ok {
		r0 = returnFunc(request)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// ChunkRequests_Add_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Add'
type ChunkRequests_Add_Call struct {
	*mock.Call
}

// Add is a helper method to define mock.On call
//   - request *verification.ChunkDataPackRequest
func (_e *ChunkRequests_Expecter) Add(request interface{}) *ChunkRequests_Add_Call {
	return &ChunkRequests_Add_Call{Call: _e.mock.On("Add", request)}
}

func (_c *ChunkRequests_Add_Call) Run(run func(request *verification.ChunkDataPackRequest)) *ChunkRequests_Add_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *verification.ChunkDataPackRequest
		if args[0] != nil {
			arg0 = args[0].(*verification.ChunkDataPackRequest)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ChunkRequests_Add_Call) Return(b bool) *ChunkRequests_Add_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *ChunkRequests_Add_Call) RunAndReturn(run func(request *verification.ChunkDataPackRequest) bool) *ChunkRequests_Add_Call {
	_c.Call.Return(run)
	return _c
}

// All provides a mock function for the type ChunkRequests
func (_mock *ChunkRequests) All() verification.ChunkDataPackRequestInfoList {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for All")
	}

	var r0 verification.ChunkDataPackRequestInfoList
	if returnFunc, ok := ret.Get(0).(func() verification.ChunkDataPackRequestInfoList); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(verification.ChunkDataPackRequestInfoList)
		}
	}
	return r0
}

// ChunkRequests_All_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'All'
type ChunkRequests_All_Call struct {
	*mock.Call
}

// All is a helper method to define mock.On call
func (_e *ChunkRequests_Expecter) All() *ChunkRequests_All_Call {
	return &ChunkRequests_All_Call{Call: _e.mock.On("All")}
}

func (_c *ChunkRequests_All_Call) Run(run func()) *ChunkRequests_All_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ChunkRequests_All_Call) Return(chunkDataPackRequestInfoList verification.ChunkDataPackRequestInfoList) *ChunkRequests_All_Call {
	_c.Call.Return(chunkDataPackRequestInfoList)
	return _c
}

func (_c *ChunkRequests_All_Call) RunAndReturn(run func() verification.ChunkDataPackRequestInfoList) *ChunkRequests_All_Call {
	_c.Call.Return(run)
	return _c
}

// IncrementAttempt provides a mock function for the type ChunkRequests
func (_mock *ChunkRequests) IncrementAttempt(chunkID flow.Identifier) bool {
	ret := _mock.Called(chunkID)

	if len(ret) == 0 {
		panic("no return value specified for IncrementAttempt")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) bool); ok {
		r0 = returnFunc(chunkID)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// ChunkRequests_IncrementAttempt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IncrementAttempt'
type ChunkRequests_IncrementAttempt_Call struct {
	*mock.Call
}

// IncrementAttempt is a helper method to define mock.On call
//   - chunkID flow.Identifier
func (_e *ChunkRequests_Expecter) IncrementAttempt(chunkID interface{}) *ChunkRequests_IncrementAttempt_Call {
	return &ChunkRequests_IncrementAttempt_Call{Call: _e.mock.On("IncrementAttempt", chunkID)}
}

func (_c *ChunkRequests_IncrementAttempt_Call) Run(run func(chunkID flow.Identifier)) *ChunkRequests_IncrementAttempt_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ChunkRequests_IncrementAttempt_Call) Return(b bool) *ChunkRequests_IncrementAttempt_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *ChunkRequests_IncrementAttempt_Call) RunAndReturn(run func(chunkID flow.Identifier) bool) *ChunkRequests_IncrementAttempt_Call {
	_c.Call.Return(run)
	return _c
}

// PopAll provides a mock function for the type ChunkRequests
func (_mock *ChunkRequests) PopAll(chunkID flow.Identifier) (chunks.LocatorMap, bool) {
	ret := _mock.Called(chunkID)

	if len(ret) == 0 {
		panic("no return value specified for PopAll")
	}

	var r0 chunks.LocatorMap
	var r1 bool
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (chunks.LocatorMap, bool)); ok {
		return returnFunc(chunkID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) chunks.LocatorMap); ok {
		r0 = returnFunc(chunkID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(chunks.LocatorMap)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) bool); ok {
		r1 = returnFunc(chunkID)
	} else {
		r1 = ret.Get(1).(bool)
	}
	return r0, r1
}

// ChunkRequests_PopAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PopAll'
type ChunkRequests_PopAll_Call struct {
	*mock.Call
}

// PopAll is a helper method to define mock.On call
//   - chunkID flow.Identifier
func (_e *ChunkRequests_Expecter) PopAll(chunkID interface{}) *ChunkRequests_PopAll_Call {
	return &ChunkRequests_PopAll_Call{Call: _e.mock.On("PopAll", chunkID)}
}

func (_c *ChunkRequests_PopAll_Call) Run(run func(chunkID flow.Identifier)) *ChunkRequests_PopAll_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ChunkRequests_PopAll_Call) Return(locatorMap chunks.LocatorMap, b bool) *ChunkRequests_PopAll_Call {
	_c.Call.Return(locatorMap, b)
	return _c
}

func (_c *ChunkRequests_PopAll_Call) RunAndReturn(run func(chunkID flow.Identifier) (chunks.LocatorMap, bool)) *ChunkRequests_PopAll_Call {
	_c.Call.Return(run)
	return _c
}

// Remove provides a mock function for the type ChunkRequests
func (_mock *ChunkRequests) Remove(chunkID flow.Identifier) bool {
	ret := _mock.Called(chunkID)

	if len(ret) == 0 {
		panic("no return value specified for Remove")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) bool); ok {
		r0 = returnFunc(chunkID)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// ChunkRequests_Remove_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Remove'
type ChunkRequests_Remove_Call struct {
	*mock.Call
}

// Remove is a helper method to define mock.On call
//   - chunkID flow.Identifier
func (_e *ChunkRequests_Expecter) Remove(chunkID interface{}) *ChunkRequests_Remove_Call {
	return &ChunkRequests_Remove_Call{Call: _e.mock.On("Remove", chunkID)}
}

func (_c *ChunkRequests_Remove_Call) Run(run func(chunkID flow.Identifier)) *ChunkRequests_Remove_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ChunkRequests_Remove_Call) Return(b bool) *ChunkRequests_Remove_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *ChunkRequests_Remove_Call) RunAndReturn(run func(chunkID flow.Identifier) bool) *ChunkRequests_Remove_Call {
	_c.Call.Return(run)
	return _c
}

// RequestHistory provides a mock function for the type ChunkRequests
func (_mock *ChunkRequests) RequestHistory(chunkID flow.Identifier) (uint64, time.Time, time.Duration, bool) {
	ret := _mock.Called(chunkID)

	if len(ret) == 0 {
		panic("no return value specified for RequestHistory")
	}

	var r0 uint64
	var r1 time.Time
	var r2 time.Duration
	var r3 bool
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (uint64, time.Time, time.Duration, bool)); ok {
		return returnFunc(chunkID)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) uint64); ok {
		r0 = returnFunc(chunkID)
	} else {
		r0 = ret.Get(0).(uint64)
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) time.Time); ok {
		r1 = returnFunc(chunkID)
	} else {
		r1 = ret.Get(1).(time.Time)
	}
	if returnFunc, ok := ret.Get(2).(func(flow.Identifier) time.Duration); ok {
		r2 = returnFunc(chunkID)
	} else {
		r2 = ret.Get(2).(time.Duration)
	}
	if returnFunc, ok := ret.Get(3).(func(flow.Identifier) bool); ok {
		r3 = returnFunc(chunkID)
	} else {
		r3 = ret.Get(3).(bool)
	}
	return r0, r1, r2, r3
}

// ChunkRequests_RequestHistory_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RequestHistory'
type ChunkRequests_RequestHistory_Call struct {
	*mock.Call
}

// RequestHistory is a helper method to define mock.On call
//   - chunkID flow.Identifier
func (_e *ChunkRequests_Expecter) RequestHistory(chunkID interface{}) *ChunkRequests_RequestHistory_Call {
	return &ChunkRequests_RequestHistory_Call{Call: _e.mock.On("RequestHistory", chunkID)}
}

func (_c *ChunkRequests_RequestHistory_Call) Run(run func(chunkID flow.Identifier)) *ChunkRequests_RequestHistory_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ChunkRequests_RequestHistory_Call) Return(v uint64, time1 time.Time, duration time.Duration, b bool) *ChunkRequests_RequestHistory_Call {
	_c.Call.Return(v, time1, duration, b)
	return _c
}

func (_c *ChunkRequests_RequestHistory_Call) RunAndReturn(run func(chunkID flow.Identifier) (uint64, time.Time, time.Duration, bool)) *ChunkRequests_RequestHistory_Call {
	_c.Call.Return(run)
	return _c
}

// Size provides a mock function for the type ChunkRequests
func (_mock *ChunkRequests) Size() uint {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Size")
	}

	var r0 uint
	if returnFunc, ok := ret.Get(0).(func() uint); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint)
	}
	return r0
}

// ChunkRequests_Size_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Size'
type ChunkRequests_Size_Call struct {
	*mock.Call
}

// Size is a helper method to define mock.On call
func (_e *ChunkRequests_Expecter) Size() *ChunkRequests_Size_Call {
	return &ChunkRequests_Size_Call{Call: _e.mock.On("Size")}
}

func (_c *ChunkRequests_Size_Call) Run(run func()) *ChunkRequests_Size_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ChunkRequests_Size_Call) Return(v uint) *ChunkRequests_Size_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *ChunkRequests_Size_Call) RunAndReturn(run func() uint) *ChunkRequests_Size_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateRequestHistory provides a mock function for the type ChunkRequests
func (_mock *ChunkRequests) UpdateRequestHistory(chunkID flow.Identifier, updater mempool.ChunkRequestHistoryUpdaterFunc) (uint64, time.Time, time.Duration, bool) {
	ret := _mock.Called(chunkID, updater)

	if len(ret) == 0 {
		panic("no return value specified for UpdateRequestHistory")
	}

	var r0 uint64
	var r1 time.Time
	var r2 time.Duration
	var r3 bool
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, mempool.ChunkRequestHistoryUpdaterFunc) (uint64, time.Time, time.Duration, bool)); ok {
		return returnFunc(chunkID, updater)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, mempool.ChunkRequestHistoryUpdaterFunc) uint64); ok {
		r0 = returnFunc(chunkID, updater)
	} else {
		r0 = ret.Get(0).(uint64)
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier, mempool.ChunkRequestHistoryUpdaterFunc) time.Time); ok {
		r1 = returnFunc(chunkID, updater)
	} else {
		r1 = ret.Get(1).(time.Time)
	}
	if returnFunc, ok := ret.Get(2).(func(flow.Identifier, mempool.ChunkRequestHistoryUpdaterFunc) time.Duration); ok {
		r2 = returnFunc(chunkID, updater)
	} else {
		r2 = ret.Get(2).(time.Duration)
	}
	if returnFunc, ok := ret.Get(3).(func(flow.Identifier, mempool.ChunkRequestHistoryUpdaterFunc) bool); ok {
		r3 = returnFunc(chunkID, updater)
	} else {
		r3 = ret.Get(3).(bool)
	}
	return r0, r1, r2, r3
}

// ChunkRequests_UpdateRequestHistory_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateRequestHistory'
type ChunkRequests_UpdateRequestHistory_Call struct {
	*mock.Call
}

// UpdateRequestHistory is a helper method to define mock.On call
//   - chunkID flow.Identifier
//   - updater mempool.ChunkRequestHistoryUpdaterFunc
func (_e *ChunkRequests_Expecter) UpdateRequestHistory(chunkID interface{}, updater interface{}) *ChunkRequests_UpdateRequestHistory_Call {
	return &ChunkRequests_UpdateRequestHistory_Call{Call: _e.mock.On("UpdateRequestHistory", chunkID, updater)}
}

func (_c *ChunkRequests_UpdateRequestHistory_Call) Run(run func(chunkID flow.Identifier, updater mempool.ChunkRequestHistoryUpdaterFunc)) *ChunkRequests_UpdateRequestHistory_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		var arg1 mempool.ChunkRequestHistoryUpdaterFunc
		if args[1] != nil {
			arg1 = args[1].(mempool.ChunkRequestHistoryUpdaterFunc)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ChunkRequests_UpdateRequestHistory_Call) Return(v uint64, time1 time.Time, duration time.Duration, b bool) *ChunkRequests_UpdateRequestHistory_Call {
	_c.Call.Return(v, time1, duration, b)
	return _c
}

func (_c *ChunkRequests_UpdateRequestHistory_Call) RunAndReturn(run func(chunkID flow.Identifier, updater mempool.ChunkRequestHistoryUpdaterFunc) (uint64, time.Time, time.Duration, bool)) *ChunkRequests_UpdateRequestHistory_Call {
	_c.Call.Return(run)
	return _c
}

// NewChunkStatuses creates a new instance of ChunkStatuses. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewChunkStatuses(t interface {
	mock.TestingT
	Cleanup(func())
}) *ChunkStatuses {
	mock := &ChunkStatuses{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// ChunkStatuses is an autogenerated mock type for the ChunkStatuses type
type ChunkStatuses struct {
	mock.Mock
}

type ChunkStatuses_Expecter struct {
	mock *mock.Mock
}

func (_m *ChunkStatuses) EXPECT() *ChunkStatuses_Expecter {
	return &ChunkStatuses_Expecter{mock: &_m.Mock}
}

// Add provides a mock function for the type ChunkStatuses
func (_mock *ChunkStatuses) Add(identifier flow.Identifier, chunkStatus *verification.ChunkStatus) bool {
	ret := _mock.Called(identifier, chunkStatus)

	if len(ret) == 0 {
		panic("no return value specified for Add")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, *verification.ChunkStatus) bool); ok {
		r0 = returnFunc(identifier, chunkStatus)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// ChunkStatuses_Add_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Add'
type ChunkStatuses_Add_Call struct {
	*mock.Call
}

// Add is a helper method to define mock.On call
//   - identifier flow.Identifier
//   - chunkStatus *verification.ChunkStatus
func (_e *ChunkStatuses_Expecter) Add(identifier interface{}, chunkStatus interface{}) *ChunkStatuses_Add_Call {
	return &ChunkStatuses_Add_Call{Call: _e.mock.On("Add", identifier, chunkStatus)}
}

func (_c *ChunkStatuses_Add_Call) Run(run func(identifier flow.Identifier, chunkStatus *verification.ChunkStatus)) *ChunkStatuses_Add_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		var arg1 *verification.ChunkStatus
		if args[1] != nil {
			arg1 = args[1].(*verification.ChunkStatus)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ChunkStatuses_Add_Call) Return(b bool) *ChunkStatuses_Add_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *ChunkStatuses_Add_Call) RunAndReturn(run func(identifier flow.Identifier, chunkStatus *verification.ChunkStatus) bool) *ChunkStatuses_Add_Call {
	_c.Call.Return(run)
	return _c
}

// Adjust provides a mock function for the type ChunkStatuses
func (_mock *ChunkStatuses) Adjust(key flow.Identifier, f func(*verification.ChunkStatus) *verification.ChunkStatus) (*verification.ChunkStatus, bool) {
	ret := _mock.Called(key, f)

	if len(ret) == 0 {
		panic("no return value specified for Adjust")
	}

	var r0 *verification.ChunkStatus
	var r1 bool
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, func(*verification.ChunkStatus) *verification.ChunkStatus) (*verification.ChunkStatus, bool)); ok {
		return returnFunc(key, f)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, func(*verification.ChunkStatus) *verification.ChunkStatus) *verification.ChunkStatus); ok {
		r0 = returnFunc(key, f)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*verification.ChunkStatus)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier, func(*verification.ChunkStatus) *verification.ChunkStatus) bool); ok {
		r1 = returnFunc(key, f)
	} else {
		r1 = ret.Get(1).(bool)
	}
	return r0, r1
}

// ChunkStatuses_Adjust_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Adjust'
type ChunkStatuses_Adjust_Call struct {
	*mock.Call
}

// Adjust is a helper method to define mock.On call
//   - key flow.Identifier
//   - f func(*verification.ChunkStatus) *verification.ChunkStatus
func (_e *ChunkStatuses_Expecter) Adjust(key interface{}, f interface{}) *ChunkStatuses_Adjust_Call {
	return &ChunkStatuses_Adjust_Call{Call: _e.mock.On("Adjust", key, f)}
}

func (_c *ChunkStatuses_Adjust_Call) Run(run func(key flow.Identifier, f func(*verification.ChunkStatus) *verification.ChunkStatus)) *ChunkStatuses_Adjust_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		var arg1 func(*verification.ChunkStatus) *verification.ChunkStatus
		if args[1] != nil {
			arg1 = args[1].(func(*verification.ChunkStatus) *verification.ChunkStatus)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ChunkStatuses_Adjust_Call) Return(chunkStatus *verification.ChunkStatus, b bool) *ChunkStatuses_Adjust_Call {
	_c.Call.Return(chunkStatus, b)
	return _c
}

func (_c *ChunkStatuses_Adjust_Call) RunAndReturn(run func(key flow.Identifier, f func(*verification.ChunkStatus) *verification.ChunkStatus) (*verification.ChunkStatus, bool)) *ChunkStatuses_Adjust_Call {
	_c.Call.Return(run)
	return _c
}

// All provides a mock function for the type ChunkStatuses
func (_mock *ChunkStatuses) All() map[flow.Identifier]*verification.ChunkStatus {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for All")
	}

	var r0 map[flow.Identifier]*verification.ChunkStatus
	if returnFunc, ok := ret.Get(0).(func() map[flow.Identifier]*verification.ChunkStatus); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[flow.Identifier]*verification.ChunkStatus)
		}
	}
	return r0
}

// ChunkStatuses_All_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'All'
type ChunkStatuses_All_Call struct {
	*mock.Call
}

// All is a helper method to define mock.On call
func (_e *ChunkStatuses_Expecter) All() *ChunkStatuses_All_Call {
	return &ChunkStatuses_All_Call{Call: _e.mock.On("All")}
}

func (_c *ChunkStatuses_All_Call) Run(run func()) *ChunkStatuses_All_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ChunkStatuses_All_Call) Return(identifierToChunkStatus map[flow.Identifier]*verification.ChunkStatus) *ChunkStatuses_All_Call {
	_c.Call.Return(identifierToChunkStatus)
	return _c
}

func (_c *ChunkStatuses_All_Call) RunAndReturn(run func() map[flow.Identifier]*verification.ChunkStatus) *ChunkStatuses_All_Call {
	_c.Call.Return(run)
	return _c
}

// Clear provides a mock function for the type ChunkStatuses
func (_mock *ChunkStatuses) Clear() {
	_mock.Called()
	return
}

// ChunkStatuses_Clear_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Clear'
type ChunkStatuses_Clear_Call struct {
	*mock.Call
}

// Clear is a helper method to define mock.On call
func (_e *ChunkStatuses_Expecter) Clear() *ChunkStatuses_Clear_Call {
	return &ChunkStatuses_Clear_Call{Call: _e.mock.On("Clear")}
}

func (_c *ChunkStatuses_Clear_Call) Run(run func()) *ChunkStatuses_Clear_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ChunkStatuses_Clear_Call) Return() *ChunkStatuses_Clear_Call {
	_c.Call.Return()
	return _c
}

func (_c *ChunkStatuses_Clear_Call) RunAndReturn(run func()) *ChunkStatuses_Clear_Call {
	_c.Run(run)
	return _c
}

// Get provides a mock function for the type ChunkStatuses
func (_mock *ChunkStatuses) Get(identifier flow.Identifier) (*verification.ChunkStatus, bool) {
	ret := _mock.Called(identifier)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *verification.ChunkStatus
	var r1 bool
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (*verification.ChunkStatus, bool)); ok {
		return returnFunc(identifier)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) *verification.ChunkStatus); ok {
		r0 = returnFunc(identifier)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*verification.ChunkStatus)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) bool); ok {
		r1 = returnFunc(identifier)
	} else {
		r1 = ret.Get(1).(bool)
	}
	return r0, r1
}

// ChunkStatuses_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type ChunkStatuses_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - identifier flow.Identifier
func (_e *ChunkStatuses_Expecter) Get(identifier interface{}) *ChunkStatuses_Get_Call {
	return &ChunkStatuses_Get_Call{Call: _e.mock.On("Get", identifier)}
}

func (_c *ChunkStatuses_Get_Call) Run(run func(identifier flow.Identifier)) *ChunkStatuses_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ChunkStatuses_Get_Call) Return(chunkStatus *verification.ChunkStatus, b bool) *ChunkStatuses_Get_Call {
	_c.Call.Return(chunkStatus, b)
	return _c
}

func (_c *ChunkStatuses_Get_Call) RunAndReturn(run func(identifier flow.Identifier) (*verification.ChunkStatus, bool)) *ChunkStatuses_Get_Call {
	_c.Call.Return(run)
	return _c
}

// Has provides a mock function for the type ChunkStatuses
func (_mock *ChunkStatuses) Has(identifier flow.Identifier) bool {
	ret := _mock.Called(identifier)

	if len(ret) == 0 {
		panic("no return value specified for Has")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) bool); ok {
		r0 = returnFunc(identifier)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// ChunkStatuses_Has_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Has'
type ChunkStatuses_Has_Call struct {
	*mock.Call
}

// Has is a helper method to define mock.On call
//   - identifier flow.Identifier
func (_e *ChunkStatuses_Expecter) Has(identifier interface{}) *ChunkStatuses_Has_Call {
	return &ChunkStatuses_Has_Call{Call: _e.mock.On("Has", identifier)}
}

func (_c *ChunkStatuses_Has_Call) Run(run func(identifier flow.Identifier)) *ChunkStatuses_Has_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ChunkStatuses_Has_Call) Return(b bool) *ChunkStatuses_Has_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *ChunkStatuses_Has_Call) RunAndReturn(run func(identifier flow.Identifier) bool) *ChunkStatuses_Has_Call {
	_c.Call.Return(run)
	return _c
}

// Remove provides a mock function for the type ChunkStatuses
func (_mock *ChunkStatuses) Remove(identifier flow.Identifier) bool {
	ret := _mock.Called(identifier)

	if len(ret) == 0 {
		panic("no return value specified for Remove")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) bool); ok {
		r0 = returnFunc(identifier)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// ChunkStatuses_Remove_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Remove'
type ChunkStatuses_Remove_Call struct {
	*mock.Call
}

// Remove is a helper method to define mock.On call
//   - identifier flow.Identifier
func (_e *ChunkStatuses_Expecter) Remove(identifier interface{}) *ChunkStatuses_Remove_Call {
	return &ChunkStatuses_Remove_Call{Call: _e.mock.On("Remove", identifier)}
}

func (_c *ChunkStatuses_Remove_Call) Run(run func(identifier flow.Identifier)) *ChunkStatuses_Remove_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ChunkStatuses_Remove_Call) Return(b bool) *ChunkStatuses_Remove_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *ChunkStatuses_Remove_Call) RunAndReturn(run func(identifier flow.Identifier) bool) *ChunkStatuses_Remove_Call {
	_c.Call.Return(run)
	return _c
}

// Size provides a mock function for the type ChunkStatuses
func (_mock *ChunkStatuses) Size() uint {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Size")
	}

	var r0 uint
	if returnFunc, ok := ret.Get(0).(func() uint); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint)
	}
	return r0
}

// ChunkStatuses_Size_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Size'
type ChunkStatuses_Size_Call struct {
	*mock.Call
}

// Size is a helper method to define mock.On call
func (_e *ChunkStatuses_Expecter) Size() *ChunkStatuses_Size_Call {
	return &ChunkStatuses_Size_Call{Call: _e.mock.On("Size")}
}

func (_c *ChunkStatuses_Size_Call) Run(run func()) *ChunkStatuses_Size_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ChunkStatuses_Size_Call) Return(v uint) *ChunkStatuses_Size_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *ChunkStatuses_Size_Call) RunAndReturn(run func() uint) *ChunkStatuses_Size_Call {
	_c.Call.Return(run)
	return _c
}

// Values provides a mock function for the type ChunkStatuses
func (_mock *ChunkStatuses) Values() []*verification.ChunkStatus {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Values")
	}

	var r0 []*verification.ChunkStatus
	if returnFunc, ok := ret.Get(0).(func() []*verification.ChunkStatus); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*verification.ChunkStatus)
		}
	}
	return r0
}

// ChunkStatuses_Values_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Values'
type ChunkStatuses_Values_Call struct {
	*mock.Call
}

// Values is a helper method to define mock.On call
func (_e *ChunkStatuses_Expecter) Values() *ChunkStatuses_Values_Call {
	return &ChunkStatuses_Values_Call{Call: _e.mock.On("Values")}
}

func (_c *ChunkStatuses_Values_Call) Run(run func()) *ChunkStatuses_Values_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ChunkStatuses_Values_Call) Return(chunkStatuss []*verification.ChunkStatus) *ChunkStatuses_Values_Call {
	_c.Call.Return(chunkStatuss)
	return _c
}

func (_c *ChunkStatuses_Values_Call) RunAndReturn(run func() []*verification.ChunkStatus) *ChunkStatuses_Values_Call {
	_c.Call.Return(run)
	return _c
}

// NewDNSCache creates a new instance of DNSCache. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewDNSCache(t interface {
	mock.TestingT
	Cleanup(func())
}) *DNSCache {
	mock := &DNSCache{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// DNSCache is an autogenerated mock type for the DNSCache type
type DNSCache struct {
	mock.Mock
}

type DNSCache_Expecter struct {
	mock *mock.Mock
}

func (_m *DNSCache) EXPECT() *DNSCache_Expecter {
	return &DNSCache_Expecter{mock: &_m.Mock}
}

// GetDomainIp provides a mock function for the type DNSCache
func (_mock *DNSCache) GetDomainIp(s string) (*mempool.IpRecord, bool) {
	ret := _mock.Called(s)

	if len(ret) == 0 {
		panic("no return value specified for GetDomainIp")
	}

	var r0 *mempool.IpRecord
	var r1 bool
	if returnFunc, ok := ret.Get(0).(func(string) (*mempool.IpRecord, bool)); ok {
		return returnFunc(s)
	}
	if returnFunc, ok := ret.Get(0).(func(string) *mempool.IpRecord); ok {
		r0 = returnFunc(s)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mempool.IpRecord)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string) bool); ok {
		r1 = returnFunc(s)
	} else {
		r1 = ret.Get(1).(bool)
	}
	return r0, r1
}

// DNSCache_GetDomainIp_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDomainIp'
type DNSCache_GetDomainIp_Call struct {
	*mock.Call
}

// GetDomainIp is a helper method to define mock.On call
//   - s string
func (_e *DNSCache_Expecter) GetDomainIp(s interface{}) *DNSCache_GetDomainIp_Call {
	return &DNSCache_GetDomainIp_Call{Call: _e.mock.On("GetDomainIp", s)}
}

func (_c *DNSCache_GetDomainIp_Call) Run(run func(s string)) *DNSCache_GetDomainIp_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *DNSCache_GetDomainIp_Call) Return(ipRecord *mempool.IpRecord, b bool) *DNSCache_GetDomainIp_Call {
	_c.Call.Return(ipRecord, b)
	return _c
}

func (_c *DNSCache_GetDomainIp_Call) RunAndReturn(run func(s string) (*mempool.IpRecord, bool)) *DNSCache_GetDomainIp_Call {
	_c.Call.Return(run)
	return _c
}

// GetTxtRecord provides a mock function for the type DNSCache
func (_mock *DNSCache) GetTxtRecord(s string) (*mempool.TxtRecord, bool) {
	ret := _mock.Called(s)

	if len(ret) == 0 {
		panic("no return value specified for GetTxtRecord")
	}

	var r0 *mempool.TxtRecord
	var r1 bool
	if returnFunc, ok := ret.Get(0).(func(string) (*mempool.TxtRecord, bool)); ok {
		return returnFunc(s)
	}
	if returnFunc, ok := ret.Get(0).(func(string) *mempool.TxtRecord); ok {
		r0 = returnFunc(s)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mempool.TxtRecord)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string) bool); ok {
		r1 = returnFunc(s)
	} else {
		r1 = ret.Get(1).(bool)
	}
	return r0, r1
}

// DNSCache_GetTxtRecord_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTxtRecord'
type DNSCache_GetTxtRecord_Call struct {
	*mock.Call
}

// GetTxtRecord is a helper method to define mock.On call
//   - s string
func (_e *DNSCache_Expecter) GetTxtRecord(s interface{}) *DNSCache_GetTxtRecord_Call {
	return &DNSCache_GetTxtRecord_Call{Call: _e.mock.On("GetTxtRecord", s)}
}

func (_c *DNSCache_GetTxtRecord_Call) Run(run func(s string)) *DNSCache_GetTxtRecord_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *DNSCache_GetTxtRecord_Call) Return(txtRecord *mempool.TxtRecord, b bool) *DNSCache_GetTxtRecord_Call {
	_c.Call.Return(txtRecord, b)
	return _c
}

func (_c *DNSCache_GetTxtRecord_Call) RunAndReturn(run func(s string) (*mempool.TxtRecord, bool)) *DNSCache_GetTxtRecord_Call {
	_c.Call.Return(run)
	return _c
}

// LockIPDomain provides a mock function for the type DNSCache
func (_mock *DNSCache) LockIPDomain(s string) (bool, error) {
	ret := _mock.Called(s)

	if len(ret) == 0 {
		panic("no return value specified for LockIPDomain")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string) (bool, error)); ok {
		return returnFunc(s)
	}
	if returnFunc, ok := ret.Get(0).(func(string) bool); ok {
		r0 = returnFunc(s)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(string) error); ok {
		r1 = returnFunc(s)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// DNSCache_LockIPDomain_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LockIPDomain'
type DNSCache_LockIPDomain_Call struct {
	*mock.Call
}

// LockIPDomain is a helper method to define mock.On call
//   - s string
func (_e *DNSCache_Expecter) LockIPDomain(s interface{}) *DNSCache_LockIPDomain_Call {
	return &DNSCache_LockIPDomain_Call{Call: _e.mock.On("LockIPDomain", s)}
}

func (_c *DNSCache_LockIPDomain_Call) Run(run func(s string)) *DNSCache_LockIPDomain_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *DNSCache_LockIPDomain_Call) Return(b bool, err error) *DNSCache_LockIPDomain_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *DNSCache_LockIPDomain_Call) RunAndReturn(run func(s string) (bool, error)) *DNSCache_LockIPDomain_Call {
	_c.Call.Return(run)
	return _c
}

// LockTxtRecord provides a mock function for the type DNSCache
func (_mock *DNSCache) LockTxtRecord(s string) (bool, error) {
	ret := _mock.Called(s)

	if len(ret) == 0 {
		panic("no return value specified for LockTxtRecord")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string) (bool, error)); ok {
		return returnFunc(s)
	}
	if returnFunc, ok := ret.Get(0).(func(string) bool); ok {
		r0 = returnFunc(s)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(string) error); ok {
		r1 = returnFunc(s)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// DNSCache_LockTxtRecord_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LockTxtRecord'
type DNSCache_LockTxtRecord_Call struct {
	*mock.Call
}

// LockTxtRecord is a helper method to define mock.On call
//   - s string
func (_e *DNSCache_Expecter) LockTxtRecord(s interface{}) *DNSCache_LockTxtRecord_Call {
	return &DNSCache_LockTxtRecord_Call{Call: _e.mock.On("LockTxtRecord", s)}
}

func (_c *DNSCache_LockTxtRecord_Call) Run(run func(s string)) *DNSCache_LockTxtRecord_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *DNSCache_LockTxtRecord_Call) Return(b bool, err error) *DNSCache_LockTxtRecord_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *DNSCache_LockTxtRecord_Call) RunAndReturn(run func(s string) (bool, error)) *DNSCache_LockTxtRecord_Call {
	_c.Call.Return(run)
	return _c
}

// PutIpDomain provides a mock function for the type DNSCache
func (_mock *DNSCache) PutIpDomain(s string, iPAddrs []net.IPAddr, n int64) bool {
	ret := _mock.Called(s, iPAddrs, n)

	if len(ret) == 0 {
		panic("no return value specified for PutIpDomain")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(string, []net.IPAddr, int64) bool); ok {
		r0 = returnFunc(s, iPAddrs, n)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// DNSCache_PutIpDomain_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutIpDomain'
type DNSCache_PutIpDomain_Call struct {
	*mock.Call
}

// PutIpDomain is a helper method to define mock.On call
//   - s string
//   - iPAddrs []net.IPAddr
//   - n int64
func (_e *DNSCache_Expecter) PutIpDomain(s interface{}, iPAddrs interface{}, n interface{}) *DNSCache_PutIpDomain_Call {
	return &DNSCache_PutIpDomain_Call{Call: _e.mock.On("PutIpDomain", s, iPAddrs, n)}
}

func (_c *DNSCache_PutIpDomain_Call) Run(run func(s string, iPAddrs []net.IPAddr, n int64)) *DNSCache_PutIpDomain_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 []net.IPAddr
		if args[1] != nil {
			arg1 = args[1].([]net.IPAddr)
		}
		var arg2 int64
		if args[2] != nil {
			arg2 = args[2].(int64)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *DNSCache_PutIpDomain_Call) Return(b bool) *DNSCache_PutIpDomain_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *DNSCache_PutIpDomain_Call) RunAndReturn(run func(s string, iPAddrs []net.IPAddr, n int64) bool) *DNSCache_PutIpDomain_Call {
	_c.Call.Return(run)
	return _c
}

// PutTxtRecord provides a mock function for the type DNSCache
func (_mock *DNSCache) PutTxtRecord(s string, strings []string, n int64) bool {
	ret := _mock.Called(s, strings, n)

	if len(ret) == 0 {
		panic("no return value specified for PutTxtRecord")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(string, []string, int64) bool); ok {
		r0 = returnFunc(s, strings, n)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// DNSCache_PutTxtRecord_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutTxtRecord'
type DNSCache_PutTxtRecord_Call struct {
	*mock.Call
}

// PutTxtRecord is a helper method to define mock.On call
//   - s string
//   - strings []string
//   - n int64
func (_e *DNSCache_Expecter) PutTxtRecord(s interface{}, strings interface{}, n interface{}) *DNSCache_PutTxtRecord_Call {
	return &DNSCache_PutTxtRecord_Call{Call: _e.mock.On("PutTxtRecord", s, strings, n)}
}

func (_c *DNSCache_PutTxtRecord_Call) Run(run func(s string, strings []string, n int64)) *DNSCache_PutTxtRecord_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 []string
		if args[1] != nil {
			arg1 = args[1].([]string)
		}
		var arg2 int64
		if args[2] != nil {
			arg2 = args[2].(int64)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *DNSCache_PutTxtRecord_Call) Return(b bool) *DNSCache_PutTxtRecord_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *DNSCache_PutTxtRecord_Call) RunAndReturn(run func(s string, strings []string, n int64) bool) *DNSCache_PutTxtRecord_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveIp provides a mock function for the type DNSCache
func (_mock *DNSCache) RemoveIp(s string) bool {
	ret := _mock.Called(s)

	if len(ret) == 0 {
		panic("no return value specified for RemoveIp")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(string) bool); ok {
		r0 = returnFunc(s)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// DNSCache_RemoveIp_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveIp'
type DNSCache_RemoveIp_Call struct {
	*mock.Call
}

// RemoveIp is a helper method to define mock.On call
//   - s string
func (_e *DNSCache_Expecter) RemoveIp(s interface{}) *DNSCache_RemoveIp_Call {
	return &DNSCache_RemoveIp_Call{Call: _e.mock.On("RemoveIp", s)}
}

func (_c *DNSCache_RemoveIp_Call) Run(run func(s string)) *DNSCache_RemoveIp_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *DNSCache_RemoveIp_Call) Return(b bool) *DNSCache_RemoveIp_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *DNSCache_RemoveIp_Call) RunAndReturn(run func(s string) bool) *DNSCache_RemoveIp_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveTxt provides a mock function for the type DNSCache
func (_mock *DNSCache) RemoveTxt(s string) bool {
	ret := _mock.Called(s)

	if len(ret) == 0 {
		panic("no return value specified for RemoveTxt")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(string) bool); ok {
		r0 = returnFunc(s)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// DNSCache_RemoveTxt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveTxt'
type DNSCache_RemoveTxt_Call struct {
	*mock.Call
}

// RemoveTxt is a helper method to define mock.On call
//   - s string
func (_e *DNSCache_Expecter) RemoveTxt(s interface{}) *DNSCache_RemoveTxt_Call {
	return &DNSCache_RemoveTxt_Call{Call: _e.mock.On("RemoveTxt", s)}
}

func (_c *DNSCache_RemoveTxt_Call) Run(run func(s string)) *DNSCache_RemoveTxt_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *DNSCache_RemoveTxt_Call) Return(b bool) *DNSCache_RemoveTxt_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *DNSCache_RemoveTxt_Call) RunAndReturn(run func(s string) bool) *DNSCache_RemoveTxt_Call {
	_c.Call.Return(run)
	return _c
}

// Size provides a mock function for the type DNSCache
func (_mock *DNSCache) Size() (uint, uint) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Size")
	}

	var r0 uint
	var r1 uint
	if returnFunc, ok := ret.Get(0).(func() (uint, uint)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() uint); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint)
	}
	if returnFunc, ok := ret.Get(1).(func() uint); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Get(1).(uint)
	}
	return r0, r1
}

// DNSCache_Size_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Size'
type DNSCache_Size_Call struct {
	*mock.Call
}

// Size is a helper method to define mock.On call
func (_e *DNSCache_Expecter) Size() *DNSCache_Size_Call {
	return &DNSCache_Size_Call{Call: _e.mock.On("Size")}
}

func (_c *DNSCache_Size_Call) Run(run func()) *DNSCache_Size_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *DNSCache_Size_Call) Return(v uint, v1 uint) *DNSCache_Size_Call {
	_c.Call.Return(v, v1)
	return _c
}

func (_c *DNSCache_Size_Call) RunAndReturn(run func() (uint, uint)) *DNSCache_Size_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateIPDomain provides a mock function for the type DNSCache
func (_mock *DNSCache) UpdateIPDomain(s string, iPAddrs []net.IPAddr, n int64) error {
	ret := _mock.Called(s, iPAddrs, n)

	if len(ret) == 0 {
		panic("no return value specified for UpdateIPDomain")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string, []net.IPAddr, int64) error); ok {
		r0 = returnFunc(s, iPAddrs, n)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// DNSCache_UpdateIPDomain_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateIPDomain'
type DNSCache_UpdateIPDomain_Call struct {
	*mock.Call
}

// UpdateIPDomain is a helper method to define mock.On call
//   - s string
//   - iPAddrs []net.IPAddr
//   - n int64
func (_e *DNSCache_Expecter) UpdateIPDomain(s interface{}, iPAddrs interface{}, n interface{}) *DNSCache_UpdateIPDomain_Call {
	return &DNSCache_UpdateIPDomain_Call{Call: _e.mock.On("UpdateIPDomain", s, iPAddrs, n)}
}

func (_c *DNSCache_UpdateIPDomain_Call) Run(run func(s string, iPAddrs []net.IPAddr, n int64)) *DNSCache_UpdateIPDomain_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 []net.IPAddr
		if args[1] != nil {
			arg1 = args[1].([]net.IPAddr)
		}
		var arg2 int64
		if args[2] != nil {
			arg2 = args[2].(int64)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *DNSCache_UpdateIPDomain_Call) Return(err error) *DNSCache_UpdateIPDomain_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *DNSCache_UpdateIPDomain_Call) RunAndReturn(run func(s string, iPAddrs []net.IPAddr, n int64) error) *DNSCache_UpdateIPDomain_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateTxtRecord provides a mock function for the type DNSCache
func (_mock *DNSCache) UpdateTxtRecord(s string, strings []string, n int64) error {
	ret := _mock.Called(s, strings, n)

	if len(ret) == 0 {
		panic("no return value specified for UpdateTxtRecord")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string, []string, int64) error); ok {
		r0 = returnFunc(s, strings, n)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// DNSCache_UpdateTxtRecord_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateTxtRecord'
type DNSCache_UpdateTxtRecord_Call struct {
	*mock.Call
}

// UpdateTxtRecord is a helper method to define mock.On call
//   - s string
//   - strings []string
//   - n int64
func (_e *DNSCache_Expecter) UpdateTxtRecord(s interface{}, strings interface{}, n interface{}) *DNSCache_UpdateTxtRecord_Call {
	return &DNSCache_UpdateTxtRecord_Call{Call: _e.mock.On("UpdateTxtRecord", s, strings, n)}
}

func (_c *DNSCache_UpdateTxtRecord_Call) Run(run func(s string, strings []string, n int64)) *DNSCache_UpdateTxtRecord_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 []string
		if args[1] != nil {
			arg1 = args[1].([]string)
		}
		var arg2 int64
		if args[2] != nil {
			arg2 = args[2].(int64)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *DNSCache_UpdateTxtRecord_Call) Return(err error) *DNSCache_UpdateTxtRecord_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *DNSCache_UpdateTxtRecord_Call) RunAndReturn(run func(s string, strings []string, n int64) error) *DNSCache_UpdateTxtRecord_Call {
	_c.Call.Return(run)
	return _c
}

// NewExecutionData creates a new instance of ExecutionData. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewExecutionData(t interface {
	mock.TestingT
	Cleanup(func())
}) *ExecutionData {
	mock := &ExecutionData{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// ExecutionData is an autogenerated mock type for the ExecutionData type
type ExecutionData struct {
	mock.Mock
}

type ExecutionData_Expecter struct {
	mock *mock.Mock
}

func (_m *ExecutionData) EXPECT() *ExecutionData_Expecter {
	return &ExecutionData_Expecter{mock: &_m.Mock}
}

// Add provides a mock function for the type ExecutionData
func (_mock *ExecutionData) Add(identifier flow.Identifier, blockExecutionDataEntity *execution_data.BlockExecutionDataEntity) bool {
	ret := _mock.Called(identifier, blockExecutionDataEntity)

	if len(ret) == 0 {
		panic("no return value specified for Add")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, *execution_data.BlockExecutionDataEntity) bool); ok {
		r0 = returnFunc(identifier, blockExecutionDataEntity)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// ExecutionData_Add_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Add'
type ExecutionData_Add_Call struct {
	*mock.Call
}

// Add is a helper method to define mock.On call
//   - identifier flow.Identifier
//   - blockExecutionDataEntity *execution_data.BlockExecutionDataEntity
func (_e *ExecutionData_Expecter) Add(identifier interface{}, blockExecutionDataEntity interface{}) *ExecutionData_Add_Call {
	return &ExecutionData_Add_Call{Call: _e.mock.On("Add", identifier, blockExecutionDataEntity)}
}

func (_c *ExecutionData_Add_Call) Run(run func(identifier flow.Identifier, blockExecutionDataEntity *execution_data.BlockExecutionDataEntity)) *ExecutionData_Add_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		var arg1 *execution_data.BlockExecutionDataEntity
		if args[1] != nil {
			arg1 = args[1].(*execution_data.BlockExecutionDataEntity)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ExecutionData_Add_Call) Return(b bool) *ExecutionData_Add_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *ExecutionData_Add_Call) RunAndReturn(run func(identifier flow.Identifier, blockExecutionDataEntity *execution_data.BlockExecutionDataEntity) bool) *ExecutionData_Add_Call {
	_c.Call.Return(run)
	return _c
}

// Adjust provides a mock function for the type ExecutionData
func (_mock *ExecutionData) Adjust(key flow.Identifier, f func(*execution_data.BlockExecutionDataEntity) *execution_data.BlockExecutionDataEntity) (*execution_data.BlockExecutionDataEntity, bool) {
	ret := _mock.Called(key, f)

	if len(ret) == 0 {
		panic("no return value specified for Adjust")
	}

	var r0 *execution_data.BlockExecutionDataEntity
	var r1 bool
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, func(*execution_data.BlockExecutionDataEntity) *execution_data.BlockExecutionDataEntity) (*execution_data.BlockExecutionDataEntity, bool)); ok {
		return returnFunc(key, f)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, func(*execution_data.BlockExecutionDataEntity) *execution_data.BlockExecutionDataEntity) *execution_data.BlockExecutionDataEntity); ok {
		r0 = returnFunc(key, f)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*execution_data.BlockExecutionDataEntity)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier, func(*execution_data.BlockExecutionDataEntity) *execution_data.BlockExecutionDataEntity) bool); ok {
		r1 = returnFunc(key, f)
	} else {
		r1 = ret.Get(1).(bool)
	}
	return r0, r1
}

// ExecutionData_Adjust_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Adjust'
type ExecutionData_Adjust_Call struct {
	*mock.Call
}

// Adjust is a helper method to define mock.On call
//   - key flow.Identifier
//   - f func(*execution_data.BlockExecutionDataEntity) *execution_data.BlockExecutionDataEntity
func (_e *ExecutionData_Expecter) Adjust(key interface{}, f interface{}) *ExecutionData_Adjust_Call {
	return &ExecutionData_Adjust_Call{Call: _e.mock.On("Adjust", key, f)}
}

func (_c *ExecutionData_Adjust_Call) Run(run func(key flow.Identifier, f func(*execution_data.BlockExecutionDataEntity) *execution_data.BlockExecutionDataEntity)) *ExecutionData_Adjust_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		var arg1 func(*execution_data.BlockExecutionDataEntity) *execution_data.BlockExecutionDataEntity
		if args[1] != nil {
			arg1 = args[1].(func(*execution_data.BlockExecutionDataEntity) *execution_data.BlockExecutionDataEntity)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ExecutionData_Adjust_Call) Return(blockExecutionDataEntity *execution_data.BlockExecutionDataEntity, b bool) *ExecutionData_Adjust_Call {
	_c.Call.Return(blockExecutionDataEntity, b)
	return _c
}

func (_c *ExecutionData_Adjust_Call) RunAndReturn(run func(key flow.Identifier, f func(*execution_data.BlockExecutionDataEntity) *execution_data.BlockExecutionDataEntity) (*execution_data.BlockExecutionDataEntity, bool)) *ExecutionData_Adjust_Call {
	_c.Call.Return(run)
	return _c
}

// All provides a mock function for the type ExecutionData
func (_mock *ExecutionData) All() map[flow.Identifier]*execution_data.BlockExecutionDataEntity {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for All")
	}

	var r0 map[flow.Identifier]*execution_data.BlockExecutionDataEntity
	if returnFunc, ok := ret.Get(0).(func() map[flow.Identifier]*execution_data.BlockExecutionDataEntity); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[flow.Identifier]*execution_data.BlockExecutionDataEntity)
		}
	}
	return r0
}

// ExecutionData_All_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'All'
type ExecutionData_All_Call struct {
	*mock.Call
}

// All is a helper method to define mock.On call
func (_e *ExecutionData_Expecter) All() *ExecutionData_All_Call {
	return &ExecutionData_All_Call{Call: _e.mock.On("All")}
}

func (_c *ExecutionData_All_Call) Run(run func()) *ExecutionData_All_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ExecutionData_All_Call) Return(identifierToBlockExecutionDataEntity map[flow.Identifier]*execution_data.BlockExecutionDataEntity) *ExecutionData_All_Call {
	_c.Call.Return(identifierToBlockExecutionDataEntity)
	return _c
}

func (_c *ExecutionData_All_Call) RunAndReturn(run func() map[flow.Identifier]*execution_data.BlockExecutionDataEntity) *ExecutionData_All_Call {
	_c.Call.Return(run)
	return _c
}

// Clear provides a mock function for the type ExecutionData
func (_mock *ExecutionData) Clear() {
	_mock.Called()
	return
}

// ExecutionData_Clear_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Clear'
type ExecutionData_Clear_Call struct {
	*mock.Call
}

// Clear is a helper method to define mock.On call
func (_e *ExecutionData_Expecter) Clear() *ExecutionData_Clear_Call {
	return &ExecutionData_Clear_Call{Call: _e.mock.On("Clear")}
}

func (_c *ExecutionData_Clear_Call) Run(run func()) *ExecutionData_Clear_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ExecutionData_Clear_Call) Return() *ExecutionData_Clear_Call {
	_c.Call.Return()
	return _c
}

func (_c *ExecutionData_Clear_Call) RunAndReturn(run func()) *ExecutionData_Clear_Call {
	_c.Run(run)
	return _c
}

// Get provides a mock function for the type ExecutionData
func (_mock *ExecutionData) Get(identifier flow.Identifier) (*execution_data.BlockExecutionDataEntity, bool) {
	ret := _mock.Called(identifier)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *execution_data.BlockExecutionDataEntity
	var r1 bool
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (*execution_data.BlockExecutionDataEntity, bool)); ok {
		return returnFunc(identifier)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) *execution_data.BlockExecutionDataEntity); ok {
		r0 = returnFunc(identifier)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*execution_data.BlockExecutionDataEntity)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) bool); ok {
		r1 = returnFunc(identifier)
	} else {
		r1 = ret.Get(1).(bool)
	}
	return r0, r1
}

// ExecutionData_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type ExecutionData_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - identifier flow.Identifier
func (_e *ExecutionData_Expecter) Get(identifier interface{}) *ExecutionData_Get_Call {
	return &ExecutionData_Get_Call{Call: _e.mock.On("Get", identifier)}
}

func (_c *ExecutionData_Get_Call) Run(run func(identifier flow.Identifier)) *ExecutionData_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ExecutionData_Get_Call) Return(blockExecutionDataEntity *execution_data.BlockExecutionDataEntity, b bool) *ExecutionData_Get_Call {
	_c.Call.Return(blockExecutionDataEntity, b)
	return _c
}

func (_c *ExecutionData_Get_Call) RunAndReturn(run func(identifier flow.Identifier) (*execution_data.BlockExecutionDataEntity, bool)) *ExecutionData_Get_Call {
	_c.Call.Return(run)
	return _c
}

// Has provides a mock function for the type ExecutionData
func (_mock *ExecutionData) Has(identifier flow.Identifier) bool {
	ret := _mock.Called(identifier)

	if len(ret) == 0 {
		panic("no return value specified for Has")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) bool); ok {
		r0 = returnFunc(identifier)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// ExecutionData_Has_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Has'
type ExecutionData_Has_Call struct {
	*mock.Call
}

// Has is a helper method to define mock.On call
//   - identifier flow.Identifier
func (_e *ExecutionData_Expecter) Has(identifier interface{}) *ExecutionData_Has_Call {
	return &ExecutionData_Has_Call{Call: _e.mock.On("Has", identifier)}
}

func (_c *ExecutionData_Has_Call) Run(run func(identifier flow.Identifier)) *ExecutionData_Has_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ExecutionData_Has_Call) Return(b bool) *ExecutionData_Has_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *ExecutionData_Has_Call) RunAndReturn(run func(identifier flow.Identifier) bool) *ExecutionData_Has_Call {
	_c.Call.Return(run)
	return _c
}

// Remove provides a mock function for the type ExecutionData
func (_mock *ExecutionData) Remove(identifier flow.Identifier) bool {
	ret := _mock.Called(identifier)

	if len(ret) == 0 {
		panic("no return value specified for Remove")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) bool); ok {
		r0 = returnFunc(identifier)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// ExecutionData_Remove_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Remove'
type ExecutionData_Remove_Call struct {
	*mock.Call
}

// Remove is a helper method to define mock.On call
//   - identifier flow.Identifier
func (_e *ExecutionData_Expecter) Remove(identifier interface{}) *ExecutionData_Remove_Call {
	return &ExecutionData_Remove_Call{Call: _e.mock.On("Remove", identifier)}
}

func (_c *ExecutionData_Remove_Call) Run(run func(identifier flow.Identifier)) *ExecutionData_Remove_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ExecutionData_Remove_Call) Return(b bool) *ExecutionData_Remove_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *ExecutionData_Remove_Call) RunAndReturn(run func(identifier flow.Identifier) bool) *ExecutionData_Remove_Call {
	_c.Call.Return(run)
	return _c
}

// Size provides a mock function for the type ExecutionData
func (_mock *ExecutionData) Size() uint {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Size")
	}

	var r0 uint
	if returnFunc, ok := ret.Get(0).(func() uint); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint)
	}
	return r0
}

// ExecutionData_Size_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Size'
type ExecutionData_Size_Call struct {
	*mock.Call
}

// Size is a helper method to define mock.On call
func (_e *ExecutionData_Expecter) Size() *ExecutionData_Size_Call {
	return &ExecutionData_Size_Call{Call: _e.mock.On("Size")}
}

func (_c *ExecutionData_Size_Call) Run(run func()) *ExecutionData_Size_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ExecutionData_Size_Call) Return(v uint) *ExecutionData_Size_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *ExecutionData_Size_Call) RunAndReturn(run func() uint) *ExecutionData_Size_Call {
	_c.Call.Return(run)
	return _c
}

// Values provides a mock function for the type ExecutionData
func (_mock *ExecutionData) Values() []*execution_data.BlockExecutionDataEntity {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Values")
	}

	var r0 []*execution_data.BlockExecutionDataEntity
	if returnFunc, ok := ret.Get(0).(func() []*execution_data.BlockExecutionDataEntity); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*execution_data.BlockExecutionDataEntity)
		}
	}
	return r0
}

// ExecutionData_Values_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Values'
type ExecutionData_Values_Call struct {
	*mock.Call
}

// Values is a helper method to define mock.On call
func (_e *ExecutionData_Expecter) Values() *ExecutionData_Values_Call {
	return &ExecutionData_Values_Call{Call: _e.mock.On("Values")}
}

func (_c *ExecutionData_Values_Call) Run(run func()) *ExecutionData_Values_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ExecutionData_Values_Call) Return(blockExecutionDataEntitys []*execution_data.BlockExecutionDataEntity) *ExecutionData_Values_Call {
	_c.Call.Return(blockExecutionDataEntitys)
	return _c
}

func (_c *ExecutionData_Values_Call) RunAndReturn(run func() []*execution_data.BlockExecutionDataEntity) *ExecutionData_Values_Call {
	_c.Call.Return(run)
	return _c
}

// NewExecutionTree creates a new instance of ExecutionTree. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewExecutionTree(t interface {
	mock.TestingT
	Cleanup(func())
}) *ExecutionTree {
	mock := &ExecutionTree{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// ExecutionTree is an autogenerated mock type for the ExecutionTree type
type ExecutionTree struct {
	mock.Mock
}

type ExecutionTree_Expecter struct {
	mock *mock.Mock
}

func (_m *ExecutionTree) EXPECT() *ExecutionTree_Expecter {
	return &ExecutionTree_Expecter{mock: &_m.Mock}
}

// AddReceipt provides a mock function for the type ExecutionTree
func (_mock *ExecutionTree) AddReceipt(receipt *flow.ExecutionReceipt, block *flow.Header) (bool, error) {
	ret := _mock.Called(receipt, block)

	if len(ret) == 0 {
		panic("no return value specified for AddReceipt")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*flow.ExecutionReceipt, *flow.Header) (bool, error)); ok {
		return returnFunc(receipt, block)
	}
	if returnFunc, ok := ret.Get(0).(func(*flow.ExecutionReceipt, *flow.Header) bool); ok {
		r0 = returnFunc(receipt, block)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(*flow.ExecutionReceipt, *flow.Header) error); ok {
		r1 = returnFunc(receipt, block)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ExecutionTree_AddReceipt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddReceipt'
type ExecutionTree_AddReceipt_Call struct {
	*mock.Call
}

// AddReceipt is a helper method to define mock.On call
//   - receipt *flow.ExecutionReceipt
//   - block *flow.Header
func (_e *ExecutionTree_Expecter) AddReceipt(receipt interface{}, block interface{}) *ExecutionTree_AddReceipt_Call {
	return &ExecutionTree_AddReceipt_Call{Call: _e.mock.On("AddReceipt", receipt, block)}
}

func (_c *ExecutionTree_AddReceipt_Call) Run(run func(receipt *flow.ExecutionReceipt, block *flow.Header)) *ExecutionTree_AddReceipt_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *flow.ExecutionReceipt
		if args[0] != nil {
			arg0 = args[0].(*flow.ExecutionReceipt)
		}
		var arg1 *flow.Header
		if args[1] != nil {
			arg1 = args[1].(*flow.Header)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ExecutionTree_AddReceipt_Call) Return(b bool, err error) *ExecutionTree_AddReceipt_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *ExecutionTree_AddReceipt_Call) RunAndReturn(run func(receipt *flow.ExecutionReceipt, block *flow.Header) (bool, error)) *ExecutionTree_AddReceipt_Call {
	_c.Call.Return(run)
	return _c
}

// AddResult provides a mock function for the type ExecutionTree
func (_mock *ExecutionTree) AddResult(result *flow.ExecutionResult, block *flow.Header) error {
	ret := _mock.Called(result, block)

	if len(ret) == 0 {
		panic("no return value specified for AddResult")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*flow.ExecutionResult, *flow.Header) error); ok {
		r0 = returnFunc(result, block)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ExecutionTree_AddResult_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddResult'
type ExecutionTree_AddResult_Call struct {
	*mock.Call
}

// AddResult is a helper method to define mock.On call
//   - result *flow.ExecutionResult
//   - block *flow.Header
func (_e *ExecutionTree_Expecter) AddResult(result interface{}, block interface{}) *ExecutionTree_AddResult_Call {
	return &ExecutionTree_AddResult_Call{Call: _e.mock.On("AddResult", result, block)}
}

func (_c *ExecutionTree_AddResult_Call) Run(run func(result *flow.ExecutionResult, block *flow.Header)) *ExecutionTree_AddResult_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *flow.ExecutionResult
		if args[0] != nil {
			arg0 = args[0].(*flow.ExecutionResult)
		}
		var arg1 *flow.Header
		if args[1] != nil {
			arg1 = args[1].(*flow.Header)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ExecutionTree_AddResult_Call) Return(err error) *ExecutionTree_AddResult_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ExecutionTree_AddResult_Call) RunAndReturn(run func(result *flow.ExecutionResult, block *flow.Header) error) *ExecutionTree_AddResult_Call {
	_c.Call.Return(run)
	return _c
}

// HasReceipt provides a mock function for the type ExecutionTree
func (_mock *ExecutionTree) HasReceipt(receipt *flow.ExecutionReceipt) bool {
	ret := _mock.Called(receipt)

	if len(ret) == 0 {
		panic("no return value specified for HasReceipt")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(*flow.ExecutionReceipt) bool); ok {
		r0 = returnFunc(receipt)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// ExecutionTree_HasReceipt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HasReceipt'
type ExecutionTree_HasReceipt_Call struct {
	*mock.Call
}

// HasReceipt is a helper method to define mock.On call
//   - receipt *flow.ExecutionReceipt
func (_e *ExecutionTree_Expecter) HasReceipt(receipt interface{}) *ExecutionTree_HasReceipt_Call {
	return &ExecutionTree_HasReceipt_Call{Call: _e.mock.On("HasReceipt", receipt)}
}

func (_c *ExecutionTree_HasReceipt_Call) Run(run func(receipt *flow.ExecutionReceipt)) *ExecutionTree_HasReceipt_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *flow.ExecutionReceipt
		if args[0] != nil {
			arg0 = args[0].(*flow.ExecutionReceipt)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ExecutionTree_HasReceipt_Call) Return(b bool) *ExecutionTree_HasReceipt_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *ExecutionTree_HasReceipt_Call) RunAndReturn(run func(receipt *flow.ExecutionReceipt) bool) *ExecutionTree_HasReceipt_Call {
	_c.Call.Return(run)
	return _c
}

// LowestHeight provides a mock function for the type ExecutionTree
func (_mock *ExecutionTree) LowestHeight() uint64 {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for LowestHeight")
	}

	var r0 uint64
	if returnFunc, ok := ret.Get(0).(func() uint64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint64)
	}
	return r0
}

// ExecutionTree_LowestHeight_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LowestHeight'
type ExecutionTree_LowestHeight_Call struct {
	*mock.Call
}

// LowestHeight is a helper method to define mock.On call
func (_e *ExecutionTree_Expecter) LowestHeight() *ExecutionTree_LowestHeight_Call {
	return &ExecutionTree_LowestHeight_Call{Call: _e.mock.On("LowestHeight")}
}

func (_c *ExecutionTree_LowestHeight_Call) Run(run func()) *ExecutionTree_LowestHeight_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ExecutionTree_LowestHeight_Call) Return(v uint64) *ExecutionTree_LowestHeight_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *ExecutionTree_LowestHeight_Call) RunAndReturn(run func() uint64) *ExecutionTree_LowestHeight_Call {
	_c.Call.Return(run)
	return _c
}

// PruneUpToHeight provides a mock function for the type ExecutionTree
func (_mock *ExecutionTree) PruneUpToHeight(newLowestHeight uint64) error {
	ret := _mock.Called(newLowestHeight)

	if len(ret) == 0 {
		panic("no return value specified for PruneUpToHeight")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(uint64) error); ok {
		r0 = returnFunc(newLowestHeight)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ExecutionTree_PruneUpToHeight_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PruneUpToHeight'
type ExecutionTree_PruneUpToHeight_Call struct {
	*mock.Call
}

// PruneUpToHeight is a helper method to define mock.On call
//   - newLowestHeight uint64
func (_e *ExecutionTree_Expecter) PruneUpToHeight(newLowestHeight interface{}) *ExecutionTree_PruneUpToHeight_Call {
	return &ExecutionTree_PruneUpToHeight_Call{Call: _e.mock.On("PruneUpToHeight", newLowestHeight)}
}

func (_c *ExecutionTree_PruneUpToHeight_Call) Run(run func(newLowestHeight uint64)) *ExecutionTree_PruneUpToHeight_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ExecutionTree_PruneUpToHeight_Call) Return(err error) *ExecutionTree_PruneUpToHeight_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ExecutionTree_PruneUpToHeight_Call) RunAndReturn(run func(newLowestHeight uint64) error) *ExecutionTree_PruneUpToHeight_Call {
	_c.Call.Return(run)
	return _c
}

// ReachableReceipts provides a mock function for the type ExecutionTree
func (_mock *ExecutionTree) ReachableReceipts(resultID flow.Identifier, blockFilter mempool.BlockFilter, receiptFilter mempool.ReceiptFilter) ([]*flow.ExecutionReceipt, error) {
	ret := _mock.Called(resultID, blockFilter, receiptFilter)

	if len(ret) == 0 {
		panic("no return value specified for ReachableReceipts")
	}

	var r0 []*flow.ExecutionReceipt
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, mempool.BlockFilter, mempool.ReceiptFilter) ([]*flow.ExecutionReceipt, error)); ok {
		return returnFunc(resultID, blockFilter, receiptFilter)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, mempool.BlockFilter, mempool.ReceiptFilter) []*flow.ExecutionReceipt); ok {
		r0 = returnFunc(resultID, blockFilter, receiptFilter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*flow.ExecutionReceipt)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier, mempool.BlockFilter, mempool.ReceiptFilter) error); ok {
		r1 = returnFunc(resultID, blockFilter, receiptFilter)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ExecutionTree_ReachableReceipts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReachableReceipts'
type ExecutionTree_ReachableReceipts_Call struct {
	*mock.Call
}

// ReachableReceipts is a helper method to define mock.On call
//   - resultID flow.Identifier
//   - blockFilter mempool.BlockFilter
//   - receiptFilter mempool.ReceiptFilter
func (_e *ExecutionTree_Expecter) ReachableReceipts(resultID interface{}, blockFilter interface{}, receiptFilter interface{}) *ExecutionTree_ReachableReceipts_Call {
	return &ExecutionTree_ReachableReceipts_Call{Call: _e.mock.On("ReachableReceipts", resultID, blockFilter, receiptFilter)}
}

func (_c *ExecutionTree_ReachableReceipts_Call) Run(run func(resultID flow.Identifier, blockFilter mempool.BlockFilter, receiptFilter mempool.ReceiptFilter)) *ExecutionTree_ReachableReceipts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		var arg1 mempool.BlockFilter
		if args[1] != nil {
			arg1 = args[1].(mempool.BlockFilter)
		}
		var arg2 mempool.ReceiptFilter
		if args[2] != nil {
			arg2 = args[2].(mempool.ReceiptFilter)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *ExecutionTree_ReachableReceipts_Call) Return(executionReceipts []*flow.ExecutionReceipt, err error) *ExecutionTree_ReachableReceipts_Call {
	_c.Call.Return(executionReceipts, err)
	return _c
}

func (_c *ExecutionTree_ReachableReceipts_Call) RunAndReturn(run func(resultID flow.Identifier, blockFilter mempool.BlockFilter, receiptFilter mempool.ReceiptFilter) ([]*flow.ExecutionReceipt, error)) *ExecutionTree_ReachableReceipts_Call {
	_c.Call.Return(run)
	return _c
}

// Size provides a mock function for the type ExecutionTree
func (_mock *ExecutionTree) Size() uint {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Size")
	}

	var r0 uint
	if returnFunc, ok := ret.Get(0).(func() uint); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint)
	}
	return r0
}

// ExecutionTree_Size_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Size'
type ExecutionTree_Size_Call struct {
	*mock.Call
}

// Size is a helper method to define mock.On call
func (_e *ExecutionTree_Expecter) Size() *ExecutionTree_Size_Call {
	return &ExecutionTree_Size_Call{Call: _e.mock.On("Size")}
}

func (_c *ExecutionTree_Size_Call) Run(run func()) *ExecutionTree_Size_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ExecutionTree_Size_Call) Return(v uint) *ExecutionTree_Size_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *ExecutionTree_Size_Call) RunAndReturn(run func() uint) *ExecutionTree_Size_Call {
	_c.Call.Return(run)
	return _c
}

// NewGuarantees creates a new instance of Guarantees. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewGuarantees(t interface {
	mock.TestingT
	Cleanup(func())
}) *Guarantees {
	mock := &Guarantees{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Guarantees is an autogenerated mock type for the Guarantees type
type Guarantees struct {
	mock.Mock
}

type Guarantees_Expecter struct {
	mock *mock.Mock
}

func (_m *Guarantees) EXPECT() *Guarantees_Expecter {
	return &Guarantees_Expecter{mock: &_m.Mock}
}

// Add provides a mock function for the type Guarantees
func (_mock *Guarantees) Add(identifier flow.Identifier, collectionGuarantee *flow.CollectionGuarantee) bool {
	ret := _mock.Called(identifier, collectionGuarantee)

	if len(ret) == 0 {
		panic("no return value specified for Add")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, *flow.CollectionGuarantee) bool); ok {
		r0 = returnFunc(identifier, collectionGuarantee)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// Guarantees_Add_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Add'
type Guarantees_Add_Call struct {
	*mock.Call
}

// Add is a helper method to define mock.On call
//   - identifier flow.Identifier
//   - collectionGuarantee *flow.CollectionGuarantee
func (_e *Guarantees_Expecter) Add(identifier interface{}, collectionGuarantee interface{}) *Guarantees_Add_Call {
	return &Guarantees_Add_Call{Call: _e.mock.On("Add", identifier, collectionGuarantee)}
}

func (_c *Guarantees_Add_Call) Run(run func(identifier flow.Identifier, collectionGuarantee *flow.CollectionGuarantee)) *Guarantees_Add_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		var arg1 *flow.CollectionGuarantee
		if args[1] != nil {
			arg1 = args[1].(*flow.CollectionGuarantee)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Guarantees_Add_Call) Return(b bool) *Guarantees_Add_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *Guarantees_Add_Call) RunAndReturn(run func(identifier flow.Identifier, collectionGuarantee *flow.CollectionGuarantee) bool) *Guarantees_Add_Call {
	_c.Call.Return(run)
	return _c
}

// Adjust provides a mock function for the type Guarantees
func (_mock *Guarantees) Adjust(key flow.Identifier, f func(*flow.CollectionGuarantee) *flow.CollectionGuarantee) (*flow.CollectionGuarantee, bool) {
	ret := _mock.Called(key, f)

	if len(ret) == 0 {
		panic("no return value specified for Adjust")
	}

	var r0 *flow.CollectionGuarantee
	var r1 bool
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, func(*flow.CollectionGuarantee) *flow.CollectionGuarantee) (*flow.CollectionGuarantee, bool)); ok {
		return returnFunc(key, f)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, func(*flow.CollectionGuarantee) *flow.CollectionGuarantee) *flow.CollectionGuarantee); ok {
		r0 = returnFunc(key, f)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.CollectionGuarantee)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier, func(*flow.CollectionGuarantee) *flow.CollectionGuarantee) bool); ok {
		r1 = returnFunc(key, f)
	} else {
		r1 = ret.Get(1).(bool)
	}
	return r0, r1
}

// Guarantees_Adjust_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Adjust'
type Guarantees_Adjust_Call struct {
	*mock.Call
}

// Adjust is a helper method to define mock.On call
//   - key flow.Identifier
//   - f func(*flow.CollectionGuarantee) *flow.CollectionGuarantee
func (_e *Guarantees_Expecter) Adjust(key interface{}, f interface{}) *Guarantees_Adjust_Call {
	return &Guarantees_Adjust_Call{Call: _e.mock.On("Adjust", key, f)}
}

func (_c *Guarantees_Adjust_Call) Run(run func(key flow.Identifier, f func(*flow.CollectionGuarantee) *flow.CollectionGuarantee)) *Guarantees_Adjust_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		var arg1 func(*flow.CollectionGuarantee) *flow.CollectionGuarantee
		if args[1] != nil {
			arg1 = args[1].(func(*flow.CollectionGuarantee) *flow.CollectionGuarantee)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Guarantees_Adjust_Call) Return(collectionGuarantee *flow.CollectionGuarantee, b bool) *Guarantees_Adjust_Call {
	_c.Call.Return(collectionGuarantee, b)
	return _c
}

func (_c *Guarantees_Adjust_Call) RunAndReturn(run func(key flow.Identifier, f func(*flow.CollectionGuarantee) *flow.CollectionGuarantee) (*flow.CollectionGuarantee, bool)) *Guarantees_Adjust_Call {
	_c.Call.Return(run)
	return _c
}

// All provides a mock function for the type Guarantees
func (_mock *Guarantees) All() map[flow.Identifier]*flow.CollectionGuarantee {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for All")
	}

	var r0 map[flow.Identifier]*flow.CollectionGuarantee
	if returnFunc, ok := ret.Get(0).(func() map[flow.Identifier]*flow.CollectionGuarantee); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[flow.Identifier]*flow.CollectionGuarantee)
		}
	}
	return r0
}

// Guarantees_All_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'All'
type Guarantees_All_Call struct {
	*mock.Call
}

// All is a helper method to define mock.On call
func (_e *Guarantees_Expecter) All() *Guarantees_All_Call {
	return &Guarantees_All_Call{Call: _e.mock.On("All")}
}

func (_c *Guarantees_All_Call) Run(run func()) *Guarantees_All_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Guarantees_All_Call) Return(identifierToCollectionGuarantee map[flow.Identifier]*flow.CollectionGuarantee) *Guarantees_All_Call {
	_c.Call.Return(identifierToCollectionGuarantee)
	return _c
}

func (_c *Guarantees_All_Call) RunAndReturn(run func() map[flow.Identifier]*flow.CollectionGuarantee) *Guarantees_All_Call {
	_c.Call.Return(run)
	return _c
}

// Clear provides a mock function for the type Guarantees
func (_mock *Guarantees) Clear() {
	_mock.Called()
	return
}

// Guarantees_Clear_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Clear'
type Guarantees_Clear_Call struct {
	*mock.Call
}

// Clear is a helper method to define mock.On call
func (_e *Guarantees_Expecter) Clear() *Guarantees_Clear_Call {
	return &Guarantees_Clear_Call{Call: _e.mock.On("Clear")}
}

func (_c *Guarantees_Clear_Call) Run(run func()) *Guarantees_Clear_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Guarantees_Clear_Call) Return() *Guarantees_Clear_Call {
	_c.Call.Return()
	return _c
}

func (_c *Guarantees_Clear_Call) RunAndReturn(run func()) *Guarantees_Clear_Call {
	_c.Run(run)
	return _c
}

// Get provides a mock function for the type Guarantees
func (_mock *Guarantees) Get(identifier flow.Identifier) (*flow.CollectionGuarantee, bool) {
	ret := _mock.Called(identifier)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *flow.CollectionGuarantee
	var r1 bool
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (*flow.CollectionGuarantee, bool)); ok {
		return returnFunc(identifier)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) *flow.CollectionGuarantee); ok {
		r0 = returnFunc(identifier)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.CollectionGuarantee)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) bool); ok {
		r1 = returnFunc(identifier)
	} else {
		r1 = ret.Get(1).(bool)
	}
	return r0, r1
}

// Guarantees_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type Guarantees_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - identifier flow.Identifier
func (_e *Guarantees_Expecter) Get(identifier interface{}) *Guarantees_Get_Call {
	return &Guarantees_Get_Call{Call: _e.mock.On("Get", identifier)}
}

func (_c *Guarantees_Get_Call) Run(run func(identifier flow.Identifier)) *Guarantees_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Guarantees_Get_Call) Return(collectionGuarantee *flow.CollectionGuarantee, b bool) *Guarantees_Get_Call {
	_c.Call.Return(collectionGuarantee, b)
	return _c
}

func (_c *Guarantees_Get_Call) RunAndReturn(run func(identifier flow.Identifier) (*flow.CollectionGuarantee, bool)) *Guarantees_Get_Call {
	_c.Call.Return(run)
	return _c
}

// Has provides a mock function for the type Guarantees
func (_mock *Guarantees) Has(identifier flow.Identifier) bool {
	ret := _mock.Called(identifier)

	if len(ret) == 0 {
		panic("no return value specified for Has")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) bool); ok {
		r0 = returnFunc(identifier)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// Guarantees_Has_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Has'
type Guarantees_Has_Call struct {
	*mock.Call
}

// Has is a helper method to define mock.On call
//   - identifier flow.Identifier
func (_e *Guarantees_Expecter) Has(identifier interface{}) *Guarantees_Has_Call {
	return &Guarantees_Has_Call{Call: _e.mock.On("Has", identifier)}
}

func (_c *Guarantees_Has_Call) Run(run func(identifier flow.Identifier)) *Guarantees_Has_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Guarantees_Has_Call) Return(b bool) *Guarantees_Has_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *Guarantees_Has_Call) RunAndReturn(run func(identifier flow.Identifier) bool) *Guarantees_Has_Call {
	_c.Call.Return(run)
	return _c
}

// Remove provides a mock function for the type Guarantees
func (_mock *Guarantees) Remove(identifier flow.Identifier) bool {
	ret := _mock.Called(identifier)

	if len(ret) == 0 {
		panic("no return value specified for Remove")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) bool); ok {
		r0 = returnFunc(identifier)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// Guarantees_Remove_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Remove'
type Guarantees_Remove_Call struct {
	*mock.Call
}

// Remove is a helper method to define mock.On call
//   - identifier flow.Identifier
func (_e *Guarantees_Expecter) Remove(identifier interface{}) *Guarantees_Remove_Call {
	return &Guarantees_Remove_Call{Call: _e.mock.On("Remove", identifier)}
}

func (_c *Guarantees_Remove_Call) Run(run func(identifier flow.Identifier)) *Guarantees_Remove_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Guarantees_Remove_Call) Return(b bool) *Guarantees_Remove_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *Guarantees_Remove_Call) RunAndReturn(run func(identifier flow.Identifier) bool) *Guarantees_Remove_Call {
	_c.Call.Return(run)
	return _c
}

// Size provides a mock function for the type Guarantees
func (_mock *Guarantees) Size() uint {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Size")
	}

	var r0 uint
	if returnFunc, ok := ret.Get(0).(func() uint); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint)
	}
	return r0
}

// Guarantees_Size_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Size'
type Guarantees_Size_Call struct {
	*mock.Call
}

// Size is a helper method to define mock.On call
func (_e *Guarantees_Expecter) Size() *Guarantees_Size_Call {
	return &Guarantees_Size_Call{Call: _e.mock.On("Size")}
}

func (_c *Guarantees_Size_Call) Run(run func()) *Guarantees_Size_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Guarantees_Size_Call) Return(v uint) *Guarantees_Size_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *Guarantees_Size_Call) RunAndReturn(run func() uint) *Guarantees_Size_Call {
	_c.Call.Return(run)
	return _c
}

// Values provides a mock function for the type Guarantees
func (_mock *Guarantees) Values() []*flow.CollectionGuarantee {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Values")
	}

	var r0 []*flow.CollectionGuarantee
	if returnFunc, ok := ret.Get(0).(func() []*flow.CollectionGuarantee); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*flow.CollectionGuarantee)
		}
	}
	return r0
}

// Guarantees_Values_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Values'
type Guarantees_Values_Call struct {
	*mock.Call
}

// Values is a helper method to define mock.On call
func (_e *Guarantees_Expecter) Values() *Guarantees_Values_Call {
	return &Guarantees_Values_Call{Call: _e.mock.On("Values")}
}

func (_c *Guarantees_Values_Call) Run(run func()) *Guarantees_Values_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Guarantees_Values_Call) Return(collectionGuarantees []*flow.CollectionGuarantee) *Guarantees_Values_Call {
	_c.Call.Return(collectionGuarantees)
	return _c
}

func (_c *Guarantees_Values_Call) RunAndReturn(run func() []*flow.CollectionGuarantee) *Guarantees_Values_Call {
	_c.Call.Return(run)
	return _c
}

// NewIdentifierMap creates a new instance of IdentifierMap. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIdentifierMap(t interface {
	mock.TestingT
	Cleanup(func())
}) *IdentifierMap {
	mock := &IdentifierMap{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// IdentifierMap is an autogenerated mock type for the IdentifierMap type
type IdentifierMap struct {
	mock.Mock
}

type IdentifierMap_Expecter struct {
	mock *mock.Mock
}

func (_m *IdentifierMap) EXPECT() *IdentifierMap_Expecter {
	return &IdentifierMap_Expecter{mock: &_m.Mock}
}

// Append provides a mock function for the type IdentifierMap
func (_mock *IdentifierMap) Append(key flow.Identifier, id flow.Identifier) {
	_mock.Called(key, id)
	return
}

// IdentifierMap_Append_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Append'
type IdentifierMap_Append_Call struct {
	*mock.Call
}

// Append is a helper method to define mock.On call
//   - key flow.Identifier
//   - id flow.Identifier
func (_e *IdentifierMap_Expecter) Append(key interface{}, id interface{}) *IdentifierMap_Append_Call {
	return &IdentifierMap_Append_Call{Call: _e.mock.On("Append", key, id)}
}

func (_c *IdentifierMap_Append_Call) Run(run func(key flow.Identifier, id flow.Identifier)) *IdentifierMap_Append_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		var arg1 flow.Identifier
		if args[1] != nil {
			arg1 = args[1].(flow.Identifier)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *IdentifierMap_Append_Call) Return() *IdentifierMap_Append_Call {
	_c.Call.Return()
	return _c
}

func (_c *IdentifierMap_Append_Call) RunAndReturn(run func(key flow.Identifier, id flow.Identifier)) *IdentifierMap_Append_Call {
	_c.Run(run)
	return _c
}

// Get provides a mock function for the type IdentifierMap
func (_mock *IdentifierMap) Get(key flow.Identifier) (flow.IdentifierList, bool) {
	ret := _mock.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 flow.IdentifierList
	var r1 bool
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (flow.IdentifierList, bool)); ok {
		return returnFunc(key)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) flow.IdentifierList); ok {
		r0 = returnFunc(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.IdentifierList)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) bool); ok {
		r1 = returnFunc(key)
	} else {
		r1 = ret.Get(1).(bool)
	}
	return r0, r1
}

// IdentifierMap_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type IdentifierMap_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - key flow.Identifier
func (_e *IdentifierMap_Expecter) Get(key interface{}) *IdentifierMap_Get_Call {
	return &IdentifierMap_Get_Call{Call: _e.mock.On("Get", key)}
}

func (_c *IdentifierMap_Get_Call) Run(run func(key flow.Identifier)) *IdentifierMap_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *IdentifierMap_Get_Call) Return(identifierList flow.IdentifierList, b bool) *IdentifierMap_Get_Call {
	_c.Call.Return(identifierList, b)
	return _c
}

func (_c *IdentifierMap_Get_Call) RunAndReturn(run func(key flow.Identifier) (flow.IdentifierList, bool)) *IdentifierMap_Get_Call {
	_c.Call.Return(run)
	return _c
}

// Has provides a mock function for the type IdentifierMap
func (_mock *IdentifierMap) Has(key flow.Identifier) bool {
	ret := _mock.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for Has")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) bool); ok {
		r0 = returnFunc(key)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// IdentifierMap_Has_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Has'
type IdentifierMap_Has_Call struct {
	*mock.Call
}

// Has is a helper method to define mock.On call
//   - key flow.Identifier
func (_e *IdentifierMap_Expecter) Has(key interface{}) *IdentifierMap_Has_Call {
	return &IdentifierMap_Has_Call{Call: _e.mock.On("Has", key)}
}

func (_c *IdentifierMap_Has_Call) Run(run func(key flow.Identifier)) *IdentifierMap_Has_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *IdentifierMap_Has_Call) Return(b bool) *IdentifierMap_Has_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *IdentifierMap_Has_Call) RunAndReturn(run func(key flow.Identifier) bool) *IdentifierMap_Has_Call {
	_c.Call.Return(run)
	return _c
}

// Keys provides a mock function for the type IdentifierMap
func (_mock *IdentifierMap) Keys() (flow.IdentifierList, bool) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Keys")
	}

	var r0 flow.IdentifierList
	var r1 bool
	if returnFunc, ok := ret.Get(0).(func() (flow.IdentifierList, bool)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() flow.IdentifierList); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flow.IdentifierList)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() bool); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Get(1).(bool)
	}
	return r0, r1
}

// IdentifierMap_Keys_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Keys'
type IdentifierMap_Keys_Call struct {
	*mock.Call
}

// Keys is a helper method to define mock.On call
func (_e *IdentifierMap_Expecter) Keys() *IdentifierMap_Keys_Call {
	return &IdentifierMap_Keys_Call{Call: _e.mock.On("Keys")}
}

func (_c *IdentifierMap_Keys_Call) Run(run func()) *IdentifierMap_Keys_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *IdentifierMap_Keys_Call) Return(identifierList flow.IdentifierList, b bool) *IdentifierMap_Keys_Call {
	_c.Call.Return(identifierList, b)
	return _c
}

func (_c *IdentifierMap_Keys_Call) RunAndReturn(run func() (flow.IdentifierList, bool)) *IdentifierMap_Keys_Call {
	_c.Call.Return(run)
	return _c
}

// Remove provides a mock function for the type IdentifierMap
func (_mock *IdentifierMap) Remove(key flow.Identifier) bool {
	ret := _mock.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for Remove")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) bool); ok {
		r0 = returnFunc(key)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// IdentifierMap_Remove_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Remove'
type IdentifierMap_Remove_Call struct {
	*mock.Call
}

// Remove is a helper method to define mock.On call
//   - key flow.Identifier
func (_e *IdentifierMap_Expecter) Remove(key interface{}) *IdentifierMap_Remove_Call {
	return &IdentifierMap_Remove_Call{Call: _e.mock.On("Remove", key)}
}

func (_c *IdentifierMap_Remove_Call) Run(run func(key flow.Identifier)) *IdentifierMap_Remove_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *IdentifierMap_Remove_Call) Return(b bool) *IdentifierMap_Remove_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *IdentifierMap_Remove_Call) RunAndReturn(run func(key flow.Identifier) bool) *IdentifierMap_Remove_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveIdFromKey provides a mock function for the type IdentifierMap
func (_mock *IdentifierMap) RemoveIdFromKey(key flow.Identifier, id flow.Identifier) error {
	ret := _mock.Called(key, id)

	if len(ret) == 0 {
		panic("no return value specified for RemoveIdFromKey")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, flow.Identifier) error); ok {
		r0 = returnFunc(key, id)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// IdentifierMap_RemoveIdFromKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveIdFromKey'
type IdentifierMap_RemoveIdFromKey_Call struct {
	*mock.Call
}

// RemoveIdFromKey is a helper method to define mock.On call
//   - key flow.Identifier
//   - id flow.Identifier
func (_e *IdentifierMap_Expecter) RemoveIdFromKey(key interface{}, id interface{}) *IdentifierMap_RemoveIdFromKey_Call {
	return &IdentifierMap_RemoveIdFromKey_Call{Call: _e.mock.On("RemoveIdFromKey", key, id)}
}

func (_c *IdentifierMap_RemoveIdFromKey_Call) Run(run func(key flow.Identifier, id flow.Identifier)) *IdentifierMap_RemoveIdFromKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		var arg1 flow.Identifier
		if args[1] != nil {
			arg1 = args[1].(flow.Identifier)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *IdentifierMap_RemoveIdFromKey_Call) Return(err error) *IdentifierMap_RemoveIdFromKey_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *IdentifierMap_RemoveIdFromKey_Call) RunAndReturn(run func(key flow.Identifier, id flow.Identifier) error) *IdentifierMap_RemoveIdFromKey_Call {
	_c.Call.Return(run)
	return _c
}

// Size provides a mock function for the type IdentifierMap
func (_mock *IdentifierMap) Size() uint {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Size")
	}

	var r0 uint
	if returnFunc, ok := ret.Get(0).(func() uint); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint)
	}
	return r0
}

// IdentifierMap_Size_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Size'
type IdentifierMap_Size_Call struct {
	*mock.Call
}

// Size is a helper method to define mock.On call
func (_e *IdentifierMap_Expecter) Size() *IdentifierMap_Size_Call {
	return &IdentifierMap_Size_Call{Call: _e.mock.On("Size")}
}

func (_c *IdentifierMap_Size_Call) Run(run func()) *IdentifierMap_Size_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *IdentifierMap_Size_Call) Return(v uint) *IdentifierMap_Size_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *IdentifierMap_Size_Call) RunAndReturn(run func() uint) *IdentifierMap_Size_Call {
	_c.Call.Return(run)
	return _c
}

// NewIncorporatedResultSeals creates a new instance of IncorporatedResultSeals. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIncorporatedResultSeals(t interface {
	mock.TestingT
	Cleanup(func())
}) *IncorporatedResultSeals {
	mock := &IncorporatedResultSeals{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// IncorporatedResultSeals is an autogenerated mock type for the IncorporatedResultSeals type
type IncorporatedResultSeals struct {
	mock.Mock
}

type IncorporatedResultSeals_Expecter struct {
	mock *mock.Mock
}

func (_m *IncorporatedResultSeals) EXPECT() *IncorporatedResultSeals_Expecter {
	return &IncorporatedResultSeals_Expecter{mock: &_m.Mock}
}

// Add provides a mock function for the type IncorporatedResultSeals
func (_mock *IncorporatedResultSeals) Add(irSeal *flow.IncorporatedResultSeal) (bool, error) {
	ret := _mock.Called(irSeal)

	if len(ret) == 0 {
		panic("no return value specified for Add")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*flow.IncorporatedResultSeal) (bool, error)); ok {
		return returnFunc(irSeal)
	}
	if returnFunc, ok := ret.Get(0).(func(*flow.IncorporatedResultSeal) bool); ok {
		r0 = returnFunc(irSeal)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(*flow.IncorporatedResultSeal) error); ok {
		r1 = returnFunc(irSeal)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// IncorporatedResultSeals_Add_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Add'
type IncorporatedResultSeals_Add_Call struct {
	*mock.Call
}

// Add is a helper method to define mock.On call
//   - irSeal *flow.IncorporatedResultSeal
func (_e *IncorporatedResultSeals_Expecter) Add(irSeal interface{}) *IncorporatedResultSeals_Add_Call {
	return &IncorporatedResultSeals_Add_Call{Call: _e.mock.On("Add", irSeal)}
}

func (_c *IncorporatedResultSeals_Add_Call) Run(run func(irSeal *flow.IncorporatedResultSeal)) *IncorporatedResultSeals_Add_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *flow.IncorporatedResultSeal
		if args[0] != nil {
			arg0 = args[0].(*flow.IncorporatedResultSeal)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *IncorporatedResultSeals_Add_Call) Return(b bool, err error) *IncorporatedResultSeals_Add_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *IncorporatedResultSeals_Add_Call) RunAndReturn(run func(irSeal *flow.IncorporatedResultSeal) (bool, error)) *IncorporatedResultSeals_Add_Call {
	_c.Call.Return(run)
	return _c
}

// All provides a mock function for the type IncorporatedResultSeals
func (_mock *IncorporatedResultSeals) All() []*flow.IncorporatedResultSeal {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for All")
	}

	var r0 []*flow.IncorporatedResultSeal
	if returnFunc, ok := ret.Get(0).(func() []*flow.IncorporatedResultSeal); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*flow.IncorporatedResultSeal)
		}
	}
	return r0
}

// IncorporatedResultSeals_All_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'All'
type IncorporatedResultSeals_All_Call struct {
	*mock.Call
}

// All is a helper method to define mock.On call
func (_e *IncorporatedResultSeals_Expecter) All() *IncorporatedResultSeals_All_Call {
	return &IncorporatedResultSeals_All_Call{Call: _e.mock.On("All")}
}

func (_c *IncorporatedResultSeals_All_Call) Run(run func()) *IncorporatedResultSeals_All_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *IncorporatedResultSeals_All_Call) Return(incorporatedResultSeals []*flow.IncorporatedResultSeal) *IncorporatedResultSeals_All_Call {
	_c.Call.Return(incorporatedResultSeals)
	return _c
}

func (_c *IncorporatedResultSeals_All_Call) RunAndReturn(run func() []*flow.IncorporatedResultSeal) *IncorporatedResultSeals_All_Call {
	_c.Call.Return(run)
	return _c
}

// Clear provides a mock function for the type IncorporatedResultSeals
func (_mock *IncorporatedResultSeals) Clear() {
	_mock.Called()
	return
}

// IncorporatedResultSeals_Clear_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Clear'
type IncorporatedResultSeals_Clear_Call struct {
	*mock.Call
}

// Clear is a helper method to define mock.On call
func (_e *IncorporatedResultSeals_Expecter) Clear() *IncorporatedResultSeals_Clear_Call {
	return &IncorporatedResultSeals_Clear_Call{Call: _e.mock.On("Clear")}
}

func (_c *IncorporatedResultSeals_Clear_Call) Run(run func()) *IncorporatedResultSeals_Clear_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *IncorporatedResultSeals_Clear_Call) Return() *IncorporatedResultSeals_Clear_Call {
	_c.Call.Return()
	return _c
}

func (_c *IncorporatedResultSeals_Clear_Call) RunAndReturn(run func()) *IncorporatedResultSeals_Clear_Call {
	_c.Run(run)
	return _c
}

// Get provides a mock function for the type IncorporatedResultSeals
func (_mock *IncorporatedResultSeals) Get(identifier flow.Identifier) (*flow.IncorporatedResultSeal, bool) {
	ret := _mock.Called(identifier)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *flow.IncorporatedResultSeal
	var r1 bool
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (*flow.IncorporatedResultSeal, bool)); ok {
		return returnFunc(identifier)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) *flow.IncorporatedResultSeal); ok {
		r0 = returnFunc(identifier)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.IncorporatedResultSeal)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) bool); ok {
		r1 = returnFunc(identifier)
	} else {
		r1 = ret.Get(1).(bool)
	}
	return r0, r1
}

// IncorporatedResultSeals_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type IncorporatedResultSeals_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - identifier flow.Identifier
func (_e *IncorporatedResultSeals_Expecter) Get(identifier interface{}) *IncorporatedResultSeals_Get_Call {
	return &IncorporatedResultSeals_Get_Call{Call: _e.mock.On("Get", identifier)}
}

func (_c *IncorporatedResultSeals_Get_Call) Run(run func(identifier flow.Identifier)) *IncorporatedResultSeals_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *IncorporatedResultSeals_Get_Call) Return(incorporatedResultSeal *flow.IncorporatedResultSeal, b bool) *IncorporatedResultSeals_Get_Call {
	_c.Call.Return(incorporatedResultSeal, b)
	return _c
}

func (_c *IncorporatedResultSeals_Get_Call) RunAndReturn(run func(identifier flow.Identifier) (*flow.IncorporatedResultSeal, bool)) *IncorporatedResultSeals_Get_Call {
	_c.Call.Return(run)
	return _c
}

// Limit provides a mock function for the type IncorporatedResultSeals
func (_mock *IncorporatedResultSeals) Limit() uint {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Limit")
	}

	var r0 uint
	if returnFunc, ok := ret.Get(0).(func() uint); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint)
	}
	return r0
}

// IncorporatedResultSeals_Limit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Limit'
type IncorporatedResultSeals_Limit_Call struct {
	*mock.Call
}

// Limit is a helper method to define mock.On call
func (_e *IncorporatedResultSeals_Expecter) Limit() *IncorporatedResultSeals_Limit_Call {
	return &IncorporatedResultSeals_Limit_Call{Call: _e.mock.On("Limit")}
}

func (_c *IncorporatedResultSeals_Limit_Call) Run(run func()) *IncorporatedResultSeals_Limit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *IncorporatedResultSeals_Limit_Call) Return(v uint) *IncorporatedResultSeals_Limit_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *IncorporatedResultSeals_Limit_Call) RunAndReturn(run func() uint) *IncorporatedResultSeals_Limit_Call {
	_c.Call.Return(run)
	return _c
}

// PruneUpToHeight provides a mock function for the type IncorporatedResultSeals
func (_mock *IncorporatedResultSeals) PruneUpToHeight(height uint64) error {
	ret := _mock.Called(height)

	if len(ret) == 0 {
		panic("no return value specified for PruneUpToHeight")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(uint64) error); ok {
		r0 = returnFunc(height)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// IncorporatedResultSeals_PruneUpToHeight_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PruneUpToHeight'
type IncorporatedResultSeals_PruneUpToHeight_Call struct {
	*mock.Call
}

// PruneUpToHeight is a helper method to define mock.On call
//   - height uint64
func (_e *IncorporatedResultSeals_Expecter) PruneUpToHeight(height interface{}) *IncorporatedResultSeals_PruneUpToHeight_Call {
	return &IncorporatedResultSeals_PruneUpToHeight_Call{Call: _e.mock.On("PruneUpToHeight", height)}
}

func (_c *IncorporatedResultSeals_PruneUpToHeight_Call) Run(run func(height uint64)) *IncorporatedResultSeals_PruneUpToHeight_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *IncorporatedResultSeals_PruneUpToHeight_Call) Return(err error) *IncorporatedResultSeals_PruneUpToHeight_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *IncorporatedResultSeals_PruneUpToHeight_Call) RunAndReturn(run func(height uint64) error) *IncorporatedResultSeals_PruneUpToHeight_Call {
	_c.Call.Return(run)
	return _c
}

// Remove provides a mock function for the type IncorporatedResultSeals
func (_mock *IncorporatedResultSeals) Remove(incorporatedResultID flow.Identifier) bool {
	ret := _mock.Called(incorporatedResultID)

	if len(ret) == 0 {
		panic("no return value specified for Remove")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) bool); ok {
		r0 = returnFunc(incorporatedResultID)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// IncorporatedResultSeals_Remove_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Remove'
type IncorporatedResultSeals_Remove_Call struct {
	*mock.Call
}

// Remove is a helper method to define mock.On call
//   - incorporatedResultID flow.Identifier
func (_e *IncorporatedResultSeals_Expecter) Remove(incorporatedResultID interface{}) *IncorporatedResultSeals_Remove_Call {
	return &IncorporatedResultSeals_Remove_Call{Call: _e.mock.On("Remove", incorporatedResultID)}
}

func (_c *IncorporatedResultSeals_Remove_Call) Run(run func(incorporatedResultID flow.Identifier)) *IncorporatedResultSeals_Remove_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *IncorporatedResultSeals_Remove_Call) Return(b bool) *IncorporatedResultSeals_Remove_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *IncorporatedResultSeals_Remove_Call) RunAndReturn(run func(incorporatedResultID flow.Identifier) bool) *IncorporatedResultSeals_Remove_Call {
	_c.Call.Return(run)
	return _c
}

// Size provides a mock function for the type IncorporatedResultSeals
func (_mock *IncorporatedResultSeals) Size() uint {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Size")
	}

	var r0 uint
	if returnFunc, ok := ret.Get(0).(func() uint); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint)
	}
	return r0
}

// IncorporatedResultSeals_Size_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Size'
type IncorporatedResultSeals_Size_Call struct {
	*mock.Call
}

// Size is a helper method to define mock.On call
func (_e *IncorporatedResultSeals_Expecter) Size() *IncorporatedResultSeals_Size_Call {
	return &IncorporatedResultSeals_Size_Call{Call: _e.mock.On("Size")}
}

func (_c *IncorporatedResultSeals_Size_Call) Run(run func()) *IncorporatedResultSeals_Size_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *IncorporatedResultSeals_Size_Call) Return(v uint) *IncorporatedResultSeals_Size_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *IncorporatedResultSeals_Size_Call) RunAndReturn(run func() uint) *IncorporatedResultSeals_Size_Call {
	_c.Call.Return(run)
	return _c
}

// NewMempool creates a new instance of Mempool. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMempool[K comparable, V any](t interface {
	mock.TestingT
	Cleanup(func())
}) *Mempool[K, V] {
	mock := &Mempool[K, V]{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Mempool is an autogenerated mock type for the Mempool type
type Mempool[K comparable, V any] struct {
	mock.Mock
}

type Mempool_Expecter[K comparable, V any] struct {
	mock *mock.Mock
}

func (_m *Mempool[K, V]) EXPECT() *Mempool_Expecter[K, V] {
	return &Mempool_Expecter[K, V]{mock: &_m.Mock}
}

// Add provides a mock function for the type Mempool
func (_mock *Mempool[K, V]) Add(v K, v1 V) bool {
	ret := _mock.Called(v, v1)

	if len(ret) == 0 {
		panic("no return value specified for Add")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(K, V) bool); ok {
		r0 = returnFunc(v, v1)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// Mempool_Add_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Add'
type Mempool_Add_Call[K comparable, V any] struct {
	*mock.Call
}

// Add is a helper method to define mock.On call
//   - v K
//   - v1 V
func (_e *Mempool_Expecter[K, V]) Add(v interface{}, v1 interface{}) *Mempool_Add_Call[K, V] {
	return &Mempool_Add_Call[K, V]{Call: _e.mock.On("Add", v, v1)}
}

func (_c *Mempool_Add_Call[K, V]) Run(run func(v K, v1 V)) *Mempool_Add_Call[K, V] {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 K
		if args[0] != nil {
			arg0 = args[0].(K)
		}
		var arg1 V
		if args[1] != nil {
			arg1 = args[1].(V)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Mempool_Add_Call[K, V]) Return(b bool) *Mempool_Add_Call[K, V] {
	_c.Call.Return(b)
	return _c
}

func (_c *Mempool_Add_Call[K, V]) RunAndReturn(run func(v K, v1 V) bool) *Mempool_Add_Call[K, V] {
	_c.Call.Return(run)
	return _c
}

// Adjust provides a mock function for the type Mempool
func (_mock *Mempool[K, V]) Adjust(key K, f func(V) V) (V, bool) {
	ret := _mock.Called(key, f)

	if len(ret) == 0 {
		panic("no return value specified for Adjust")
	}

	var r0 V
	var r1 bool
	if returnFunc, ok := ret.Get(0).(func(K, func(V) V) (V, bool)); ok {
		return returnFunc(key, f)
	}
	if returnFunc, ok := ret.Get(0).(func(K, func(V) V) V); ok {
		r0 = returnFunc(key, f)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(V)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(K, func(V) V) bool); ok {
		r1 = returnFunc(key, f)
	} else {
		r1 = ret.Get(1).(bool)
	}
	return r0, r1
}

// Mempool_Adjust_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Adjust'
type Mempool_Adjust_Call[K comparable, V any] struct {
	*mock.Call
}

// Adjust is a helper method to define mock.On call
//   - key K
//   - f func(V) V
func (_e *Mempool_Expecter[K, V]) Adjust(key interface{}, f interface{}) *Mempool_Adjust_Call[K, V] {
	return &Mempool_Adjust_Call[K, V]{Call: _e.mock.On("Adjust", key, f)}
}

func (_c *Mempool_Adjust_Call[K, V]) Run(run func(key K, f func(V) V)) *Mempool_Adjust_Call[K, V] {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 K
		if args[0] != nil {
			arg0 = args[0].(K)
		}
		var arg1 func(V) V
		if args[1] != nil {
			arg1 = args[1].(func(V) V)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Mempool_Adjust_Call[K, V]) Return(v V, b bool) *Mempool_Adjust_Call[K, V] {
	_c.Call.Return(v, b)
	return _c
}

func (_c *Mempool_Adjust_Call[K, V]) RunAndReturn(run func(key K, f func(V) V) (V, bool)) *Mempool_Adjust_Call[K, V] {
	_c.Call.Return(run)
	return _c
}

// All provides a mock function for the type Mempool
func (_mock *Mempool[K, V]) All() map[K]V {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for All")
	}

	var r0 map[K]V
	if returnFunc, ok := ret.Get(0).(func() map[K]V); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[K]V)
		}
	}
	return r0
}

// Mempool_All_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'All'
type Mempool_All_Call[K comparable, V any] struct {
	*mock.Call
}

// All is a helper method to define mock.On call
func (_e *Mempool_Expecter[K, V]) All() *Mempool_All_Call[K, V] {
	return &Mempool_All_Call[K, V]{Call: _e.mock.On("All")}
}

func (_c *Mempool_All_Call[K, V]) Run(run func()) *Mempool_All_Call[K, V] {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Mempool_All_Call[K, V]) Return(vToV map[K]V) *Mempool_All_Call[K, V] {
	_c.Call.Return(vToV)
	return _c
}

func (_c *Mempool_All_Call[K, V]) RunAndReturn(run func() map[K]V) *Mempool_All_Call[K, V] {
	_c.Call.Return(run)
	return _c
}

// Clear provides a mock function for the type Mempool
func (_mock *Mempool[K, V]) Clear() {
	_mock.Called()
	return
}

// Mempool_Clear_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Clear'
type Mempool_Clear_Call[K comparable, V any] struct {
	*mock.Call
}

// Clear is a helper method to define mock.On call
func (_e *Mempool_Expecter[K, V]) Clear() *Mempool_Clear_Call[K, V] {
	return &Mempool_Clear_Call[K, V]{Call: _e.mock.On("Clear")}
}

func (_c *Mempool_Clear_Call[K, V]) Run(run func()) *Mempool_Clear_Call[K, V] {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Mempool_Clear_Call[K, V]) Return() *Mempool_Clear_Call[K, V] {
	_c.Call.Return()
	return _c
}

func (_c *Mempool_Clear_Call[K, V]) RunAndReturn(run func()) *Mempool_Clear_Call[K, V] {
	_c.Run(run)
	return _c
}

// Get provides a mock function for the type Mempool
func (_mock *Mempool[K, V]) Get(v K) (V, bool) {
	ret := _mock.Called(v)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 V
	var r1 bool
	if returnFunc, ok := ret.Get(0).(func(K) (V, bool)); ok {
		return returnFunc(v)
	}
	if returnFunc, ok := ret.Get(0).(func(K) V); ok {
		r0 = returnFunc(v)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(V)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(K) bool); ok {
		r1 = returnFunc(v)
	} else {
		r1 = ret.Get(1).(bool)
	}
	return r0, r1
}

// Mempool_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type Mempool_Get_Call[K comparable, V any] struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - v K
func (_e *Mempool_Expecter[K, V]) Get(v interface{}) *Mempool_Get_Call[K, V] {
	return &Mempool_Get_Call[K, V]{Call: _e.mock.On("Get", v)}
}

func (_c *Mempool_Get_Call[K, V]) Run(run func(v K)) *Mempool_Get_Call[K, V] {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 K
		if args[0] != nil {
			arg0 = args[0].(K)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Mempool_Get_Call[K, V]) Return(v1 V, b bool) *Mempool_Get_Call[K, V] {
	_c.Call.Return(v1, b)
	return _c
}

func (_c *Mempool_Get_Call[K, V]) RunAndReturn(run func(v K) (V, bool)) *Mempool_Get_Call[K, V] {
	_c.Call.Return(run)
	return _c
}

// Has provides a mock function for the type Mempool
func (_mock *Mempool[K, V]) Has(v K) bool {
	ret := _mock.Called(v)

	if len(ret) == 0 {
		panic("no return value specified for Has")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(K) bool); ok {
		r0 = returnFunc(v)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// Mempool_Has_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Has'
type Mempool_Has_Call[K comparable, V any] struct {
	*mock.Call
}

// Has is a helper method to define mock.On call
//   - v K
func (_e *Mempool_Expecter[K, V]) Has(v interface{}) *Mempool_Has_Call[K, V] {
	return &Mempool_Has_Call[K, V]{Call: _e.mock.On("Has", v)}
}

func (_c *Mempool_Has_Call[K, V]) Run(run func(v K)) *Mempool_Has_Call[K, V] {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 K
		if args[0] != nil {
			arg0 = args[0].(K)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Mempool_Has_Call[K, V]) Return(b bool) *Mempool_Has_Call[K, V] {
	_c.Call.Return(b)
	return _c
}

func (_c *Mempool_Has_Call[K, V]) RunAndReturn(run func(v K) bool) *Mempool_Has_Call[K, V] {
	_c.Call.Return(run)
	return _c
}

// Remove provides a mock function for the type Mempool
func (_mock *Mempool[K, V]) Remove(v K) bool {
	ret := _mock.Called(v)

	if len(ret) == 0 {
		panic("no return value specified for Remove")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(K) bool); ok {
		r0 = returnFunc(v)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// Mempool_Remove_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Remove'
type Mempool_Remove_Call[K comparable, V any] struct {
	*mock.Call
}

// Remove is a helper method to define mock.On call
//   - v K
func (_e *Mempool_Expecter[K, V]) Remove(v interface{}) *Mempool_Remove_Call[K, V] {
	return &Mempool_Remove_Call[K, V]{Call: _e.mock.On("Remove", v)}
}

func (_c *Mempool_Remove_Call[K, V]) Run(run func(v K)) *Mempool_Remove_Call[K, V] {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 K
		if args[0] != nil {
			arg0 = args[0].(K)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Mempool_Remove_Call[K, V]) Return(b bool) *Mempool_Remove_Call[K, V] {
	_c.Call.Return(b)
	return _c
}

func (_c *Mempool_Remove_Call[K, V]) RunAndReturn(run func(v K) bool) *Mempool_Remove_Call[K, V] {
	_c.Call.Return(run)
	return _c
}

// Size provides a mock function for the type Mempool
func (_mock *Mempool[K, V]) Size() uint {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Size")
	}

	var r0 uint
	if returnFunc, ok := ret.Get(0).(func() uint); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint)
	}
	return r0
}

// Mempool_Size_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Size'
type Mempool_Size_Call[K comparable, V any] struct {
	*mock.Call
}

// Size is a helper method to define mock.On call
func (_e *Mempool_Expecter[K, V]) Size() *Mempool_Size_Call[K, V] {
	return &Mempool_Size_Call[K, V]{Call: _e.mock.On("Size")}
}

func (_c *Mempool_Size_Call[K, V]) Run(run func()) *Mempool_Size_Call[K, V] {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Mempool_Size_Call[K, V]) Return(v uint) *Mempool_Size_Call[K, V] {
	_c.Call.Return(v)
	return _c
}

func (_c *Mempool_Size_Call[K, V]) RunAndReturn(run func() uint) *Mempool_Size_Call[K, V] {
	_c.Call.Return(run)
	return _c
}

// Values provides a mock function for the type Mempool
func (_mock *Mempool[K, V]) Values() []V {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Values")
	}

	var r0 []V
	if returnFunc, ok := ret.Get(0).(func() []V); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]V)
		}
	}
	return r0
}

// Mempool_Values_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Values'
type Mempool_Values_Call[K comparable, V any] struct {
	*mock.Call
}

// Values is a helper method to define mock.On call
func (_e *Mempool_Expecter[K, V]) Values() *Mempool_Values_Call[K, V] {
	return &Mempool_Values_Call[K, V]{Call: _e.mock.On("Values")}
}

func (_c *Mempool_Values_Call[K, V]) Run(run func()) *Mempool_Values_Call[K, V] {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Mempool_Values_Call[K, V]) Return(vs []V) *Mempool_Values_Call[K, V] {
	_c.Call.Return(vs)
	return _c
}

func (_c *Mempool_Values_Call[K, V]) RunAndReturn(run func() []V) *Mempool_Values_Call[K, V] {
	_c.Call.Return(run)
	return _c
}

// NewMutableBackData creates a new instance of MutableBackData. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMutableBackData[K comparable, V any](t interface {
	mock.TestingT
	Cleanup(func())
}) *MutableBackData[K, V] {
	mock := &MutableBackData[K, V]{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MutableBackData is an autogenerated mock type for the MutableBackData type
type MutableBackData[K comparable, V any] struct {
	mock.Mock
}

type MutableBackData_Expecter[K comparable, V any] struct {
	mock *mock.Mock
}

func (_m *MutableBackData[K, V]) EXPECT() *MutableBackData_Expecter[K, V] {
	return &MutableBackData_Expecter[K, V]{mock: &_m.Mock}
}

// Add provides a mock function for the type MutableBackData
func (_mock *MutableBackData[K, V]) Add(key K, value V) bool {
	ret := _mock.Called(key, value)

	if len(ret) == 0 {
		panic("no return value specified for Add")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(K, V) bool); ok {
		r0 = returnFunc(key, value)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// MutableBackData_Add_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Add'
type MutableBackData_Add_Call[K comparable, V any] struct {
	*mock.Call
}

// Add is a helper method to define mock.On call
//   - key K
//   - value V
func (_e *MutableBackData_Expecter[K, V]) Add(key interface{}, value interface{}) *MutableBackData_Add_Call[K, V] {
	return &MutableBackData_Add_Call[K, V]{Call: _e.mock.On("Add", key, value)}
}

func (_c *MutableBackData_Add_Call[K, V]) Run(run func(key K, value V)) *MutableBackData_Add_Call[K, V] {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 K
		if args[0] != nil {
			arg0 = args[0].(K)
		}
		var arg1 V
		if args[1] != nil {
			arg1 = args[1].(V)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MutableBackData_Add_Call[K, V]) Return(b bool) *MutableBackData_Add_Call[K, V] {
	_c.Call.Return(b)
	return _c
}

func (_c *MutableBackData_Add_Call[K, V]) RunAndReturn(run func(key K, value V) bool) *MutableBackData_Add_Call[K, V] {
	_c.Call.Return(run)
	return _c
}

// Adjust provides a mock function for the type MutableBackData
func (_mock *MutableBackData[K, V]) Adjust(key K, f func(value V) V) (V, bool) {
	ret := _mock.Called(key, f)

	if len(ret) == 0 {
		panic("no return value specified for Adjust")
	}

	var r0 V
	var r1 bool
	if returnFunc, ok := ret.Get(0).(func(K, func(value V) V) (V, bool)); ok {
		return returnFunc(key, f)
	}
	if returnFunc, ok := ret.Get(0).(func(K, func(value V) V) V); ok {
		r0 = returnFunc(key, f)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(V)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(K, func(value V) V) bool); ok {
		r1 = returnFunc(key, f)
	} else {
		r1 = ret.Get(1).(bool)
	}
	return r0, r1
}

// MutableBackData_Adjust_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Adjust'
type MutableBackData_Adjust_Call[K comparable, V any] struct {
	*mock.Call
}

// Adjust is a helper method to define mock.On call
//   - key K
//   - f func(value V) V
func (_e *MutableBackData_Expecter[K, V]) Adjust(key interface{}, f interface{}) *MutableBackData_Adjust_Call[K, V] {
	return &MutableBackData_Adjust_Call[K, V]{Call: _e.mock.On("Adjust", key, f)}
}

func (_c *MutableBackData_Adjust_Call[K, V]) Run(run func(key K, f func(value V) V)) *MutableBackData_Adjust_Call[K, V] {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 K
		if args[0] != nil {
			arg0 = args[0].(K)
		}
		var arg1 func(value V) V
		if args[1] != nil {
			arg1 = args[1].(func(value V) V)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MutableBackData_Adjust_Call[K, V]) Return(v V, b bool) *MutableBackData_Adjust_Call[K, V] {
	_c.Call.Return(v, b)
	return _c
}

func (_c *MutableBackData_Adjust_Call[K, V]) RunAndReturn(run func(key K, f func(value V) V) (V, bool)) *MutableBackData_Adjust_Call[K, V] {
	_c.Call.Return(run)
	return _c
}

// AdjustWithInit provides a mock function for the type MutableBackData
func (_mock *MutableBackData[K, V]) AdjustWithInit(key K, adjust func(value V) V, init func() V) (V, bool) {
	ret := _mock.Called(key, adjust, init)

	if len(ret) == 0 {
		panic("no return value specified for AdjustWithInit")
	}

	var r0 V
	var r1 bool
	if returnFunc, ok := ret.Get(0).(func(K, func(value V) V, func() V) (V, bool)); ok {
		return returnFunc(key, adjust, init)
	}
	if returnFunc, ok := ret.Get(0).(func(K, func(value V) V, func() V) V); ok {
		r0 = returnFunc(key, adjust, init)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(V)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(K, func(value V) V, func() V) bool); ok {
		r1 = returnFunc(key, adjust, init)
	} else {
		r1 = ret.Get(1).(bool)
	}
	return r0, r1
}

// MutableBackData_AdjustWithInit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AdjustWithInit'
type MutableBackData_AdjustWithInit_Call[K comparable, V any] struct {
	*mock.Call
}

// AdjustWithInit is a helper method to define mock.On call
//   - key K
//   - adjust func(value V) V
//   - init func() V
func (_e *MutableBackData_Expecter[K, V]) AdjustWithInit(key interface{}, adjust interface{}, init interface{}) *MutableBackData_AdjustWithInit_Call[K, V] {
	return &MutableBackData_AdjustWithInit_Call[K, V]{Call: _e.mock.On("AdjustWithInit", key, adjust, init)}
}

func (_c *MutableBackData_AdjustWithInit_Call[K, V]) Run(run func(key K, adjust func(value V) V, init func() V)) *MutableBackData_AdjustWithInit_Call[K, V] {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 K
		if args[0] != nil {
			arg0 = args[0].(K)
		}
		var arg1 func(value V) V
		if args[1] != nil {
			arg1 = args[1].(func(value V) V)
		}
		var arg2 func() V
		if args[2] != nil {
			arg2 = args[2].(func() V)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MutableBackData_AdjustWithInit_Call[K, V]) Return(v V, b bool) *MutableBackData_AdjustWithInit_Call[K, V] {
	_c.Call.Return(v, b)
	return _c
}

func (_c *MutableBackData_AdjustWithInit_Call[K, V]) RunAndReturn(run func(key K, adjust func(value V) V, init func() V) (V, bool)) *MutableBackData_AdjustWithInit_Call[K, V] {
	_c.Call.Return(run)
	return _c
}

// All provides a mock function for the type MutableBackData
func (_mock *MutableBackData[K, V]) All() map[K]V {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for All")
	}

	var r0 map[K]V
	if returnFunc, ok := ret.Get(0).(func() map[K]V); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[K]V)
		}
	}
	return r0
}

// MutableBackData_All_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'All'
type MutableBackData_All_Call[K comparable, V any] struct {
	*mock.Call
}

// All is a helper method to define mock.On call
func (_e *MutableBackData_Expecter[K, V]) All() *MutableBackData_All_Call[K, V] {
	return &MutableBackData_All_Call[K, V]{Call: _e.mock.On("All")}
}

func (_c *MutableBackData_All_Call[K, V]) Run(run func()) *MutableBackData_All_Call[K, V] {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MutableBackData_All_Call[K, V]) Return(vToV map[K]V) *MutableBackData_All_Call[K, V] {
	_c.Call.Return(vToV)
	return _c
}

func (_c *MutableBackData_All_Call[K, V]) RunAndReturn(run func() map[K]V) *MutableBackData_All_Call[K, V] {
	_c.Call.Return(run)
	return _c
}

// Clear provides a mock function for the type MutableBackData
func (_mock *MutableBackData[K, V]) Clear() {
	_mock.Called()
	return
}

// MutableBackData_Clear_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Clear'
type MutableBackData_Clear_Call[K comparable, V any] struct {
	*mock.Call
}

// Clear is a helper method to define mock.On call
func (_e *MutableBackData_Expecter[K, V]) Clear() *MutableBackData_Clear_Call[K, V] {
	return &MutableBackData_Clear_Call[K, V]{Call: _e.mock.On("Clear")}
}

func (_c *MutableBackData_Clear_Call[K, V]) Run(run func()) *MutableBackData_Clear_Call[K, V] {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MutableBackData_Clear_Call[K, V]) Return() *MutableBackData_Clear_Call[K, V] {
	_c.Call.Return()
	return _c
}

func (_c *MutableBackData_Clear_Call[K, V]) RunAndReturn(run func()) *MutableBackData_Clear_Call[K, V] {
	_c.Run(run)
	return _c
}

// Get provides a mock function for the type MutableBackData
func (_mock *MutableBackData[K, V]) Get(key K) (V, bool) {
	ret := _mock.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 V
	var r1 bool
	if returnFunc, ok := ret.Get(0).(func(K) (V, bool)); ok {
		return returnFunc(key)
	}
	if returnFunc, ok := ret.Get(0).(func(K) V); ok {
		r0 = returnFunc(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(V)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(K) bool); ok {
		r1 = returnFunc(key)
	} else {
		r1 = ret.Get(1).(bool)
	}
	return r0, r1
}

// MutableBackData_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type MutableBackData_Get_Call[K comparable, V any] struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - key K
func (_e *MutableBackData_Expecter[K, V]) Get(key interface{}) *MutableBackData_Get_Call[K, V] {
	return &MutableBackData_Get_Call[K, V]{Call: _e.mock.On("Get", key)}
}

func (_c *MutableBackData_Get_Call[K, V]) Run(run func(key K)) *MutableBackData_Get_Call[K, V] {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 K
		if args[0] != nil {
			arg0 = args[0].(K)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MutableBackData_Get_Call[K, V]) Return(v V, b bool) *MutableBackData_Get_Call[K, V] {
	_c.Call.Return(v, b)
	return _c
}

func (_c *MutableBackData_Get_Call[K, V]) RunAndReturn(run func(key K) (V, bool)) *MutableBackData_Get_Call[K, V] {
	_c.Call.Return(run)
	return _c
}

// Has provides a mock function for the type MutableBackData
func (_mock *MutableBackData[K, V]) Has(key K) bool {
	ret := _mock.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for Has")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(K) bool); ok {
		r0 = returnFunc(key)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// MutableBackData_Has_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Has'
type MutableBackData_Has_Call[K comparable, V any] struct {
	*mock.Call
}

// Has is a helper method to define mock.On call
//   - key K
func (_e *MutableBackData_Expecter[K, V]) Has(key interface{}) *MutableBackData_Has_Call[K, V] {
	return &MutableBackData_Has_Call[K, V]{Call: _e.mock.On("Has", key)}
}

func (_c *MutableBackData_Has_Call[K, V]) Run(run func(key K)) *MutableBackData_Has_Call[K, V] {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 K
		if args[0] != nil {
			arg0 = args[0].(K)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MutableBackData_Has_Call[K, V]) Return(b bool) *MutableBackData_Has_Call[K, V] {
	_c.Call.Return(b)
	return _c
}

func (_c *MutableBackData_Has_Call[K, V]) RunAndReturn(run func(key K) bool) *MutableBackData_Has_Call[K, V] {
	_c.Call.Return(run)
	return _c
}

// Keys provides a mock function for the type MutableBackData
func (_mock *MutableBackData[K, V]) Keys() []K {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Keys")
	}

	var r0 []K
	if returnFunc, ok := ret.Get(0).(func() []K); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]K)
		}
	}
	return r0
}

// MutableBackData_Keys_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Keys'
type MutableBackData_Keys_Call[K comparable, V any] struct {
	*mock.Call
}

// Keys is a helper method to define mock.On call
func (_e *MutableBackData_Expecter[K, V]) Keys() *MutableBackData_Keys_Call[K, V] {
	return &MutableBackData_Keys_Call[K, V]{Call: _e.mock.On("Keys")}
}

func (_c *MutableBackData_Keys_Call[K, V]) Run(run func()) *MutableBackData_Keys_Call[K, V] {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MutableBackData_Keys_Call[K, V]) Return(vs []K) *MutableBackData_Keys_Call[K, V] {
	_c.Call.Return(vs)
	return _c
}

func (_c *MutableBackData_Keys_Call[K, V]) RunAndReturn(run func() []K) *MutableBackData_Keys_Call[K, V] {
	_c.Call.Return(run)
	return _c
}

// Remove provides a mock function for the type MutableBackData
func (_mock *MutableBackData[K, V]) Remove(key K) (V, bool) {
	ret := _mock.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for Remove")
	}

	var r0 V
	var r1 bool
	if returnFunc, ok := ret.Get(0).(func(K) (V, bool)); ok {
		return returnFunc(key)
	}
	if returnFunc, ok := ret.Get(0).(func(K) V); ok {
		r0 = returnFunc(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(V)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(K) bool); ok {
		r1 = returnFunc(key)
	} else {
		r1 = ret.Get(1).(bool)
	}
	return r0, r1
}

// MutableBackData_Remove_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Remove'
type MutableBackData_Remove_Call[K comparable, V any] struct {
	*mock.Call
}

// Remove is a helper method to define mock.On call
//   - key K
func (_e *MutableBackData_Expecter[K, V]) Remove(key interface{}) *MutableBackData_Remove_Call[K, V] {
	return &MutableBackData_Remove_Call[K, V]{Call: _e.mock.On("Remove", key)}
}

func (_c *MutableBackData_Remove_Call[K, V]) Run(run func(key K)) *MutableBackData_Remove_Call[K, V] {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 K
		if args[0] != nil {
			arg0 = args[0].(K)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MutableBackData_Remove_Call[K, V]) Return(v V, b bool) *MutableBackData_Remove_Call[K, V] {
	_c.Call.Return(v, b)
	return _c
}

func (_c *MutableBackData_Remove_Call[K, V]) RunAndReturn(run func(key K) (V, bool)) *MutableBackData_Remove_Call[K, V] {
	_c.Call.Return(run)
	return _c
}

// Size provides a mock function for the type MutableBackData
func (_mock *MutableBackData[K, V]) Size() uint {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Size")
	}

	var r0 uint
	if returnFunc, ok := ret.Get(0).(func() uint); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint)
	}
	return r0
}

// MutableBackData_Size_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Size'
type MutableBackData_Size_Call[K comparable, V any] struct {
	*mock.Call
}

// Size is a helper method to define mock.On call
func (_e *MutableBackData_Expecter[K, V]) Size() *MutableBackData_Size_Call[K, V] {
	return &MutableBackData_Size_Call[K, V]{Call: _e.mock.On("Size")}
}

func (_c *MutableBackData_Size_Call[K, V]) Run(run func()) *MutableBackData_Size_Call[K, V] {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MutableBackData_Size_Call[K, V]) Return(v uint) *MutableBackData_Size_Call[K, V] {
	_c.Call.Return(v)
	return _c
}

func (_c *MutableBackData_Size_Call[K, V]) RunAndReturn(run func() uint) *MutableBackData_Size_Call[K, V] {
	_c.Call.Return(run)
	return _c
}

// Values provides a mock function for the type MutableBackData
func (_mock *MutableBackData[K, V]) Values() []V {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Values")
	}

	var r0 []V
	if returnFunc, ok := ret.Get(0).(func() []V); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]V)
		}
	}
	return r0
}

// MutableBackData_Values_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Values'
type MutableBackData_Values_Call[K comparable, V any] struct {
	*mock.Call
}

// Values is a helper method to define mock.On call
func (_e *MutableBackData_Expecter[K, V]) Values() *MutableBackData_Values_Call[K, V] {
	return &MutableBackData_Values_Call[K, V]{Call: _e.mock.On("Values")}
}

func (_c *MutableBackData_Values_Call[K, V]) Run(run func()) *MutableBackData_Values_Call[K, V] {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MutableBackData_Values_Call[K, V]) Return(vs []V) *MutableBackData_Values_Call[K, V] {
	_c.Call.Return(vs)
	return _c
}

func (_c *MutableBackData_Values_Call[K, V]) RunAndReturn(run func() []V) *MutableBackData_Values_Call[K, V] {
	_c.Call.Return(run)
	return _c
}

// NewPendingReceipts creates a new instance of PendingReceipts. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewPendingReceipts(t interface {
	mock.TestingT
	Cleanup(func())
}) *PendingReceipts {
	mock := &PendingReceipts{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// PendingReceipts is an autogenerated mock type for the PendingReceipts type
type PendingReceipts struct {
	mock.Mock
}

type PendingReceipts_Expecter struct {
	mock *mock.Mock
}

func (_m *PendingReceipts) EXPECT() *PendingReceipts_Expecter {
	return &PendingReceipts_Expecter{mock: &_m.Mock}
}

// Add provides a mock function for the type PendingReceipts
func (_mock *PendingReceipts) Add(receipt *flow.ExecutionReceipt) bool {
	ret := _mock.Called(receipt)

	if len(ret) == 0 {
		panic("no return value specified for Add")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(*flow.ExecutionReceipt) bool); ok {
		r0 = returnFunc(receipt)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// PendingReceipts_Add_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Add'
type PendingReceipts_Add_Call struct {
	*mock.Call
}

// Add is a helper method to define mock.On call
//   - receipt *flow.ExecutionReceipt
func (_e *PendingReceipts_Expecter) Add(receipt interface{}) *PendingReceipts_Add_Call {
	return &PendingReceipts_Add_Call{Call: _e.mock.On("Add", receipt)}
}

func (_c *PendingReceipts_Add_Call) Run(run func(receipt *flow.ExecutionReceipt)) *PendingReceipts_Add_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *flow.ExecutionReceipt
		if args[0] != nil {
			arg0 = args[0].(*flow.ExecutionReceipt)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PendingReceipts_Add_Call) Return(b bool) *PendingReceipts_Add_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *PendingReceipts_Add_Call) RunAndReturn(run func(receipt *flow.ExecutionReceipt) bool) *PendingReceipts_Add_Call {
	_c.Call.Return(run)
	return _c
}

// ByPreviousResultID provides a mock function for the type PendingReceipts
func (_mock *PendingReceipts) ByPreviousResultID(previousResultID flow.Identifier) []*flow.ExecutionReceipt {
	ret := _mock.Called(previousResultID)

	if len(ret) == 0 {
		panic("no return value specified for ByPreviousResultID")
	}

	var r0 []*flow.ExecutionReceipt
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) []*flow.ExecutionReceipt); ok {
		r0 = returnFunc(previousResultID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*flow.ExecutionReceipt)
		}
	}
	return r0
}

// PendingReceipts_ByPreviousResultID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByPreviousResultID'
type PendingReceipts_ByPreviousResultID_Call struct {
	*mock.Call
}

// ByPreviousResultID is a helper method to define mock.On call
//   - previousResultID flow.Identifier
func (_e *PendingReceipts_Expecter) ByPreviousResultID(previousResultID interface{}) *PendingReceipts_ByPreviousResultID_Call {
	return &PendingReceipts_ByPreviousResultID_Call{Call: _e.mock.On("ByPreviousResultID", previousResultID)}
}

func (_c *PendingReceipts_ByPreviousResultID_Call) Run(run func(previousResultID flow.Identifier)) *PendingReceipts_ByPreviousResultID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PendingReceipts_ByPreviousResultID_Call) Return(executionReceipts []*flow.ExecutionReceipt) *PendingReceipts_ByPreviousResultID_Call {
	_c.Call.Return(executionReceipts)
	return _c
}

func (_c *PendingReceipts_ByPreviousResultID_Call) RunAndReturn(run func(previousResultID flow.Identifier) []*flow.ExecutionReceipt) *PendingReceipts_ByPreviousResultID_Call {
	_c.Call.Return(run)
	return _c
}

// PruneUpToHeight provides a mock function for the type PendingReceipts
func (_mock *PendingReceipts) PruneUpToHeight(height uint64) error {
	ret := _mock.Called(height)

	if len(ret) == 0 {
		panic("no return value specified for PruneUpToHeight")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(uint64) error); ok {
		r0 = returnFunc(height)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// PendingReceipts_PruneUpToHeight_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PruneUpToHeight'
type PendingReceipts_PruneUpToHeight_Call struct {
	*mock.Call
}

// PruneUpToHeight is a helper method to define mock.On call
//   - height uint64
func (_e *PendingReceipts_Expecter) PruneUpToHeight(height interface{}) *PendingReceipts_PruneUpToHeight_Call {
	return &PendingReceipts_PruneUpToHeight_Call{Call: _e.mock.On("PruneUpToHeight", height)}
}

func (_c *PendingReceipts_PruneUpToHeight_Call) Run(run func(height uint64)) *PendingReceipts_PruneUpToHeight_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PendingReceipts_PruneUpToHeight_Call) Return(err error) *PendingReceipts_PruneUpToHeight_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *PendingReceipts_PruneUpToHeight_Call) RunAndReturn(run func(height uint64) error) *PendingReceipts_PruneUpToHeight_Call {
	_c.Call.Return(run)
	return _c
}

// Remove provides a mock function for the type PendingReceipts
func (_mock *PendingReceipts) Remove(receiptID flow.Identifier) bool {
	ret := _mock.Called(receiptID)

	if len(ret) == 0 {
		panic("no return value specified for Remove")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) bool); ok {
		r0 = returnFunc(receiptID)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// PendingReceipts_Remove_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Remove'
type PendingReceipts_Remove_Call struct {
	*mock.Call
}

// Remove is a helper method to define mock.On call
//   - receiptID flow.Identifier
func (_e *PendingReceipts_Expecter) Remove(receiptID interface{}) *PendingReceipts_Remove_Call {
	return &PendingReceipts_Remove_Call{Call: _e.mock.On("Remove", receiptID)}
}

func (_c *PendingReceipts_Remove_Call) Run(run func(receiptID flow.Identifier)) *PendingReceipts_Remove_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PendingReceipts_Remove_Call) Return(b bool) *PendingReceipts_Remove_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *PendingReceipts_Remove_Call) RunAndReturn(run func(receiptID flow.Identifier) bool) *PendingReceipts_Remove_Call {
	_c.Call.Return(run)
	return _c
}

// NewTransactionTimings creates a new instance of TransactionTimings. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewTransactionTimings(t interface {
	mock.TestingT
	Cleanup(func())
}) *TransactionTimings {
	mock := &TransactionTimings{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// TransactionTimings is an autogenerated mock type for the TransactionTimings type
type TransactionTimings struct {
	mock.Mock
}

type TransactionTimings_Expecter struct {
	mock *mock.Mock
}

func (_m *TransactionTimings) EXPECT() *TransactionTimings_Expecter {
	return &TransactionTimings_Expecter{mock: &_m.Mock}
}

// Add provides a mock function for the type TransactionTimings
func (_mock *TransactionTimings) Add(identifier flow.Identifier, transactionTiming *flow.TransactionTiming) bool {
	ret := _mock.Called(identifier, transactionTiming)

	if len(ret) == 0 {
		panic("no return value specified for Add")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, *flow.TransactionTiming) bool); ok {
		r0 = returnFunc(identifier, transactionTiming)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// TransactionTimings_Add_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Add'
type TransactionTimings_Add_Call struct {
	*mock.Call
}

// Add is a helper method to define mock.On call
//   - identifier flow.Identifier
//   - transactionTiming *flow.TransactionTiming
func (_e *TransactionTimings_Expecter) Add(identifier interface{}, transactionTiming interface{}) *TransactionTimings_Add_Call {
	return &TransactionTimings_Add_Call{Call: _e.mock.On("Add", identifier, transactionTiming)}
}

func (_c *TransactionTimings_Add_Call) Run(run func(identifier flow.Identifier, transactionTiming *flow.TransactionTiming)) *TransactionTimings_Add_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		var arg1 *flow.TransactionTiming
		if args[1] != nil {
			arg1 = args[1].(*flow.TransactionTiming)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *TransactionTimings_Add_Call) Return(b bool) *TransactionTimings_Add_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *TransactionTimings_Add_Call) RunAndReturn(run func(identifier flow.Identifier, transactionTiming *flow.TransactionTiming) bool) *TransactionTimings_Add_Call {
	_c.Call.Return(run)
	return _c
}

// Adjust provides a mock function for the type TransactionTimings
func (_mock *TransactionTimings) Adjust(key flow.Identifier, f func(*flow.TransactionTiming) *flow.TransactionTiming) (*flow.TransactionTiming, bool) {
	ret := _mock.Called(key, f)

	if len(ret) == 0 {
		panic("no return value specified for Adjust")
	}

	var r0 *flow.TransactionTiming
	var r1 bool
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, func(*flow.TransactionTiming) *flow.TransactionTiming) (*flow.TransactionTiming, bool)); ok {
		return returnFunc(key, f)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, func(*flow.TransactionTiming) *flow.TransactionTiming) *flow.TransactionTiming); ok {
		r0 = returnFunc(key, f)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.TransactionTiming)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier, func(*flow.TransactionTiming) *flow.TransactionTiming) bool); ok {
		r1 = returnFunc(key, f)
	} else {
		r1 = ret.Get(1).(bool)
	}
	return r0, r1
}

// TransactionTimings_Adjust_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Adjust'
type TransactionTimings_Adjust_Call struct {
	*mock.Call
}

// Adjust is a helper method to define mock.On call
//   - key flow.Identifier
//   - f func(*flow.TransactionTiming) *flow.TransactionTiming
func (_e *TransactionTimings_Expecter) Adjust(key interface{}, f interface{}) *TransactionTimings_Adjust_Call {
	return &TransactionTimings_Adjust_Call{Call: _e.mock.On("Adjust", key, f)}
}

func (_c *TransactionTimings_Adjust_Call) Run(run func(key flow.Identifier, f func(*flow.TransactionTiming) *flow.TransactionTiming)) *TransactionTimings_Adjust_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		var arg1 func(*flow.TransactionTiming) *flow.TransactionTiming
		if args[1] != nil {
			arg1 = args[1].(func(*flow.TransactionTiming) *flow.TransactionTiming)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *TransactionTimings_Adjust_Call) Return(transactionTiming *flow.TransactionTiming, b bool) *TransactionTimings_Adjust_Call {
	_c.Call.Return(transactionTiming, b)
	return _c
}

func (_c *TransactionTimings_Adjust_Call) RunAndReturn(run func(key flow.Identifier, f func(*flow.TransactionTiming) *flow.TransactionTiming) (*flow.TransactionTiming, bool)) *TransactionTimings_Adjust_Call {
	_c.Call.Return(run)
	return _c
}

// All provides a mock function for the type TransactionTimings
func (_mock *TransactionTimings) All() map[flow.Identifier]*flow.TransactionTiming {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for All")
	}

	var r0 map[flow.Identifier]*flow.TransactionTiming
	if returnFunc, ok := ret.Get(0).(func() map[flow.Identifier]*flow.TransactionTiming); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[flow.Identifier]*flow.TransactionTiming)
		}
	}
	return r0
}

// TransactionTimings_All_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'All'
type TransactionTimings_All_Call struct {
	*mock.Call
}

// All is a helper method to define mock.On call
func (_e *TransactionTimings_Expecter) All() *TransactionTimings_All_Call {
	return &TransactionTimings_All_Call{Call: _e.mock.On("All")}
}

func (_c *TransactionTimings_All_Call) Run(run func()) *TransactionTimings_All_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *TransactionTimings_All_Call) Return(identifierToTransactionTiming map[flow.Identifier]*flow.TransactionTiming) *TransactionTimings_All_Call {
	_c.Call.Return(identifierToTransactionTiming)
	return _c
}

func (_c *TransactionTimings_All_Call) RunAndReturn(run func() map[flow.Identifier]*flow.TransactionTiming) *TransactionTimings_All_Call {
	_c.Call.Return(run)
	return _c
}

// Clear provides a mock function for the type TransactionTimings
func (_mock *TransactionTimings) Clear() {
	_mock.Called()
	return
}

// TransactionTimings_Clear_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Clear'
type TransactionTimings_Clear_Call struct {
	*mock.Call
}

// Clear is a helper method to define mock.On call
func (_e *TransactionTimings_Expecter) Clear() *TransactionTimings_Clear_Call {
	return &TransactionTimings_Clear_Call{Call: _e.mock.On("Clear")}
}

func (_c *TransactionTimings_Clear_Call) Run(run func()) *TransactionTimings_Clear_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *TransactionTimings_Clear_Call) Return() *TransactionTimings_Clear_Call {
	_c.Call.Return()
	return _c
}

func (_c *TransactionTimings_Clear_Call) RunAndReturn(run func()) *TransactionTimings_Clear_Call {
	_c.Run(run)
	return _c
}

// Get provides a mock function for the type TransactionTimings
func (_mock *TransactionTimings) Get(identifier flow.Identifier) (*flow.TransactionTiming, bool) {
	ret := _mock.Called(identifier)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *flow.TransactionTiming
	var r1 bool
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (*flow.TransactionTiming, bool)); ok {
		return returnFunc(identifier)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) *flow.TransactionTiming); ok {
		r0 = returnFunc(identifier)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.TransactionTiming)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) bool); ok {
		r1 = returnFunc(identifier)
	} else {
		r1 = ret.Get(1).(bool)
	}
	return r0, r1
}

// TransactionTimings_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type TransactionTimings_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - identifier flow.Identifier
func (_e *TransactionTimings_Expecter) Get(identifier interface{}) *TransactionTimings_Get_Call {
	return &TransactionTimings_Get_Call{Call: _e.mock.On("Get", identifier)}
}

func (_c *TransactionTimings_Get_Call) Run(run func(identifier flow.Identifier)) *TransactionTimings_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *TransactionTimings_Get_Call) Return(transactionTiming *flow.TransactionTiming, b bool) *TransactionTimings_Get_Call {
	_c.Call.Return(transactionTiming, b)
	return _c
}

func (_c *TransactionTimings_Get_Call) RunAndReturn(run func(identifier flow.Identifier) (*flow.TransactionTiming, bool)) *TransactionTimings_Get_Call {
	_c.Call.Return(run)
	return _c
}

// Has provides a mock function for the type TransactionTimings
func (_mock *TransactionTimings) Has(identifier flow.Identifier) bool {
	ret := _mock.Called(identifier)

	if len(ret) == 0 {
		panic("no return value specified for Has")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) bool); ok {
		r0 = returnFunc(identifier)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// TransactionTimings_Has_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Has'
type TransactionTimings_Has_Call struct {
	*mock.Call
}

// Has is a helper method to define mock.On call
//   - identifier flow.Identifier
func (_e *TransactionTimings_Expecter) Has(identifier interface{}) *TransactionTimings_Has_Call {
	return &TransactionTimings_Has_Call{Call: _e.mock.On("Has", identifier)}
}

func (_c *TransactionTimings_Has_Call) Run(run func(identifier flow.Identifier)) *TransactionTimings_Has_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *TransactionTimings_Has_Call) Return(b bool) *TransactionTimings_Has_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *TransactionTimings_Has_Call) RunAndReturn(run func(identifier flow.Identifier) bool) *TransactionTimings_Has_Call {
	_c.Call.Return(run)
	return _c
}

// Remove provides a mock function for the type TransactionTimings
func (_mock *TransactionTimings) Remove(identifier flow.Identifier) bool {
	ret := _mock.Called(identifier)

	if len(ret) == 0 {
		panic("no return value specified for Remove")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) bool); ok {
		r0 = returnFunc(identifier)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// TransactionTimings_Remove_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Remove'
type TransactionTimings_Remove_Call struct {
	*mock.Call
}

// Remove is a helper method to define mock.On call
//   - identifier flow.Identifier
func (_e *TransactionTimings_Expecter) Remove(identifier interface{}) *TransactionTimings_Remove_Call {
	return &TransactionTimings_Remove_Call{Call: _e.mock.On("Remove", identifier)}
}

func (_c *TransactionTimings_Remove_Call) Run(run func(identifier flow.Identifier)) *TransactionTimings_Remove_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *TransactionTimings_Remove_Call) Return(b bool) *TransactionTimings_Remove_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *TransactionTimings_Remove_Call) RunAndReturn(run func(identifier flow.Identifier) bool) *TransactionTimings_Remove_Call {
	_c.Call.Return(run)
	return _c
}

// Size provides a mock function for the type TransactionTimings
func (_mock *TransactionTimings) Size() uint {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Size")
	}

	var r0 uint
	if returnFunc, ok := ret.Get(0).(func() uint); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint)
	}
	return r0
}

// TransactionTimings_Size_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Size'
type TransactionTimings_Size_Call struct {
	*mock.Call
}

// Size is a helper method to define mock.On call
func (_e *TransactionTimings_Expecter) Size() *TransactionTimings_Size_Call {
	return &TransactionTimings_Size_Call{Call: _e.mock.On("Size")}
}

func (_c *TransactionTimings_Size_Call) Run(run func()) *TransactionTimings_Size_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *TransactionTimings_Size_Call) Return(v uint) *TransactionTimings_Size_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *TransactionTimings_Size_Call) RunAndReturn(run func() uint) *TransactionTimings_Size_Call {
	_c.Call.Return(run)
	return _c
}

// Values provides a mock function for the type TransactionTimings
func (_mock *TransactionTimings) Values() []*flow.TransactionTiming {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Values")
	}

	var r0 []*flow.TransactionTiming
	if returnFunc, ok := ret.Get(0).(func() []*flow.TransactionTiming); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*flow.TransactionTiming)
		}
	}
	return r0
}

// TransactionTimings_Values_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Values'
type TransactionTimings_Values_Call struct {
	*mock.Call
}

// Values is a helper method to define mock.On call
func (_e *TransactionTimings_Expecter) Values() *TransactionTimings_Values_Call {
	return &TransactionTimings_Values_Call{Call: _e.mock.On("Values")}
}

func (_c *TransactionTimings_Values_Call) Run(run func()) *TransactionTimings_Values_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *TransactionTimings_Values_Call) Return(transactionTimings []*flow.TransactionTiming) *TransactionTimings_Values_Call {
	_c.Call.Return(transactionTimings)
	return _c
}

func (_c *TransactionTimings_Values_Call) RunAndReturn(run func() []*flow.TransactionTiming) *TransactionTimings_Values_Call {
	_c.Call.Return(run)
	return _c
}

// NewTransactions creates a new instance of Transactions. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewTransactions(t interface {
	mock.TestingT
	Cleanup(func())
}) *Transactions {
	mock := &Transactions{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Transactions is an autogenerated mock type for the Transactions type
type Transactions struct {
	mock.Mock
}

type Transactions_Expecter struct {
	mock *mock.Mock
}

func (_m *Transactions) EXPECT() *Transactions_Expecter {
	return &Transactions_Expecter{mock: &_m.Mock}
}

// Add provides a mock function for the type Transactions
func (_mock *Transactions) Add(identifier flow.Identifier, transactionBody *flow.TransactionBody) bool {
	ret := _mock.Called(identifier, transactionBody)

	if len(ret) == 0 {
		panic("no return value specified for Add")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, *flow.TransactionBody) bool); ok {
		r0 = returnFunc(identifier, transactionBody)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// Transactions_Add_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Add'
type Transactions_Add_Call struct {
	*mock.Call
}

// Add is a helper method to define mock.On call
//   - identifier flow.Identifier
//   - transactionBody *flow.TransactionBody
func (_e *Transactions_Expecter) Add(identifier interface{}, transactionBody interface{}) *Transactions_Add_Call {
	return &Transactions_Add_Call{Call: _e.mock.On("Add", identifier, transactionBody)}
}

func (_c *Transactions_Add_Call) Run(run func(identifier flow.Identifier, transactionBody *flow.TransactionBody)) *Transactions_Add_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		var arg1 *flow.TransactionBody
		if args[1] != nil {
			arg1 = args[1].(*flow.TransactionBody)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Transactions_Add_Call) Return(b bool) *Transactions_Add_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *Transactions_Add_Call) RunAndReturn(run func(identifier flow.Identifier, transactionBody *flow.TransactionBody) bool) *Transactions_Add_Call {
	_c.Call.Return(run)
	return _c
}

// Adjust provides a mock function for the type Transactions
func (_mock *Transactions) Adjust(key flow.Identifier, f func(*flow.TransactionBody) *flow.TransactionBody) (*flow.TransactionBody, bool) {
	ret := _mock.Called(key, f)

	if len(ret) == 0 {
		panic("no return value specified for Adjust")
	}

	var r0 *flow.TransactionBody
	var r1 bool
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, func(*flow.TransactionBody) *flow.TransactionBody) (*flow.TransactionBody, bool)); ok {
		return returnFunc(key, f)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier, func(*flow.TransactionBody) *flow.TransactionBody) *flow.TransactionBody); ok {
		r0 = returnFunc(key, f)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.TransactionBody)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier, func(*flow.TransactionBody) *flow.TransactionBody) bool); ok {
		r1 = returnFunc(key, f)
	} else {
		r1 = ret.Get(1).(bool)
	}
	return r0, r1
}

// Transactions_Adjust_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Adjust'
type Transactions_Adjust_Call struct {
	*mock.Call
}

// Adjust is a helper method to define mock.On call
//   - key flow.Identifier
//   - f func(*flow.TransactionBody) *flow.TransactionBody
func (_e *Transactions_Expecter) Adjust(key interface{}, f interface{}) *Transactions_Adjust_Call {
	return &Transactions_Adjust_Call{Call: _e.mock.On("Adjust", key, f)}
}

func (_c *Transactions_Adjust_Call) Run(run func(key flow.Identifier, f func(*flow.TransactionBody) *flow.TransactionBody)) *Transactions_Adjust_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		var arg1 func(*flow.TransactionBody) *flow.TransactionBody
		if args[1] != nil {
			arg1 = args[1].(func(*flow.TransactionBody) *flow.TransactionBody)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Transactions_Adjust_Call) Return(transactionBody *flow.TransactionBody, b bool) *Transactions_Adjust_Call {
	_c.Call.Return(transactionBody, b)
	return _c
}

func (_c *Transactions_Adjust_Call) RunAndReturn(run func(key flow.Identifier, f func(*flow.TransactionBody) *flow.TransactionBody) (*flow.TransactionBody, bool)) *Transactions_Adjust_Call {
	_c.Call.Return(run)
	return _c
}

// All provides a mock function for the type Transactions
func (_mock *Transactions) All() map[flow.Identifier]*flow.TransactionBody {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for All")
	}

	var r0 map[flow.Identifier]*flow.TransactionBody
	if returnFunc, ok := ret.Get(0).(func() map[flow.Identifier]*flow.TransactionBody); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[flow.Identifier]*flow.TransactionBody)
		}
	}
	return r0
}

// Transactions_All_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'All'
type Transactions_All_Call struct {
	*mock.Call
}

// All is a helper method to define mock.On call
func (_e *Transactions_Expecter) All() *Transactions_All_Call {
	return &Transactions_All_Call{Call: _e.mock.On("All")}
}

func (_c *Transactions_All_Call) Run(run func()) *Transactions_All_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Transactions_All_Call) Return(identifierToTransactionBody map[flow.Identifier]*flow.TransactionBody) *Transactions_All_Call {
	_c.Call.Return(identifierToTransactionBody)
	return _c
}

func (_c *Transactions_All_Call) RunAndReturn(run func() map[flow.Identifier]*flow.TransactionBody) *Transactions_All_Call {
	_c.Call.Return(run)
	return _c
}

// ByPayer provides a mock function for the type Transactions
func (_mock *Transactions) ByPayer(payer flow.Address) []*flow.TransactionBody {
	ret := _mock.Called(payer)

	if len(ret) == 0 {
		panic("no return value specified for ByPayer")
	}

	var r0 []*flow.TransactionBody
	if returnFunc, ok := ret.Get(0).(func(flow.Address) []*flow.TransactionBody); ok {
		r0 = returnFunc(payer)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*flow.TransactionBody)
		}
	}
	return r0
}

// Transactions_ByPayer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByPayer'
type Transactions_ByPayer_Call struct {
	*mock.Call
}

// ByPayer is a helper method to define mock.On call
//   - payer flow.Address
func (_e *Transactions_Expecter) ByPayer(payer interface{}) *Transactions_ByPayer_Call {
	return &Transactions_ByPayer_Call{Call: _e.mock.On("ByPayer", payer)}
}

func (_c *Transactions_ByPayer_Call) Run(run func(payer flow.Address)) *Transactions_ByPayer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Address
		if args[0] != nil {
			arg0 = args[0].(flow.Address)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Transactions_ByPayer_Call) Return(transactionBodys []*flow.TransactionBody) *Transactions_ByPayer_Call {
	_c.Call.Return(transactionBodys)
	return _c
}

func (_c *Transactions_ByPayer_Call) RunAndReturn(run func(payer flow.Address) []*flow.TransactionBody) *Transactions_ByPayer_Call {
	_c.Call.Return(run)
	return _c
}

// Clear provides a mock function for the type Transactions
func (_mock *Transactions) Clear() {
	_mock.Called()
	return
}

// Transactions_Clear_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Clear'
type Transactions_Clear_Call struct {
	*mock.Call
}

// Clear is a helper method to define mock.On call
func (_e *Transactions_Expecter) Clear() *Transactions_Clear_Call {
	return &Transactions_Clear_Call{Call: _e.mock.On("Clear")}
}

func (_c *Transactions_Clear_Call) Run(run func()) *Transactions_Clear_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Transactions_Clear_Call) Return() *Transactions_Clear_Call {
	_c.Call.Return()
	return _c
}

func (_c *Transactions_Clear_Call) RunAndReturn(run func()) *Transactions_Clear_Call {
	_c.Run(run)
	return _c
}

// Get provides a mock function for the type Transactions
func (_mock *Transactions) Get(identifier flow.Identifier) (*flow.TransactionBody, bool) {
	ret := _mock.Called(identifier)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *flow.TransactionBody
	var r1 bool
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) (*flow.TransactionBody, bool)); ok {
		return returnFunc(identifier)
	}
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) *flow.TransactionBody); ok {
		r0 = returnFunc(identifier)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flow.TransactionBody)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(flow.Identifier) bool); ok {
		r1 = returnFunc(identifier)
	} else {
		r1 = ret.Get(1).(bool)
	}
	return r0, r1
}

// Transactions_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type Transactions_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - identifier flow.Identifier
func (_e *Transactions_Expecter) Get(identifier interface{}) *Transactions_Get_Call {
	return &Transactions_Get_Call{Call: _e.mock.On("Get", identifier)}
}

func (_c *Transactions_Get_Call) Run(run func(identifier flow.Identifier)) *Transactions_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Transactions_Get_Call) Return(transactionBody *flow.TransactionBody, b bool) *Transactions_Get_Call {
	_c.Call.Return(transactionBody, b)
	return _c
}

func (_c *Transactions_Get_Call) RunAndReturn(run func(identifier flow.Identifier) (*flow.TransactionBody, bool)) *Transactions_Get_Call {
	_c.Call.Return(run)
	return _c
}

// Has provides a mock function for the type Transactions
func (_mock *Transactions) Has(identifier flow.Identifier) bool {
	ret := _mock.Called(identifier)

	if len(ret) == 0 {
		panic("no return value specified for Has")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) bool); ok {
		r0 = returnFunc(identifier)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// Transactions_Has_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Has'
type Transactions_Has_Call struct {
	*mock.Call
}

// Has is a helper method to define mock.On call
//   - identifier flow.Identifier
func (_e *Transactions_Expecter) Has(identifier interface{}) *Transactions_Has_Call {
	return &Transactions_Has_Call{Call: _e.mock.On("Has", identifier)}
}

func (_c *Transactions_Has_Call) Run(run func(identifier flow.Identifier)) *Transactions_Has_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Transactions_Has_Call) Return(b bool) *Transactions_Has_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *Transactions_Has_Call) RunAndReturn(run func(identifier flow.Identifier) bool) *Transactions_Has_Call {
	_c.Call.Return(run)
	return _c
}

// Remove provides a mock function for the type Transactions
func (_mock *Transactions) Remove(identifier flow.Identifier) bool {
	ret := _mock.Called(identifier)

	if len(ret) == 0 {
		panic("no return value specified for Remove")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(flow.Identifier) bool); ok {
		r0 = returnFunc(identifier)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// Transactions_Remove_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Remove'
type Transactions_Remove_Call struct {
	*mock.Call
}

// Remove is a helper method to define mock.On call
//   - identifier flow.Identifier
func (_e *Transactions_Expecter) Remove(identifier interface{}) *Transactions_Remove_Call {
	return &Transactions_Remove_Call{Call: _e.mock.On("Remove", identifier)}
}

func (_c *Transactions_Remove_Call) Run(run func(identifier flow.Identifier)) *Transactions_Remove_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 flow.Identifier
		if args[0] != nil {
			arg0 = args[0].(flow.Identifier)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Transactions_Remove_Call) Return(b bool) *Transactions_Remove_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *Transactions_Remove_Call) RunAndReturn(run func(identifier flow.Identifier) bool) *Transactions_Remove_Call {
	_c.Call.Return(run)
	return _c
}

// Size provides a mock function for the type Transactions
func (_mock *Transactions) Size() uint {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Size")
	}

	var r0 uint
	if returnFunc, ok := ret.Get(0).(func() uint); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint)
	}
	return r0
}

// Transactions_Size_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Size'
type Transactions_Size_Call struct {
	*mock.Call
}

// Size is a helper method to define mock.On call
func (_e *Transactions_Expecter) Size() *Transactions_Size_Call {
	return &Transactions_Size_Call{Call: _e.mock.On("Size")}
}

func (_c *Transactions_Size_Call) Run(run func()) *Transactions_Size_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Transactions_Size_Call) Return(v uint) *Transactions_Size_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *Transactions_Size_Call) RunAndReturn(run func() uint) *Transactions_Size_Call {
	_c.Call.Return(run)
	return _c
}

// Values provides a mock function for the type Transactions
func (_mock *Transactions) Values() []*flow.TransactionBody {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Values")
	}

	var r0 []*flow.TransactionBody
	if returnFunc, ok := ret.Get(0).(func() []*flow.TransactionBody); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*flow.TransactionBody)
		}
	}
	return r0
}

// Transactions_Values_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Values'
type Transactions_Values_Call struct {
	*mock.Call
}

// Values is a helper method to define mock.On call
func (_e *Transactions_Expecter) Values() *Transactions_Values_Call {
	return &Transactions_Values_Call{Call: _e.mock.On("Values")}
}

func (_c *Transactions_Values_Call) Run(run func()) *Transactions_Values_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Transactions_Values_Call) Return(transactionBodys []*flow.TransactionBody) *Transactions_Values_Call {
	_c.Call.Return(transactionBodys)
	return _c
}

func (_c *Transactions_Values_Call) RunAndReturn(run func() []*flow.TransactionBody) *Transactions_Values_Call {
	_c.Call.Return(run)
	return _c
}
